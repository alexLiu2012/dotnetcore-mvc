## about router routing & in mvc



### 1. about

不同的 http 请求希望得到不同的处理，这就是路由（routing）的作用。router routing 是 asp.net core 的经典路由方法，通过验证 http request 是否满足特定路由模板，从而决定应用什么样的处理方法。

#### 1.1 路由组件模型

##### 1.1.1 `route template`

路由模板的简单抽象，用字符串表示，不支 attribute routing；
定义了描述 http request path 的模型，包括：

* `template segment`

  以 "/" 分隔的、http request path 的 各个部分

* `template part`

  segment 中的组成部分
  通常每个 segment 只有1个 part，这样的 segment 称为 "simple segment"；
  如果 segment 中包含超过1个part，这样的 segment 称为 "complex segment"，比如 "{city}.{town}"

* `inline constraint`

  route template 中表示内联的约束条件，用于验证 http request path 是否满足特定的约束

##### 1.1.2 `route pattern`

路由模板通用且完整的抽象，可用于 conventional routing 和 attribute routing；
定义了描述 http request path 的模型，包括：

* `pattern path segment`

  和 template segment 类似，表示 http request path 由 "/" 分隔的各个部分

* `pattern part`

  和 template part 类型，表示 template path segment 的组成部分；
  通常每个 template path segment 只有1个 pattern part

  根据表示内容不同，分为：

  * `route pattern literal part`

    表示 “文本” 内容，即 part 是纯文本

  * `route pattern separator part`

    表示 “分隔符” ，即 part 是表示分隔的特殊字符

  * `route pattern parameter part`

    表示 “参数”，即 part 是可以解析成路由数据的 kvp 对象

##### 1.1.3 `parameter policy`

parameter part 是否满足特定（约束）的验证策略，即检查 parameter part 是否服务特定要求的方法

派生出：

* `route constraint`

  和 route template 中的 inline constraint类型，表示 parameter part 的约束条件

* `outbound parameter transformer`

  

#### 1.2 路由服务

##### 1.2.1 router

###### 1.2.1.1 route

统一的 router 模型；
内部包含的 template matcher 和 template binder 可以实现 route（正向路由）和 get virtual path（反向路由）方法

###### 1.2.1.2 route handler

封装 request delegate 的 router，用于执行路由匹配后的具体处理方法（handler）

###### 1.2.1.3 route collection

router 的组合模式，内部封装多个 route，每个 route 都包含特定的 route matcher

##### 1.2.2 for route（正向路由）

路由过程，即将输入的 http request path 分析、解析，匹配到适合的 request delegate 上：

1. template mater 验证 request path 是否匹配特定 route template，同时提取 request path 中的 parameter 及其 value 到 route value dictionary；

2. 之后，constraint matcher 验证 提取的 route value dictionary 是否满足特定的 constraint，它可以是单独定义的（实现 IRouteConstraint 接口、或者 inline 定义在 route template 中）
3. constraint matcher 中封装了inline constraint resolver，它的默认实现 default inline constraint resolver 加载了很多 route constraint，如 int、bool、string 等，这些都在 route options 中定义，可以在 add router 时添加自定义 route constraint

###### 1.2.1.1 template matcher

验证 http request path 是否符合特定的 route template，同时提取 request path 中的参数到 route value dictionary；
封装了 route pattern matcher，由其真正实现 match 方法

###### 1.2.1.2 route constraint matcher

验证 request path 中的参数是否符合特定的约束条件；
封装了 inline constraint resolver，用于验证 constraint

###### 1.2.1.3 inline constraint resolver

inline constraint（route template 内联约束解析器），可以解析 route template 中由字符串定义的约束条件，形如 `param:constraint(args)`。
default inline constraint 是默认实现，加载了 route options 中预定义的很多 route constraint，如 int constraint、bool constraint；可以在 add router 方法中通过 route options 注入自定义 inline constraint

##### 1.2.3 for get virtual path（反向路由）

针对每个特定的 route template，由传入的 route value dictionary 创建 request path（反向路由）。
对于不同的 route template，需要使用不同的 template binder，所以 template binder factory 提供了创建 template binder 的服务

###### 1.2.3.1 template binder

根据给定的 route template，由传入的 route value dictionary 创建 request path（反向路由）。

###### 1.2.3.2 template binder factory

创建 tmeplate binder 的工厂

#### 1.3 attribute routing

利用 tree 结构解析 url（正向路由）、生成 url（反向路由）的 router

##### 1.3.1 trees

###### 1.3.1.1 url matching tree

###### 1.3.1.2 link generation decision tree

##### 1.3.2 tree router

使用 url matching tree 解析 、路由 request path；使用 link generation tree 创建 url

##### 1.3.3 attribute router

将路由数据注入、创建 tree router，并由 tree router 进行路由服务



### 2. route components

#### 2.1 route template

##### 2.1.1 route template

* 路由模板，用于 conventional routing

```c#
[DebuggerDisplay("{DebuggerToString()}")]
public class RouteTemplate
{
    private const string SeparatorString = "/";
    
    public string? TemplateText { get; }      
    public IList<TemplateSegment> Segments { get; }
    public IList<TemplatePart> Parameters { get; }                            
    public RouteTemplate(RoutePattern other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        // RequiredValues will be ignored. RouteTemplate doesn't support them.
        
        // text
        TemplateText = other.RawText;
        // segments
        Segments = new List<TemplateSegment>(
            			   other.PathSegments
            					.Select(p => 
                                        	new TemplateSegment(p)));
        // parameters
        Parameters = new List<TemplatePart>();
        for (var i = 0; i < Segments.Count; i++)
        {
            var segment = Segments[i];
            for (var j = 0; j < segment.Parts.Count; j++)
            {
                var part = segment.Parts[j];
                if (part.IsParameter)
                {
                    Parameters.Add(part);
                }
            }
        }
    }
           
    public RouteTemplate(
        string template, 
        List<TemplateSegment> segments)
    {
        if (segments == null)
        {
            throw new ArgumentNullException(nameof(segments));
        }
        
        // text
        TemplateText = template;
        // segments
        Segments = segments;
        // parameters
        Parameters = new List<TemplatePart>();
        for (var i = 0; i < segments.Count; i++)
        {
            var segment = Segments[i];
            for (var j = 0; j < segment.Parts.Count; j++)
            {
                var part = segment.Parts[j];
                if (part.IsParameter)
                {
                    Parameters.Add(part);
                }
            }
        }
    }
    
    // get segment
    public TemplateSegment? GetSegment(int index)
    {
        if (index < 0)
        {
            throw new IndexOutOfRangeException();
        }
        
        return index >= Segments.Count ? null : Segments[index];
    }
            
    // get parameter
    public TemplatePart? GetParameter(string name)
    {
        for (var i = 0; i < Parameters.Count; i++)
        {
            var parameter = Parameters[i];
            if (string.Equals(
                		   parameter.Name, 
                		   name, 
                		   StringComparison.OrdinalIgnoreCase))
            {
                return parameter;
            }
        }
        
        return null;
    }
    
    // to route pattern    
    public RoutePattern ToRoutePattern()
    {
        var segments = Segments.Select(s => 
                                       	   s.ToRoutePatternPathSegment());
        
        return RoutePatternFactory.Pattern(TemplateText, segments);
    }
    
    private string DebuggerToString()
    {
        return string.Join(
            SeparatorString, 
            Segments.Select(s => s.DebuggerToString()));
    }
}

```

###### 2.1.1.1 template segment

```c#
[DebuggerDisplay("{DebuggerToString()}")]
public class TemplateSegment
{
    public List<TemplatePart> Parts { get; }
    public bool IsSimple => Parts.Count == 1;           
        
    public TemplateSegment()
    {
        Parts = new List<TemplatePart>();
    }
       
    public TemplateSegment(RoutePatternPathSegment other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        var partCount = other.Parts.Count;
        Parts = new List<TemplatePart>(partCount);
        for (var i = 0; i < partCount; i++)
        {
            Parts.Add(new TemplatePart(other.Parts[i]));
        }
    }
    
    public RoutePatternPathSegment ToRoutePatternPathSegment()
    {
        var parts = Parts.Select(p => p.ToRoutePatternPart());
        return RoutePatternFactory.Segment(parts);
    }
    
    internal string DebuggerToString()
    {
        return string.Join(
            string.Empty, 
            Parts.Select(p => p.DebuggerToString()));
    }    
}

```

###### 2.1.1.2 template part

```c#
[DebuggerDisplay("{DebuggerToString()}")]
public class TemplatePart
{
    public bool IsCatchAll { get; private set; }    
    public bool IsLiteral { get; private set; }   
    public bool IsParameter { get; private set; }    
    public bool IsOptional { get; private set; }    
    public bool IsOptionalSeperator { get; set; }   
    
    public string? Name { get; private set; }    
    public string? Text { get; private set; }    
    public object? DefaultValue { get; private set; }
    
    public IEnumerable<InlineConstraint> 
        InlineConstraints { get; private set; } = Enumerable.Empty<InlineConstraint>();
        
    public TemplatePart()
    {
    }
    
    public TemplatePart(RoutePatternPart other)
    {
        IsLiteral = other.IsLiteral || other.IsSeparator;
        IsParameter = other.IsParameter;
        
        if (other.IsLiteral && 
            other is RoutePatternLiteralPart literal)
        {
            Text = literal.Content;
        }
        else if (other.IsParameter && 
                 other is RoutePatternParameterPart parameter)
        {
            // Text is unused by TemplatePart and assumed to be null when the part 
            // is a parameter.
            Name = parameter.Name;
            IsCatchAll = parameter.IsCatchAll;
            IsOptional = parameter.IsOptional;
            DefaultValue = parameter.Default;
            InlineConstraints = 
                parameter.ParameterPolicies
                		 ?.Select(p => new InlineConstraint(p)) 
                			 ?? Enumerable.Empty<InlineConstraint>();
        }
        else if (other.IsSeparator && 
                 other is RoutePatternSeparatorPart separator)
        {
            Text = separator.Content;
            IsOptionalSeperator = true;
        }
        else
        {
            // Unreachable
            throw new NotSupportedException();
        }
    }
        
    // 创建 literal part
    public static TemplatePart CreateLiteral(string text)
    {
        return new TemplatePart()
        {
            IsLiteral = true,
            Text = text,
        };
    }
    
    // 创建 parameter part
    public static TemplatePart CreateParameter(
        string name,
        bool isCatchAll,
        bool isOptional,
        object? defaultValue,
        IEnumerable<InlineConstraint>? inlineConstraints)
    {
        if (name == null)
        {
            throw new ArgumentNullException(nameof(name));
        }
        
        return new TemplatePart()
        {
            IsParameter = true,
            Name = name,
            IsCatchAll = isCatchAll,
            IsOptional = isOptional,
            DefaultValue = defaultValue,
            InlineConstraints = inlineConstraints ?? Enumerable.Empty<InlineConstraint>(),
        };
    }
             
    // to route pattern
    public RoutePatternPart ToRoutePatternPart()
    {
        if (IsLiteral && 
            IsOptionalSeperator)
        {
            return RoutePatternFactory.SeparatorPart(Text!);
        }
        else if (IsLiteral)
        {
            return RoutePatternFactory.LiteralPart(Text!);
        }
        else
        {
            var kind = IsCatchAll 
                		   ? RoutePatternParameterKind.CatchAll 
                		   : IsOptional 
                               ? RoutePatternParameterKind.Optional 
                               : RoutePatternParameterKind.Standard;
            
            var constraints = InlineConstraints.Select(
                	c => new RoutePatternParameterPolicyReference(c.Constraint));
            
            return RoutePatternFactory.ParameterPart(
                						   Name!, 
                						   DefaultValue, 
                						   kind, 
                						   constraints);
        }
    }
    
    internal string? DebuggerToString()
    {
        if (IsParameter)
        {
            return "{" + 
                	(IsCatchAll ? "*" : string.Empty) + 
                	Name + 
                	(IsOptional ? "?" : string.Empty) + 
                	"}";
        }
        else
        {
            return Text;
        }
    }
}

```

###### 2.1.1.3 inline constraint

```c#
public class InlineConstraint
{
    public string Constraint { get; }
    
    public InlineConstraint(string constraint)
    {
        if (constraint == null)
        {
            throw new ArgumentNullException(nameof(constraint));
        }
        
        Constraint = constraint;
    }
        
    public InlineConstraint(RoutePatternParameterPolicyReference other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        Constraint = other.Content!;
    }            
}

```



##### 2.1.2 route template parser

* 创建 route template

###### 2.1.2.1 template parser

* 封装 route pattern factory，由其创建 route pattern，然后转换为 route template

```c#
public static class TemplateParser
{        
    public static RouteTemplate Parse(string routeTemplate)
    {
        if (routeTemplate == null)
        {
            throw new ArgumentNullException(routeTemplate);
        }
        
        try
        {
            var inner = RoutePatternFactory.Parse(routeTemplate);
            return new RouteTemplate(inner);
        }
        catch (RoutePatternException ex)
        {
            // Preserving the existing behavior of this API even though the logic moved.
            throw new ArgumentException(ex.Message, nameof(routeTemplate), ex);
        }
    }
}

```

###### 2.1.2.2 inline route parameter parser

```c#
public static class InlineRouteParameterParser
{    
    public static TemplatePart ParseRouteParameter(string routeParameter)
    {
        if (routeParameter == null)
        {
            hrow new ArgumentNullException(nameof(routeParameter));
            
        }
        
        if (routeParameter.Length == 0)
        {
            return TemplatePart.CreateParameter(
                name: string.Empty,
                isCatchAll: false,
                isOptional: false,
                defaultValue: null,
                inlineConstraints: null);
        }
        
        var startIndex = 0;
        var endIndex = routeParameter.Length - 1;
        
        var isCatchAll = false;
        var isOptional = false;
        
        if (routeParameter[0] == '*')
        {
            isCatchAll = true;
            startIndex++;
        }
        
        if (routeParameter[endIndex] == '?')
        {
            isOptional = true;
            endIndex--;
        }
        
        
        var currentIndex = startIndex;
        
        // Parse parameter name
        var parameterName = string.Empty;
        
        while (currentIndex <= endIndex)
        {
            var currentChar = routeParameter[currentIndex];
            
            if ((currentChar == ':' || currentChar == '=') && 
                startIndex != currentIndex)
            {
                // Parameter names are allowed to start with delimiters used to denote 
                // constraints or default values.
                // i.e. "=foo" or ":bar" would be treated as parameter names rather than 
                // default value or constraint specifications.
                parameterName = routeParameter.Substring(
                    startIndex, 
                    currentIndex - startIndex);
                
                // Roll the index back and move to the constraint parsing stage.
                currentIndex--;
                break;
            }
            else if (currentIndex == endIndex)
            {
                parameterName = routeParameter.Substring(
                    startIndex, 
                    currentIndex - startIndex + 1);
            }
            
            currentIndex++;
        }
        
        var parseResults = ParseConstraints(
            routeParameter, 
            currentIndex, 
            endIndex);
        
        currentIndex = parseResults.CurrentIndex;
        
        string? defaultValue = null;
        if (currentIndex <= endIndex &&
            routeParameter[currentIndex] == '=')
        {
            defaultValue = routeParameter.Substring(
                currentIndex + 1, 
                endIndex - currentIndex);
        }
        
        return TemplatePart.CreateParameter(
            parameterName,
            isCatchAll,
            isOptional,
            defaultValue,
            parseResults.Constraints);
    }
    
    private static ConstraintParseResults ParseConstraints(
        string routeParameter,
        int currentIndex,
        int endIndex)
    {
        var inlineConstraints = new List<InlineConstraint>();
        var state = ParseState.Start;
        var startIndex = currentIndex;
        do
        {
            var currentChar = currentIndex > endIndex 
                ? null 
                : (char?)routeParameter[currentIndex];
            
            switch (state)
            {
                case ParseState.Start:
                    switch (currentChar)
                    {
                        case null:
                            state = ParseState.End;
                            break;
                        case ':':
                            state = ParseState.ParsingName;
                            startIndex = currentIndex + 1;
                            break;
                        case '(':
                            state = ParseState.InsideParenthesis;
                            break;
                        case '=':
                            state = ParseState.End;
                            currentIndex--;
                            break;
                    }
                    break;
                    
                case ParseState.InsideParenthesis:
                    switch (currentChar)
                    {
                        case null:
                            state = ParseState.End;
                            var constraintText = routeParameter.Substring(
                                startIndex, 
                                currentIndex - startIndex);
                            inlineConstraints.Add(new InlineConstraint(constraintText));
                            break;
                        case ')':
                            // Only consume a ')' token if
                            // (a) it is the last token
                            // (b) the next character is the start of the new constraint ':'
                            // (c) the next character is the start of the default value.
                            
                            var nextChar = currentIndex + 1 > endIndex 
                                ? null 
                                : (char?)routeParameter[currentIndex + 1];
                            switch (nextChar)
                            {
                                case null:
                                    state = ParseState.End;
                                    constraintText = routeParameter.Substring(
                                        startIndex, 
                                        currentIndex - startIndex + 1);
                                    inlineConstraints.Add(
                                        new InlineConstraint(constraintText));
                                    break;
                                case ':':
                                    state = ParseState.Start;
                                    constraintText = routeParameter.Substring(
                                        startIndex, 
                                        currentIndex - startIndex + 1);
                                    inlineConstraints.Add(
                                        new InlineConstraint(constraintText));
                                    startIndex = currentIndex + 1;
                                    break;
                                case '=':
                                    state = ParseState.End;
                                    constraintText = routeParameter.Substring(
                                        startIndex, 
                                        currentIndex - startIndex + 1);
                                    inlineConstraints.Add(
                                        new InlineConstraint(constraintText));
                                    break;
                            }
                            break;
                        case ':':
                        case '=':
                            // In the original implementation, the Regex would've 
                            // backtracked if it encountered an unbalanced opening 
                            // bracket followed by (not necessarily immediatiely) a delimiter.
                            // Simply verifying that the parantheses will eventually be closed
                            // should suffice to determine if the terminator needs to be 
                            // consumed as part of the current constraint specification.
                            var indexOfClosingParantheses = r
                                outeParameter.IndexOf(')', currentIndex + 1);
                            if (indexOfClosingParantheses == -1)
                            {
                                constraintText = routeParameter.Substring(
                                    startIndex, 
                                    currentIndex - startIndex);
                                
                                inlineConstraints.Add(new InlineConstraint(constraintText));
                                
                                if (currentChar == ':')
                                {
                                    state = ParseState.ParsingName;
                                    startIndex = currentIndex + 1;
                                }
                                else
                                {
                                    state = ParseState.End;
                                    currentIndex--;
                                }
                            }
                            else
                            {
                                currentIndex = indexOfClosingParantheses;
                            }
                            
                            break;
                    }
                    break;
                case ParseState.ParsingName:
                    switch (currentChar)
                    {
                        case null:
                            state = ParseState.End;
                            var constraintText = routeParameter.Substring(
                                startIndex, 
                                currentIndex - startIndex);
                            inlineConstraints.Add(
                                new InlineConstraint(constraintText));
                            break;
                        case ':':
                            constraintText = routeParameter.Substring(
                                startIndex, 
                                currentIndex - startIndex);
                            inlineConstraints.Add(
                                new InlineConstraint(constraintText));
                            startIndex = currentIndex + 1;
                            break;
                        case '(':
                            state = ParseState.InsideParenthesis;
                            break;
                        case '=':
                            state = ParseState.End;
                            constraintText = routeParameter.Substring(
                                startIndex, 
                                currentIndex - startIndex);
                            inlineConstraints.Add(
                                new InlineConstraint(constraintText));
                            currentIndex--;
                            break;
                    }
                    break;
            }
            
            currentIndex++;
            
        } while (state != ParseState.End);
        
        return new ConstraintParseResults(currentIndex, inlineConstraints);
    }
    
    private enum ParseState
    {
        Start,
        ParsingName,
        InsideParenthesis,
        End
    }
    
    private readonly struct ConstraintParseResults
    {
        public readonly int CurrentIndex;        
        public readonly IEnumerable<InlineConstraint> Constraints;
        
        public ConstraintParseResults(
            int currentIndex, 
            IEnumerable<InlineConstraint> constraints)
        {
            CurrentIndex = currentIndex;
            Constraints = constraints;
        }
    }
}

```

##### 2.1.3 template matcher

* 用于正向路由

```c#
public class TemplateMatcher
{
    /* 分隔符 */
    private const string SeparatorString = "/";
    private const char SeparatorChar = '/';
    private static readonly char[] Delimiters = new char[] { SeparatorChar };
    
    // Perf: This is a cache to avoid looking things up in 'Defaults' each request.
    private readonly bool[] _hasDefaultValue;
    private readonly object?[] _defaultValues;
       
    // pattern matcher
    private RoutePatternMatcher _routePatternMatcher;
    
    public RouteTemplate Template { get; }
    public RouteValueDictionary Defaults { get; }
            
    public TemplateMatcher(
        RouteTemplate template,
        RouteValueDictionary defaults)
    {
        if (template == null)
        {
            throw new ArgumentNullException(nameof(template));
        }
        
        /* 注入 route template、defautls(route value dictionary)  */
        Template = template;
        Defaults = defaults ?? new RouteValueDictionary();
        
        /* 创建 has default value、default value 集合（默认值）*/
        // Perf: cache the default value for each parameter (other than complex segments).
        _hasDefaultValue = new bool[Template.Segments.Count];
        _defaultValues = new object[Template.Segments.Count];
        
        /* 从参数 default(route value dictionary) 中查找 parameter 的 default value，
           注入 default values 集合 */
        for (var i = 0; i < Template.Segments.Count; i++)
        {
            var segment = Template.Segments[i];
            if (!segment.IsSimple)
            {
                continue;
            }
            
            var part = segment.Parts[0];
            if (!part.IsParameter)
            {
                continue;
            }
            
            if (Defaults.TryGetValue(part.Name!, out var value))
            {
                _hasDefaultValue[i] = true;
                _defaultValues[i] = value;
            }
        }
        
        /* 创建 route pattern matcher */
        // route template -> route pattern
        var routePattern = Template.ToRoutePattern();
        // 由 route pattern、defaults 创建 route pattern matcher
        _routePatternMatcher = new RoutePatternMatcher(routePattern, Defaults);
    }   
    
    // 调用了 pattern matcher 的 match 方法
    public bool TryMatch(PathString path, RouteValueDictionary values)
    {
        if (values == null)
        {
            throw new ArgumentNullException(nameof(values));
        }
        
        return _routePatternMatcher.TryMatch(path, values);        
    }
}

```

##### 2.1.4 uri binding context

```c#
[DebuggerDisplay("{DebuggerToString(),nq}")]
internal class UriBuildingContext
{    
    private readonly StringBuilder _path;
    private StringBuilder _query;    
    // Holds the 'optional' parts of the path.     
    private readonly List<BufferValue> _buffer;
    
    private readonly UrlEncoder _urlEncoder;
    
    private bool _hasEmptySegment;
    private int _lastValueOffset;    
    public bool LowercaseUrls { get; set; }
    public bool LowercaseQueryStrings { get; set; }
    public bool AppendTrailingSlash { get; set; }
    
    public TextWriter PathWriter { get; }
    public TextWriter QueryWriter { get; }
    
    public SegmentState BufferState { get; private set; }
    public SegmentState UriState { get; private set; }
               
    public UriBuildingContext(UrlEncoder urlEncoder)
    {
        _path = new StringBuilder();
        _query = new StringBuilder();
        _buffer = new List<BufferValue>();
                
        _urlEncoder = urlEncoder;        
        PathWriter = new StringWriter(_path);
        QueryWriter = new StringWriter(_query);
        
        _lastValueOffset = -1;        
        BufferState = SegmentState.Beginning;
        UriState = SegmentState.Beginning;
    }
                  
    public void Remove(string literal)
    {
        Debug.Assert(
            _lastValueOffset != -1, 
            "Cannot invoke Remove more than once.");
        
        _path.Length = _lastValueOffset;
        _lastValueOffset = -1;
    }
            
    public void EndSegment()
    {
        BufferState = SegmentState.Beginning;
        UriState = SegmentState.Beginning;
    }
    
    public void Clear()
    {
        _path.Clear();
        if (_path.Capacity > 128)
        {
            // We don't want to retain too much memory if this is getting pooled.
            _path.Capacity = 128;
        }
        
        _query.Clear();
        if (_query.Capacity > 128)
        {
            _query.Capacity = 128;
        }
        
        _buffer.Clear();
        if (_buffer.Capacity > 8)
        {
            _buffer.Capacity = 8;
        }
        
        _hasEmptySegment = false;
        _lastValueOffset = -1;
        BufferState = SegmentState.Beginning;
        UriState = SegmentState.Beginning;
        
        AppendTrailingSlash = false;
        LowercaseQueryStrings = false;
        LowercaseUrls = false;
    }        
           
    private string DebuggerToString()
    {
        return string.Format(
            CultureInfo.InvariantCulture, 
            "{{Accepted: '{0}' Buffered: '{1}'}}", 
            _path, 
            string.Join("", _buffer));
    }
    
    private readonly struct BufferValue
    {
        public bool RequiresEncoding { get; }        
        public string Value { get; }
        
        public BufferValue(string value, bool requiresEncoding)
        {
            Value = value;
            RequiresEncoding = requiresEncoding;
        }                
    }
}

```

###### 2.1.4.1 accept (value)

```c#
internal class UriBuildingContext
{
    /* 判断 value 是否可以绑定到 path */
    public bool Accept(string? value)
    {
        return Accept(value, encodeSlashes: true);
    }
    
    public bool Accept(string? value, bool encodeSlashes)
    {
        // 如果 value（segment）是空
        if (string.IsNullOrEmpty(value))
        {
            // 如果 uri state 是 inside，或者 buffer state 是 inside，-> false（url、buffer 中间不能空）
            if (UriState == SegmentState.Inside || 
                BufferState == SegmentState.Inside)
            {
                // We can't write an 'empty' part inside a segment
                return false;
            }
            // 否则，即 url state、buffer state 都不是 inside（应该是 end），-> true，标记 has empty segment
            else
            {
                _hasEmptySegment = true;
                return true;
            }
        }
        // 否则，即 value（segment）不是空，但是标记了 has empty segment（上一个 segment 为空），-> false
        // （empty segment 后面不能有其他 segment）
        else if (_hasEmptySegment)
        {
            // We're trying to write text after an empty segment - this is not allowed.
            return false;
        }
        
        // NOTE: this needs to be above all 'EncodeValue' and _path.Append calls
        if (LowercaseUrls)
        {
            value = value.ToLowerInvariant();
        }
        
        // 将 buffer 追加到 path，
        var buffer = _buffer;
        for (var i = 0; i < buffer.Count; i++)
        {
            var bufferValue = buffer[i].Value;
            if (LowercaseUrls)
            {
                bufferValue = bufferValue.ToLowerInvariant();
            }
            
            if (buffer[i].RequiresEncoding)
            {
                EncodeValue(bufferValue);
            }
            else
            {
                _path.Append(bufferValue);
            }
        }
        // 清空 buffer
        buffer.Clear();
        
        // 如果 url state 或者 buffer state 为 beginning，
        if (UriState == SegmentState.Beginning && 
            BufferState == SegmentState.Beginning)
        {
            // path 为 empty，-> path 追加 “/”
            if (_path.Length != 0)
            {
                _path.Append("/");
            }
        }
        
        // url state、buffer state 置为 inside
        BufferState = SegmentState.Inside;
        UriState = SegmentState.Inside;
        
        _lastValueOffset = _path.Length;
        
        // Allow the first segment to have a leading slash.
        // This prevents the leading slash from PathString segments from being encoded.
        
        // path 追加 value，（path 将处理前导“/”）
        if (_path.Length == 0 && 
            value.Length > 0 && 
            value[0] == '/')
        {
            _path.Append("/");
            EncodeValue(value, 1, value.Length - 1, encodeSlashes);
        }
        else
        {
            EncodeValue(value, encodeSlashes);
        }
        
        return true;
    }
    
    private void EncodeValue(string value)
    {
        EncodeValue(value, encodeSlashes: true);
    }
    
    private void EncodeValue(string value, bool encodeSlashes)
    {
        EncodeValue(
            value, 
            start: 0, 
            characterCount: value.Length, 
            encodeSlashes);
    }
        
    internal void EncodeValue(
        string value, 
        int start, 
        int characterCount, 
        bool encodeSlashes)
    {
        // Just encode everything if its ok to encode slashes
        if (encodeSlashes)
        {
            _urlEncoder.Encode(PathWriter, value, start, characterCount);
        }
        else
        {
            int end;
            int length = start + characterCount;
            while ((end = value.IndexOf('/', start, characterCount)) >= 0)
            {
                _urlEncoder.Encode(PathWriter, value, start, end - start);
                _path.Append("/");
                
                start = end + 1;
                characterCount = length - start;
            }
            
            if (end < 0 && characterCount >= 0)
            {
                _urlEncoder.Encode(PathWriter, value, start, length - start);
            }
        }
    }
}
```



###### 2.1.4.2 buffer (value)

```c#
internal class UriBuildingContext
{
    public bool Buffer(string? value)
    {
        if (string.IsNullOrEmpty(value))
        {
            if (BufferState == SegmentState.Inside)
            {
                // We can't write an 'empty' part inside a segment
                return false;
            }
            else
            {
                _hasEmptySegment = true;
                return true;
            }
        }
        else if (_hasEmptySegment)
        {
            // We're trying to write text after an empty segment - this is not allowed.
            return false;
        }
        
        if (UriState == SegmentState.Inside)
        {
            // We've already written part of this segment so there's no point in 
            // buffering, we need to write out the rest or give up.
            var result = Accept(value);
            
            // We've already checked the conditions that could result in a rejected 
            // part, so this should always be true.
            Debug.Assert(result);
            
            return result;
        }
        
        if (UriState == SegmentState.Beginning && 
            BufferState == SegmentState.Beginning)
        {
            if (_path.Length != 0 || _buffer.Count != 0)
            {
                _buffer.Add(
                    new BufferValue("/", requiresEncoding: false));
            }
            
            BufferState = SegmentState.Inside;
        }
        
        _buffer.Add(
            new BufferValue(value, requiresEncoding: true));
        
        return true;
    }
}

```

###### 2.1.4.3 to string

```c#
internal class UriBuildingContext
{
    // Used by TemplateBinder.BindValues - the legacy code path of IRouter
    public override string ToString()
    {
        // We can ignore any currently buffered segments - they are are guaranteed 
        // to be 'defaults'.
        if (_path.Length > 0 && _path[0] != '/')
        {
            // Normalize generated paths so that they always contain a leading slash.
            _path.Insert(0, '/');
        }
        
        return _path.ToString() + _query.ToString();
    }
    
    // Used by TemplateBinder.TryBindValues - the new code path of LinkGenerator
    public PathString ToPathString()
    {
        PathString pathString;
        
        if (_path.Length > 0)
        {
            if (_path[0] != '/')
            {
                // Normalize generated paths so that they always contain a leading slash.
                _path.Insert(0, '/');
            }
            
            if (AppendTrailingSlash && 
                _path[_path.Length - 1] != '/')
            {
                _path.Append('/');
            }
            
            pathString = new PathString(_path.ToString());
        }
        else
        {
            pathString = PathString.Empty;
        }
        
        return pathString;
    }
    
    // Used by TemplateBinder.TryBindValues - the new code path of LinkGenerator
    public QueryString ToQueryString()
    {
        if (_query.Length > 0 && _query[0] != '?')
        {
            // Normalize generated query so that they always contain a leading ?.
            _query.Insert(0, '?');
        }
        
        return new QueryString(_query.ToString());
    }
}
```

###### 2.1.4.4 uri builder context pooled object policy

```c#
internal class UriBuilderContextPooledObjectPolicy : IPooledObjectPolicy<UriBuildingContext>
{
    public UriBuildingContext Create()
    {
        return new UriBuildingContext(UrlEncoder.Default);
    }
    
    public bool Return(UriBuildingContext obj)
    {
        obj.Clear();
        return true;
    }
}

```



##### 2.1.5 template binder

* 用于反向路由

```c#
public class TemplateBinder
{
    private readonly UrlEncoder _urlEncoder;
    private readonly ObjectPool<UriBuildingContext> _pool;
    
    private readonly (string parameterName, IRouteConstraint constraint)[] _constraints;
    private readonly RouteValueDictionary? _defaults;
    private readonly KeyValuePair<string, object?>[] _filters;
    private readonly (string parameterName, IOutboundParameterTransformer transformer)[] _parameterTransformers;
    private readonly RoutePattern _pattern;
    private readonly string[] _requiredKeys;
    
    // A pre-allocated template for the 'known' route values that this template binder uses.    
    // We always make a copy of this and operate on the copy, so that we don't mutate shared state.
    private readonly KeyValuePair<string, object?>[] _slots;
        
    internal TemplateBinder(
        UrlEncoder urlEncoder,
        ObjectPool<UriBuildingContext> pool,
        RouteTemplate template,
        RouteValueDictionary defaults)            
        	: this(
                urlEncoder, 
                pool, 
                template?.ToRoutePattern()!, 
                defaults,
                requiredKeys: null, 
                parameterPolicies: null)
    {
    }
            
    internal TemplateBinder(
        UrlEncoder urlEncoder,
        ObjectPool<UriBuildingContext> pool,
        RoutePattern pattern,
        RouteValueDictionary? defaults,
        IEnumerable<string>? requiredKeys,
        IEnumerable<(string parameterName, IParameterPolicy policy)>? parameterPolicies)
    {
        if (urlEncoder == null)
        {
            throw new ArgumentNullException(nameof(urlEncoder));
        }        
        if (pool == null)
        {
            throw new ArgumentNullException(nameof(pool));
        }        
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }
        
        /* 注入 */
        _urlEncoder = urlEncoder;
        _pool = pool;
        _pattern = pattern;
        _defaults = defaults;
        _requiredKeys = requiredKeys?.ToArray() ?? Array.Empty<string>();
                
        // Any default that doesn't have a corresponding parameter is a 'filter' 
        // and if a value is provided for that 'filter' it must match the value in defaults.
        
        /* 注入 filter, 
           即 defaults 提供的 value，但是没有在 parameter 中定义
           （复制 defaults，从中移除 parameter 同名的 value） */
        var filters = new RouteValueDictionary(_defaults);
        for (var i = 0; i < pattern.Parameters.Count; i++)
        {
            filters.Remove(pattern.Parameters[i].Name);
        }
        _filters = filters.ToArray();
        
        /* 注入 route constraint，
           （从传入的 parameter policy 中过滤 route constraint 接口的实现） */
        _constraints = parameterPolicies?.Where(p => p.policy is IRouteConstraint)
            						   .Select(p => (p.parameterName, (IRouteConstraint)p.policy))
						               .ToArray() ?? Array.Empty<(string, IRouteConstraint)>();
        
        /* 注入 parameter transformers，
           （从传入的 parameter policy 中过滤 outbound parameter transformer 接口的实现） */
        _parameterTransformers = parameterPolicies?.Where(p => p.policy is IOutboundParameterTransformer)
            									.Select(p => (p.parameterName, (IOutboundParameterTransformer)p.policy))
									            .ToArray() ?? Array.Empty<(string, IOutboundParameterTransformer)>();
        
        /* 将 patter、filter 封装为 slot  */
        _slots = AssignSlots(_pattern, _filters);
    }
    
    internal TemplateBinder(
        UrlEncoder urlEncoder,
        ObjectPool<UriBuildingContext> pool,
        RoutePattern pattern,
        IEnumerable<(string parameterName, IParameterPolicy policy)> parameterPolicies)
    {
        if (urlEncoder == null)
        {
            throw new ArgumentNullException(nameof(urlEncoder));
        }        
        if (pool == null)
        {
            throw new ArgumentNullException(nameof(pool));
        }        
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }
        
        /* 注入 */        
        _urlEncoder = urlEncoder;
        _pool = pool;
        _pattern = pattern;
        _defaults = new RouteValueDictionary(pattern.Defaults);
        _requiredKeys = pattern.RequiredValues.Keys.ToArray();
                
        // Any default that doesn't have a corresponding parameter is a 'filter' 
        // and if a value is provided for that 'filter' it must match the value in defaults.
        
        /* 注入 filter */
        var filters = new RouteValueDictionary(_defaults);
        for (var i = 0; i < pattern.Parameters.Count; i++)
        {
            filters.Remove(pattern.Parameters[i].Name);
        }
        _filters = filters.ToArray();
        
        /* 注入 route constraint，
           （从 parameter policy 中过滤 route constraint 接口的实现） */
        _constraints = parameterPolicies
            ?.Where(p => p.policy is IRouteConstraint)
            .Select(p => (p.parameterName, (IRouteConstraint)p.policy))
            .ToArray() ?? Array.Empty<(string, IRouteConstraint)>();
        
        /* 注入 transformer，
           （从 parameter policy 中过滤 outbound parameter transformer） */
        _parameterTransformers = parameterPolicies
            ?.Where(p => p.policy is IOutboundParameterTransformer)
            .Select(p => (p.parameterName, (IOutboundParameterTransformer)p.policy))
            .ToArray() ?? Array.Empty<(string, IOutboundParameterTransformer)>();
        
        /* 将 pattern、filter 封装为 slot */
        _slots = AssignSlots(_pattern, _filters);
    }
       
    // 创建 key 的容器，包含 pattern parameter、filter 的 key
    private static KeyValuePair<string, object?>[] AssignSlots(
        RoutePattern pattern, 
        KeyValuePair<string, object?>[] filters)
    {
        var slots = new KeyValuePair<string, object?>[pattern.Parameters.Count + filters.Length];
        
        // 遍历 parameter，注入 slot
        for (var i = 0; i < pattern.Parameters.Count; i++)
        {
            slots[i] = new KeyValuePair<string, object?>(
                pattern.Parameters[i].Name, 
                null);
        }
        // 遍历 filter，注入 slot（在 parameter 之后）
        for (var i = 0; i < filters.Length; i++)
        {
            slots[i + pattern.Parameters.Count] = 
                new KeyValuePair<string, object?>(filters[i].Key, null);
        }
        
        return slots;
    }
                                       
    // step 1 - 处理 constraint（如果在 ctro 中传入）
    public bool TryProcessConstraints(
        HttpContext? httpContext, 
        RouteValueDictionary combinedValues, 
        out string? parameterName, 
        out IRouteConstraint? constraint)
    {
        var constraints = _constraints;
        
        // 遍历 constraint，调用 constraint 的 match 方法
        for (var i = 0; i < constraints.Length; i++)
        {
            (parameterName, constraint) = constraints[i];
            
            if (!constraint.Match(
	                httpContext, 
    	            NullRouter.Instance, 
        	        parameterName, 
            	    combinedValues, 
                	RouteDirection.UrlGeneration))
            {
                return false;
            }
        }
        
        parameterName = null;
        constraint = null;
        return true;
    }
           
    // Step 2 - If the route is a match generate the appropriate URI   
    public static bool RoutePartsEqual(object? a, object? b)
    {
        var sa = a as string ?? (ReferenceEquals(SentinullValue.Instance, a) 
                                 	? string.Empty 
                                 	: null);
        var sb = b as string ?? (ReferenceEquals(SentinullValue.Instance, b) 
                                 	? string.Empty 
                                 	: null);
        
        // In case of strings, consider empty and null the same.
        // Since null cannot tell us the type, consider it to be a string if the other 
        // value is a string.
        if ((sa == string.Empty && sb == null) || 
            (sb == string.Empty && sa == null))
        {
            return true;
        }
        else if (sa != null && sb != null)
        {
            // For strings do a case-insensitive comparison
            return string.Equals(sa, sb, StringComparison.OrdinalIgnoreCase);
        }
        else
        {
            if (a != null && b != null)
            {
                // Explicitly call .Equals() in case it is overridden in the type
                return a.Equals(b);
            }
            else
            {
                // At least one of them is null. Return true if they both are
                return a == b;
            }
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool IsRoutePartNonEmpty(object? part)
    {
        if (part == null)
        {
            return false;
        }
        
        if (ReferenceEquals(SentinullValue.Instance, part))
        {
            return false;
        }
        
        if (part is string stringPart && stringPart.Length == 0)
        {
            return false;
        }
        
        return true;
    }                        
}

```

###### 2.1.5.1 try bind values core

```c#
public class TemplateBinder
{
    private bool TryBindValuesCore(
        UriBuildingContext context, 
        RouteValueDictionary acceptedValues)
    {
        // 遍历 parameter transformer，-> 使用 transform 对 accepted value 进行变换
        var parameterTransformers = _parameterTransformers;
        for (var i = 0; i < parameterTransformers.Length; i++)
        {
            (var parameterName, var transformer) = parameterTransformers[i];
            if (acceptedValues.TryGetValue(parameterName, out var value))
            {
                acceptedValues[parameterName] = transformer.TransformOutbound(value);
            }
        }
        
        // 遍历 pattern segment，
        var segments = _pattern.PathSegments;       
        var segmentsCount = segments.Count;                
        for (var i = 0; i < segmentsCount; i++)
        {
            Debug.Assert(context.BufferState == SegmentState.Beginning);
            Debug.Assert(context.UriState == SegmentState.Beginning);
            
            // 遍历 segment 中的 part，
            var parts = segments[i].Parts;           
            var partsCount = parts.Count;
            for (var j = 0; j < partsCount; j++)
            {
                var part = parts[j];
                
                // 如果 part 是 literal part，
                // 向 binding context 注入 part，如果不成功，-> false
                if (part is RoutePatternLiteralPart literalPart)
                {
                    if (!context.Accept(literalPart.Content))
                    {
                        return false;
                    }
                }
                // 如果 part 是 separator part，
                // 向 binding context 注入 part，如果不成功，-> false
                else if (part is RoutePatternSeparatorPart separatorPart)
                {
                    if (!context.Accept(separatorPart.Content))
                    {
                        return false;
                    }
                }
                // 如果 part 是 parameter part， 
                else if (part is RoutePatternParameterPart parameterPart)
                {                    
                    // 从 accepted values 中解析 parameter value，然后从 accepted values 中移除
                    acceptedValues.Remove(parameterPart.Name, out var value);
                    
                    // 判断 parameter value 与 default 是否相同
                    var isSameAsDefault = false;
                    if (_defaults != null &&
                        _defaults.TryGetValue(parameterPart.Name, out var defaultValue) &&
                        RoutePartsEqual(value, defaultValue))
                    {
                        isSameAsDefault = true;
                    }
                    
                    // 按照 culture info 转换 parameter value
                    var converted = Convert.ToString(value, CultureInfo.InvariantCulture);
                    
                    // 如果 parameter value 是 default value，
                    // buffer value 到 binding context，如果不成功，-> false
                    if (isSameAsDefault)
                    {
                        // If the accepted value is the same as the default value buffer 
                        // it since we won't necessarily add it to the URI we generate.
                        if (!context.Buffer(converted))
                        {
                            return false;
                        }
                    }
                    // 否则，即 parameter value 不是 default value，
                    else
                    {                        
                        // Example: template = {id}.{format?}. parameters: id=5
                        // In this case after we have generated "5.", we wont find any value
                        // for format, so we remove '.' and generate 5.
                        
                        // 如果不能向 binding context 注入 parameter value，
                        if (!context.Accept(converted, parameterPart.EncodeSlashes))
                        {
                            RoutePatternSeparatorPart? nullablePart;
                            
                            // 如果当前 parameter part 不是唯一的（complext segment),
                            // 且 parameter part 是 optional，
                            // 且 前一个 part 是 separator part
                            if (j != 0 && 
                                parameterPart.IsOptional && 
                                (nullablePart = parts[j - 1] as RoutePatternSeparatorPart) != null)
                            {
                                // 移除 separator part，见 example
                                separatorPart = nullablePart;
                                context.Remove(separatorPart.Content);
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
            }
            
            context.EndSegment();
        }
        
        // Generate the query string from the remaining values
        var wroteFirst = false;
        
        // 遍历 accepted values 中的 values
        foreach (var kvp in acceptedValues)
        {
            // 忽略 default（default 包含 accepted value key）
            if (_defaults != null && 
                _defaults.ContainsKey(kvp.Key))
            {
                // This value is a 'filter' we don't need to put it in the query string.
                continue;
            }
            
            var values = kvp.Value as IEnumerable;
            
            // 如果 values 不是 string，遍历 values 调用 add query key value
            if (values != null && !(values is string))
            {
                foreach (var value in values)
                {
                    wroteFirst |= AddQueryKeyValueToContext(
                        context, 
                        kvp.Key, 
                        value, 
                        wroteFirst);
                }
            }
            // 否则，即 values 是 string，直接调用 add query key value 方法
            else
            {
                wroteFirst |= AddQueryKeyValueToContext(
                    context, 
                    kvp.Key, 
                    kvp.Value, 
                    wroteFirst);
            }
        }
        
        return true;
    }
    
    private bool AddQueryKeyValueToContext(
        UriBuildingContext context, 
        string key, 
        object? value, 
        bool wroteFirst)
    {
        // 将 value 按照 culture 转换 -> string
        var converted = Convert.ToString(value, CultureInfo.InvariantCulture);
        
        if (!string.IsNullOrEmpty(converted))
        {
            if (context.LowercaseQueryStrings)
            {
                key = key.ToLowerInvariant();
                converted = converted.ToLowerInvariant();
            }
            
            /* 拼接 query string */
            
            // ‘?'开头；后面的是'&''
            context.QueryWriter.Write(wroteFirst ? '&' : '?');
            // query key
            _urlEncoder.Encode(context.QueryWriter, key);
            // '='
            context.QueryWriter.Write('=');
            // query value (converted)
            _urlEncoder.Encode(context.QueryWriter, converted);
            
            return true;
        }
        return false;
    }                                        
}
 
```

###### 2.1.5.2 bind values

```c#
public class TemplateBinder
{   
    // for route.get virtual path
    public string? BindValues(RouteValueDictionary acceptedValues)
    {
        // 解析 url binder context
        var context = _pool.Get();
        
        try
        {
            return TryBindValuesCore(context, acceptedValues) 
                	   ? context.ToString() 
                	   : null;
        }
        finally
        {
            // 返回 url binder context
            _pool.Return(context);
        }
    }
    
    // for link generator
    internal bool TryBindValues(
        RouteValueDictionary acceptedValues,
        LinkOptions? options,
        LinkOptions globalOptions,
        out (PathString path, QueryString query) result)
    {
        var context = _pool.Get();
        
        context.AppendTrailingSlash = options?.AppendTrailingSlash 
            ?? globalOptions.AppendTrailingSlash 
            ?? false;
        context.LowercaseQueryStrings = options?.LowercaseQueryStrings 
            ?? globalOptions.LowercaseQueryStrings 
            ?? false;
        context.LowercaseUrls = options?.LowercaseUrls 
            ?? globalOptions.LowercaseUrls 
            ?? false;

        try
        {
            if (TryBindValuesCore(context, acceptedValues))
            {
                result = (context.ToPathString(), context.ToQueryString());
                return true;
            }
            
            result = default;
            return false;
        }
        finally
        {
            _pool.Return(context);
        }
    }        
}

```

###### 2.1.5.3 link options?

```c#
public class LinkOptions
{    
    public bool? LowercaseUrls { get; set; }        
    public bool? LowercaseQueryStrings { get; set; }        
    public bool? AppendTrailingSlash { get; set; }
}

```

###### 2.1.5.4 get values

* 从传入参数 values、ambient values 中解析（过滤）可以使用的 value

```c#
public class TemplateBinder
{
    public TemplateValuesResult? GetValues(
        RouteValueDictionary? ambientValues, 
        RouteValueDictionary values)
    {
        /* 注入 slot value */
        
        // 复制 slots（仅有 key）
        var slots = new KeyValuePair<string, object?>[_slots.Length];
        Array.Copy(_slots, 0, slots, 0, slots.Length);
        // 
        var valueProcessedCount = 0;
               
        // 遍历 slots，从传入的 values 中按照 slot key 取值并注入 slot
        for (var i = 0; i < slots.Length; i++)
        {
            var key = slots[i].Key;
            if (values.TryGetValue(key, out var value))
            {                
                // 'senti null' for null explicit value，                
                value = IsRoutePartNonEmpty(value) ? value : SentinullValue.Instance;
                slots[i] = new KeyValuePair<string, object?>(key, value);
                
                // Track the count of processed values - this allows a fast path later.
                valueProcessedCount++;
            }
        }
                
        /* 判断是否需要使用 ambient value（for required value 特性路由）*/     
        
        var copyAmbientValues = ambientValues != null;
        if (copyAmbientValues)
        {
            // 遍历 required key，
            var requiredKeys = _requiredKeys;
            for (var i = 0; i < requiredKeys.Length; i++)
            {                
                // 获取 key
                var key = requiredKeys[i];   
                
                // 按照 key 从传入的 values 解析 explicit value
                var hasExplicitValue = values.TryGetValue(key, out var value);       
                
                // 按照 key 从传入的 ambient values 解析 ambient value，
                // （如果解析不到，ambient value = null）
                if (ambientValues == null || 
                    !ambientValues.TryGetValue(key, out var ambientValue))
                {
                    ambientValue = null;
                }
                
                // For now, only check ambient values with required values that don't 
                // have a parameter Ambient values for parameters are processed below
                
                /* 如果不能按照 key 解析 pattern parameter，
                   即 key 对应的可能是 filter，或者 key 不正确 */                                
                var hasParameter = _pattern.GetParameter(key) != null;                
                if (!hasParameter)
                {
                    // pattern required value 中没有 key 对应的 value， 
                    // 即，
                    //   ambient value 提供了: 
                    //   	pattern parameter 没有定义的、
                    //   	pattern required value 没有包含的 value，
                    //   -> 抛出异常
                    if (!_pattern.RequiredValues
                        		 .TryGetValue(key, out var requiredValue))
                    {
                        throw new InvalidOperationException(
                            $"Unable to find required value '{key}' on route pattern.");
                    }
                    // 由上，ambient value 与 pattern required value 不同，
                    // 并且 pattern required value 不是 any，
                    // 即，    
                    //   ambient value 提供了
                    //   	pattern parameter 没有定义的、
                    //   	pattern required value 包含的 value，
                    //   但是 ambient value 与 pattern required value 不同，
                    //   -> 标记不使用 ambient value，退出遍历    
                    if (!RoutePartsEqual(ambientValue, _pattern.RequiredValues[key]) &&
                        !RoutePattern.IsRequiredValueAny(_pattern.RequiredValues[key]))
                    {
                        copyAmbientValues = false;
                        break;
                    }
                    // 如果 explicit value 与 ambient value 不同，
                    // 即，
                    //   ambient value 提供了
                    //   	pattern parameter 没有定义的、
                    //   	pattern required value 包含的 value，
                    //   同时 value 也提供了对应值 explicit value，
                    //   但是 ambient value 与 explicit value 不同，
                    //   -> 标记不使用 ambient value，退出遍历
                    if (hasExplicitValue && 
                        !RoutePartsEqual(value, ambientValue))
                    {
                        copyAmbientValues = false;
                        break;
                    }
                }
            }
        }
                
        /* 解析、注入 parameter value（约定路由）*/
        
        // 遍历 pattern parameter，
        var parameters = _pattern.Parameters;
        var parameterCount = _pattern.Parameters.Count;
        for (var i = 0; i < parameterCount; i++)
        {
            // 从 slot 中取值（slot = parameter + filter，顺序是对应的）
            var key = slots[i].Key;
            var value = slots[i].Value;
            
            // Whether or not the value was explicitly provided is signficant when 
            // comparing ambient values. 
            // Remember that we're using a special sentinel value so that we can tell the
            // difference between an omitted value and an explicitly specified null.
            
            // explicit value
            var hasExplicitValue = value != null;
            // ambient value
            var hasAmbientValue = false;
            var ambientValue = (object?)null;
            // parameter
            var parameter = parameters[i];                        
            
            // 如果标记使用 ambient value，
            if (copyAmbientValues)
            {
                hasAmbientValue = ambientValues != null && 
                    			  ambientValues.TryGetValue(key, out ambientValue);
                
                // 如果能够解析 explicit value、ambient value，
                // 但是二者不相同，-> 标记不使用 ambient value
                if (hasExplicitValue && 
                    hasAmbientValue && 
                    !RoutePartsEqual(ambientValue, value))
                {
                    // Stop copying current values when we find one that doesn't match
                    copyAmbientValues = false;
                }
                // 如果不能解析 explicit value 且不能解析 ambient value，
                // 并且 parameter 没有对应的 default，
                // -> 标记不使用 ambient value
                if (!hasExplicitValue &&
                    !hasAmbientValue &&
                    _defaults?.ContainsKey(parameter.Name) != true)
                {
                    // This is an unsatisfied parameter value and there are no defaults. 
                    // We might still be able to generate a URL but we should stop 'accepting'
                    // ambient values.
                    //
                    // This might be a case like:
                    //   template: a/{b?}/{c?}
                    //   ambient: { c = 17 }
                    //   values: { }
                    //
                    // We can still generate a URL from this ("/a") but we shouldn't accept 
                    // 'c' because we can't use it.
                    //
                    // In the example above we should fall into this block for 'b'.
                    copyAmbientValues = false;
                }
            }
                        
            // 如果标记不使用 ambient value，且无法解析 explicit value            
            // 但是 pattern required value 包含 key 对应值，
            // -> 使用 ambient value as compromise
            if (!copyAmbientValues && 
                !hasExplicitValue && 
                _pattern.RequiredValues.TryGetValue(key, out var requiredValue))
            {
                hasAmbientValue = ambientValues != null && 
                    			 ambientValues.TryGetValue(key, out ambientValue);
                
                // 能够解析 ambient value，
                // 且 ambient value 与 required value 相同，或者 required value 是 any
                if (hasAmbientValue &&
                    (RoutePartsEqual(requiredValue, ambientValue) || 
                     RoutePattern.IsRequiredValueAny(requiredValue)))
                {
                    // Treat this an an explicit value to *force it*.
                    slots[i] = new KeyValuePair<string, object?>(key, ambientValue);
                    hasExplicitValue = true;
                    value = ambientValue;
                }
            }
            
            // If the parameter is a match, add it to the list of values we will use 
            // for URI generation
            
            // 如果能够解析 explicit value，且 explicit value 不是 senti null，
            // 后续处理。。。
            if (hasExplicitValue && 
                !ReferenceEquals(value, SentinullValue.Instance))
            {
                // Already has a value in the list, do nothing
            }
            // 否则，即
            //   不能解析 explicit value，或者 explicit value 是 senti null，
            // 如果标记了使用 ambient value 并且可以解析 ambient value，
            // -> slot = ambient value
            else if (copyAmbientValues && hasAmbientValue)
            {
                slots[i] = new KeyValuePair<string, object?>(key, ambientValue);
            }
            // 否则，即
            //   不能解析 explicit value，或者 explicit value 是 senti null，
            //   标记不使用 ambient，或者不能解析 ambient value，
            // 如果 parameter 是 optional 或者 catch all，
            // -> slot = default
            else if (parameter.IsOptional || parameter.IsCatchAll)
            {
                // Value isn't needed for optional or catchall parameters - wipe out the key, 
                // so it will be omitted from the RVD.
                slots[i] = default;
            }
            // 否则，即
            //   不能解析 explicit value，或者 explicit value 是 senti null，
            //   标记不使用 ambient，或者不能解析 ambient value，
            //   parameter 不是 optional 和 catch all，
            // 如果 default 不为 null，且 default 包含 key 对应的 value
            // -> slot = value
            else if (_defaults != null && 
                     _defaults.TryGetValue(parameter.Name, out var defaultValue))
            {
                
                // Add the default value only if there isn't already a new value for it and
                // only if it actually has a default value.
                slots[i] = new KeyValuePair<string, object?>(key, defaultValue);
            }
            // 否则，-> value = null
            else
            {      
                // If we get here, this parameter needs a value, but doesn't have one. 
                // This is a failure case.
                return null;
            }
        }
        
        // Any default values that don't appear as parameters are treated like filters. 
        // Any new values provided must match these defaults.
        
        /* 解析、注入 filter value */
        
        // 遍历 filter
        var filters = _filters;
        for (var i = 0; i < filters.Length; i++)
        {
            // 从 slot 中取值（slot = parameter + filter，顺序是对应的）
            var key = filters[i].Key;
            var value = slots[i + parameterCount].Value;
                        
            var hasExplictValue = value != null;
            if (hasExplictValue)
            {
                // If there is a non-parameterized value in the route and there is a
                // new value for it and it doesn't match, this route won't match.
                if (!RoutePartsEqual(value, filters[i].Value))
                {
                    return null;
                }
            }
            else
            {
                // If no value was provided, then blank out this slot so that it doesn't 
                // show up in accepted values.
                slots[i + parameterCount] = default;
            }
        }
        
        // At this point we've captured all of the 'known' route values, but we have't
        // handled an extra route values that were provided in 'values'. 
        // These all need to be included in the accepted values.               
        
        // 如果传入的 values 比 slots 多，
        // 将多余的、defaults 不包含的 value 注入 accepted values
        var acceptedValues = RouteValueDictionary.FromArray(slots);
        if (valueProcessedCount < values.Count)
        {
            // There are some values in 'value' that are unaccounted for, 
            // merge them into the dictionary.
            foreach (var kvp in values)
            {
                if (!_defaults!.ContainsKey(kvp.Key))
                {
#if RVD_TryAdd
                    acceptedValues.TryAdd(kvp.Key, kvp.Value);
#else
                    if (!acceptedValues.ContainsKey(kvp.Key))
                    {
                        acceptedValues.Add(kvp.Key, kvp.Value);
                    }
#endif
                }
            }
        }
        
        // Currently this copy is required because BindValues will mutate 
        // the accepted values
        var combinedValues = new RouteValueDictionary(acceptedValues);
        
        // Add any ambient values that don't match parameters - they need to be visible 
        // to constraints but they will ignored by link generation.
        CopyNonParameterAmbientValues(
            ambientValues: ambientValues,
            acceptedValues: acceptedValues,
            combinedValues: combinedValues);
        
        return new TemplateValuesResult()
        {
            AcceptedValues = acceptedValues,
            CombinedValues = combinedValues,
        };
    }
        
    private void CopyNonParameterAmbientValues(
        RouteValueDictionary? ambientValues,
        RouteValueDictionary acceptedValues,
        RouteValueDictionary combinedValues)
    {
        if (ambientValues == null)
        {
            return;
        }
        
        foreach (var kvp in ambientValues)
        {
            if (IsRoutePartNonEmpty(kvp.Value))
            {
                var parameter = _pattern.GetParameter(kvp.Key);
                if (parameter == null && !acceptedValues.ContainsKey(kvp.Key))
                {
                    combinedValues.Add(kvp.Key, kvp.Value);
                }
            }
        }
    }  
    
    // This represents an 'explicit null' in the slots array.
    [DebuggerDisplay("explicit null")]
    private class SentinullValue
    {
        public static object Instance = new SentinullValue();
        
        private SentinullValue()
        {
        }
        
        public override string ToString() => string.Empty;
    }
}

```

###### 2.1.5.5 template value result

```c#
public class TemplateValuesResult
{    
    public RouteValueDictionary AcceptedValues { get; set; } = default!;        
 
    // This combines implicit (ambient) values from the <see cref="RouteData"/> of the current request
    // (if applicable), explictly provided values, and default values for parameters that appear in
    // the route template.
    //
    // Implicit (ambient) values which are invalidated due to changes in values lexically earlier in the
    // route template are excluded from this set.
    public RouteValueDictionary CombinedValues { get; set; } = default!;
}

```

##### 2.1.6 template binder factory

###### 2.1.6.1 抽象基类

```c#
public abstract class TemplateBinderFactory
{    
    public abstract TemplateBinder Create(RoutePattern pattern);
    public abstract TemplateBinder Create(
        RouteTemplate template, 
        RouteValueDictionary defaults);           
}

```

###### 2.1.6.2 default template binder factory

```c#
internal sealed class DefaultTemplateBinderFactory : TemplateBinderFactory
{
    private readonly ParameterPolicyFactory _policyFactory;
    private readonly ObjectPool<UriBuildingContext> _pool;
    
    public DefaultTemplateBinderFactory(
        ParameterPolicyFactory policyFactory,
        ObjectPool<UriBuildingContext> pool)
    {
        if (policyFactory == null)
        {
            throw new ArgumentNullException(nameof(policyFactory));
        }        
        if (pool == null)
        {
            throw new ArgumentNullException(nameof(pool));
        }
        
        // 注入服务
        _policyFactory = policyFactory;
        _pool = pool;
        
    }
    
    // create by template
    public override TemplateBinder Create(
        RouteTemplate template, 
        RouteValueDictionary defaults)
    {
        if (template == null)
        {
            throw new ArgumentNullException(nameof(template));
        }        
        if (defaults == null)
        {
            throw new ArgumentNullException(nameof(defaults));
        }
        
        return new TemplateBinder(
            UrlEncoder.Default, 
            _pool, 
            template, 
            defaults);
    }
    
    // create by pattern
    public override TemplateBinder Create(RoutePattern pattern)
    {
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }
        
        // Now create the constraints and parameter transformers from the pattern
        var policies = new List<(string parameterName, IParameterPolicy policy)>();
        foreach (var kvp in pattern.ParameterPolicies)
        {
            var parameterName = kvp.Key;
            
            // It's possible that we don't have an actual route parameter, 
            // we need to support that case.
            var parameter = pattern.GetParameter(parameterName);
            
            // Use the first parameter transformer per parameter
            var foundTransformer = false;
            for (var i = 0; i < kvp.Value.Count; i++)
            {
                var parameterPolicy = _policyFactory.Create(parameter, kvp.Value[i]);
                
                if (!foundTransformer && 
                    parameterPolicy is IOutboundParameterTransformer parameterTransformer)
                {
                    policies.Add((parameterName, parameterTransformer));
                    foundTransformer = true;
                }
                
                if (parameterPolicy is IRouteConstraint constraint)
                {
                    policies.Add((parameterName, constraint));
                }
            }
        }
        
        return new TemplateBinder(
            UrlEncoder.Default, 
            _pool, 
            pattern, 
            policies);
    }
}

```

#### 2.2 route pattern

##### 2.2.1 route pattern

```c#
[DebuggerDisplay("{DebuggerToString()}")]
public sealed class RoutePattern
{
    /* 分隔符 */
    private const string SeparatorString = "/";    
    
    /* 通配符 any */
    // required value - *any* 类型
    [DebuggerDisplay("{DebuggerToString(),nq}")]
    private class RequiredValueAnySentinal
    {
        private string DebuggerToString() => "*any*";
    }
    // required value 常量
    public static readonly object RequiredValueAny = new RequiredValueAnySentinal();        
    // 判断 value 是不是 any   
    internal static bool IsRequiredValueAny(object? value)
    {
        return object.ReferenceEquals(RequiredValueAny, value);
    }
        
    // pattern 字符串
    public string? RawText { get; }
    
    // segments
    public IReadOnlyList<RoutePatternPathSegment> PathSegments { get; }
    
    // parameters
    public IReadOnlyList<RoutePatternParameterPart> Parameters { get; }     
    // parameter policy reference
    public IReadOnlyDictionary<
        string, 
    	IReadOnlyList<RoutePatternParameterPolicyReference>> 
            ParameterPolicies { get; }
    // (parameter) default
    public IReadOnlyDictionary<string, object?> Defaults { get; }   
    
    // required values（特性路由）
    public IReadOnlyDictionary<string, object?> RequiredValues { get; }       
    // precedence
    public decimal InboundPrecedence { get; }    
    public decimal OutboundPrecedence { get; }   
                                                                       
    internal RoutePattern(
        string? rawText,
        IReadOnlyDictionary<string, object?> defaults,
        IReadOnlyDictionary<
        	string, 
        	IReadOnlyList<RoutePatternParameterPolicyReference>> 
        		parameterPolicies,
        IReadOnlyDictionary<string, object?> requiredValues,
        IReadOnlyList<RoutePatternParameterPart> parameters,
        IReadOnlyList<RoutePatternPathSegment> pathSegments)
    {
        Debug.Assert(defaults != null);
        Debug.Assert(parameterPolicies != null);
        Debug.Assert(parameters != null);
        Debug.Assert(requiredValues != null);
        Debug.Assert(pathSegments != null);
        
        /* 注入 */
        RawText = rawText;
        PathSegments = pathSegments;
        Parameters = parameters;        
        ParameterPolicies = parameterPolicies;
        Defaults = defaults;
        RequiredValues = requiredValues;
               
        /* 计算 precedence */
        InboundPrecedence = RoutePrecedence.ComputeInbound(this);
        OutboundPrecedence = RoutePrecedence.ComputeOutbound(this);
    }
            
    // get parameter                                                
    public RoutePatternParameterPart? GetParameter(string name)
    {
        if (name == null)
        {
            throw new ArgumentNullException(nameof(name));
        }
        
        var parameters = Parameters;
        // Read interface .Count once rather than per iteration
        var parametersCount = parameters.Count;
        for (var i = 0; i < parametersCount; i++)
        {
            var parameter = parameters[i];
            if (string.Equals(
                	parameter.Name, 
                	name, 
                	StringComparison.OrdinalIgnoreCase))       
            { 
                return parameter;
            }
        }
        
        return null;
    }
    
    internal string DebuggerToString()
    {
        return RawText 
            ?? string.Join(
            	SeparatorString, 
            	PathSegments.Select(s => s.DebuggerToString()));
    }        
}

```

###### 2.2.1.1 pattern path segment

```c#
[DebuggerDisplay("{DebuggerToString()}")]
public sealed class RoutePatternPathSegment
{
    public IReadOnlyList<RoutePatternPart> Parts { get; }
    public bool IsSimple => Parts.Count == 1;
            
    internal RoutePatternPathSegment(IReadOnlyList<RoutePatternPart> parts)
    {
        Parts = parts;
    }
                
    internal string DebuggerToString()
    {
        return DebuggerToString(Parts);
    }
    
    internal static string DebuggerToString(IReadOnlyList<RoutePatternPart> parts)
    {
        return string.Join(
            string.Empty, 
            parts.Select(p => p.DebuggerToString()));
    }
}

```

###### 2.2.1.2 pattern part 

```c#
public abstract class RoutePatternPart
{
    public RoutePatternPartKind PartKind { get; }        
    
    // This class is **not** an extensibility point - every part of the routing system
    // needs to be aware of what kind of parts we support.       
    // It is abstract so we can add semantics later inside the library.
    private protected RoutePatternPart(RoutePatternPartKind partKind)
        
    {
        PartKind = partKind;
    }
    
    public bool IsLiteral => PartKind == RoutePatternPartKind.Literal;        
    public bool IsParameter => PartKind == RoutePatternPartKind.Parameter;        
    public bool IsSeparator => PartKind == RoutePatternPartKind.Separator;
        
    internal abstract string DebuggerToString();
}

// pattern part kind 枚举
public enum RoutePatternPartKind
{     
    Literal,          
    Parameter,          
    Separator,
}

```

###### a- literal part

```c#
[DebuggerDisplay("{DebuggerToString()}")]
public sealed class RoutePatternLiteralPart : RoutePatternPart
{
    public string Content { get; }
    
    internal RoutePatternLiteralPart(string content) 
        : base(RoutePatternPartKind.Literal)
    {
        Debug.Assert(!string.IsNullOrEmpty(content));
        Content = content;
    }
              
    internal override string DebuggerToString()
    {
        return Content;
    }
}

```

###### b- separator part

```c#
[DebuggerDisplay("{DebuggerToString()}")]
public sealed class RoutePatternSeparatorPart : RoutePatternPart
{
    public string Content { get; }
    
    internal RoutePatternSeparatorPart(string content)
        : base(RoutePatternPartKind.Separator)
    {
        Debug.Assert(!string.IsNullOrEmpty(content));            
        Content = content;
    }
            
    internal override string DebuggerToString()
    {
        return Content;
    }
}

```

###### c- parameter part

* 表示参数，形如`{*name:policy=default?}`

```c#
[DebuggerDisplay("{DebuggerToString()}")]
public sealed class RoutePatternParameterPart : RoutePatternPart
{
    public string Name { get; }    
    public object? Default { get; }
    public RoutePatternParameterKind ParameterKind { get; }
    public IReadOnlyList<RoutePatternParameterPolicyReference> ParameterPolicies { get; }      
    public bool EncodeSlashes { get; }        
    
    public bool IsCatchAll => ParameterKind == RoutePatternParameterKind.CatchAll;        
    public bool IsOptional => ParameterKind == RoutePatternParameterKind.Optional;
    
    internal RoutePatternParameterPart(
        string parameterName,
        object? @default,
        RoutePatternParameterKind parameterKind,
        RoutePatternParameterPolicyReference[] parameterPolicies)
            : this(
                parameterName, 
                @default, 
                parameterKind, 
                parameterPolicies, 
                encodeSlashes: true)
    {
    }
    
    internal RoutePatternParameterPart(
        string parameterName,
        object? @default,
        RoutePatternParameterKind parameterKind,
        RoutePatternParameterPolicyReference[] parameterPolicies,
        bool encodeSlashes)
        	: base(RoutePatternPartKind.Parameter)
    {
        // See #475 - this code should have some asserts, 
        // but it can't because of the design of RouteParameterParser.

        Name = parameterName;
        Default = @default;
        ParameterKind = parameterKind;
        ParameterPolicies = parameterPolicies;
        EncodeSlashes = encodeSlashes;
    }
                    
    internal override string DebuggerToString()
    {
        var builder = new StringBuilder();
        builder.Append("{");
        
        if (IsCatchAll)
        {
            builder.Append("*");
            if (!EncodeSlashes)
            {
                builder.Append("*");
            }
        }
        
        builder.Append(Name);
        
        foreach (var constraint in ParameterPolicies)
        {
            builder.Append(":");
            builder.Append(constraint.ParameterPolicy);
        }
        
        if (Default != null)
        {
            builder.Append("=");
            builder.Append(Default);
        }
        
        if (IsOptional)
        {
            builder.Append("?");
        }
        
        builder.Append("}");
        return builder.ToString();
    }
}

// pattern parameter part kind 枚举
public enum RoutePatternParameterKind
{    
    Standard,        
    Optional,        
    CatchAll,
}

```

###### 2.2.1.3 pattern parameter policy reference

* parameter policy 的封装，包含 parameter policy 本身和原始 content string

```c#
[DebuggerDisplay("{DebuggerToString()}")]
public sealed class RoutePatternParameterPolicyReference
{
    // policy 字符串
    public string? Content { get; }        
    // parameter policy
    public IParameterPolicy? ParameterPolicy { get; }
    
    internal RoutePatternParameterPolicyReference(string content)
    {
        Content = content;
    }
    
    internal RoutePatternParameterPolicyReference(IParameterPolicy parameterPolicy)
    {
        ParameterPolicy = parameterPolicy;
    }
                
    private string? DebuggerToString()
    {
        return Content;
    }
}

```

###### 2.2.1.4 route precedence

###### a- computer inbound

```c#
public static class RoutePrecedence
{    
    /* compute inbound with route template */
    
    // <example>
    //     e.g.: /api/template == 1.1
    //     /api/template/{id} == 1.13
    //     /api/{id:int} == 1.2
    //     /api/template/{id:int} == 1.12    
    public static decimal ComputeInbound(RouteTemplate template)
    {
        ValidateSegementLength(template.Segments.Count);

        // Each precedence digit corresponds to one decimal place. 
        // For example, 3 segments with precedences 2, 1, and 4 results in a combined 
        // precedence of 2.14 (decimal).
        var precedence = 0m;
        
        for (var i = 0; i < template.Segments.Count; i++)
        {
            var segment = template.Segments[i];
            
            var digit = ComputeInboundPrecedenceDigit(segment);
            Debug.Assert(digit >= 0 && digit < 10);
            
            precedence += decimal.Divide(digit, (decimal)Math.Pow(10, i));
        }
        
        return precedence;
    }
    
    // Segments have the following order:
    // 	1 - Literal segments
    // 	2 - Constrained parameter segments / Multi-part segments
    // 	3 - Unconstrained parameter segments
    // 	4 - Constrained wildcard parameter segments
    // 	5 - Unconstrained wildcard parameter segments
    private static int ComputeInboundPrecedenceDigit(TemplateSegment segment)
    {
        if (segment.Parts.Count > 1)
        {
            // Multi-part segments should appear after literal segments and along with 
            // parameter segments
            return 2;
        }
        
        var part = segment.Parts[0];
        // Literal segments always go first
        if (part.IsLiteral)
        {
            return 1;
        }
        else
        {
            Debug.Assert(part.IsParameter);
            var digit = part.IsCatchAll ? 5 : 3;
            
            // If there is a route constraint for the parameter, reduce order by 1
            // Constrained parameters end up with order 2, Constrained catch alls end up 
            // with order 4
            if (part.InlineConstraints != null && part.InlineConstraints.Any())
            {
                digit--;
            }
            
            return digit;
        }
    }
    
    /* computer inbound with route pattern */
        
    internal static decimal ComputeInbound(RoutePattern routePattern)
    {
        ValidateSegementLength(routePattern.PathSegments.Count);
        
        var precedence = 0m;
        
        for (var i = 0; i < routePattern.PathSegments.Count; i++)
        {
            var segment = routePattern.PathSegments[i];
            
            var digit = ComputeInboundPrecedenceDigit(routePattern, segment);
            Debug.Assert(digit >= 0 && digit < 10);
            
            precedence += decimal.Divide(digit, (decimal)Math.Pow(10, i));
        }
        
        return precedence;
    }
    
    /* compute inbound with route pattern and pattern path segment */
    
    internal static int ComputeInboundPrecedenceDigit(
        RoutePattern routePattern, 
        RoutePatternPathSegment pathSegment)
    {
        if (pathSegment.Parts.Count > 1)
        {
            // Multi-part segments should appear after literal segments and along with 
            // parameter segments
            return 2;
        }
        
        var part = pathSegment.Parts[0];
        // Literal segments always go first
        if (part.IsLiteral)
        {
            return 1;
        }
        else if (part is RoutePatternParameterPart parameterPart)
        {
            // Parameter with a required value is matched as a literal
            if (routePattern.RequiredValues
                			.TryGetValue(
                                parameterPart.Name, 
                                out var requiredValue) &&
                !RouteValueEqualityComparer.Default
                						   .Equals(requiredValue, string.Empty))
            {
                return 1;
            }
            
            var digit = parameterPart.IsCatchAll ? 5 : 3;
            
            
            // If there is a route constraint for the parameter, reduce order by 1
            // Constrained parameters end up with order 2, Constrained catch alls end up 
            // with order 4
            if (parameterPart.ParameterPolicies.Count > 0)
            {
                digit--;
            }    
            
            return digit;
        }
        else
        {
            // Unreachable
            throw new NotSupportedException();
        }
    }
       
    /* validate segment length */   
    
    private static void ValidateSegementLength(int length)
    {
        if (length > 28)
        {
            // An OverflowException will be thrown by Math.Pow when greater than 28
            throw new InvalidOperationException(
                "Route exceeds the maximum number of allowed segments of 28 and 
                "is unable to be processed.");
        }
    }                            
}

```

###### b- computer outbound

```c#
public static class RoutePrecedence
{                         
    /* compute outbound with route template */
    
    // <example>
    //     e.g.: /api/template    == 5.5
    //     /api/template/{id}     == 5.53
    //     /api/{id:int}          == 5.4
    //     /api/template/{id:int} == 5.54    
    public static decimal ComputeOutbound(RouteTemplate template)
    {
        ValidateSegementLength(template.Segments.Count);
        
        // Each precedence digit corresponds to one decimal place.
        // For example, 3 segments with precedences 2, 1, and 4 results in a combined 
        // precedence of 2.14 (decimal).
        var precedence = 0m;
        
        for (var i = 0; i < template.Segments.Count; i++)
        {
            var segment = template.Segments[i];
            
            var digit = ComputeOutboundPrecedenceDigit(segment);
            Debug.Assert(digit >= 0 && digit < 10);
            
            precedence += decimal.Divide(digit, (decimal)Math.Pow(10, i));
        }
        
        return precedence;
    }
    
    // Segments have the following order:
    // 	5 - Literal segments
    // 	4 - Multi-part segments && Constrained parameter segments
    // 	3 - Unconstrained parameter segements
    // 	2 - Constrained wildcard parameter segments
    // 	1 - Unconstrained wildcard parameter segments
    private static int ComputeOutboundPrecedenceDigit(TemplateSegment segment)
    {
        if(segment.Parts.Count > 1)
        {
            return 4;
        }
        
        var part = segment.Parts[0];
        if(part.IsLiteral)
        {
            return 5;
        }
        else
        {
            Debug.Assert(part.IsParameter);
            var digit = part.IsCatchAll ? 1 :  3;
            
            if (part.InlineConstraints != null && part.InlineConstraints.Any())
            {
                digit++;
            }
            
            return digit;
        }
    }
    
    
    /* compute outbound with route pattern */
        
    internal static decimal ComputeOutbound(RoutePattern routePattern)
    {
        ValidateSegementLength(routePattern.PathSegments.Count);
        
        // Each precedence digit corresponds to one decimal place. 
        // For example, 3 segments with precedences 2, 1, and 4 results in a combined 
        // precedence of 2.14 (decimal).
        var precedence = 0m;
        
        for (var i = 0; i < routePattern.PathSegments.Count; i++)
        {
            var segment = routePattern.PathSegments[i];
            
            var digit = ComputeOutboundPrecedenceDigit(segment);
            Debug.Assert(digit >= 0 && digit < 10);
            
            precedence += decimal.Divide(digit, (decimal)Math.Pow(10, i));
        }
        
        return precedence;
    }
                       
    private static int ComputeOutboundPrecedenceDigit(RoutePatternPathSegment pathSegment)
    {
        if (pathSegment.Parts.Count > 1)
        {
            return 4;
        }
        
        var part = pathSegment.Parts[0];
        if (part.IsLiteral)
        {
            return 5;
        }
        else if (part is RoutePatternParameterPart parameterPart)
        {
            Debug.Assert(parameterPart != null);
            var digit = parameterPart.IsCatchAll ? 1 : 3;
            
            if (parameterPart.ParameterPolicies.Count > 0)
            {
                digit++;
            }
            
            return digit;
        }
        else
        {
            // Unreachable
            throw new NotSupportedException();
        }
    }
    
    /* validate segment length */
    
    private static void ValidateSegementLength(int length)
    {
        if (length > 28)
        {
            // An OverflowException will be thrown by Math.Pow when greater than 28
            throw new InvalidOperationException(
                "Route exceeds the maximum number of allowed segments of 28 and 
                "is unable to be processed.");
        }
    }                            
}

```

##### 2.2.2  route pattern parser

```c#
internal static class RoutePatternParser
{
    private const char Separator = '/';
    private const char OpenBrace = '{';
    private const char CloseBrace = '}';
    private const char EqualsSign = '=';
    private const char QuestionMark = '?';
    private const char Asterisk = '*';
    private const string PeriodString = ".";
    
    internal static readonly char[] InvalidParameterNameChars = new char[]
    {
        Separator,
        OpenBrace,
        CloseBrace,
        QuestionMark,
        Asterisk
    };
    
    /* parse 方法 */
    
    public static RoutePattern Parse(string pattern)
    {
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }
        
        // 去掉 pattern 空格
        var trimmedPattern = TrimPrefix(pattern);        
        // 创建 pattern parse context
        var context = new Context(trimmedPattern);     
        
        /* 解析 segment */
        
        // 创建 pattern path segment（预结果）
        var segments = new List<RoutePatternPathSegment>();
        
        while (context.MoveNext())
        {
            var i = context.Index;
            
            // 如果当前字符是 separator，抛出异常
            if (context.Current == Separator)
            {
                // If we get here is means that there's a consecutive '/' character.
                // Templates don't start with a '/' and 
                // parsing a segment consumes the separator.
                throw new RoutePatternException(
                    pattern, 
                    Resources.TemplateRoute_CannotHaveConsecutiveSeparators);
            }
            
            // parse segment（同时递归 parse parameter），
            // 如果不成功，抛出异常
            if (!ParseSegment(context, segments))
            {
                throw new RoutePatternException(pattern, context.Error);
            }
            
            // A successful parse should always result in us 
            // being at the end or at a separator.
            Debug.Assert(context.AtEnd() || 
                         context.Current == Separator);
            
            if (context.Index <= i)
            {
                // This shouldn't happen, but we want to crash if it does.
                var message = "Infinite loop detected in the parser. Please open an issue.";
                throw new InvalidProgramException(message);
            }
        }
        
        // 如果 segments 有效，由 pattern factory 创建 pattern 并返回
        if (IsAllValid(context, segments))
        {
            return RoutePatternFactory.Pattern(pattern, segments);
        }
        // 否则，即 segments 无效，抛出异常
        else
        {
            throw new RoutePatternException(pattern, context.Error);
        }
    }
            
    private static bool IsAllValid(
        Context context, 
        List<RoutePatternPathSegment> segments)
    {
        // A catch-all parameter must be the last part of the last segment
        for (var i = 0; i < segments.Count; i++)
        {
            var segment = segments[i];
            for (var j = 0; j < segment.Parts.Count; j++)
            {
                var part = segment.Parts[j];
                if (part is RoutePatternParameterPart parameter && 
                    parameter.IsCatchAll &&
                    (i != segments.Count - 1 || j != segment.Parts.Count - 1))
                {
                    context.Error = Resources.TemplateRoute_CatchAllMustBeLast;
                    return false;
                }
            }
        }
        
        return true;
    }                        
    
    // 去掉 pattern string 的空格
    private static string TrimPrefix(string routePattern)
    {
        if (routePattern.StartsWith("~/", StringComparison.Ordinal))
        {
            return routePattern.Substring(2);
        }
        else if (routePattern.StartsWith("/", StringComparison.Ordinal))
        {
            return routePattern.Substring(1);
        }
        else if (routePattern.StartsWith("~", StringComparison.Ordinal))
        {
            throw new RoutePatternException(
                routePattern,
                Resources.TemplateRoute_InvalidRouteTemplate);
        }
        return routePattern;
    }   
    
    // (route pattern) contexxt
    [DebuggerDisplay("{DebuggerToString()}")]
    private class Context
    {
        /* parameter name 集合，存储解析 parameter name 结果 */
        private readonly HashSet<string> _parameterNames = 
            new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        
        public HashSet<string> ParameterNames
        {
            get 
            { 
                return _parameterNames; 
            }
        }
        
        // pattern string
        private readonly string _template;     
        
        private int _index;
        private int? _mark;  
        
        public int Index => _index;
        public char Current
        {
            get 
            { 
                return (_index < _template.Length && 
                        _index >= 0) 
                    		? _template[_index] 
                    		: (char)0; 
            }
        }
        public string Error { get; set; }
                        
        // 构造函数，注入 pattern string，index=-1
        public Context(string template)
        {
            Debug.Assert(template != null);
            
            _template = template;            
            _index = -1;
        }
                                        
        public bool Back()
        {
            return --_index >= 0;
        }
        
        public bool AtEnd()
        {
            return _index >= _template.Length;
        }
        
        public bool MoveNext()
        {
            return ++_index < _template.Length;
        }
                      
        public void Mark()
        {
            Debug.Assert(_index >= 0);
            
            // Index is always the index of the character *past* Current 
            // - we want to 'mark' Current.
            _mark = _index;
        }
        
        public string Capture()
        {
            if (_mark.HasValue)
            {
                var value = _template.Substring(_mark.Value, _index - _mark.Value);
                _mark = null;
                return value;
            }
            else
            {
                return null;
            }
        }
        
        private string DebuggerToString()
        {
            if (_index == -1)
            {
                return _template;
            }
            else if (_mark.HasValue)
            {
                return _template.Substring(0, _mark.Value) +
	                   "|" +
    	               _template.Substring(_mark.Value, _index - _mark.Value) +
        	           "|" +
            	       _template.Substring(_index);
            }
            else
            {
                return _template.Substring(0, _index) + 
	                   "|" + 
    	               _template.Substring(_index);
            }
        }
    }
}

```

###### 2.2.2.1 parse segment & valid

```c#
internal static class RoutePatternParser
{
    private static bool ParseSegment(
        Context context, 
        List<RoutePatternPathSegment> segments)
    {
        Debug.Assert(context != null);
        Debug.Assert(segments != null);
        
        // 创建 route pattern part 集合
        var parts = new List<RoutePatternPart>();
        
        while (true)
        {
            var i = context.Index;
            
            // 如果是“{”，
            if (context.Current == OpenBrace)
            {
                // string 已经 end，即单独“{”，-> 错误
                if (!context.MoveNext())
                {
                    // This is a dangling open-brace, which is not allowed
                    context.Error = Resources.TemplateRoute_MismatchedParameter;
                    return false;
                }
                // 下一个 char 是“{”，
                if (context.Current == OpenBrace)
                {
                    // 解析 literal，保存到 parts，
                    // 如果解析失败 -> 错误
                    // This is an 'escaped' brace in a literal, like "{{foo"
                    context.Back();
                    if (!ParseLiteral(context, parts))
                    {
                        return false;
                    }
                }
                // 应该是 parameter，
                else
                {
                    // 解析 parameter，保存到 parts，
                    // 如果解析失败 -> 错误
                    // This is a parameter
                    context.Back();
                    if (!ParseParameter(context, parts))
                    {
                        return false;
                    }
                }
            }
            // 否则，即不是“{”，
            // 解析 literal part，保存到 parts，
            // 如果解析失败 -> 错误
            else
            {
                if (!ParseLiteral(context, parts))
                {
                    return false;
                }
            }
            // 如果是分隔符“/”或者 string 已经 end，-> 结束            
            if (context.Current == Separator || context.AtEnd())
            {
                // We've reached the end of the segment
                break;
            }
            
            if (context.Index <= i)
            {
                // This shouldn't happen, but we want to crash if it does.
                var message = "Infinite loop detected in the parser. Please open an issue.";
                throw new InvalidProgramException(message);
            }
        }
        
        // 如果 parts 合规，由 parts 创建 route pattern path segment，
        // 注入到 segment 
        if (IsSegmentValid(context, parts))
        {
            segments.Add(new RoutePatternPathSegment(parts));
            return true;
        }
        // 否则，返回 false
        else
        {
            return false;
        }
    }
    
    // 验证 parts 是否合规
    private static bool IsSegmentValid(
        Context context, 
        List<RoutePatternPart> parts)
    {
        /* 包含多个 part，且有 parameter part 标记为 catch all，错误 */           
        // If a segment has multiple parts, then it can't contain a catch all.
        for (var i = 0; i < parts.Count; i++)
        {
            var part = parts[i];
            if (part is RoutePatternParameterPart parameter && 
                parameter.IsCatchAll && 
                parts.Count > 1)
            {
                context.Error = Resources.TemplateRoute_CannotHaveCatchAllInMultiSegment;
                return false;
            }
        }
        
        /* 包含多个 part，且有 parameter part 标记 optional。。。*/          
        // if a segment has multiple parts, then only the last one parameter can be optional
        // if it is following a optional seperator.
        for (var i = 0; i < parts.Count; i++)
        {
            var part = parts[i];
            
            // 如果是 parameter part 且标记为 optional
            if (part is RoutePatternParameterPart parameter && 
                parameter.IsOptional && 
                parts.Count > 1)
            {
                /* 如果上述 parameter part 是最后一个（可选参数必须在最后），*/
                // This optional parameter is the last part in the segment
                if (i == parts.Count - 1)
                {
                    // 解析之前一个 parameter part
                    var previousPart = parts[i - 1];
                    
                    /* 如果 pre part 是 parameter part -> 错误 */                               
                    /* parameter part 之间只能用“.”连接 */                       
                    if (!previousPart.IsLiteral && 
                        !previousPart.IsSeparator)
                    {
                        // The optional parameter is preceded by something 
                        // that is not a literal or separator
                        // Example of error message:
                        // "In the segment '{RouteValue}{param?}', 
                        // the optional parameter 'param' is preceded 
                        // by an invalid segment '{RouteValue}'. 
                        // Only a period (.) can precede an optional parameter.
                        context.Error = 
                            Resources.FormatTemplateRoute
                            		  _OptionalParameterCanbBePrecededByPeriod(
                            			  RoutePatternPathSegment.DebuggerToString(parts),
                            			  parameter.Name,
                            			  parts[i - 1].DebuggerToString());
                        
                        return false;
                    }
                    /* 如果 pre part 是 literal part，但不是“."字符 -> 错误 */
                    /* parameter part 之间只能用“.”连接 */      
                    else if (previousPart is RoutePatternLiteralPart literal && 
                             literal.Content != PeriodString)
                    {
                        // The optional parameter is preceded by a literal other than period.
                        // Example of error message:
                        // "In the segment '{RouteValue}-{param?}', 
                        // the optional parameter 'param' is preceded
                        // by an invalid segment '-'. 
                        // Only a period (.) can precede an optional parameter.
                        context.Error = 
                            Resources.FormatTemplateRoute
		                              _OptionalParameterCanbBePrecededByPeriod(
          			                      RoutePatternPathSegment.DebuggerToString(parts),
                    			          parameter.Name,
                                		  parts[i - 1].DebuggerToString());
                        
                        return false;
                    }
                    
                    /* pre part 是 separator part（“."），
                       使用 route pattern factory 创建 separator part 并注入 "*/                 
                    parts[i - 1] = 
                        RoutePatternFactory.SeparatorPart(
                        	((RoutePatternLiteralPart)previousPart).Content);
                }
                /* 否则，即标记为 optional 的 parameter part 不是最后一个 -> 错误 */               
                else
                {
                    // This optional parameter is not the last one in the segment
                    // Example:
                    // An optional parameter must be at the end of the segment. 
                    // In the segment '{RouteValue?})',
                    // optional parameter 'RouteValue' is followed by ')'
                    context.Error = 
                        Resources.FormatTemplateRoute
		                          _OptionalParameterHasTobeTheLast(
          			                  RoutePatternPathSegment.DebuggerToString(parts),
                    			      parameter.Name,
		                              parts[i + 1].DebuggerToString());
                    
                    return false;
                }
            }
        }
        
        /* 如果有不止一个 parameter part -> 错误 */
        /* 一个 segment 只能有一个 parameter part */        
        var isLastSegmentParameter = false;
        for (var i = 0; i < parts.Count; i++)
        {
            var part = parts[i];
            if (part.IsParameter && isLastSegmentParameter)
            {
                context.Error = Resources
                    .TemplateRoute_CannotHaveConsecutiveParameters;
                return false;
            }
            
            isLastSegmentParameter = part.IsParameter;
        }
        
        /* 没有上述情况，合规 */
        return true;
    }
}

```

###### 2.2.2.2 parse parameter & valid

```c#
internal static class RoutePatternParser
{
    private static bool ParseParameter(
        Context context, 
        List<RoutePatternPart> parts)
    {
        // 下一个，即保证去掉了代表 parameter part 开始的“{”
        Debug.Assert(context.Current == OpenBrace);
        context.Mark();        
        context.MoveNext();
        
        while (true)
        {
            // 如果是“{”
            if (context.Current == OpenBrace)
            {
                /* 没有 end 。。。*/
                // This is an open brace inside of a parameter, it has to be escaped
                if (context.MoveNext())
                {
                    /* 下一个字符不是“{”，即 包含单独的“{” -> 错误 */
                    if (context.Current != OpenBrace)
                    {
                        // If we see something like "{p1:regex(^\d{3", we will come here.
                        context.Error = Resources.TemplateRoute_UnescapedBrace;
                        return false;
                    }
                }
                /* 已经 end 。。。，即包含“}“ -> 错误 */
                else
                {
                    // This is a dangling open-brace, which is not allowed
                    // Example: "{p1:regex(^\d{"
                    context.Error = Resources.TemplateRoute_MismatchedParameter;
                    return false;
                }
            }
            // 如果是“}”
            else if (context.Current == CloseBrace)
            {
                /* 已经 end 。。。，退出 */
                // When we encounter Closed brace here, 
                // it either means end of the parameter or it is a closed
                // brace in the parameter, in that case it needs to be escaped.
                // Example: {p1:regex(([}}])\w+}. 
                // First pair is escaped one and last marks end of the parameter
                if (!context.MoveNext())
                {
                    // This is the end of the string -and we have a valid parameter
                    break;
                }
                /* 没有 end，且下一个字符（在上面代码中已经 move next）是“}”，
                   即包含“}}”，继续 */
                if (context.Current == CloseBrace)
                {
                    // This is an 'escaped' brace in a parameter name
                }
                /* 否则，即已经 end，且只有一个“}”，结束*/
                else
                {
                    // This is the end of the parameter
                    break;
                }
            }
            
            /* 已经 end，包含单独的“}” -> 错误 */
            if (!context.MoveNext())
            {
                // This is a dangling open-brace, which is not allowed
                context.Error = Resources.TemplateRoute_MismatchedParameter;
                return false;
            }
        }
        
        // 截取 context 中的 string text        
        var text = context.Capture();
        // 如果是“{}” -> 错误
        if (text == "{}")
        {
            context.Error = Resources
                .FormatTemplateRoute_InvalidParameterName(string.Empty);
            return false;
        }
        // 截取 parameter text，
        // 因为上面代码已经 move next
        var inside = text.Substring(1, text.Length - 2);
        // 替换“{{”和“}}”
        var decoded = inside.Replace("}}", "}").Replace("{{", "{");
        
        /* 使用 route parameter parser 解析 parameter part */
        // At this point, we need to parse the raw name for inline constraint,
        // default values and optional parameters.
        var templatePart = RouteParameterParser.ParseRouteParameter(decoded);
        
        // See #475 - this is here because InlineRouteParameterParser can't return errors
        
        /* 如果同时标记了通配符“*”和“？” -> 错误 */
        if (decoded.StartsWith("*", StringComparison.Ordinal) && 
            decoded.EndsWith("?", StringComparison.Ordinal))
        {
            context.Error = 
                Resources.TemplateRoute_CatchAllCannotBeOptional;
            return false;
        }
        /* 如果解析到 parameter part 是 optional 但是没有 default -> 错误 */
        if (templatePart.IsOptional && 
            templatePart.Default != null)
        {
            // Cannot be optional and have a default value.
            // The only way to declare an optional parameter is to have a ? at the end,
            // hence we cannot have both default value 
            // and optional parameter within the template.
            // A workaround is to add it as a separate entry in the defaults argument.
            context.Error = 
                Resources.TemplateRoute_OptionalCannotHaveDefaultValue;
            return false;
        }
                
        // 验证 parameter name
        var parameterName = templatePart.Name;        
        if (IsValidParameterName(context, parameterName))
        {
            // 合规，注入 parts
            parts.Add(templatePart);
            return true;
        }
        // parameter name 不合规，错误
        else
        {
            return false;
        }
    }
    
    // 验证 parameter name
    private static bool IsValidParameterName(
        Context context, 
        string parameterName)
    {
        // 如果 parameter name 为 empty，或者包含 invalid char -> 错误
        if (parameterName.Length == 0 || 
            parameterName.IndexOfAny(InvalidParameterNameChars) >= 0)
        {
            context.Error = 
                Resources.FormatTemplateRoute_InvalidParameterName(parameterName);
            return false;
        }
        // 如果 parameter name 无法注入 context，即有重名 parameter name -> 错误
        if (!context.ParameterNames.Add(parameterName))
        {
            context.Error = 
                Resources.FormatTemplateRoute_RepeatedParameter(parameterName);
            return false;
        }
        
        return true;
    }
}

```

###### 2.2.2.3 parse literal & valid

```c#
internal static class RoutePatternParser
{
    private static bool ParseLiteral(
        Context context, 
        List<RoutePatternPart> parts)
    {
        // 下一个，即保证去掉了代表 literal part 开头的“/“
        context.Mark();
        
        while (true)
        {
            /* 如果是“/”，结束 */
            if (context.Current == Separator)
            {
                // End of the segment
                break;
            }
            /* 如果是“{”，*/
            else if (context.Current == OpenBrace)
            {
                /* 如果 end，错误 */
                if (!context.MoveNext())
                {
                    // This is a dangling open-brace, which is not allowed
                    context.Error = Resources.TemplateRoute_MismatchedParameter;
                    return false;
                }
                /* 如果是“{”（已经 move next），即包含“{{”，继续 */
                if (context.Current == OpenBrace)
                {
                    // This is an 'escaped' brace in a literal, like "{{foo" - keep going.
                }
                /* 以“{”开始，说明是 parameter，context 回退（为了转向 parameter 解析）*/
                else
                {
                    // We've just seen the start of a parameter, so back up.
                    context.Back();
                    break;
                }
            }
            /* 如果是“}“*/
            else if (context.Current == CloseBrace)
            {
                /* 如果 end，错误 */
                if (!context.MoveNext())
                {
                    // This is a dangling close-brace, which is not allowed
                    context.Error = Resources.TemplateRoute_MismatchedParameter;
                    return false;
                }
                /* 如果是“}”（已经 move next），即包含“}}”，继续 */
                if (context.Current == CloseBrace)
                {
                    // This is an 'escaped' brace in a literal, like "{{foo" - keep going. 
                }
                /* 仅有一个“}”，错误 */
                else
                {
                    // This is an unbalanced close-brace, which is not allowed
                    context.Error = Resources.TemplateRoute_MismatchedParameter;
                    return false;
                }
            }
            /* 如果 end，结束 */
            if (!context.MoveNext())
            {
                break;
            }
        }
        
        // 获取 literal 字符，替换 “{{“、”}}“
        var encoded = context.Capture();
        var decoded = encoded.Replace("}}", "}").Replace("{{", "{");
        
        // 检查 valid
        if (IsValidLiteral(context, decoded))
        {
            parts.Add(RoutePatternFactory.LiteralPart(decoded));
            return true;
        }
        else
        {
            return false;
        }
    }
    
    // 验证 literal
    private static bool IsValidLiteral(Context context, string literal)
    {
        Debug.Assert(context != null);
        Debug.Assert(literal != null);
        
        // 如果包含“？”，错误
        if (literal.IndexOf(QuestionMark) != -1)
        {
            context.Error = Resources.FormatTemplateRoute_InvalidLiteral(literal);
            return false;
        }
        
        return true;
    }
}

```

##### 2.2.3 route parameter parser

###### 2.2.3.1 parse parameter

```c#
internal static class RouteParameterParser
{
    // This code parses the inside of the route parameter 
    //
    // Ex: {hello} - this method is responsible for parsing 'hello'
    // The factoring between this class and RoutePatternParser is due to legacy.
    public static RoutePatternParameterPart ParseRouteParameter(string parameter)
    {
        // paramete string 为 null，抛出异常
        if (parameter == null)
        {
            throw new ArgumentNullException(nameof(parameter));
        }
        
        // parameter string 为 empty，创建 empty parameter part
        if (parameter.Length == 0)
        {
            return new RoutePatternParameterPart(
                string.Empty, 
                null, 
                RoutePatternParameterKind.Standard, 
                Array.Empty<RoutePatternParameterPolicyReference>());
        }
                
        var startIndex = 0;
        var endIndex = parameter.Length - 1;
        var encodeSlashes = true;        
        var parameterKind = RoutePatternParameterKind.Standard;
        
        // 处理前缀 prefix，如果有“**”或者“*”表示 catch all
        if (parameter.StartsWith("**", StringComparison.Ordinal))
        {
            encodeSlashes = false;
            parameterKind = RoutePatternParameterKind.CatchAll;
            startIndex += 2;
        }
        else if (parameter[0] == '*')
        {
            parameterKind = RoutePatternParameterKind.CatchAll;
            startIndex++;
        }
        // 处理后缀，如果有“？”表示 optional 
        if (parameter[endIndex] == '?')
        {
            parameterKind = RoutePatternParameterKind.Optional;
            endIndex--;
        }
        
        var currentIndex = startIndex;
        
        /* 解析 parameter name */
        
        var parameterName = string.Empty;
        while (currentIndex <= endIndex)
        {
            var currentChar = parameter[currentIndex];
            
            // 字符串中的 ':' 和 '='' 后面的是 constraint 或者 defualt，
            // 前面部分就是 parameter name
            // param name 可以由 ':' 和 '=' 开头，所以忽略第一个 ':' 或 '='，
            // 即 startIndex != currentIndex
            if ((currentChar == ':' || currentChar == '=') && 
                startIndex != currentIndex)
            {                
                parameterName = parameter.Substring(
                    startIndex, 
                    currentIndex - startIndex);
                
                // Roll the index back and move to the constraint parsing stage.
                currentIndex--;
                break;
            }
            else if (currentIndex == endIndex)
            {
                parameterName = parameter.Substring(
                    startIndex, 
                    currentIndex - startIndex + 1);
            }
            
            currentIndex++;
        }
		
        /* 解析 constraints */
        
        var parseResults = ParseConstraints(
            parameter, 
            currentIndex, 
            endIndex);
        
        /* 解析 default value */
        
        currentIndex = parseResults.CurrentIndex;        
        string? defaultValue = null;
        
        // 字符串中 '=' 后面的是 default value
        if (currentIndex <= endIndex &&
            parameter[currentIndex] == '=')
        {
            defaultValue = parameter.Substring(
                currentIndex + 1, 
                endIndex - currentIndex);
        }
        
        /* 创建 parameter part */
        
        return new RoutePatternParameterPart(
            parameterName,
            defaultValue,
            parameterKind,
            parseResults.ParameterPolicies,
            encodeSlashes);
    }           
}

```

###### 2.2.3.2 parse parameter constraint

```c#
internal static class RouteParameterParser
{
    private enum ParseState
    {
        Start,				// 开始解析
        ParsingName,		// 找到了约束（“：”开头），开始解析约束
        InsideParenthesis,	// 找到了约束的参数（“（”开头），开始解析约束参数
        End					// 结束解析
    }
    
    /* parameter policy result 结构体 */
    private readonly struct ParameterPolicyParseResults
    {
        public readonly int CurrentIndex;        
        public readonly RoutePatternParameterPolicyReference[] ParameterPolicies;
        
        public ParameterPolicyParseResults(
            int currentIndex, 
            RoutePatternParameterPolicyReference[] parameterPolicies)
        {
            CurrentIndex = currentIndex;
            ParameterPolicies = parameterPolicies;
        }
    }
    
    /* 解析 constraint result */
    private static ParameterPolicyParseResults ParseConstraints(
        string text,
        int currentIndex,
        int endIndex)
    {
        // 初始化 constraints
        var constraints = new ArrayBuilder<RoutePatternParameterPolicyReference>(0);
        var state = ParseState.Start;
        var startIndex = currentIndex;
        
        do
        {
            // 解析当前字符
            var currentChar = currentIndex > endIndex 
                ? null 
                : (char?)text[currentIndex];
            
            switch (state)
            {
                // 开始解析
                case ParseState.Start:
                    switch (currentChar)
                    {
                        case null:
                            state = ParseState.End;                               
                            break; 
                        case ':':	// 找到“：”，有约束，后面是约束，
                            		// 转到约束解析过程
                            state = ParseState.ParsingName;
                            startIndex = currentIndex + 1;
                            break;
                        case '(':	// 找到“（”，由约束的参数，后面是参数，
                            		// 转到解析约束参数的过程
                            state = ParseState.InsideParenthesis;
                            break;
                        case '=':	// 找到“=”，没有约束，后面是 default value，
                            		// 解析结束
                            state = ParseState.End;
                            currentIndex--;
                            break;
                    }
                    break;
                // 解析约束的参数
                case ParseState.InsideParenthesis:
                    switch (currentChar)
                    {
                        case null:
                            state = ParseState.End;
                            var constraintText = text.Substring(
                                startIndex, 
                                currentIndex - startIndex);
                            constraints.Add(
                                RoutePatternFactory
                                	.ParameterPolicy(constraintText));
                            break;
                        case ')':
                            // Only consume a ')' token if
                            // (a) it is the last token
                            // (b) the next character is the start of the new constraint ':
                            // (c) the next character is the start of the default value.
                            var nextChar = currentIndex + 1 > endIndex 
                                ? null 
                                : (char?)text[currentIndex + 1];
                            switch (nextChar)
                            {
                                case null:
                                    state = ParseState.End;
                                    constraintText = text.Substring(
                                        startIndex, 
                                        currentIndex - startIndex + 1);
                                    constraints.Add(
                                        RoutePatternFactory
                                        	.ParameterPolicy(constraintText));
                                    break;
                                case ':':
                                    state = ParseState.Start;
                                    constraintText = text.Substring(
                                        startIndex, 
                                        currentIndex - startIndex + 1);
                                    constraints.Add(
                                        RoutePatternFactory
                                        	.ParameterPolicy(constraintText));
                                    startIndex = currentIndex + 1;
                                    break;
                                case '=':
                                    state = ParseState.End;
                                    constraintText = text.Substring(
                                        startIndex, 
                                        currentIndex - startIndex + 1);
                                    constraints.Add(
                                        RoutePatternFactory
                                        	.ParameterPolicy(constraintText));
                                    break;
                            }
                            break;
                        case ':':
                        case '=':
                            // In the original implementation, 
                            // the Regex would've backtracked if it encountered an
                            // unbalanced opening bracket followed by 
                            // (not necessarily immediatiely) a delimiter.
                            // Simply verifying that the parantheses will eventually 
                            // be closed should suffice to determine 
                            // if the terminator needs to be consumed as part of 
                            // the current constraint specification.
                            var indexOfClosingParantheses = text.IndexOf(
                                ')', 
                                currentIndex + 1);
                            
                            if (indexOfClosingParantheses == -1)
                            {
                                constraintText = text.Substring(
                                    startIndex, 
                                    currentIndex - startIndex);
                                    constraints.Add(
                                        RoutePatternFactory
                                        	.ParameterPolicy(constraintText));
                                
                                if (currentChar == ':')
                                {
                                    state = ParseState.ParsingName;
                                    startIndex = currentIndex + 1;
                                }
                                else
                                {
                                    state = ParseState.End;
                                    currentIndex--;
                                }
                            }
                            else
                            {
                                currentIndex = indexOfClosingParantheses;
                            }
                            
                            break;
                    }
                    break;
                // 解析约束
                case ParseState.ParsingName:
                    switch (currentChar)
                    {
                        case null:	// null，字符串已经结尾
                            		// 解析解析，
                            // 截取字符串为 constraint name，加入 constraints 集合
                            state = ParseState.End;
                            var constraintText = text.Substring(
                                startIndex, 
                                currentIndex - startIndex);
                            if (constraintText.Length > 0)
                            {                                    
                                constraints.Add(
                                RoutePatternFactory
                                	.ParameterPolicy(constraintText));
                            }
                            break;
                        case ':':	// 找到“：”，表示有另一一个约束   
                            // 截取字符串为 constraint name，加入 constraints 集合
                            constraintText = text.Substring(
                                startIndex, 
                                currentIndex - startIndex);
                            if (constraintText.Length > 0)
                            {
                                constraints.Add(
                                    RoutePatternFactory
                                    	.ParameterPolicy(constraintText));
                            }
                            startIndex = currentIndex + 1;
                            break;
                        case '(':	// 找到“（”，有参数，
                            		// 转到约束参数解析过程
                            state = ParseState.InsideParenthesis;
                            break;
                        case '=':	// 找到“=”，后面是 default value
                            		// 约束解析结束，
                            		// 截取字符串为 constraint name, 加入 constraints 集合
                            state = ParseState.End;
                            constraintText = text.Substring(
                                startIndex, 
                                currentIndex - startIndex);
                            if (constraintText.Length > 0)
                            {
                                constraints.Add(
                                    RoutePatternFactory
                                    	.ParameterPolicy(constraintText));
                            }
                            currentIndex--;
                            break;
                    }
                    break;
            }
            
            // 不是上述情况，即解析中的普通字符，
            // 移动字符指针
            currentIndex++;            
        } 
        while (state != ParseState.End);
        
        // 创建结果
        return new ParameterPolicyParseResults(
            currentIndex, 
            constraints.ToArray());
    }        
}

```

##### 2.2.4 route pattern factory

```c#
public static class RoutePatternFactory
{
    // empty dictionary，default、required value 的默认值
    private static readonly IReadOnlyDictionary<string, object?> 
        EmptyDictionary = 
        	new ReadOnlyDictionary<string, object?>(
        		new Dictionary<string, object?>());
    
    // empty parameter policy reference dictionary
    private static readonly IReadOnlyDictionary<
        string, 
    	IReadOnlyList<RoutePatternParameterPolicyReference>> 
            EmptyPoliciesDictionary =
            	new ReadOnlyDictionary<
            		string, 
    				IReadOnlyList<RoutePatternParameterPolicyReference>>(
                        new Dictionary<string, 
                        ReadOnlyList<RoutePatternParameterPolicyReference>>());                                                   
    /* 通过构造函数创建 route pattern */
    private static RoutePattern PatternCore(
        string? rawText,
        RouteValueDictionary? defaults,
        RouteValueDictionary? parameterPolicies,
        RouteValueDictionary? requiredValues,
        IEnumerable<RoutePatternPathSegment> segments)
    {
        // We want to merge the segment data with the 'out of line' defaults 
        // and parameter policies.
        //
        // This means that for parameters that have 'out of line' defaults we will modify
        // the parameter to contain the default (same story for parameter policies).
        //
        // We also maintain a collection of defaults and parameter policies that will also
        // contain the values that don't match a parameter.
        //
        // It's important that these two views of the data are consistent. We don't want
        // values specified out of line to have a different behavior.
        
        /* a- 注入 default values */
        
        // 创建 updated defaults 集合（预结果）
        Dictionary<string, object?>? updatedDefaults = null;        
        // 如果参数 defaults 有效（不为 null 且不为 empty）
        if (defaults != null && 
            defaults.Count > 0)
        {
            updatedDefaults = new Dictionary<string, object?>(
                defaults.Count, 
                StringComparer.OrdinalIgnoreCase);
            
            // 遍历参数 defaults，将值注入 updated defaults 
            foreach (var kvp in defaults)
            {
                updatedDefaults.Add(kvp.Key, kvp.Value);
            }
        }
        
        /* b- 注入 parameter policies */
        
        // 创建 updated parameter policy reference 集合（预结果）
        Dictionary<string, 
        		   List<RoutePatternParameterPolicyReference>>? 
        	updatedParameterPolicies = null;
        // 如果参数 policies 有效（不为 null 且不为 empty）
        if (parameterPolicies != null && 
            parameterPolicies.Count > 0)
        {
            updatedParameterPolicies = 
                new Dictionary<string, 
            				   List<RoutePatternParameterPolicyReference>>(
                                   parameterPolicies.Count, 
                                   StringComparer.OrdinalIgnoreCase);
            // 遍历参数 parameter policies，将有效值注入 updated policies
            foreach (var kvp in parameterPolicies)
            {
                var policyReferences = new List<RoutePatternParameterPolicyReference>();
                
                if (kvp.Value is IParameterPolicy parameterPolicy)
                {
                    policyReferences.Add(ParameterPolicy(parameterPolicy));
                }
                else if (kvp.Value is string)
                {
                    // Constraint will convert string values into regex constraints
                    policyReferences.Add(Constraint(kvp.Value));
                }
                else if (kvp.Value is IEnumerable multiplePolicies)
                {
                    foreach (var item in multiplePolicies)
                    {
                        // Constraint will convert string values into regex constraints
                        policyReferences.Add(
                            item is IParameterPolicy p 
                            	? ParameterPolicy(p) 
                            	: Constraint(item));
                    }
                }
                else
                {
                    throw new InvalidOperationException(
                        Resources.FormatRoutePattern_InvalidConstraintReference(
                            kvp.Value ?? "null",
                            typeof(IRouteConstraint)));
                }
                
                updatedParameterPolicies.Add(kvp.Key, policyReferences);
            }
        }
        
        /* c- 注入 segment 和 parameter */
        
        // 创建 parameter part 集合（预结果）
        List<RoutePatternParameterPart>? parameters = null;
        // 创建 segment 集合（预结果），初始为参数 segments 数组
        var updatedSegments = segments.ToArray();
        
        // 遍历参数 segment 数组
        for (var i = 0; i < updatedSegments.Length; i++)
        {
            // 刷新 segment
            var segment = VisitSegment(updatedSegments[i]);
            // 注入 updated segment
            updatedSegments[i] = segment;
            
            // 遍历 segment 中的 part
            for (var j = 0; j < segment.Parts.Count; j++)
            {
                // 将 parameter part 注入 parameter 集合（预结果）
                if (segment.Parts[j] is RoutePatternParameterPart parameter)
                {
                    if (parameters == null)
                    {
                        parameters = new List<RoutePatternParameterPart>();
                    }
                    
                    parameters.Add(parameter);
                }
            }
        }
        
        /* 检查参数 required value 是否有效，
           如果无效，抛出异常*/
        // Each Required Value either needs to either:
        // 1. be null-ish
        // 2. have a corresponding parameter
        // 3. have a corrsponding default that matches both key and value
        if (requiredValues != null)
        {
            foreach (var kvp in requiredValues)
            {
                // 1.be null-ish
                var found = RouteValueEqualityComparer
                    .Default
                    .Equals(string.Empty, kvp.Value);
                
                // 2. have a corresponding parameter
                if (!found && parameters != null)
                {
                    for (var i = 0; i < parameters.Count; i++)
                    {
                        if (string.Equals(
                            	kvp.Key, 
                            	parameters[i].Name, 
                            	StringComparison.OrdinalIgnoreCase))
                        {
                            found = true;
                            break;
                        }
                    }
                }
                
                // 3. have a corrsponding default that matches both key and value
                if (!found &&
                    updatedDefaults != null &&
                    updatedDefaults.TryGetValue(kvp.Key, out var defaultValue) &&
                    RouteValueEqualityComparer.Default
                    						  .Equals(kvp.Value, defaultValue))
                {
                    found = true;
                }
                
                if (!found)
                {
                    throw new InvalidOperationException(
                        $"No corresponding parameter or default value 
                        "could be found for the required value " +
                        $"'{kvp.Key}={kvp.Value}'. A non-null required value 
                        "must correspond to a route parameter or the " +
                        $"route pattern must have a matching default value.");
                }
            }
        }
        
        // 创建 route pattern
        return new RoutePattern(
            // string
            rawText,
            // default values
            updatedDefaults ?? EmptyDictionary,
            // parameter policy
            updatedParameterPolicies != null
            	? updatedParameterPolicies
            		.ToDictionary(
                    	kvp => kvp.Key, 
                    	kvp => 
                    		(IReadOnlyList<RoutePatternParameterPolicyReference>)
                    			kvp.Value.ToArray())
            	: EmptyPoliciesDictionary,
            // required value
            requiredValues ?? EmptyDictionary,
            // parameter
            (IReadOnlyList<RoutePatternParameterPart>?)parameters 
            	?? Array.Empty<RoutePatternParameterPart>(),
            // segment
            updatedSegments);
                
        /* visit segment 方法 */
        RoutePatternPathSegment VisitSegment(RoutePatternPathSegment segment)
        {
            RoutePatternPart[]? updatedParts = null;
            for (var i = 0; i < segment.Parts.Count; i++)
            {
                var part = segment.Parts[i];
                var updatedPart = VisitPart(part);
                
                if (part != updatedPart)
                {
                    if (updatedParts == null)
                    {
                        updatedParts = segment.Parts.ToArray();
                    }
                    
                    updatedParts[i] = updatedPart;
                }
            }
            
            if (updatedParts == null)
            {
                // Segment has not changed
                return segment;
            }
            
            return new RoutePatternPathSegment(updatedParts);
        }
        
        /* visit part 方法 */
        RoutePatternPart VisitPart(RoutePatternPart part)
        {
            if (!part.IsParameter)
            {
                return part;
            }
            
            var parameter = (RoutePatternParameterPart)part;
            var @default = parameter.Default;
            
            if (updatedDefaults != null && 
                updatedDefaults.TryGetValue(parameter.Name, out var newDefault))
            {
                if (parameter.Default != null && 
                    !Equals(newDefault, parameter.Default))
                {
                    var message = Resources
                        .FormatTemplateRoute
                        _CannotHaveDefaultValueSpecifiedInlineAndExplicitly(parameter.Name);   
                    throw new InvalidOperationException(message);
                }
                
                if (parameter.IsOptional)
                {
                    var message = Resources
                        .TemplateRoute_OptionalCannotHaveDefaultValue;
                    throw new InvalidOperationException(message);
                }
                
                @default = newDefault;
            }
            
            if (parameter.Default != null)
            {
                if (updatedDefaults == null)
                {
                    updatedDefaults = 
                        new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
                }
                
                updatedDefaults[parameter.Name] = parameter.Default;
            }
            
            List<RoutePatternParameterPolicyReference>? parameterConstraints = null;
            if ((updatedParameterPolicies == null || 
                 !updatedParameterPolicies.TryGetValue(
                     parameter.Name, 
                     out parameterConstraints)) && 
                parameter.ParameterPolicies.Count > 0)
            {
                if (updatedParameterPolicies == null)
                {
                    updatedParameterPolicies = 
                        new Dictionary<
                        	string, 
                    		List<RoutePatternParameterPolicyReference>>
                        (StringComparer.OrdinalIgnoreCase);
                }
                
                parameterConstraints = 
                    new List<RoutePatternParameterPolicyReference>
                    	(parameter.ParameterPolicies.Count);
                
                updatedParameterPolicies.Add(
                    parameter.Name, 
                    parameterConstraints);
            }
            
            if (parameter.ParameterPolicies.Count > 0)
            {
                parameterConstraints!.AddRange(parameter.ParameterPolicies);
            }
            
            if (Equals(parameter.Default, @default) && 
                parameter.ParameterPolicies.Count == 0 && 
                (parameterConstraints?.Count ?? 0) == 0)
            {
                // Part has not changed
                return part;
            }
            
            return ParameterPartCore(
                parameter.Name,
                @default,
                parameter.ParameterKind,    
                parameterConstraints?.ToArray() 
                	?? Array.Empty<RoutePatternParameterPolicyReference>(),
                parameter.EncodeSlashes);
        }
    }                  
}

```

###### 2.2.4.1 pattern 方法

```c#
public static class RoutePatternFactory
{
    public static RoutePattern Pattern(
        IEnumerable<RoutePatternPathSegment> segments)
    {
        if (segments == null)
        {
            throw new ArgumentNullException(nameof(segments));
        }
        
        return PatternCore(
            null, 
            null, 
            null, 
            null, 
            segments);
    }
    
    public static RoutePattern Pattern(
        string? rawText, 
        IEnumerable<RoutePatternPathSegment> segments)
    {
        if (segments == null)
        {
            throw new ArgumentNullException(nameof(segments));
        }
        
        return PatternCore(
            rawText, 
            null, 
            null, 
            null, 
            segments);
    }
        
    public static RoutePattern Pattern(
        object? defaults,
        object? parameterPolicies,
        IEnumerable<RoutePatternPathSegment> segments)
    {
        if (segments == null)
        {
            throw new ArgumentNullException(nameof(segments));
        }
        
        return PatternCore(
            null, 
            new RouteValueDictionary(defaults), 
            new RouteValueDictionary(parameterPolicies), 
            requiredValues: null, 
            segments);
    }
    
    public static RoutePattern Pattern(
        string? rawText,
        object? defaults,
        object? parameterPolicies,
        IEnumerable<RoutePatternPathSegment> segments)
    {
        if (segments == null)
        {
            throw new ArgumentNullException(nameof(segments));
        }
        
        return PatternCore(
            rawText, 
            new RouteValueDictionary(defaults), 
            new RouteValueDictionary(parameterPolicies), 
            requiredValues: null, 
            segments);
    }
           
    public static RoutePattern Pattern(
        params RoutePatternPathSegment[] segments)
    {
        if (segments == null)
        {
            throw new ArgumentNullException(nameof(segments));
        }
        
        return PatternCore(
            null, 
            null, 
            null, 
            requiredValues: null, 
            segments);
    }
    
    public static RoutePattern Pattern(
        string rawText, 
        params RoutePatternPathSegment[] segments)
    {
        if (segments == null)
        {
            throw new ArgumentNullException(nameof(segments));
        }
        
        return PatternCore(
            rawText, 
            null, 
            null, 
            requiredValues: null, 
            segments);
    }
            
    public static RoutePattern Pattern(
        object? defaults,
        object? parameterPolicies,
        params RoutePatternPathSegment[] segments)
    {
        if (segments == null)
        {
            throw new ArgumentNullException(nameof(segments));
        }
        
        return PatternCore(
            null, 
            new RouteValueDictionary(defaults), 
            new RouteValueDictionary(parameterPolicies), 
            requiredValues: null, 
            segments);
    }
    
    public static RoutePattern Pattern(
        string? rawText,
        object? defaults,
        object? parameterPolicies,
        params RoutePatternPathSegment[] segments)
    {
        if (segments == null)
        {
            throw new ArgumentNullException(nameof(segments));
        }
        
        return PatternCore(
            rawText, 
            new RouteValueDictionary(defaults), 
            new RouteValueDictionary(parameterPolicies), 
            requiredValues: null, 
            segments);
    }
}

```

###### 2.2.4.2 parse 方法

```c#
public static class RoutePatternFactory
{       
    public static RoutePattern Parse(string pattern)
    {
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }
        
        return RoutePatternParser.Parse(pattern);
    }
        
    public static RoutePattern Parse(
        string pattern, 
        object? defaults, 
        object? parameterPolicies)
    {
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }
        
        var original = RoutePatternParser.Parse(pattern);
        return PatternCore(
            original.RawText, 
            Wrap(defaults), 
            Wrap(parameterPolicies), 
            requiredValues: null, 
            original.PathSegments);
    }
        
    public static RoutePattern Parse(
        string pattern, 
        object? defaults, 
        object? parameterPolicies, 
        object? requiredValues)
    {
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }
        
        var original = RoutePatternParser.Parse(pattern);
        return PatternCore(
            original.RawText, 
            Wrap(defaults), 
            Wrap(parameterPolicies), 
            Wrap(requiredValues), 
            original.PathSegments);
    }
    
    // wrap value(object) to route value dictionary
    private static RouteValueDictionary? Wrap(object? values)
    {
        return values == null ? 
            null : 
        	new RouteValueDictionary(values);
    }                           
}

```

###### 2.2.4.3 创建 pattern 元素

###### a- 创建 segment

```c#
public static class RoutePatternFactory
{    
    // 真正创建 segment 的方法
    private static RoutePatternPathSegment SegmentCore(
        RoutePatternPart[] parts)
    {
        return new RoutePatternPathSegment(parts);
    }
    
    /* 扩展的构建方法 */
    
    public static RoutePatternPathSegment Segment(
        params RoutePatternPart[] parts)
    {
        if (parts == null)
        {
            throw new ArgumentNullException(nameof(parts));
        }
        
        return SegmentCore((RoutePatternPart[])parts.Clone());        
    }
            
    public static RoutePatternPathSegment Segment(
        IEnumerable<RoutePatternPart> parts)
    {
        if (parts == null)
        {
            hrow new ArgumentNullException(nameof(parts));
            
        }
        
        return SegmentCore(parts.ToArray());
    }
}

```

###### b- 创建 literal part

```c#
public static class RoutePatternFactory
{    
    // 真正创建 literal part 的方法
    private static RoutePatternLiteralPart LiteralPartCore(string content)
    {
        return new RoutePatternLiteralPart(content);
    }
    
    /* 扩展的构建方法 */
    public static RoutePatternLiteralPart LiteralPart(string content)
    {        
        if (string.IsNullOrEmpty(content))
        {
            throw new ArgumentException(
                Resources.Argument_NullOrEmpty, 
                nameof(content));
        }        
        // string 中包含“？”，抛出异常
        if (content.IndexOf('?') >= 0)
        {
            throw new ArgumentException(
                Resources.FormatTemplateRoute_InvalidLiteral(content));
        }
        
        return LiteralPartCore(content);
    }        
}

```

###### c- 创建 separator part

```c#
public static class RoutePatternFactory
{
    // 真正创建 separator part 的方法
    private static RoutePatternSeparatorPart SeparatorPartCore(string content)
    {
        return new RoutePatternSeparatorPart(content);
    }
    
    /* 扩展的构建方法 */
    public static RoutePatternSeparatorPart SeparatorPart(string content)
    {
        if (string.IsNullOrEmpty(content))
        {
            throw new ArgumentException(
                Resources.Argument_NullOrEmpty, 
                nameof(content));
        }
        
        return SeparatorPartCore(content);
    }        
}

```

###### d- 创建 parameter part

```c#
public static class RoutePatternFactory
{
    /* 真正创建 parameter part 的方法 */
    
    private static RoutePatternParameterPart ParameterPartCore(
        string parameterName,
        object? @default,
        RoutePatternParameterKind parameterKind,
        RoutePatternParameterPolicyReference[] parameterPolicies)
    {
        return ParameterPartCore(
            parameterName, 
            @default, 
            parameterKind, 
            parameterPolicies, 
            encodeSlashes: true);
    }
    
    private static RoutePatternParameterPart ParameterPartCore(
        string parameterName,
        object? @default,
        RoutePatternParameterKind parameterKind,
        RoutePatternParameterPolicyReference[] parameterPolicies,
        bool encodeSlashes)
    {
        return new RoutePatternParameterPart(
            parameterName,
            @default,
            parameterKind,
            parameterPolicies,
            encodeSlashes);
    }
    
    /* 扩展的构建方法 */
        
    public static RoutePatternParameterPart ParameterPart(
        string parameterName,
        object? @default,
        RoutePatternParameterKind parameterKind,
        params RoutePatternParameterPolicyReference[] parameterPolicies)
    {        
        // parameter name 为空，抛出异常
        if (string.IsNullOrEmpty(parameterName))
        {
            throw new ArgumentException(
                Resources.Argument_NullOrEmpty, 
                nameof(parameterName));
        }
        
        // parameter name 包含不合法字符，抛出异常
        if (parameterName.IndexOfAny(
            	RoutePatternParser.InvalidParameterNameChars) >= 0)
        {
            throw new ArgumentException(
                Resources
                	.FormatTemplateRoute_InvalidParameterName(parameterName));
        }
        
        // 注入了 default value，但是 parameter kind 是 optional，抛出异常
        if (@default != null && 
            parameterKind == RoutePatternParameterKind.Optional)
        {
            throw new ArgumentNullException(
                Resources.TemplateRoute_OptionalCannotHaveDefaultValue, 
                nameof(parameterKind));
        }
        
        if (parameterPolicies == null)
        {
            throw new ArgumentNullException(nameof(parameterPolicies));
        }
        
        return ParameterPartCore(
            parameterName: parameterName,
            @default: @default,
            parameterKind: parameterKind,
            parameterPolicies: 
            	(RoutePatternParameterPolicyReference[])
            		parameterPolicies.Clone());
    }
            
    public static RoutePatternParameterPart ParameterPart(
        string parameterName,
        object? @default,
        RoutePatternParameterKind parameterKind,
        IEnumerable<RoutePatternParameterPolicyReference> parameterPolicies)
    {
        // parameter name 为空，抛出异常
        if (string.IsNullOrEmpty(parameterName))
        {
            throw new ArgumentException(
                Resources.Argument_NullOrEmpty, 
                nameof(parameterName));
        }
        // parameter name 包含不合法字符，抛出异常
        if (parameterName.IndexOfAny(
            RoutePatternParser.InvalidParameterNameChars) >= 0)
        {
            throw new ArgumentException(
                Resources
                	.FormatTemplateRoute_InvalidParameterName(parameterName));
        }
        // 注入了 default value，但是 parameter kind 是 optional，抛出异常
        if (@default != null && 
            parameterKind == RoutePatternParameterKind.Optional)
        {
            throw new ArgumentNullException(
                Resources.TemplateRoute_OptionalCannotHaveDefaultValue, 
                nameof(parameterKind));
        }
        
        if (parameterPolicies == null)
        {
            throw new ArgumentNullException(nameof(parameterPolicies));
        }
        
        return ParameterPartCore(
            parameterName: parameterName,
            @default: @default,
            parameterKind: parameterKind,
            parameterPolicies: parameterPolicies.ToArray());
    }
    
    public static RoutePatternParameterPart ParameterPart(
        string parameterName,
        object? @default,
        RoutePatternParameterKind parameterKind)
    {
        // parameter name 为空，抛出异常
        if (string.IsNullOrEmpty(parameterName))
        {
            throw new ArgumentException(
                Resources.Argument_NullOrEmpty, 
                nameof(parameterName));
        }
        
        // parameter name 包含不合法字符，抛出异常
        if (parameterName.IndexOfAny(
            RoutePatternParser.InvalidParameterNameChars) >= 0)
        {
            throw new ArgumentException(
                Resources
                	.FormatTemplateRoute_InvalidParameterName(parameterName));
        }
        // 注入了 default value，但是 parameter kind 是 optional，抛出异常
        if (@default != null && 
            parameterKind == RoutePatternParameterKind.Optional)
        {
            throw new ArgumentNullException(
                Resources.TemplateRoute_OptionalCannotHaveDefaultValue, 
                nameof(parameterKind));
        }
        
        return ParameterPartCore(
            parameterName: parameterName,
            @default: @default,
            parameterKind: parameterKind,
            // empty parameter policy reference 集合
            parameterPolicies: Array.Empty<RoutePatternParameterPolicyReference>());
    }
    
    public static RoutePatternParameterPart ParameterPart(
        string parameterName, 
        object @default)
    {
        if (string.IsNullOrEmpty(parameterName))
        {
            throw new ArgumentException(
                Resources.Argument_NullOrEmpty, 
                nameof(parameterName));
        }
        // 包含不合法字符，抛出异常
        if (parameterName.IndexOfAny(
            	RoutePatternParser.InvalidParameterNameChars) >= 0)
        {
            throw new ArgumentException(
                Resources
                	.FormatTemplateRoute_InvalidParameterName(parameterName));
        }
        
        return ParameterPartCore(
            parameterName: parameterName,
            @default: @default,
            parameterKind: RoutePatternParameterKind.Standard,
            parameterPolicies: Array.Empty<RoutePatternParameterPolicyReference>());
    }
    
    public static RoutePatternParameterPart ParameterPart(string parameterName)
    {
        if (string.IsNullOrEmpty(parameterName))
        {
            throw new ArgumentException(
                Resources.Argument_NullOrEmpty, 
                nameof(parameterName));
        }
        // 包含不合法字符，抛出异常
        if (parameterName.IndexOfAny(
            RoutePatternParser.InvalidParameterNameChars) >= 0)
        {
            throw new ArgumentException(
                Resources.FormatTemplateRoute_InvalidParameterName(parameterName));
        }
        
        return ParameterPartCore(
            parameterName: parameterName,
            @default: null,
            parameterKind: RoutePatternParameterKind.Standard,
            parameterPolicies: Array.Empty<RoutePatternParameterPolicyReference>());
    }
}

```

###### e-创建 parameter constraint

```c#
public static class RoutePatternFactory
{    
    // 由 parameter policy 字符串 创建 parameter policy reference 
    private static RoutePatternParameterPolicyReference ParameterPolicyCore(
        string parameterPolicy)
    {
        return 
            new RoutePatternParameterPolicyReference(parameterPolicy);
    }
    
    // 由 parameter policy 创建 创建 parameter policy reference 
    private static RoutePatternParameterPolicyReference ParameterPolicyCore(
        IParameterPolicy parameterPolicy)
    {
        return 
            new RoutePatternParameterPolicyReference(parameterPolicy);
    }
    
    /* parameter policy */
    
    public static RoutePatternParameterPolicyReference 
        ParameterPolicy(IParameterPolicy parameterPolicy)
    {
        if (parameterPolicy == null)
        {
            throw new ArgumentNullException(nameof(parameterPolicy));
        }
        
        return ParameterPolicyCore(parameterPolicy);
    }
        
    public static RoutePatternParameterPolicyReference 
        ParameterPolicy(string parameterPolicy)
    {
        if (string.IsNullOrEmpty(parameterPolicy))
        {
            throw new ArgumentException(
                Resources.Argument_NullOrEmpty, 
                nameof(parameterPolicy));
        }
        
        return ParameterPolicyCore(parameterPolicy);
    }                
    
    /* constraint */
    
    public static RoutePatternParameterPolicyReference 
        Constraint(object constraint)
    {
        // Similar to RouteConstraintBuilder
        if (constraint is IRouteConstraint policy)
        {
            return ParameterPolicyCore(policy);
        }
        else if (constraint is string content)
        {
            return ParameterPolicyCore(
                new RegexRouteConstraint("^(" + content + ")$"));
        }
        else
        {
            throw new InvalidOperationException(
                Resources
                	.FormatRoutePattern_InvalidConstraintReference(
                        constraint ?? "null",
                        typeof(IRouteConstraint)));
        }
    }
           
    public static RoutePatternParameterPolicyReference 
        Constraint(IRouteConstraint constraint)
    {
        if (constraint == null)
        {
            throw new ArgumentNullException(nameof(constraint));
        }
        
        return ParameterPolicyCore(constraint);
    }
        
    public static RoutePatternParameterPolicyReference 
        Constraint(string constraint)
    {
        if (string.IsNullOrEmpty(constraint))
        {
            throw new ArgumentException(
                Resources.Argument_NullOrEmpty, 
                nameof(constraint));
        }
        
        return ParameterPolicyCore(constraint);
    }
}

```

##### 2.2.5 route pattern matcher

```c#
internal class RoutePatternMatcher
{
    private const string SeparatorString = "/";
    private const char SeparatorChar = '/';
    
    // Perf: This is a cache to avoid looking things up in 'Defaults' each request.
    private readonly bool[] _hasDefaultValue;
    private readonly object[] _defaultValues;
    
    private static readonly char[] Delimiters = new char[] { SeparatorChar };
    
    // route pattern
    public RoutePattern RoutePattern { get; }
    // default value
    public RouteValueDictionary Defaults { get; }    
    
    public RoutePatternMatcher(
        RoutePattern pattern,
        RouteValueDictionary defaults)
    {
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }
        
        // 注入 route pattern
        RoutePattern = pattern;
        // 注入 default value (route value dictionary)
        Defaults = defaults ?? new RouteValueDictionary();
        
        /* 解析并缓存 default value (object) */
        
        // 初始化 default value (cache)
        _hasDefaultValue = new bool[RoutePattern.PathSegments.Count];
        _defaultValues = new object[RoutePattern.PathSegments.Count];
        // 遍历 route pattern 的 segment，
        for (var i = 0; i < RoutePattern.PathSegments.Count; i++)
        {
            // 如果不是 simple segment，-> 下一个 segment（忽略此segment）
            var segment = RoutePattern.PathSegments[i];
            if (!segment.IsSimple)
            {
                continue;
            }
            // 获取 part，因为 simple segment 只有1个 part            
            var part = segment.Parts[0];
            // 如果 part 不是 parameter part，-> 下一个 segment（忽略此 segment）
            if (!part.IsParameter)
            {
                continue;
            }
            // 转为类型 => pattern part -> pattern parameter part
            var parameter = (RoutePatternParameterPart)part;
            // 按照 parameter part 的 name，
            // 从传入的 default value (route value dictionary) 解析 value (object)，
            // 存入 default value (object) 缓存
            if (Defaults.TryGetValue(parameter.Name, out var value))
            {
                _hasDefaultValue[i] = true;
                _defaultValues[i] = value;
            }
        }
    }
    
    /* match 方法 */
    public bool TryMatch(
        PathString path, 
        RouteValueDictionary values)
    {
        if (values == null)
        {
            throw new ArgumentNullException(nameof(values));
        }
        
        // 标记
        var i = 0;
        // 散列传入的 request path
        var pathTokenizer = new PathTokenizer(path);
        
        // Perf: We do a traversal of the request-segments + route-segments twice.
        //
        // For most segment-types, we only really need to any work on one of the two passes.
        //
        // On the first pass, we're just looking to see if there's anything that would 
        // disqualify us from matching.
        // The most common case would be a literal segment that doesn't match.
        //
        // On the second pass, we're almost certainly going to match the URL, so go ahead 
        // and allocate the 'values' and start capturing strings. 
        
        /* 第一次遍历 - 排除不匹配的 literal */
        
        // 遍历散列的 request path (segment)
        foreach (var stringSegment in pathTokenizer)
        {
            // segment 为空，-> false，结束 match
            if (stringSegment.Length == 0)
            {
                return false;
            }
            
            // 获取标记对应的 route pattern 中的 segment
            // （按照模板，输入的 segment 与 pattern 的 segment 应该一一对应）
            // 如果标记超过 route pattern 中 segment 数量，取null
            // （输入了超过 pattern 的内容）            
            var pathSegment = 
                i >= RoutePattern.PathSegments.Count 
                	? null 
                	: RoutePattern.PathSegments[i];
            
            // 如果 path segment (from pattern) 为空，
            // 但是 string segment (from request) 不为空，
            // 即 request 中包含 pattern 没有定义的内容，-> false，结束 match
            if (pathSegment == null && 
                stringSegment.Length > 0)
            {
                // If pathSegment is null, then we're out of route segments. 
                // All we can match is the empty string.
                return false;
            }
            // 否则，即 path segment 和 string segment 都有值，
            //
            // 如果 path segment (from pattern) 是 simple segment，
            // 包含的 part 是 catch all (parameter part)，即通配符 all，
            // -> 结束遍历，（流转到后续流程，继续其他 pattern segment 等？）
            // （通配符可以匹配任何 reques）
            else if (pathSegment.IsSimple && 
                     pathSegment.Parts[0] is RoutePatternParameterPart parameter && 
                     parameter.IsCatchAll)
            {                
                break;
            }
            
            /* 此时，
               1- path segment 不是 simple segment，或者
               2- path segment 是 simple segment，
                  part 不是 parameter part（是 literal 或 separator)，或者
               3- path segment 是 simple segment，
                  part 是 parameter part，但不是 catch all，
                  即 part 是 parameter */
            
            // （字符串）匹配 string segment (from request) 和 path segment (from pattern)
            // 如果匹配，标记++，-> 下一个 segment；
            // 如果不匹配，-> 返回 false，结束 match
            if (!TryMatchLiterals(i++, stringSegment, pathSegment))
            {
                return false;
            }
        }
        
        /* 上述判断没有处理
           1- segment 不是 simple segment（即 complex segment 情况），
           2- segment 是 simple segment，part 是 parameter part */
        for (; i < RoutePattern.PathSegments.Count; i++)
        {
            // These need to be all single-part parameter segments with default values 
            // or else they won't match.
            
            // 获取标记对应的 route pattern 中的 segment
            var pathSegment = RoutePattern.PathSegments[i];
            Debug.Assert(pathSegment != null);
            
            // 如果不是 simple segment，-> 返回false，结束 match
            // （因为 complex segment 必然包含 literal，
            //   前面流程已经处理过（try match literal 方法），
            //   此处异常（方法中没有执行 i++?），所以 false 并结束）
            if (!pathSegment.IsSimple)
            {                
                return false;
            }
            
            // 解析 pattern segment 中的 part（simple segment，只有1个 part）
            var part = pathSegment.Parts[0];
            
            // 如果 part 是 literal 或者 separtor，-> 返回 false，结束 match
            // （因为前面流程已经处理过（try match literal 方法），
            //   此处异常（方法中没有执行 i++？），所以 false 并结束）
            if (part.IsLiteral || part.IsSeparator)
            {                
                return false;
            }
            
            // 转换 part 类型 -> parameter part
            var parameter = (RoutePatternParameterPart)part;
            // 如果 parameter part 是 catch all，-> 结束遍历
            // （catch all 可以匹配所以 request）
            if (parameter.IsCatchAll)
            {                
                break;
            }
                        
            // 如果 parameter part 在 default value 缓存中没有对应值（default），
            // 并且 parameter part 不是 optional，
            // -> 返回 false，结束 match
            if (!_hasDefaultValue[i] && !parameter.IsOptional)
            {                
                return false;
            }
        }
        
        // At this point we've very likely got a match, so start capturing values for real.
    	// 
        
        /* 第二次遍历 - 获取 route value */
        
        // 标记
        i = 0;
        // 遍历散列的 request path (segment)，
        foreach (var requestSegment in pathTokenizer)
        {
            // 解析对应的 path segment (from pattern)
            // 按照模板，path segment 与 request segment 位置是一一对应的
            var pathSegment = RoutePattern.PathSegments[i++];
            
            // （对应 simple segment）
            // 将 request segment 保存为 parameter 对应 value；            
            // true = 遇到 catch all，表示结尾，-> 结束遍历
            // （不处理 complex segment）
            if (SavePathSegmentsAsValues(i, values, requestSegment, pathSegment))
            {
                break;
            }
            
            // 如果 path segment 不是 simple segment，即 complex segment
            if (!pathSegment.IsSimple)
            {
                // 将 request segment 保存为 parameter 对应 value
                if (!MatchComplexSegment(pathSegment, requestSegment.AsSpan(), values))
                {
                    return false;
                }
            }
        }
        
        /* 处理 route pattern 剩余的 segment，
           （即 request path 没有提供对应内容的部分）*/
        for (; i < RoutePattern.PathSegments.Count; i++)
        {
            // We've matched the request path so far, but still have remaining route segments. 
            // We already know these are simple parameters that either have a default, 
            // or don't need to produce a value.
            
            // 解析 pattern segment
            var pathSegment = RoutePattern.PathSegments[i];            
            Debug.Assert(pathSegment != null);
            Debug.Assert(pathSegment.IsSimple);
            
            // 解析 pattern part
            var part = pathSegment.Parts[0];
            Debug.Assert(part.IsParameter);
            
            // 如果 part 是 parameter part，
            // 并且 part 是 catch all，或者在 default value 缓存中存在对应 value
            if (part is RoutePatternParameterPart parameter && 
                (parameter.IsCatchAll || _hasDefaultValue[i]))
            {
                // 解析 default value，
                // 如果 default value 不为 null，
                // 或者结果 values 不存在 parameter 对应 value，
                // 注入结果 values（route value dictionary），                
                var defaultValue = _defaultValues[i];
                if (defaultValue != null || !values.ContainsKey(parameter.Name))
                {
                    values[parameter.Name] = defaultValue;
                }
            }
        }
        
        // Copy all remaining default values to the route data
        foreach (var kvp in Defaults)
        {
#if RVD_TryAdd
    		values.TryAdd(kvp.Key, kvp.Value);
#else
            if (!values.ContainsKey(kvp.Key))
            {
                values.Add(kvp.Key, kvp.Value);
            }
#endif
        }
        
        return true;
    }                               
}

```

###### 2.2.5.0 path tokenizer

```c#
internal struct PathTokenizer : IReadOnlyList<StringSegment>
{
    private readonly string _path;
    private int _count;
    
    public PathTokenizer(PathString path)
    {
        _path = path.Value;
        _count = -1;
    }
    
    public int Count
    {
        get
        {
            if (_count == -1)
            {
                // We haven't computed the real count of segments yet.
                if (_path.Length == 0)
                {
                    // The empty string has length of 0.
                    _count = 0;
                    return _count;
                }
                
                // A string of length 1 must be "/" - all PathStrings start with '/'
                if (_path.Length == 1)
                {
                    // We treat this as empty - there's nothing to parse here for routing, because routing ignores
                    // a trailing slash.
                    Debug.Assert(_path[0] == '/');
                    count = 0;
                    
                    return _count;
                }
                
                // This is a non-trival PathString
                _count = 1;
                
                // Since a non-empty PathString must begin with a `/`, we can just count the number of occurrences
                // of `/` to find the number of segments. However, we don't look at the last character, because
                // routing ignores a trailing slash.
                for (var i = 1; i < _path.Length - 1; i++)
                {
                    if (_path[i] == '/')
                    {
                        _count++;
                    }
                }
            }
            
            return _count;
        }
    }
    
    public StringSegment this[int index]
    {
        get
        {
            if (index >= Count)
            {
                throw new IndexOutOfRangeException();
            }
            
            
            var currentSegmentIndex = 0;
            var currentSegmentStart = 1;
            
            // Skip the first `/`.
            var delimiterIndex = 1;
            while ((delimiterIndex = _path.IndexOf('/', delimiterIndex)) != -1)
            {
                if (currentSegmentIndex++ == index)
                {
                    return new StringSegment(_path, currentSegmentStart, delimiterIndex - currentSegmentStart);
                }
                else
                {
                    currentSegmentStart = delimiterIndex + 1;
                    delimiterIndex++;
                }
            }
            
            // If we get here we're at the end of the string. The implementation of .Count should protect us
            // from these cases. 
            Debug.Assert(_path[_path.Length - 1] != '/');
            Debug.Assert(currentSegmentIndex == index);
            
            return new StringSegment(_path, currentSegmentStart, _path.Length - currentSegmentStart);
        }
    }
    
    public Enumerator GetEnumerator()
    {
        return new Enumerator(this);
    }
    
    IEnumerator<StringSegment> IEnumerable<StringSegment>.GetEnumerator()
    {
        return GetEnumerator();
    }
    
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
    
    public struct Enumerator : IEnumerator<StringSegment>
    {
        private readonly string _path;
        
        private int _index;
        private int _length;
        
        public Enumerator(PathTokenizer tokenizer)
        {
            _path = tokenizer._path;
            
            _index = -1;
            _length = -1;
        }
        
        public StringSegment Current
        {
            get
            {
                return new StringSegment(_path, _index, _length);
            }
        }
        
        object IEnumerator.Current
        {
            get
            {
                return Current;
            }
        }
        
        public void Dispose()
        {
        }
        
        public bool MoveNext()
        {
            if (_path == null || _path.Length <= 1)
            {
                return false;
            }
            
            if (_index == -1)
            {
                // Skip the first `/`.
                _index = 1;
            }
            else
            {
                // Skip to the end of the previous segment + the separator.
                _index += _length + 1;
            }
            
            if (_index >= _path.Length)
            {
                // We're at the end
                return false;
            }
            
            var delimiterIndex = _path.IndexOf('/', _index);
            if (delimiterIndex != -1)
            {
                _length = delimiterIndex - _index;
                return true;
            }
            
            // We might have some trailing text after the last separator.
            if (_path[_path.Length - 1] == '/')
            {
                // If the last char is a '/' then it's just a trailing slash, we don't have another segment.
                return false;
            }
            else
            {
                _length = _path.Length - _index;
                return true;
            }
        }
        
        public void Reset()
        {
            _index = -1;
            _length = -1;
        }
    }
}

```



###### 2.2.5.1 try match literal

```c#
internal class RoutePatternMatcher
{
    private bool TryMatchLiterals(
        int index, 
        // segment from request
        StringSegment stringSegment, 
        // segment from pattern
        RoutePatternPathSegment pathSegment)
    {
        // 如果 path segment (from pattern) 是 simple segment，
        // 并且 part 不是 parameter part
        if (pathSegment.IsSimple && 
            !pathSegment.Parts[0].IsParameter)
        {
            // 如果 part 是 parameter part
            if (pathSegment.Parts[0].IsLiteral)
            {
                // 转换 part 类型 -> literal part
                var part = (RoutePatternLiteralPart)pathSegment.Parts[0];
                // 判断（string 判断）
                if (!stringSegment.Equals(
                    	part.Content, 
                    	StringComparison.OrdinalIgnoreCase))
                {
                    return false;
                }
            }
            // 否则，即 part 是 separator part
            else
            {
                // 转换 part 类型 -> separator part
                var part = (RoutePatternSeparatorPart)pathSegment.Parts[0];
                // 判断（string 判断）
                if (!stringSegment.Equals(
                    	part.Content, 
                    	StringComparison.OrdinalIgnoreCase))
                {
                    return false;
                }
            }
        }
        // 否则，
        // 如果 path segment (from pattern) 是 simple segment，
        // 并且 part 是 parameter part
        else if (pathSegment.IsSimple && 
                 pathSegment.Parts[0].IsParameter)
        {
            // 转换 part 类型 -> parameter part
            var part = (RoutePatternParameterPart)pathSegment.Parts[0];
            
            // 如果 string segment (from request) 为空（即没有提供 parameter 对应内容），
            // 并且 default value 缓存中没有 parameter 对应 value，
            // 并且 parameter 不是 optional，
            // -> false
            if (stringSegment.Length == 0 &&
                !_hasDefaultValue[index] &&
                !part.IsOptional)
            {                
                return false;
            }
        }
        // 否则，即 path segment 不是 simple segment（是 complex segment）
        // （后续流程处理）
        else
        {
            Debug.Assert(!pathSegment.IsSimple);            
        }
        
        return true;
    }
}

```

###### 2.2.5.2 save path segment as value

```c#
internal class RoutePatternMatcher
{
    private bool SavePathSegmentsAsValues(
        int index, 
        // 结果
        RouteValueDictionary values, 
        StringSegment requestSegment, 
        RoutePatternPathSegment pathSegment)
    {
        // 如果 path segment (from pattern) 是 simple segment，
        // 包含的 part 是 parameter part，且是 catch all
        if (pathSegment.IsSimple && 
            pathSegment.Parts[0] is RoutePatternParameterPart parameter && 
            parameter.IsCatchAll)
        {
            // 截取 通配符（catch all）后面的字符串
            var captured = requestSegment.Buffer.Substring(requestSegment.Offset);
            // 如果 capture 不为空，
            if (captured.Length > 0)
            {
                // 将 capture 作为 parameter 对应 value，
                // 注入结果 values (route value dictionary)
                values[parameter.Name] = captured;
            }
            // 否则，即 capture 为空，注入对应的 default value
            else
            {                
                // 将 default value 缓存中的 value（可以为 null）作为 parameter 对应 value，
                // 注入结果 values（route value dictionary）
                values[parameter.Name] = _defaultValues[index];
            }
            
            // A catch-all has to be the last part, so we're done.
            // -> true，结束
            return true;
        }
        // 否则，即 parameter part 不是 catch all
        // 如果 path segment (from pattern) 是 simple segment，
        // 包含的 part 是 parameter part
        else if (pathSegment.IsSimple && 
                 pathSegment.Parts[0].IsParameter)
        {
            // A simple parameter captures the whole segment, or a default value 
            // if nothing was provided.
            
            // 转换 part 类型 -> parameter part
            parameter = (RoutePatternParameterPart)pathSegment.Parts[0];
            
            // 如果 request segment 不为空，
            if (requestSegment.Length > 0)
            {
                // 将 request segment 作为 parameter 对应 value，
                // 注入结果 values（route value dicitonary）
                values[parameter.Name] = requestSegment.ToString();
            }
            // 否则，即 request segment 为空，            
            else
            {
                // 将 default value 缓存中的 value（可以为 null）作为 parameter 对应 value，
                // 注入结果 values（route value dictionary）
                if (_hasDefaultValue[index])
                {
                    values[parameter.Name] = _defaultValues[index];
                }
            }
        }
        
        // -> false，不是 end
        return false;
    }
}

```

###### 2.2.5.3  match complex segment

```c#
internal class RoutePatternMatcher
{
    internal static bool MatchComplexSegment(
        RoutePatternPathSegment routeSegment,
        ReadOnlySpan<char> requestSegment,
        RouteValueDictionary values)
    {
        // route pattern part 游标，定位最后一个 part
        var indexOfLastSegment = routeSegment.Parts.Count - 1;
        
        // We match the request to the template starting at the rightmost parameter
        // If the last segment of template is optional, then request can match the 
        // template with or without the last parameter. So we start with regular matching,
        // but if it doesn't match, we start with next to last parameter. Example:
        // Template: {p1}/{p2}.{p3?}. If the request is one/two.three it will match right away
        // giving p3 value of three. But if the request is one/two, we start matching from the
        // rightmost giving p3 the value of two, then we end up not matching the segment.
        // In this case we start again from p2 to match the request and we succeed giving
        // the value two to p2
        
        // 如果 last part 是 parameter part，并且是 optional
        // 并且 last part 的 pre part 是 separator part，
        // 即形如 "{p1}/{p2}.{p3?}"，"p3" 是 last part，"." 是 pre part
        if (routeSegment.Parts[indexOfLastSegment] is RoutePatternParameterPart parameter && 
            parameter.IsOptional &&
            routeSegment.Parts[indexOfLastSegment - 1].IsSeparator)
        {
            // 能够处理
            if (MatchComplexSegmentCore(
                	routeSegment, 
                	requestSegment, 
                	values, 
                	indexOfLastSegment))
            {
                return true;
            }
            // 否则，
            else
            {
                // 解析 pre part（separator part）
                var separator = 
                    (RoutePatternSeparatorPart)routeSegment.Parts[indexOfLastSegment - 1];
                
                // 如果 request segment 仅以 separator part 结尾，
                // 即 pattern 形如 "{p1}/{p2}.{p3?}"，但是 request segment 形如 "one/two."，
                // -> false，结束 match
                if (requestSegment.EndsWith(
                    	separator.Content,
                    	StringComparison.OrdinalIgnoreCase))
                {
                    return false;
                }
                
                return MatchComplexSegmentCore(
                    routeSegment,
                    requestSegment,
                    values,
                    indexOfLastSegment - 2);
            }
        }
        // 否则，即 last part 不是 parameter part，
        // 或者 parameter part 不是 optional，
        // 或者 last part 的 pre part 不是 separator part
        else
        {
            return MatchComplexSegmentCore(
                routeSegment, 
                requestSegment, 
                values, 
                indexOfLastSegment);
        }
    }
}

```

###### 2.2.5.4 match complex segment core

```c#
internal class RoutePatternMatcher
{
    private static bool MatchComplexSegmentCore(
        // pattern segment (from route pattern)
        RoutePatternPathSegment routeSegment,
        // request segment (from http request)
        ReadOnlySpan<char> requestSegment,
        // 结果
        RouteValueDictionary values,
        // pattern segment 中 part 游标（从右边数最后一个，可遍历）
        int indexOfLastSegmentUsed)
    {
        Debug.Assert(routeSegment != null);
        Debug.Assert(routeSegment.Parts.Count > 1);
                
        // request segment 字符串结尾游标
        var lastIndex = requestSegment.Length;        
        // Keeps track of a parameter segment that is pending a value
        RoutePatternParameterPart parameterNeedsValue = null; 
        // Keeps track of the left-most literal we've encountered
        RoutePatternPart lastLiteral = null; 
        
        var outValues = new RouteValueDictionary();
        
        while (indexOfLastSegmentUsed >= 0)
        {
            // 获取 request segment 字符串游标
            var newLastIndex = lastIndex;            
            // 解析 pattern part （游标定位，从右边数最后一个，可遍历）
            var part = routeSegment.Parts[indexOfLastSegmentUsed];    
            
            // 如果 part 是 parameter part，
            if (part.IsParameter)
            {                
                // 跟踪 parameter part
                parameterNeedsValue = (RoutePatternParameterPart)part;
            }
            // 否则，即 part 是 literal part 或者 separator part
            else
            {
                Debug.Assert(part.IsLiteral || part.IsSeparator);
                
                // 跟踪 literal part（包括 literal 和 separator part）
                lastLiteral = part;
			   // 获取 request segment 字符串游标（segment 长度）                                
                var startIndex = lastIndex;                
                // 如果 parameter needs value 不为 null，即需要为 pattern parameter 解析 value，
                // request segment 字符串结尾游标-1（因为 inti 是 content length）
                if (parameterNeedsValue != null)
                {
                    startIndex--;
                }
                // 如果 request segment 字符串结尾游标为0，即 request segment 字符串已经结尾，
                // -> false，结束
                if (startIndex == 0)
                {
                    return false;
                }
                
                int indexOfLiteral;
                
                // 如果 part 是 literal part
                if (part.IsLiteral)
                {
                    // 转换 part 类型 -> literal part
                    var literal = (RoutePatternLiteralPart)part;     
                    // 找到 literal part 在 request segment 字符串中对应的起始游标
                    indexOfLiteral = 
                        requestSegment.Slice(0, startIndex)
                        			 .LastIndexOf(
                        				  literal.Content,
                        				  StringComparison.OrdinalIgnoreCase);
                }
                // 否则，即 part 是 separator part
                else
                {
                    // 转换 part 类型 -> separator part
                    var literal = (RoutePatternSeparatorPart)part;
                    // 找到 separator part 在 request segment 字符串中对应的起始游标
                    indexOfLiteral = 
                        requestSegment.Slice(0, startIndex)
                        			 .LastIndexOf(
                        			     literal.Content,
                        				 StringComparison.OrdinalIgnoreCase);
                }
                
                // 如果 request segment 字符串起始游标为-1，
                // 即在 request segment 中没有找到 literal part 或者 separator part 对应 value，
                // -> false，结束
                if (indexOfLiteral == -1)
                {                    
                    return false;
                }
                
                // If the first subsegment is a literal, it must match at the right-most extent of the request URI.
                // Without this check if your route had "/Foo/" we'd match the request URI "/somethingFoo/".                
                
                // 如果 part 是最后一个
                if (indexOfLastSegmentUsed == (routeSegment.Parts.Count - 1))
                {
                    // 如果 part 是 literal part，
                    // request segment 字符串开始游标 + literal part content 长度 ！= request segment 字符串长度，
                    // -> false, 结束
                    if (part is RoutePatternLiteralPart literal && 
                        ((indexOfLiteral + literal.Content.Length) != requestSegment.Length))
                    {
                        return false;
                    }
                    // 如果 part 是 literal part，
                    // request segment 字符串开始游标 + separator part content 长度 ！= request segment 字符串长度，
                    // -> false, 结束
                    else if (part is RoutePatternSeparatorPart separator && 
                             ((indexOfLiteral + separator.Content.Length) != requestSegment.Length))
                    {
                        return false;
                    }
                }
                
                newLastIndex = indexOfLiteral;
            }
            
            // 如果（右边）有parameter part，
            if ((parameterNeedsValue != null) &&
                (((lastLiteral != null) && !part.IsParameter) || (indexOfLastSegmentUsed == 0)))
            {                
                // 需要在 request segment 字符串中截取 parameter value 的开始游标
                int parameterStartIndex;
                // 需要在 request segment 字符串中截取parameter value 的长度
                int parameterTextLength;
                
                // 如果（右边） parameter part 之前没有 literal part
                if (lastLiteral == null)
                {
                    // 并且当前 part（parameter part）之前没有其他 part
                    if (indexOfLastSegmentUsed == 0)
                    {
                        // request segment 字符串从头截取
                        parameterStartIndex = 0;
                    }
                    // 否则，即 parameter part 之前还有 part，
                    // -> 错误，多个 parameter part 之间必须有 separator part（literal）
                    else
                    {                        
                        parameterStartIndex = newLastIndex;
                        Debug.Assert(false, "indexOfLastSegementUsed should always be 0 from the check above");
                    }
                    
                    // paramete text 长度就是 request segment 字符串长度
                    parameterTextLength = lastIndex;
                }
                // 否则，即（右边） parameter part 之前有 literal part
                else
                {
                    // If we're getting a value for a parameter that is somewhere in the middle of the segment
                    
                    // 当前 part 之前没有其他 part，并且当前 part 是 parameter part
                    if ((indexOfLastSegmentUsed == 0) && (part.IsParameter))
                    {
                        // request segment 字符串从头截取
                        parameterStartIndex = 0;
                        // paramete text 长度就是 request segment 字符串长度
                        parameterTextLength = lastIndex;
                    }
                    // 否则，即当前 part 之前还有 part，
                    // 或者 当前 part 不是 parameter part
                    else
                    {
                        // 如果右边是 literal part
                        if (lastLiteral.IsLiteral)
                        {
                            var literal = (RoutePatternLiteralPart)lastLiteral;
                            // 获取长度
                            parameterStartIndex = newLastIndex + literal.Content.Length;
                        }
                        // 否则，即右边是 separator part
                        else
                        {
                            var separator = (RoutePatternSeparatorPart)lastLiteral;
                            // 获取长度
                            parameterStartIndex = newLastIndex + separator.Content.Length;
                        }
                        parameterTextLength = lastIndex - parameterStartIndex;
                    }
                }
                
                // 按照游标解析 parameter value 字符串
                var parameterValueSpan = requestSegment.Slice(parameterStartIndex, parameterTextLength);
                // 如果 parameter value 字符串为空，-> false，结束
                if (parameterValueSpan.Length == 0)
                {
                    // If we're here that means we have a segment that contains multiple sub-segments.
                    // For these segments all parameters must have non-empty values. If the parameter
                    // has an empty value it's not a match.                        
                    return false;                    
                }
                // 否则，即 parameter value 字符串不为空，注入 out values
                else
                {
                    // If there's a value in the segment for this parameter, use the subsegment value
                    outValues.Add(parameterNeedsValue.Name, new string(parameterValueSpan));
                }
                
                // parameter part、literal part 跟踪器设置为 null（复位）
                parameterNeedsValue = null;
                lastLiteral = null;
            }
            
            // 定位游标（为下一次判断）
            lastIndex = newLastIndex;
            indexOfLastSegmentUsed--;
        }
        
        // If the last subsegment is a parameter, it's OK that we didn't parse all the way to the left extent of
        // the string since the parameter will have consumed all the remaining text anyway. If the last subsegment
        // is a literal then we *must* have consumed the entire text in that literal. Otherwise we end up matching
        // the route "Foo" to the request URI "somethingFoo". Thus we have to check that we parsed the *entire*
        // request URI in order for it to be a match.
        // This check is related to the check we do earlier in this function for LiteralSubsegments.
        
        // 将 out values 注入结果 values (route value dictionary)
        if (lastIndex == 0 || routeSegment.Parts[0].IsParameter)
        {
            foreach (var item in outValues)
            {
                values[item.Key] = item.Value;
            }
            
            return true;
        }
        
        return false;
    }
}

```

##### 2.2.6 route pattern transformer

###### 2.2.6.1 抽象基类

```c#
public abstract class RoutePatternTransformer
{
    
    // Substituting required values into a route pattern is intended for us with 
    // a general-purpose parameterize route specification that can match many logical 
    // endpoints. 
    // Calling "SubstituteRequiredValues(RoutePattern, object)" can produce a derived route 
    // pattern for each set of route values that corresponds to an endpoint.
        
    public abstract RoutePattern? SubstituteRequiredValues(
        RoutePattern original, 
        object requiredValues);
}

```

###### 2.2.6.2 default route pattern transformer

```c#
internal class DefaultRoutePatternTransformer : RoutePatternTransformer
{
    private readonly ParameterPolicyFactory _policyFactory;
    
    public DefaultRoutePatternTransformer(ParameterPolicyFactory policyFactory)
    {
        if (policyFactory == null)
        {
            throw new ArgumentNullException(nameof(policyFactory));
        }
        
        _policyFactory = policyFactory;
    }
    
    public override RoutePattern SubstituteRequiredValues(RoutePattern original, object requiredValues)
    {
        if (original == null)
        {
            throw new ArgumentNullException(nameof(original));
        }
        
        return SubstituteRequiredValuesCore(original, new RouteValueDictionary(requiredValues));
    }
    
    private RoutePattern SubstituteRequiredValuesCore(RoutePattern original, RouteValueDictionary requiredValues)
    {
        // Process each required value in sequence. Bail if we find any rejection criteria. The goal
        // of rejection is to avoid creating RoutePattern instances that can't *ever* match.
        //
        // If we succeed, then we need to create a new RoutePattern with the provided required values.
        //
        // Substitution can merge with existing RequiredValues already on the RoutePattern as long
        // as all of the success criteria are still met at the end.
        foreach (var kvp in requiredValues)
        {
            // There are three possible cases here:
            // 1. Required value is null-ish
            // 2. Required value is *any*
            // 3. Required value corresponds to a parameter
            // 4. Required value corresponds to a matching default value
            //
            // If none of these are true then we can reject this substitution.
            RoutePatternParameterPart parameter;
            if (RouteValueEqualityComparer.Default.Equals(kvp.Value, string.Empty))
            {
                // 1. Required value is null-ish - check to make sure that this route doesn't have a
                // parameter or filter-like default.
                
                if (original.GetParameter(kvp.Key) != null)
                {
                    // Fail: we can't 'require' that a parameter be null. In theory this would be possible
                    // for an optional parameter, but that's not really in line with the usage of this feature
                    // so we don't handle it.
                    //
                    // Ex: {controller=Home}/{action=Index}/{id?} - with required values: { controller = "" }
                    return null;
                }
                else if (original.Defaults
                         		 .TryGetValue(kvp.Key, out var defaultValue) &&
                         !RouteValueEqualityComparer.Default
                         							.Equals(kvp.Value, defaultValue))
                {
                    // Fail: this route has a non-parameter default that doesn't match.
                    //
                    // Ex: Admin/{controller=Home}/{action=Index}/{id?} defaults: { area = "Admin" } - with required values: { area = "" }
                    return null;
                }
                
                // Success: (for this parameter at least)
                //
                // Ex: {controller=Home}/{action=Index}/{id?} - with required values: { area = "", ... }
                continue;
            }
            else if (RoutePattern.IsRequiredValueAny(kvp.Value))
            {
                // 2. Required value is *any* - this is allowed for a parameter with a default, but not
                // a non-parameter default.
                if (original.GetParameter(kvp.Key) == null &&
                    original.Defaults
                    		.TryGetValue(kvp.Key, out var defaultValue) &&
                    !RouteValueEqualityComparer.Default
                    						   .Equals(string.Empty, defaultValue))
                {
                    // Fail: this route as a non-parameter default that is stricter than *any*.
                    //
                    // Ex: Admin/{controller=Home}/{action=Index}/{id?} defaults: { area = "Admin" } - with required values: { area = *any* }
                    return null;
                }
                
                // Success: (for this parameter at least)
                //
                // Ex: {controller=Home}/{action=Index}/{id?} - with required values: { controller = *any*, ... }
                continue;
            }
            else if ((parameter = original.GetParameter(kvp.Key)) != null)
            {
                // 3. Required value corresponds to a parameter - check to make sure that this value matches
                // any IRouteConstraint implementations.
                if (!MatchesConstraints(original, parameter, kvp.Key, requiredValues))
                {
                    // Fail: this route has a constraint that failed.
                    //
                    // Ex: Admin/{controller:regex(Home|Login)}/{action=Index}/{id?} - with required values: { controller = "Store" }
                    return null;
                }
                
                // Success: (for this parameter at least)
                //
                // Ex: {area}/{controller=Home}/{action=Index}/{id?} - with required values: { area = "", ... }
                continue;
            }
            else if (original.Defaults
                     		 .TryGetValue(kvp.Key, out var defaultValue) &&
                     RouteValueEqualityComparer.Default
                     						   .Equals(kvp.Value, defaultValue))
            {
                // 4. Required value corresponds to a matching default value - check to make sure that this value matches
                // any IRouteConstraint implementations. It's unlikely that this would happen in practice but it doesn't
                // hurt for us to check.
                if (!MatchesConstraints(
                    	original, 
                    	parameter: null, 
                    	kvp.Key, 
                    	requiredValues))
                {
                    // Fail: this route has a constraint that failed.
                    //
                    // Ex: 
                    //  Admin/Home/{action=Index}/{id?} 
                    //  defaults: { area = "Admin" }
                    //  constraints: { area = "Blog" }
                    //  with required values: { area = "Admin" }
                    return null;
                }
                
                // Success: (for this parameter at least)
                //
                // Ex: Admin/{controller=Home}/{action=Index}/{id?} defaults: { area = "Admin" }- with required values: { area = "Admin", ... }
                continue;
            }
            else
            {
                // Fail: this is a required value for a key that doesn't appear in the templates, or the route
                // pattern has a different default value for a non-parameter.
                //
                // Ex: Admin/{controller=Home}/{action=Index}/{id?} defaults: { area = "Admin" }- with required values: { area = "Blog", ... }
                // OR (less likely)
                // Ex: Admin/{controller=Home}/{action=Index}/{id?} with required values: { page = "/Index", ... }
                return null;
            }
        }
        
        List<RoutePatternParameterPart> updatedParameters = null;
        List<RoutePatternPathSegment> updatedSegments = null;
        RouteValueDictionary updatedDefaults = null;
        
        // So if we get here, we're ready to update the route pattern. We need to update two things:
        // 1. Remove any default values that conflict with the required values.
        // 2. Merge any existing required values
        foreach (var kvp in requiredValues)
        {
            var parameter = original.GetParameter(kvp.Key);
            
            // We only need to handle the case where the required value maps to a parameter. That's the only
            // case where we allow a default and a required value to disagree, and we already validated the
            // other cases.
            //
            // If the required value is *any* then don't remove the default.
            if (parameter != null &&
                !RoutePattern.IsRequiredValueAny(kvp.Value) &&
                original.Defaults
                		.TryGetValue(kvp.Key, out var defaultValue) && 
                !RouteValueEqualityComparer.Default
                						   .Equals(kvp.Value, defaultValue))
            {
                if (updatedDefaults == null && 
                    updatedSegments == null && 
                    updatedParameters == null)
                {
                    updatedDefaults = 
                        new RouteValueDictionary(original.Defaults);
                    updatedSegments = 
                        new List<RoutePatternPathSegment>(original.PathSegments);
                    updatedParameters = 
                        new List<RoutePatternParameterPart>(original.Parameters);
                }
                
                updatedDefaults.Remove(kvp.Key);
                RemoveParameterDefault(
                    updatedSegments, 
                    updatedParameters, 
                    parameter);
            }
        }
        
        foreach (var kvp in original.RequiredValues)
        {
            requiredValues.TryAdd(kvp.Key, kvp.Value);
        }
        
        return new RoutePattern(
            original.RawText,
            updatedDefaults ?? original.Defaults,
            original.ParameterPolicies,
            requiredValues,
            updatedParameters ?? original.Parameters,
            updatedSegments ?? original.PathSegments);
    }
    
    private bool MatchesConstraints(
        RoutePattern pattern, 
        RoutePatternParameterPart parameter, 
        string key, 
        RouteValueDictionary requiredValues)
    {
        if (pattern.ParameterPolicies.TryGetValue(key, out var policies))
        {
            for (var i = 0; i < policies.Count; i++)
            {
                var policy = _policyFactory.Create(parameter, policies[i]);
                if (policy is IRouteConstraint constraint)
                {
                    if (!constraint.Match(
                        	httpContext: null, 
                        	NullRouter.Instance, 
                        	key, 
                        	requiredValues, 
                        	RouteDirection.IncomingRequest))
                    {
                        return false;
                    }
                }
            }
        }
        
        return true;
    }
    
    private void RemoveParameterDefault(
        List<RoutePatternPathSegment> segments, 
        List<RoutePatternParameterPart> parameters, 
        RoutePatternParameterPart parameter)
    {
        // We know that a parameter can only appear once, so we only need to rewrite one segment and one parameter.
        for (var i = 0; i < segments.Count; i++)
        {
            var segment = segments[i];
            for (var j = 0; j < segment.Parts.Count; j++)
            {
                if (object.ReferenceEquals(parameter, segment.Parts[j]))
                {
                    // Found it!
                    var updatedParameter = RoutePatternFactory.ParameterPart(
                        parameter.Name, 
                        @default: null, 
                        parameter.ParameterKind, 
                        parameter.ParameterPolicies);
                    
                    var updatedParts = new List<RoutePatternPart>(segment.Parts);
                    updatedParts[j] = updatedParameter;
                    segments[i] = RoutePatternFactory.Segment(updatedParts);
                    
                    for (var k = 0; k < parameters.Count; k++)
                    {
                        if (ReferenceEquals(parameter, parameters[k]))
                        {
                            parameters[k] = updatedParameter;
                            break;
                        }
                    }
                    
                    return;
                }
            }
        }
    }
}

```



#### 2.3 parameter policy

##### 2.3.1 抽象

###### 2.3.1.1 parameter policy 接口

```c#
public interface IParameterPolicy
{    
}

```

###### 2.3.1.2 parameter policy activator

```c#
internal static class ParameterPolicyActivator
{
    /* resove parameter policy from string */
    public static T ResolveParameterPolicy<T>(
        IDictionary<string, Type> inlineParameterPolicyMap,
        IServiceProvider serviceProvider,
        string inlineParameterPolicy,
        out string parameterPolicyKey)        
        	where T : IParameterPolicy
    {
        // IServiceProvider could be null
        // DefaultInlineConstraintResolver can be created without an IServiceProvider and then call this method
        
        if (inlineParameterPolicyMap == null)
        {
            throw new ArgumentNullException(nameof(inlineParameterPolicyMap));
        }        
        if (inlineParameterPolicy == null)
        {
            throw new ArgumentNullException(nameof(inlineParameterPolicy));
        }
        
        // 解析 parameter policy key
                
        // 如果 inline parameter policy string 包含 argument（以"(...)"标出）， 
        // 解析 parameter policy key 和 argument string
        string argumentString;
        var indexOfFirstOpenParens = inlineParameterPolicy.IndexOf('(');
        if (indexOfFirstOpenParens >= 0 && 
            inlineParameterPolicy.EndsWith(")", StringComparison.Ordinal))
        {
            parameterPolicyKey = inlineParameterPolicy.Substring(0, indexOfFirstOpenParens);
            argumentString = inlineParameterPolicy.Substring(
                indexOfFirstOpenParens + 1,
                inlineParameterPolicy.Length - indexOfFirstOpenParens - 2);
        }
        // 否则，即 inline parameter policy string 不包含 argument，
        // 直接解析 parameter policy key
        else
        {
            parameterPolicyKey = inlineParameterPolicy;
            argumentString = null;
        }
        
        // 按照 parameter policy key 从 policy map 中获取 parameter policy type，
        // 如果不能解析，-> 返回 default
        if (!inlineParameterPolicyMap.TryGetValue(parameterPolicyKey, out var parameterPolicyType))
        {
            return default;
        }
        
        // 如果 T 不是 parameter policy type 的派生类，       
        if (!typeof(T).IsAssignableFrom(parameterPolicyType))
        {
            // 如果 parameter policy type 不是 parameter policy，-> 抛出异常
            if (!typeof(IParameterPolicy).IsAssignableFrom(parameterPolicyType))
            {
                // Error if type is not a parameter policy
                throw new RouteCreationException(
                    Resources.FormatDefaultInlineConstraintResolver_TypeNotConstraint(
                        parameterPolicyType, parameterPolicyKey, typeof(T).Name));
            }
            
            // Return null if type is parameter policy but is not the exact type
            // This is used by IInlineConstraintResolver for backwards compatibility
            // e.g. looking for an IRouteConstraint but get a different IParameterPolicy type
            
            // parameter policy type 是 parameter policy，-> 返回 default
            return default;
        }
        
        // 调用 create parameter policy 方法
        try
        {
            return (T)CreateParameterPolicy(
                serviceProvider, 
                parameterPolicyType, 
                argumentString);
        }
        catch (RouteCreationException)
        {
            throw;
        }
        catch (Exception exception)
        {
            throw new RouteCreationException(
                $"An error occurred while trying to create an instance of '{parameterPolicyType.FullName}'.",
                exception);
        }
    }
    
    /* create parameter policy */
    [UnconditionalSuppressMessage(
        "ReflectionAnalysis", 
        "IL2006:UnrecognizedReflectionPattern", 
        Justification = "This type comes from the ConstraintMap.")]
    private static IParameterPolicy CreateParameterPolicy(
        IServiceProvider serviceProvider, 
        Type parameterPolicyType, 
        string argumentString)
    {
        // constructor 预结果
        ConstructorInfo activationConstructor = null;
        // parameters 预结果
        object[] parameters = null;
        
        // 从 parameter policy type 解析 constructors
        var constructors = parameterPolicyType.GetConstructors();
        
        // If there is only one constructor and it has a single parameter, pass the argument string directly
        // This is necessary for the Regex RouteConstraint to ensure that patterns are not split on commas.
        
        // 如果只有1个 constructor，并且 non convertable parameter count 为 1
        if (constructors.Length == 1 && 
            GetNonConvertableParameterTypeCount(
                serviceProvider, 
                constructors[0].GetParameters()) == 1)
        {
            // 解析 constructor
            activationConstructor = constructors[0];
            // 将 argument string 转换为 parameter
            parameters = ConvertArguments(
                serviceProvider, 
                activationConstructor.GetParameters(), 
                new string[] { argumentString });
        }
        // 否则，即有多个 constructor，或者 non convertable parameter count 不为 1
        else
        {
            // 分隔 argument string
            var arguments = 
                argumentString?.Split(',', StringSplitOptions.TrimEntries) ?? Array.Empty<string>();
            
            // 解析 constructors
            var matchingConstructors = 
                // 过滤 constructor，non convertable paramete 数量与 argument strings 相同
                constructors.Where(ci => GetNonConvertableParameterTypeCount(
                    					   serviceProvider, 
                    					   ci.GetParameters()) == arguments.Length)
                			// 按照 parameter 数量排序
                		   .OrderByDescending(ci => ci.GetParameters().Length)
                		   .ToArray();
            
            // 如果 constructors 为 0，即不能解析，-> 抛出异常
            if (matchingConstructors.Length == 0)
            {
                throw new RouteCreationException(
                    Resources.FormatDefaultInlineConstraintResolver_CouldNotFindCtor(
                        parameterPolicyType.Name, 
                        arguments.Length));
            }
            // 否则，即能够解析 constructors
            else
            {
                // 如果仅有1个 matching constructor，
                // 或者（有多个 constructors），且 ctro[0] 的 parameter 比 ctro[1] 多（已经排序）
                if (matchingConstructors.Length == 1 || 
                    matchingConstructors[0].GetParameters()
                    					 .Length > matchingConstructors[1].GetParameters()
                    												   .Length)
                {
                    // 获取 constructor
                    activationConstructor = matchingConstructors[0];
                }
                // 否则，
                // 即多个 matching constructors，且包含相同数量 parameter，-> 抛出异常
                else
                {
                    throw new RouteCreationException(
                        Resources.FormatDefaultInlineConstraintResolver_AmbiguousCtors(
                            parameterPolicyType.Name, 
                            matchingConstructors[0].GetParameters().Length));
                }
                
                // 将 argument strings 转换为 parameters
                parameters = ConvertArguments(
                    serviceProvider, 
                    activationConstructor.GetParameters(), 
                    arguments);
            }
        }
        
        // 调用解析到的 constructor
        return (IParameterPolicy)activationConstructor.Invoke(parameters);
    }
    
    private static int GetNonConvertableParameterTypeCount(
        IServiceProvider serviceProvider, 
        ParameterInfo[] parameters)
    {
        if (serviceProvider == null)
        {
            return parameters.Length;
        }
        
        var count = 0;
        
        // 遍历 parameters，计数没有实现 convertable 接口的 parameter 数量
        for (var i = 0; i < parameters.Length; i++)
        {
            if (typeof(IConvertible).IsAssignableFrom(parameters[i].ParameterType))
            {
                count++;
            }
        }
        
        return count;
    }
    
    private static object[] ConvertArguments(
        IServiceProvider serviceProvider, 
        ParameterInfo[] parameterInfos, 
        string[] arguments)
    {
        // parameters 预结果
        var parameters = new object[parameterInfos.Length];
        
        // 遍历 parameter info，
        var argumentPosition = 0;
        for (var i = 0; i < parameterInfos.Length; i++)
        {
            var parameter = parameterInfos[i];
            var parameterType = parameter.ParameterType;
            
            // 如果 parameter 没有实现 convertable 接口
            if (serviceProvider != null && 
                !typeof(IConvertible).IsAssignableFrom(parameterType))
            {
                // 从 service provider 解析
                parameters[i] = serviceProvider.GetRequiredService(parameterType);
            }
            // 否则，即 parameter 实现了 convertable 接口
            else
            {
                // 调用 convert 的静态方法
                parameters[i] = Convert.ChangeType(
                    arguments[argumentPosition], 
                    parameterType, 
                    CultureInfo.InvariantCulture);
                
                argumentPosition++;
            }
        }
        
        return parameters;
    }
}

```

###### 2.3.1.3 parameter policy factory

```c#
public abstract class ParameterPolicyFactory
{
    // 在派生类实现    
    public abstract IParameterPolicy Create(RoutePatternParameterPart? parameter, string inlineText);       
    public abstract IParameterPolicy Create(RoutePatternParameterPart? parameter, IParameterPolicy parameterPolicy);
       
    public IParameterPolicy Create(
        RoutePatternParameterPart? parameter, 
        RoutePatternParameterPolicyReference reference)
    {
        if (reference == null)
        {
            throw new ArgumentNullException(nameof(reference));
        }
        
        Debug.Assert(reference.ParameterPolicy != null || reference.Content != null);
        
        if (reference.ParameterPolicy != null)
        {
            return Create(parameter, reference.ParameterPolicy);
        }
        
        if (reference.Content != null)
        {
            return Create(parameter, reference.Content);
        }
        
        // Unreachable
        throw new NotSupportedException();
    }
}

```

##### 2.3.2 route constrait

```c#
public interface IRouteConstraint : IParameterPolicy
{  
    /* 1- 使用 pattern matcher 的 match 方法，
          解析 request path 到 route value dictionary 集合
       2- 从 route value dictionary 按照 route key 解析 value
       3- 判断 value 是否满足逻辑（policy）*/
    
    bool Match(
        HttpContext? httpContext,
        IRouter? route,
        string routeKey,
        // route value 集合（由 pattern matcher 解析得到）
        RouteValueDictionary values,
        RouteDirection routeDirection);
}

```

###### 2.3.2.1 variety of route constraint



###### 2.3.2.2 route constraint builder

```c#
public class RouteConstraintBuilder
{
    private readonly IInlineConstraintResolver _inlineConstraintResolver;
    private readonly string _displayName;
    
    private readonly Dictionary<string, List<IRouteConstraint>> _constraints;
    private readonly HashSet<string> _optionalParameters;
    
    public RouteConstraintBuilder(
        IInlineConstraintResolver inlineConstraintResolver,
        string displayName)
    {
        if (inlineConstraintResolver == null)
        {
            throw new ArgumentNullException(nameof(inlineConstraintResolver));
        }        
        if (displayName == null)
        {
            throw new ArgumentNullException(nameof(displayName));
        }
        
        // 注入 inline constraint resolver
        _inlineConstraintResolver = inlineConstraintResolver;
        // 注入 display name
        _displayName = displayName;
                
        _constraints = new Dictionary<string, List<IRouteConstraint>>(StringComparer.OrdinalIgnoreCase);
        _optionalParameters = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
    }
    
    public IDictionary<string, IRouteConstraint> Build()
    {
        var constraints = new Dictionary<string, IRouteConstraint>(StringComparer.OrdinalIgnoreCase);
        foreach (var kvp in _constraints)
        {
            IRouteConstraint constraint;
            if (kvp.Value.Count == 1)
            {
                constraint = kvp.Value[0];
            }
            else
            {
                constraint = new CompositeRouteConstraint(kvp.Value.ToArray());
            }
            
            if (_optionalParameters.Contains(kvp.Key))
            {
                var optionalConstraint = new OptionalRouteConstraint(constraint);
                constraints.Add(kvp.Key, optionalConstraint);
            }
            else
            {
                constraints.Add(kvp.Key, constraint);
            }
        }
        
        return constraints;
    }
                   
    public void AddConstraint(string key, object value)
    {
        if (key == null)
        {
            throw new ArgumentNullException(nameof(key));
        }        
        if (value == null)
        {
            throw new ArgumentNullException(nameof(value));
        }
        
        // 转换 value 类型 -> route constraint
        var constraint = value as IRouteConstraint;
        
        // 如果 constraint 为 null（转换不成功），创建 regex constraint
        if (constraint == null)
        {            
            var regexPattern = value as string;
            if (regexPattern == null)
            {
                throw new RouteCreationException(
                    Resources.FormatRouteConstraintBuilder_ValidationMustBeStringOrCustomConstraint(
                        key,
                        value,
                        _displayName,
                        typeof(IRouteConstraint)));
            }
            
            var constraintsRegEx = "^(" + regexPattern + ")$";
            constraint = new RegexRouteConstraint(constraintsRegEx);
        }
        
        Add(key, constraint);
    }
            
    public void AddResolvedConstraint(string key, string constraintText)
    {
        if (key == null)
        {
            throw new ArgumentNullException(nameof(key));
        }        
        if (constraintText == null)
        {
            throw new ArgumentNullException(nameof(constraintText));
        }
        
        // 使用 inline constraint resolve 解析 constraint text string
        var constraint = _inlineConstraintResolver.ResolveConstraint(constraintText);
        if (constraint == null)
        {
            throw new InvalidOperationException(
                Resources.FormatRouteConstraintBuilder_CouldNotResolveConstraint(
                    key,
                    constraintText,
                    _displayName,
                    _inlineConstraintResolver.GetType().Name));
        }
        else if (constraint == NullRouteConstraint.Instance)
        {
            // A null route constraint can be returned for other parameter policy types
            return;
        }
        
        Add(key, constraint);
    }
    
    private void Add(string key, IRouteConstraint constraint)
    {
        if (!_constraints.TryGetValue(key, out var list))
        {
            list = new List<IRouteConstraint>();
            _constraints.Add(key, list);
        }
        
        list.Add(constraint);
    }
    
    /// <summary>
    /// Sets the given key as optional.
    /// </summary>
    /// <param name="key">The key.</param>
    public void SetOptional(string key)
    {
        if (key == null)
        {
            throw new ArgumentNullException(nameof(key));
        }
        
        _optionalParameters.Add(key);
    }        
}

```

##### 2.3.3 inline constraint resolver

###### 2.3.3.1 接口

```c#
public interface IInlineConstraintResolver
{    
    IRouteConstraint? ResolveConstraint(string inlineConstraint);
}

```

###### 2.3.3.2 default inline constraint resolver

```c#
public class DefaultInlineConstraintResolver : IInlineConstraintResolver
{
    private readonly IDictionary<string, Type> _inlineConstraintMap;
    private readonly IServiceProvider _serviceProvider;
        
    public DefaultInlineConstraintResolver(IOptions<RouteOptions> routeOptions, IServiceProvider serviceProvider)
    {
        if (routeOptions == null)
        {
            throw new ArgumentNullException(nameof(routeOptions));
        }        
        if (serviceProvider == null)
        {
            throw new ArgumentNullException(nameof(serviceProvider));
        }
        
        _inlineConstraintMap = routeOptions.Value.ConstraintMap;
        _serviceProvider = serviceProvider;
    }

       
    public virtual IRouteConstraint? ResolveConstraint(string inlineConstraint)
    {
        if (inlineConstraint == null)
        {
            throw new ArgumentNullException(nameof(inlineConstraint));
        }
        
        // This will return null if the text resolves to a non-IRouteConstraint
        return ParameterPolicyActivator.ResolveParameterPolicy<IRouteConstraint>(
            _inlineConstraintMap,
            _serviceProvider,
            inlineConstraint,
            out _);
    }
}

```



##### 2.3.4  route constraint matcher

```c#
public static class RouteConstraintMatcher
{   
    public static bool Match(
        IDictionary<string, IRouteConstraint> constraints,
        RouteValueDictionary routeValues,
        HttpContext httpContext,
        IRouter route,
        RouteDirection routeDirection,
        ILogger logger)
    {
        if (routeValues == null)
        {
            throw new ArgumentNullException(nameof(routeValues));
        }        
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }        
        if (route == null)
        {
            throw new ArgumentNullException(nameof(route));
        }        
        if (logger == null)
        {
            throw new ArgumentNullException(nameof(logger));
        }
        
        // 传入的 constraint 为空，-> true，没有 constraint 就是满足的
        if (constraints == null || constraints.Count == 0)
        {
            return true;
        }
        
        // 遍历 constraint，使用 route constraint 的 match 方法
        foreach (var kvp in constraints)
        {
            var constraint = kvp.Value;
            
            if (!constraint.Match(httpContext, route, kvp.Key, routeValues, routeDirection))
            {
                if (routeDirection.Equals(RouteDirection.IncomingRequest))
                {
                    routeValues.TryGetValue(kvp.Key, out var routeValue);                    
                    logger.ConstraintNotMatched(routeValue!, kvp.Key, kvp.Value);
                }
                
                return false;
            }
        }
        
        return true;
    }
}

```

##### 2.3.5 outbound parameter transformer

```c#
public interface IOutboundParameterTransformer : IParameterPolicy
{
    string? TransformOutbound(object? value);
}

```

### 3. router routing

#### 3.1 router

##### 3.1.1 抽象 

```c#
// router 接口
public interface IRouter
{    
    Task RouteAsync(RouteContext context);        
    VirtualPathData? GetVirtualPath(VirtualPathContext context);
}

// named router 接口
public interface INamedRouter : IRouter
{    
    string? Name { get; }
}

```

###### 3.1.1.1 route context

* 封装 route data、request delegate

```c#
public class RouteContext
{
    private RouteData _routeData;
    public RouteData RouteData
    {
        get
        {
            return _routeData;
        }
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(RouteData));
            }
            
            _routeData = value;
        }
    }
    
    public HttpContext HttpContext { get; }
    public RequestDelegate? Handler { get; set; }
                    
    public RouteContext(HttpContext httpContext)
    {
        HttpContext = httpContext 
            ?? throw new ArgumentNullException(nameof(httpContext));     
        RouteData = new RouteData();
    }            
}

```

###### 3.1.1.2 route data

* 封装路由数据

```c#
public class RouteData
{
    // ???
    private RouteValueDictionary? _dataTokens;
    public RouteValueDictionary DataTokens
    {
        get
        {
            if (_dataTokens == null)
            {
                _dataTokens = new RouteValueDictionary();
            }
            
            return _dataTokens;
        }
    }
    
    // routers
    private List<IRouter>? _routers;
    public IList<IRouter> Routers
    {
        get
        {
            if (_routers == null)
            {
                _routers = new List<IRouter>();
            }
            
            return _routers;
        }
    }
    
    // route value
    private RouteValueDictionary? _values;
    public RouteValueDictionary Values
    {
        get
        {
            if (_values == null)
            {
                _values = new RouteValueDictionary();
            }
            
            return _values;
        }
    }
                    
    public RouteData()
    {
        // Perf: Avoid allocating collections unless needed.
    }
            
    public RouteData(RouteData other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        // Perf: Avoid allocating collections unless we need to make a copy.
        
        if (other._routers != null)
        {
            _routers = new List<IRouter>(other.Routers);
        }        
        if (other._dataTokens != null)
        {
            _dataTokens = new RouteValueDictionary(other._dataTokens);
        }        
        if (other._values != null)
        {
            _values = new RouteValueDictionary(other._values);
        }
    }

    public RouteData(RouteValueDictionary values)
    {
        if (values == null)
        {
            throw new ArgumentNullException(nameof(values));
        }
        
        _values = values;
    }
        
    public RouteDataSnapshot PushState(
        IRouter? router, 
        RouteValueDictionary? values, 
        RouteValueDictionary? dataTokens)
    {
        /* 克隆 routers 集合 */
        // Perf: this is optimized for small list sizes, in particular to avoid overhead 
        // of a native call in Array.CopyTo inside the List(IEnumerable<T>) constructor.       
        List<IRouter>? routers = null;
        var count = _routers?.Count;
        if (count > 0)
        {
            Debug.Assert(_routers != null);
            
            routers = new List<IRouter>(count.Value);
            for (var i = 0; i < count.Value; i++)
            {
                routers.Add(_routers[i]);
            }
        }
        
        /* 将原有 route data 创建 snapshot */
        var snapshot = new RouteDataSnapshot(
            this,
            _dataTokens?.Count > 0 ? new RouteValueDictionary(_dataTokens) : null, 
            routers,
            _values?.Count > 0 ? new RouteValueDictionary(_values) : null);
        
        // 注入新的 router
        if (router != null)
        {
            Routers.Add(router);
        }
        // 注入新的 values
        if (values != null)
        {
            foreach (var kvp in values)
            {
                if (kvp.Value != null)
                {
                    Values[kvp.Key] = kvp.Value;
                }
            }
        }
        // 注入新的 data token
        if (dataTokens != null)
        {
            foreach (var kvp in dataTokens)
            {
                DataTokens[kvp.Key] = kvp.Value;
            }
        }
        
        return snapshot;
    }
    
    // snap shot 结构体
    public readonly struct RouteDataSnapshot
    {
        private readonly RouteData _routeData;
        private readonly RouteValueDictionary? _dataTokens;
        private readonly IList<IRouter>? _routers;
        private readonly RouteValueDictionary? _values;
                
        public RouteDataSnapshot(
            RouteData routeData,
            RouteValueDictionary? dataTokens,
            IList<IRouter>? routers,
            RouteValueDictionary? values)
        {
            if (routeData == null)
            {
                throw new ArgumentNullException(nameof(routeData));
            }
            
            _routeData = routeData;
            _dataTokens = dataTokens;
            _routers = routers;
            _values = values;
        }
        
        // 恢复，
        // _datatoken、_routes、_values 注入 _routedata
        public void Restore()
        {
            /* data tokens */
            
            if (_routeData._dataTokens == null && 
                _dataTokens == null)
            {
                // Do nothing
            }
            else if (_dataTokens == null)
            {
                _routeData._dataTokens!.Clear();
            }
            else
            {
                _routeData._dataTokens!.Clear();
                
                foreach (var kvp in _dataTokens)
                {
                    _routeData._dataTokens
                        	  .Add(kvp.Key, kvp.Value);
                }
            }
            
            /* routers */
            
            if (_routeData._routers == null 
                && _routers == null)
            {
                // Do nothing
            }
            else if (_routers == null)
            {
                // Perf: this is optimized for small list sizes, in particular to avoid 
                // overhead of a native call in Array.Clear inside the List.Clear() method.
                var routers = _routeData._routers!;
                for (var i = routers.Count - 1; i >= 0 ; i--)
                {
                    routers.RemoveAt(i);
                }
            }
            else
            {
                // Perf: this is optimized for small list sizes, in particular to avoid 
                // overhead of a native call in Array.Clear inside the List.Clear() method.  
                //
                // We want to basically copy the contents of _routers in
                // _routeData._routers - this change does that with the minimal number of 
                // reads/writes and without calling Clear().
                var routers = _routeData._routers!;
                var snapshotRouters = _routers;
                
                // This is made more complicated by the fact that List[int] throws if 
                // i == Count, so we have to do two loops and call Add for those cases.
                var i = 0;
                for (; i < snapshotRouters.Count && 
                     i < routers.Count; i++)
                {
                    routers[i] = snapshotRouters[i];
                }
                
                for (; i < snapshotRouters.Count; i++)
                {
                    routers.Add(snapshotRouters[i]);
                }
                
                // Trim excess - again avoiding RemoveRange because it uses native methods.
                for (i = routers.Count - 1; i >= snapshotRouters.Count; i--)
                {
                    routers.RemoveAt(i);
                }
            }
            
            /* values */
            
            if (_routeData._values == null && 
                _values == null)
            {
                // Do nothing
            }
            else if (_values == null)
            {
                _routeData._values!.Clear();
            }
            else
            {
                _routeData._values!.Clear();
                
                foreach (var kvp in _values)
                {
                    _routeData._values
                        	  .Add(kvp.Key, kvp.Value);
                }
            }
        }
    }
}

```

###### 3.1.1.3 virtual path context

```c#
public class VirtualPathContext
{         
    public HttpContext HttpContext { get; }        
    public string? RouteName { get; }        
    public RouteValueDictionary Values { get; set; }
    public RouteValueDictionary AmbientValues { get; }   
    
    public VirtualPathContext(
        HttpContext httpContext,
        RouteValueDictionary ambientValues,
        RouteValueDictionary values)
            : this(httpContext, ambientValues, values, null)
    {
    }
        
    public VirtualPathContext(
        HttpContext httpContext,
        RouteValueDictionary ambientValues,
        RouteValueDictionary values,
        string? routeName)
    {
        HttpContext = httpContext;
        AmbientValues = ambientValues;
        Values = values;
        RouteName = routeName;
    }               
}

```

###### 3.1.1.4 virtual path data

```c#
public class VirtualPathData
{        
    /* data token */
    private RouteValueDictionary _dataTokens;
    public RouteValueDictionary DataTokens
    {
        get
        {
            if (_dataTokens == null)
            {
                _dataTokens = new RouteValueDictionary();
            }
            
            return _dataTokens;
        }
    }
    
    /* virtual path */
    private string _virtualPath;
    public string VirtualPath
    {
        get
        {
            return _virtualPath;
        }
        set
        {
            _virtualPath = NormalizePath(value);
        }
    }    
    
    public IRouter Router { get; set; }
                
    public VirtualPathData(IRouter router, string virtualPath)
        : this(router, virtualPath, dataTokens: null)
    {
    }
        
    public VirtualPathData(
        IRouter router,
        string virtualPath,
        RouteValueDictionary dataTokens)
    {
        if (router == null)
        {
            throw new ArgumentNullException(nameof(router));
        }
        
        Router = router;
        VirtualPath = virtualPath;
        _dataTokens = dataTokens == null 
            			  ? null 
            			  : new RouteValueDictionary(dataTokens);
    }      
    
    // 加上“/”
    private static string NormalizePath(string path)
    {
        if (string.IsNullOrEmpty(path))
        {
            return string.Empty;
        }
        
        if (!path.StartsWith("/", StringComparison.Ordinal))
        {
            return "/" + path;
        }
        
        return path;
    }
}

```

##### 3.1.2 router base

```c#
public abstract class RouteBase : IRouter, INamedRouter
{
    private readonly object _loggersLock = new object();
    
    // 匹配 request -> template
    private TemplateMatcher? _matcher;
    // 匹配 template -> virtual path
    private TemplateBinder? _binder;
    
    private ILogger? _logger;
    private ILogger? _constraintLogger;
           
    // name
    public virtual string? Name { get; protected set; }
    
    // template
    public virtual RouteTemplate ParsedTemplate { get; protected set; }
    // constraint
    public virtual IDictionary<string, IRouteConstraint> Constraints { get; protected set; } 
    protected virtual IInlineConstraintResolver ConstraintResolver { get; set; }
    // data tokens？
    public virtual RouteValueDictionary DataTokens { get; protected set; }        
    // defaults
    public virtual RouteValueDictionary Defaults { get; protected set; }
           
        
    /* 构造函数 */    
    public RouteBase(
        string? template,
        string? name,
        IInlineConstraintResolver constraintResolver,
        RouteValueDictionary? defaults,
        IDictionary<string, object>? constraints,
        RouteValueDictionary? dataTokens)
    {       
        if (constraintResolver == null)
        {
            throw new ArgumentNullException(nameof(constraintResolver));
        }
        
        // 注入 template string，如果是 null，转为 string.empty
        template = template ?? string.Empty;
        
        Name = name;                
        ConstraintResolver = constraintResolver;                
        DataTokens = dataTokens ?? new RouteValueDictionary();
        
        try
        {
            /* 1- 解析 route template，
               	  使用 template parser 从 template string 解析 route template */            
            ParsedTemplate = TemplateParser.Parse(template);
            
            /* 2- 解析 route constraint，
                  使用 inline constraint resolver 从 route template 解析 route constraint */   
            Constraints = GetConstraints(
                			  constraintResolver, 
			                  ParsedTemplate, 
              				  constraints);
            
            /* 3- 解析 parameter 的 default value， 
            	  从 route template 解析 default value */            	  
            Defaults = GetDefaults(ParsedTemplate, defaults);
            
        }
        catch (Exception exception)
        {
            throw new RouteCreationException(
                Resources.FormatTemplateRoute_Exception(name, template), 
                exception);
        }
    }
                 
    /// <inheritdoc />
    public override string ToString()
    {
        return ParsedTemplate.TemplateText!;
    }
    
    [MemberNotNull(nameof(_logger), nameof(_constraintLogger))]
    private void EnsureLoggers(HttpContext context)
    {
        // We check first using the _logger to see 
        // if the loggers have been initialized to avoid taking
        // the lock on the most common case.
        if (_logger == null)
        {
            // We need to lock here to ensure that _constraintLogger 
            // and _logger get initialized atomically.
            lock (_loggersLock)
            {
                if (_logger != null)
                {
                    // Multiple threads might have tried to acquire 
                    // the lock at the same time. 
                    // Technically there is nothing wrong if things 
                    // get reinitialized by a second thread, 
                    // but its easy to prevent by just rechecking and returning here.
                    Debug.Assert(_constraintLogger != null);
                    
                    return;
                }
                
                // 解析 logger factory
                var factory = context.RequestServices
                    				 .GetRequiredService<ILoggerFactory>();
                
                // 创建 constraint logger
                _constraintLogger = 
                    factory.CreateLogger(typeof(RouteConstraintMatcher).FullName!);
                
                // 创建 logger
                _logger = factory.CreateLogger(typeof(RouteBase).FullName!);
            }            
        }
        
        Debug.Assert(_constraintLogger != null);
    }
}

```

###### 3.1.2.1 get constraint

```c#
public abstract class RouteBase : IRouter, INamedRouter
{
    protected static IDictionary<string, IRouteConstraint> GetConstraints(
        IInlineConstraintResolver inlineConstraintResolver,
        RouteTemplate parsedTemplate,
        IDictionary<string, object>? constraints)
    {
        // 由 inline constraint resolver 创建 route constraint builder
        var constraintBuilder = new RouteConstraintBuilder(
            inlineConstraintResolver, 
            parsedTemplate.TemplateText!);
        
        // 将（传入的） constraints 注入constraint builder
        if (constraints != null)
        {
            foreach (var kvp in constraints)                
            {
                constraintBuilder.AddConstraint(kvp.Key, kvp.Value);
            }
        }
                
        // 遍历（传入的）route template 的 parameter part，
        foreach (var parameter in parsedTemplate.Parameters)
        {
            // 如果 parameter part 是 optional，标记
            if (parameter.IsOptional)
            {
                constraintBuilder.SetOptional(parameter.Name!);
            }
            // 遍历 parameter part 所有 inline constraint， 
            foreach (var inlineConstraint in parameter.InlineConstraints)
            {
                // 将 inline constraint 注入 constraint builder
                constraintBuilder.AddResolvedConstraint(
                    parameter.Name!, 
                    inlineConstraint.Constraint);
            }
        }
        
        // 构建 constraints map (string-type dictionary)
        return constraintBuilder.Build();
    }
}

```

###### 3.1.2.2 get defaults

```c#
public abstract class RouteBase : IRouter, INamedRouter
{
     protected static RouteValueDictionary GetDefaults(
        RouteTemplate parsedTemplate,
        RouteValueDictionary? defaults)
    {
        // 预结果，创建或者克隆（传入的）defaults
        var result = defaults == null 
            		 	? new RouteValueDictionary() 
			            : new RouteValueDictionary(defaults);
        
        // 遍历（传入的）route template 的 parameter part
        foreach (var parameter in parsedTemplate.Parameters)
        {
            // 如果 parameter part 的 default value 不为 null，注入 result
            if (parameter.DefaultValue != null)
            {
#if RVD_TryAdd
    			if (!result.TryAdd(
                    	parameter.Name, 
                    	parameter.DefaultValue))
                {
                    throw new InvalidOperationException(
                        Resources.FormatTemplateRoute
		                          _CannotHaveDefaultValueSpecifiedInlineAndExplicitly(
                                      parameter.Name));
                }
#else
                if (result.ContainsKey(parameter.Name!))
                {
                    throw new InvalidOperationException(
                        Resources.FormatTemplateRoute
                        		 _CannotHaveDefaultValueSpecifiedInlineAndExplicitly(
                                     parameter.Name));
                }
                else
                {
                    result.Add(
                        	   parameter.Name!, 
		                       parameter.DefaultValue);
                }
#endif
            }
        }
                
        return result;
    }                                
}

```

###### 3.1.2.3 接口方法 - route async

```c#
public abstract class RouteBase : IRouter, INamedRouter
{
    public virtual Task RouteAsync(RouteContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        // a- 确认 template matcher 不为 null（创建）
        EnsureMatcher();
        
        // 确认 logger 不为 null       
        EnsureLoggers(context.HttpContext);
                        
        // 从 http context 中解析 request path，
        var requestPath = context.HttpContext.Request.Path;     
        
        // 使用 template matche 验证 request path，不匹配 -> 结束
        if (!_matcher.TryMatch(
            	// request path
            	requestPath, 
            	// route value 结果
            	context.RouteData.Values))
        {
            // If we got back a null value set, that means the URI did not match
            return Task.CompletedTask;
        }
        
        // b- 合并（额外的）data token
        // Perf: Avoid accessing dictionaries if you don't need to write to them, 
        // these dictionaries are all created lazily.
        if (DataTokens.Count > 0)
        {
            MergeValues(
                context.RouteData.DataTokens, 
                DataTokens);
        }
                
        // 使用 constraint matcher 验证，如果不匹配 -> 结束
        if (!RouteConstraintMatcher.Match(
            	// get constraint 方法得到的结果
	            Constraints,        
            	// matcher 的 match 方法得到的结果
    	        context.RouteData.Values,
        	    context.HttpContext,
            	this,
            	RouteDirection.IncomingRequest,
            	_constraintLogger))
        {
            return Task.CompletedTask;
        }
        
        /* request path（http context 解析得到）匹配 route template 和  route constrain，*/
        
        // 记录日志
        _logger.RequestMatchedRoute(Name!, ParsedTemplate.TemplateText!);        
        // 触发 on route matched 钩子
        return OnRouteMatched(context);
    }
    
    // a- 由 route template（解析得到）创建 template matcher
    [MemberNotNull(nameof(_matcher))]
    private void EnsureMatcher()
    {
        if (_matcher == null)
        {
            _matcher = new TemplateMatcher(ParsedTemplate, Defaults);
        }
    }
    
    // b- 合并传入的 data token
    private static void MergeValues(
        RouteValueDictionary destination,
        RouteValueDictionary values)
    {
        foreach (var kvp in values)
        {
            // This will replace the original value for the specified key.
            // Values from the matched route will take preference over previous
            // data in the route context.
            destination[kvp.Key] = kvp.Value;
        }
    }
    
    // on route matched 钩子
    protected abstract Task OnRouteMatched(RouteContext context);        
}

```

###### 3.1.2.4 接口方法 - get virtual path

```c#
public abstract class RouteBase : IRouter, INamedRouter
{
    public virtual VirtualPathData? GetVirtualPath(VirtualPathContext context)
    {
        // a- 确认 template binder 不为 null（创建）
        EnsureBinder(context.HttpContext);
        
        // 确认 logger 不为 null
        EnsureLoggers(context.HttpContext);
        
        // 使用 template binder，
        // 从传入的 values、ambient values 解析 template value result，
        var values = _binder.GetValues(
            context.AmbientValues, 
            context.Values);
        // 不能解析，返回 null
        if (values == null)
        {
            // We're missing one of the required values for this route.
            return null;
        }
                        
        // 使用 constraint matcher 验证，-> 如果不匹配，返回 null
        if (!RouteConstraintMatcher.Match(
            	// get constraint 方法得到的结果
            	Constraints,
            	// template value result 的 route value dictionary
	            values.CombinedValues,
    	        context.HttpContext,
        	    this,
            	RouteDirection.UrlGeneration,
            	_constraintLogger))
        {
            return null;
        }
                
        // （通过 constraint 验证），
        // 将 template value result 的 combined values 注入到 virtual path context
        context.Values = values.CombinedValues;   
        
        /* 使用 on virtual path generated 钩子创建 virtual path data */     
        
        // b- on virtual path generated 钩子
        var pathData = OnVirtualPathGenerated(context);        
        if (pathData != null)
        {
            // If the target generates a value then that can short circuit.
            return pathData;
        }
        
        /* 不使用 on virtual path generated 钩子创建 virtual path data*/
        
        // 使用 template binder 将 template value result 绑定到 virtual path string
        var virtualPath = _binder.BindValues(values.AcceptedValues);        
        if (virtualPath == null)
        {
            return null;
        }
        // 由 virtual path string 创建 virtual path data        
        pathData = new VirtualPathData(this, virtualPath);        
        // 注入传入的 data token
        if (DataTokens != null)
        {
            foreach (var dataToken in DataTokens)
            {
                pathData.DataTokens
                    	.Add(dataToken.Key, dataToken.Value);
            }
        }        
        return pathData;
    }
    
    // a- 使用 template binder factory（从 service provider 中解析），
    //	  由 route template（解析得到）创建 template binder    
    [MemberNotNull(nameof(_binder))]
    private void EnsureBinder(HttpContext context)
    {
        if (_binder == null)
        {
            var binderFactory = context
                .RequestServices
                .GetRequiredService<TemplateBinderFactory>();
            
            _binder = binderFactory.Create(ParsedTemplate, Defaults);
        }
    }
    
    // b- virtual path generated 钩子，由派生类实现
    protected abstract VirtualPathData? 
        OnVirtualPathGenerated(VirtualPathContext context);
}

```

##### 3.1.3 route 

* router 的统一表示，封装具体执行操作的 router

```c#
public class Route : RouteBase
{
    // 封装的 router（route collection）
    private readonly IRouter _target;
    public string? RouteTemplate => ParsedTemplate.TemplateText;
    
    public Route(
        IRouter target,
        string routeTemplate,
        IInlineConstraintResolver inlineConstraintResolver)
        	: this(
                target,
                routeTemplate,
                defaults: null,
                constraints: null,
                dataTokens: null,
                inlineConstraintResolver: inlineConstraintResolver)
    {
    }
        
    public Route(
        IRouter target,
        string routeTemplate,
        RouteValueDictionary? defaults,
        IDictionary<string, object>? constraints,
        RouteValueDictionary? dataTokens,
        IInlineConstraintResolver inlineConstraintResolver)
            : this(
                target, 
                null, 
                routeTemplate, 
                defaults, 
                constraints, 
                dataTokens, 
                inlineConstraintResolver)
    {
    }
       
    public Route(
        IRouter target,
        string? routeName,
        string? routeTemplate,
        RouteValueDictionary? defaults,
        IDictionary<string, object>? constraints,
        RouteValueDictionary? dataTokens,
        IInlineConstraintResolver inlineConstraintResolver)
            : base(
                  routeTemplate,
                  routeName,
                  inlineConstraintResolver,
                  defaults,
                  constraints,
                  dataTokens)
    {
        if (target == null)
        {
            throw new ArgumentNullException(nameof(target));
        }
                
        _target = target;
    }
                
    /// <inheritdoc />
    protected override Task OnRouteMatched(RouteContext context)
    {
        // 注入 router
        context.RouteData.Routers.Add(_target);
        // 使用封装的 router 的 route 方法
        return _target.RouteAsync(context);
    }
    
    /// <inheritdoc />
    protected override VirtualPathData? OnVirtualPathGenerated(VirtualPathContext context)
    {
        // 使用封装的 router 的 get virtual path 方法
        return _target.GetVirtualPath(context);
    }
}

```

##### 3.1.4 route handler

* 封装 router 执行的 request delegate

###### 3.1.4.1 接口

```c#
public interface IRouteHandler
{
    RequestDelegate GetRequestHandler(
        HttpContext httpContext, 
        RouteData routeData);
}
```

###### 3.1.4.2 route handler

```c#
public class RouteHandler : IRouteHandler, IRouter
{
    private readonly RequestDelegate _requestDelegate;        
    public RouteHandler(RequestDelegate requestDelegate)
    {
        _requestDelegate = requestDelegate;
    }
    
    /// <inheritdoc />
    public RequestDelegate GetRequestHandler(
        HttpContext httpContext, 
        RouteData routeData)
    {
        return _requestDelegate;
    }
    
    /// <inheritdoc />
    public VirtualPathData? GetVirtualPath(VirtualPathContext context)
    {
        // Nothing to do.
        return null;
    }
    
    /// <inheritdoc />
    public Task RouteAsync(RouteContext context)
    {
        context.Handler = _requestDelegate;
        return Task.CompletedTask;
    }
}

```

##### 3.1.5 route collection

###### 3.1.5.1 接口

```c#
public interface IRouteCollection : IRouter
{    
    void Add(IRouter router);
}
```

###### 3.1.5.2 route collection

```c#
public class RouteCollection : IRouteCollection
{
    private readonly static char[] UrlQueryDelimiters = new char[] { '?', '#' };
    
    private readonly List<IRouter> _routes = new List<IRouter>();    
    private readonly List<IRouter> _unnamedRoutes = new List<IRouter>();
    private readonly Dictionary<string, INamedRouter> _namedRoutes =
        new Dictionary<string, INamedRouter>(StringComparer.OrdinalIgnoreCase);
    
    private RouteOptions? _options;
                           
    public int Count
    {
        get { return _routes.Count; }
    }        
    
    public IRouter this[int index]
    {
        get { return _routes[index]; }
    }                
    
    // 解析 route options
    [MemberNotNull(nameof(_options))]
    private void EnsureOptions(HttpContext context)
    {
        if (_options == null)
        {
            _options = context.RequestServices
                			 .GetRequiredService<IOptions<RouteOptions>>()
                			 .Value;
        }
    }                
}

```

###### 3.1.5.3 接口方法 - route async

```c#
public class RouteCollection : IRouteCollection
{    
    public async virtual Task RouteAsync(RouteContext context)
    {
        // Perf: We want to avoid allocating a new RouteData for each route we 
        // need to process.
        // We can do this by snapshotting the state at the beginning and then restoring 
        // it for each router we execute.
        var snapshot = context.RouteData.PushState(null, values: null, dataTokens: null);
        
        // 遍历 route 集合，
        for (var i = 0; i < Count; i++)
        {
            // 将 route 注入 route context
            var route = this[i];
            context.RouteData
                   .Routers
                   .Add(route);
            
            try
            {
                // 执行 route 的 route async 方法
                await route.RouteAsync(context);                
                // 如果执行结果不为 null，结束
                if (context.Handler != null)
                {
                    break;
                }
            }
            finally
            {
                if (context.Handler == null)
                {
                    snapshot.Restore();
                }
            }
        }
    }
}

```

###### 3.1.5.4 接口方法 - get virtual path

```c#
public class RouteCollection : IRouteCollection
{
    /// <inheritdoc />
    public virtual VirtualPathData? GetVirtualPath(VirtualPathContext context)
    {
        // 解析 route options 
        EnsureOptions(context.HttpContext);
        
        /* 如果 virtual path context 中 route name 不为空  */
        if (!string.IsNullOrEmpty(context.RouteName))
        {
            // 预结果
            VirtualPathData? namedRoutePathData = null;
            
            // 从 named route 集合中找到匹配的 router，
            if (_namedRoutes.TryGetValue(
                				context.RouteName, 
                				out var matchedNamedRoute))
            {
                // 如果能找到，使用 route 解析 virtual path data
                namedRoutePathData = matchedNamedRoute.GetVirtualPath(context);
            }
            
            // a- 从 unamed route 集合中解析 virtual path data
            var pathData = GetVirtualPath(context, _unnamedRoutes);
                        
            // If the named route and one of the unnamed routes also matches, 
            // then we have an ambiguity.
            
            // 如果都能解析到 virtual path data，抛出异常
            if (namedRoutePathData != null && 
                pathData != null)
            {
                var message = Resources.FormatNamedRoutes
                    					_AmbiguousRoutesFound(context.RouteName);
                throw new InvalidOperationException(message);
            }
            
            /* b- 由 named route data 或者 unamed route data 创建 virtual path data */
            return NormalizeVirtualPath(namedRoutePathData ?? pathData);
        }
        /* 否则，即 route name 为空 */
        else
        {
            // a- & b-
            return NormalizeVirtualPath(GetVirtualPath(context, _routes));
        }
    }
        
    // a- 从 route 集合中 get virtual path
    private VirtualPathData? GetVirtualPath(
        VirtualPathContext context, 
        List<IRouter> routes)
    {
        // 遍历 route 集合解析 virtual path data，        
        for (var i = 0; i < routes.Count; i++)
        {
            var route = routes[i];
            
            var pathData = route.GetVirtualPath(context);
            if (pathData != null)
            {
                // 只要找到（第一个），返回结果
                return pathData;
            }
        }
        
        // 找不到，返回 null
        return null;
    }
    
    // b- 标准化 virtual path data
    private VirtualPathData? NormalizeVirtualPath(VirtualPathData? pathData)
    {
        if (pathData == null)
        {
            return pathData;
        }
        
        Debug.Assert(_options != null);
        
        var url = pathData.VirtualPath;
        
        if (!string.IsNullOrEmpty(url) && 
            (_options.LowercaseUrls || _options.AppendTrailingSlash))
        {
            var indexOfSeparator = url.IndexOfAny(UrlQueryDelimiters);
            var urlWithoutQueryString = url;
            var queryString = string.Empty;
            
            if (indexOfSeparator != -1)
            {
                urlWithoutQueryString = url.Substring(0, indexOfSeparator);
                queryString = url.Substring(indexOfSeparator);
            }
            
            if (_options.LowercaseUrls)
            {
                urlWithoutQueryString = urlWithoutQueryString.ToLowerInvariant();
            }
            
            if (_options.LowercaseUrls && 
                _options.LowercaseQueryStrings)
            {
                queryString = queryString.ToLowerInvariant();
            }
            
            if (_options.AppendTrailingSlash && 
                !urlWithoutQueryString.EndsWith("/", StringComparison.Ordinal))
            {
                urlWithoutQueryString += "/";
            }
            
            // queryString will contain the delimiter ? or # as the first character, 
            // so it's safe to append.
            url = urlWithoutQueryString + queryString;
            
            return new VirtualPathData(pathData.Router, url, pathData.DataTokens);
        }
        
        return pathData;
    }        
}

```

###### 3.1.5.5 接口方法 - add (router)

```c#
public class RouteCollection : IRouteCollection
{    
    public void Add(IRouter router)
    {
        if (router == null)
        {
            throw new ArgumentNullException(nameof(router));
        }
        
        // 如果 route 实现了 named router 接口，
        var namedRouter = router as INamedRouter;
        if (namedRouter != null)
        {
            if (!string.IsNullOrEmpty(namedRouter.Name))
            {
                // 注入 named route 集合
                _namedRoutes.Add(namedRouter.Name, namedRouter);
            }
        }
        // 否则，即没有实现 named router 接口，
        else
        {
            // 注入 unamed route 集合
            _unnamedRoutes.Add(router);
        }
        
        // 同时注入 routes 集合（无论是否实现 named router 接口）        
        _routes.Add(router);
    }
}

```

##### 3.1.6 null router

```c#
internal class NullRouter : IRouter
{
    public static readonly NullRouter Instance = new NullRouter();
    
    private NullRouter()
    {
    }
    
    public Task RouteAsync(RouteContext context)
    {
        return Task.CompletedTask;
    }
    
    public VirtualPathData? GetVirtualPath(VirtualPathContext context)
    {
        return null;
    }        
}

```

#### 3.2 router builder

##### 3.2.1 接口

```c#
public interface IRouteBuilder
{    
    IApplicationBuilder ApplicationBuilder { get; }      
    // default router
    IRouter? DefaultHandler { get; set; }    
    IServiceProvider ServiceProvider { get; }            
    IList<IRouter> Routes { get; }
        
    IRouter Build();
}

```

##### 3.2.2 router builder

```c#
public class RouteBuilder : IRouteBuilder
{
    public IApplicationBuilder ApplicationBuilder { get; }      
    public IRouter? DefaultHandler { get; set; }       
    public IServiceProvider ServiceProvider { get; }       
    public IList<IRouter> Routes { get; }
            
    public RouteBuilder(IApplicationBuilder applicationBuilder)
        : this(
            applicationBuilder, 
            defaultHandler: null)
    {
    }
        
    public RouteBuilder(
        IApplicationBuilder applicationBuilder, 
        IRouter? defaultHandler)
    {
        if (applicationBuilder == null)
        {
            throw new ArgumentNullException(nameof(applicationBuilder));
        }
        
        // 如果 app builder 中没有注入 routing marker service，抛出异常        
        if (applicationBuilder.ApplicationServices
            				.GetService(typeof(RoutingMarkerService)) == null)
        {
            throw new InvalidOperationException(
                Resources.FormatUnableToFindServices(
                    nameof(IServiceCollection),
                    nameof(RoutingServiceCollectionExtensions.AddRouting),
                    "ConfigureServices(...)"));
        }
        
        // 注入 application builder
        ApplicationBuilder = applicationBuilder;
        // 注入 default router
        DefaultHandler = defaultHandler;
        // 从 application builder 解析 service provider
        ServiceProvider = applicationBuilder.ApplicationServices;
        
        // 创建 route 集合（默认）
        Routes = new List<IRouter>();
    }
        
    // 返回新的 route collection 实例（克隆）
    public IRouter Build()
    {
        var routeCollection = new RouteCollection();
        
        foreach (var route in Routes)
        {
            routeCollection.Add(route);
        }
        
        return routeCollection;
    }
}

```

##### 3.2.3 扩展方法 - map route

* 注册 router

###### 3.2.3.1 map route (template)

```c#
public static class MapRouteRouteBuilderExtensions
{    
    public static IRouteBuilder MapRoute(
        this IRouteBuilder routeBuilder,
        string? name,
        string? template)
    {
        return MapRoute(
            routeBuilder, 
            name, 
            template, 
            defaults: null);                
    }
        
    public static IRouteBuilder MapRoute(
        this IRouteBuilder routeBuilder,
        string? name,
        string? template,
        object? defaults)
    {
        return MapRoute(
            routeBuilder, 
            name, 
            template, 
            defaults, 
            constraints: null);
    }
            
    public static IRouteBuilder MapRoute(
        this IRouteBuilder routeBuilder,
        string? name,
        string? template,
        object? defaults,
        object? constraints)
    {
        return MapRoute(
            routeBuilder, 
            name, 
            template, 
            defaults, 
            constraints, 
            dataTokens: null);
    }
    
    // 向 route builder 中注入 route
    public static IRouteBuilder MapRoute(
        this IRouteBuilder routeBuilder,
        string? name,
        string? template,
        object? defaults,
        object? constraints,
        object? dataTokens)
    {
        if (routeBuilder.DefaultHandler == null)
        {
            throw new RouteCreationException(
                Resources.FormatDefaultHandler_MustBeSet(nameof(IRouteBuilder)));
        }
        
        routeBuilder.Routes.Add(
            new Route(
                routeBuilder.DefaultHandler,
                name,
                template,
                new RouteValueDictionary(defaults),
                new RouteValueDictionary(constraints)!,
                new RouteValueDictionary(dataTokens),
                CreateInlineConstraintResolver(routeBuilder.ServiceProvider)));
        
        return routeBuilder;
    }      
    
    /* create inline constraint resolver */
    
    private static IInlineConstraintResolver CreateInlineConstraintResolver(
        IServiceProvider serviceProvider)
    {
        var inlineConstraintResolver = 
            serviceProvider.GetRequiredService<IInlineConstraintResolver>();
        
        var parameterPolicyFactory = 
            serviceProvider.GetRequiredService<ParameterPolicyFactory>();
        
        // This inline constraint resolver will return a null constraint for 
        // non-IRouteConstraint parameter policies so Route does not error
        return new BackCompatInlineConstraintResolver(
            inlineConstraintResolver, 
            parameterPolicyFactory);
    }
    
    private class BackCompatInlineConstraintResolver : IInlineConstraintResolver
    {
        private readonly IInlineConstraintResolver _inner;
        private readonly ParameterPolicyFactory _parameterPolicyFactory;
        
        public BackCompatInlineConstraintResolver(
            IInlineConstraintResolver inner, 
            ParameterPolicyFactory parameterPolicyFactory)
        {
            _inner = inner;
            _parameterPolicyFactory = parameterPolicyFactory;
        }
        
        public IRouteConstraint? ResolveConstraint(string inlineConstraint)
        {
            // 使用 inner constraint resolver 解析 constraint，            
            var routeConstraint = _inner.ResolveConstraint(inlineConstraint);
            // 如果能解析到，返回 constraint
            if (routeConstraint != null)
            {
                return routeConstraint;
            }
            
            // 否则，即 inner constraint resolver 不能解析，
            // 由 parameter policy factory 创建 constraint，
            var parameterPolicy = _parameterPolicyFactory.Create(null!, inlineConstraint);
            // 如果能创建，返回 constraint
            if (parameterPolicy != null)
            {
                // Logic inside Route will skip adding NullRouteConstraint
                return NullRouteConstraint.Instance;
            }
            
            // 都不能，返回 null
            return null;
        }
    }
}

```

###### 3.2.3.2 map route (request delegate)

```c#
public static class RequestDelegateRouteBuilderExtensions
{    
    public static IRouteBuilder MapRoute(
        this IRouteBuilder builder, 
        string template, 
        RequestDelegate handler)
    {
        var route = new Route(
            new RouteHandler(handler),
            template,
            defaults: null,
            constraints: null,
            dataTokens: null,
            inlineConstraintResolver: GetConstraintResolver(builder));
        
        builder.Routes.Add(route);
        
        return builder;
    }
    
    public static IRouteBuilder MapMiddlewareRoute(
        this IRouteBuilder builder, 
        string template, 
        Action<IApplicationBuilder> action)
    {
        var nested = builder.ApplicationBuilder
            				.New();
        action(nested);
        
        return builder.MapRoute(template, nested.Build());
    }                           
}

```

##### 3.2.4 扩展方法 - map verb

###### 3.2.4.1 map verb (request delegate)

```c#
public static class RequestDelegateRouteBuilderExtensions
{
    private static IInlineConstraintResolver GetConstraintResolver(IRouteBuilder builder)
    {
        return builder.ServiceProvider
            		  .GetRequiredService<IInlineConstraintResolver>();
    }
    
    /* map verb */        
    public static IRouteBuilder MapVerb(
        this IRouteBuilder builder,
        string verb,
        string template,
        RequestDelegate handler)
    {
        var route = new Route(
            new RouteHandler(handler),
            template,
            defaults: null,
            constraints: 
            	new RouteValueDictionary(
                    new 
                    { 
                        httpMethod = new HttpMethodRouteConstraint(verb) 
                    })!,
            dataTokens: null,
            inlineConstraintResolver: GetConstraintResolver(builder));
        
        builder.Routes
               .Add(route);
         
        return builder;
    }
                        
    /* map get */
    public static IRouteBuilder MapGet(
        this IRouteBuilder builder, 
        string template, 
        RequestDelegate handler)
    {
        return builder.MapVerb("GET", template, handler);
    }
                            
    /* map post */
    public static IRouteBuilder MapPost(
        this IRouteBuilder builder, 
        string template, 
        RequestDelegate handler)
    {
        return builder.MapVerb("POST", template, handler);
    }
                        
    /* map put */
    public static IRouteBuilder MapPut(
        this IRouteBuilder builder, 
        string template, 
        RequestDelegate handler)
    {
        return builder.MapVerb("PUT", template, handler);
    }
                   
    /* map delete */
    public static IRouteBuilder MapDelete(
        this IRouteBuilder builder, 
        string template, 
        RequestDelegate handler)
    {
        return builder.MapVerb("DELETE", template, handler);
    }                   
}

```

###### 3.2.4.2 map verb (func)

```c#
public static class RequestDelegateRouteBuilderExtensions
{
    private static IInlineConstraintResolver GetConstraintResolver(IRouteBuilder builder)
    {
        return builder.ServiceProvider
            		  .GetRequiredService<IInlineConstraintResolver>();
    }
    
    /* map verb */
    public static IRouteBuilder MapVerb(
        this IRouteBuilder builder,
        string verb,
        string template,
        Func<HttpRequest, HttpResponse, RouteData, Task> handler)
    {
        RequestDelegate requestDelegate = 
            (httpContext) =>
        		{
            		return handler(
                    		   httpContext.Request, 
                    		   httpContext.Response, 
                    	   	   httpContext.GetRouteData());
        		};
        
        return builder.MapVerb(verb, template, requestDelegate);
    }   
                
    /* map get */   
    public static IRouteBuilder MapGet(
        this IRouteBuilder builder,
        string template,
        Func<HttpRequest, HttpResponse, RouteData, Task> handler)
    {
        return builder.MapVerb("GET", template, handler);
    }
    
    /* map post */    
    public static IRouteBuilder MapPost(
        this IRouteBuilder builder,
        string template,
        Func<HttpRequest, HttpResponse, RouteData, Task> handler)
    {
        return builder.MapVerb("POST", template, handler);
    }
    
    /* map put */    
    public static IRouteBuilder MapPut(
        this IRouteBuilder builder,
        string template,
        Func<HttpRequest, HttpResponse, RouteData, Task> handler)
    {
        return builder.MapVerb("PUT", template, handler);
    }
    
    /* map delete */    
    public static IRouteBuilder MapDelete(
        this IRouteBuilder builder,
        string template,
        Func<HttpRequest, HttpResponse, RouteData, Task> handler)
    {
        return builder.MapVerb("DELETE", template, handler);
    }                                              
}

```

###### 3.2.4.3 map verb (middleware)

```c#
public static class RequestDelegateRouteBuilderExtensions
{
    public static IRouteBuilder MapMiddlewareVerb(
        this IRouteBuilder builder,
        string verb,
        string template,
        Action<IApplicationBuilder> action)
    {
        var nested = builder.ApplicationBuilder
            				.New();
        action(nested);
        return builder.MapVerb(verb, template, nested.Build());
    }                                           
       
    // get
    public static IRouteBuilder MapMiddlewareGet(
        this IRouteBuilder builder, 
        string template, 
        Action<IApplicationBuilder> action)
    {
        return builder.MapMiddlewareVerb("GET", template, action);
    }
        
    // post
    public static IRouteBuilder MapMiddlewarePost(
        this IRouteBuilder builder, 
        string template, 
        Action<IApplicationBuilder> action)
    {
        return builder.MapMiddlewareVerb("POST", template, action);
    }
       
    // put
    public static IRouteBuilder MapMiddlewarePut(
        this IRouteBuilder builder, 
        string template, 
        Action<IApplicationBuilder> action)
    {
        return builder.MapMiddlewareVerb("PUT", template, action);
    }

    // delete
    public static IRouteBuilder MapMiddlewareDelete(
        this IRouteBuilder builder, 
        string template, 
        Action<IApplicationBuilder> action)
    {
        return builder.MapMiddlewareVerb("DELETE", template, action);
    }                                          
}

```

#### 3.3 add routing (router service)

```c#
public static class RoutingServiceCollectionExtensions
{    
    public static IServiceCollection AddRouting(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        // 注入 inline constraint resolver
        services.TryAddTransient<IInlineConstraintResolver, DefaultInlineConstraintResolver>();
        
        // 注入 uri building context (from object pool)
        services.TryAddTransient<ObjectPoolProvider, DefaultObjectPoolProvider>();
        services.TryAddSingleton<ObjectPool<UriBuildingContext>>(s =>
        	{
                var provider = s.GetRequiredService<ObjectPoolProvider>();
                return provider.Create<UriBuildingContext>(
                    new UriBuilderContextPooledObjectPolicy());
            });

        // The TreeRouteBuilder is a builder for creating routes, 
        // it should stay transient because it's stateful.        
        // 注入 tree router builder
        services.TryAdd(ServiceDescriptor.Transient<TreeRouteBuilder>(s =>
        	{
                var loggerFactory = s.GetRequiredService<ILoggerFactory>();
                var objectPool = s.GetRequiredService<ObjectPool<UriBuildingContext>>();
                var constraintResolver = s.GetRequiredService<IInlineConstraintResolver>();
                return new TreeRouteBuilder(loggerFactory, objectPool, constraintResolver);
            }));

        // 注入 template binder factory
        services.TryAddSingleton<TemplateBinderFactory, DefaultTemplateBinderFactory>();
        
        // 注入 routing marker service
        services.TryAddSingleton(typeof(RoutingMarkerService));        
        
        // 注入 route options
        var dataSources = new ObservableCollection<EndpointDataSource>();
        services.TryAddEnumerable(
            ServiceDescriptor.Transient<IConfigureOptions<RouteOptions>, ConfigureRouteOptions>(
                    serviceProvider => new ConfigureRouteOptions(dataSources)));    
        
        return services;
                                        
        
        
        /*
        // Allow global access to the list of endpoints.
        services.TryAddSingleton<EndpointDataSource>(s =>
        	{
                // Call internal ctor and pass global collection
                return new CompositeEndpointDataSource(dataSources);
            });
        
        //
        // Default matcher implementation
        //
        services.TryAddSingleton<ParameterPolicyFactory, DefaultParameterPolicyFactory>();
        services.TryAddSingleton<MatcherFactory, DfaMatcherFactory>();
        services.TryAddTransient<DfaMatcherBuilder>();
        services.TryAddSingleton<DfaGraphWriter>();
        services.TryAddTransient<DataSourceDependentMatcher.Lifetime>();
        services.TryAddSingleton<EndpointMetadataComparer>(services =>
        	{
                // This has no public constructor. 
                return new EndpointMetadataComparer(services);
            });
        //
        // Link generation related services
        //
        services.TryAddSingleton<LinkGenerator, DefaultLinkGenerator>();
        services.TryAddSingleton<IEndpointAddressScheme<string>, EndpointNameAddressScheme>();
        services.TryAddSingleton<IEndpointAddressScheme<RouteValuesAddress>, RouteValuesAddressScheme>();
        services.TryAddSingleton<LinkParser, DefaultLinkParser>();
        
        //
        // Endpoint Selection
        //
        services.TryAddSingleton<EndpointSelector, DefaultEndpointSelector>();
        services.TryAddEnumerable(ServiceDescriptor.Singleton<MatcherPolicy, HttpMethodMatcherPolicy>());
        services.TryAddEnumerable(ServiceDescriptor.Singleton<MatcherPolicy, HostMatcherPolicy>());
        
        // 注入 route pattern transformer
        services.TryAddSingleton<RoutePatternTransformer, DefaultRoutePatternTransformer>();
    }
    */
        
    // add routing by action    
    public static IServiceCollection AddRouting(
        this IServiceCollection services,
        Action<RouteOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }        
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        services.Configure(configureOptions);
        services.AddRouting();
        
        return services;
    }    
}

```

##### 3.3.1 route options

```c#
public class RouteOptions
{
    /* for constraint ...*/    
    private IDictionary<string, Type> _constraintTypeMap = GetDefaultConstraintMap();
    
    private static IDictionary<string, Type> GetDefaultConstraintMap()
    {
        var defaults = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
        
        // Type-specific constraints
        AddConstraint<IntRouteConstraint>(defaults, "int");
        AddConstraint<BoolRouteConstraint>(defaults, "bool");
        AddConstraint<DateTimeRouteConstraint>(defaults, "datetime");
        AddConstraint<DecimalRouteConstraint>(defaults, "decimal");
        AddConstraint<DoubleRouteConstraint>(defaults, "double");
        AddConstraint<FloatRouteConstraint>(defaults, "float");
        AddConstraint<GuidRouteConstraint>(defaults, "guid");
        AddConstraint<LongRouteConstraint>(defaults, "long");
        
        // Length constraints
        AddConstraint<MinLengthRouteConstraint>(defaults, "minlength");
        AddConstraint<MaxLengthRouteConstraint>(defaults, "maxlength");
        AddConstraint<LengthRouteConstraint>(defaults, "length");
        
        // Min/Max value constraints
        AddConstraint<MinRouteConstraint>(defaults, "min");
        AddConstraint<MaxRouteConstraint>(defaults, "max");
        AddConstraint<RangeRouteConstraint>(defaults, "range");
        
        // Regex-based constraints
        AddConstraint<AlphaRouteConstraint>(defaults, "alpha");
        AddConstraint<RegexInlineRouteConstraint>(defaults, "regex");
        
        AddConstraint<RequiredRouteConstraint>(defaults, "required");
        
        // Files
        AddConstraint<FileNameRouteConstraint>(defaults, "file");
        AddConstraint<NonFileNameRouteConstraint>(defaults, "nonfile");
        
        return defaults;
    }
        
    private static void AddConstraint<
        [DynamicallyAccessedMembers(
            DynamicallyAccessedMemberTypes.PublicConstructors)]TConstraint>(
        Dictionary<string, Type> constraintMap, 
        string text) 
        	where TConstraint : IRouteConstraint
    {
        constraintMap[text] = typeof(TConstraint);
    }
    
    public IDictionary<string, Type> ConstraintMap
    {
        get
        {
            return _constraintTypeMap;
        }
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(ConstraintMap));
            }
            
            _constraintTypeMap = value;
        }
    }
    
    /* for template binder ... */
    public bool LowercaseUrls { get; set; }        
    public bool LowercaseQueryStrings { get; set; }        
    public bool AppendTrailingSlash { get; set; }
    
    
    /*
    private ICollection<EndpointDataSource> _endpointDataSources = default!;       
    internal ICollection<EndpointDataSource> EndpointDataSources
    {
        get
        {
            Debug.Assert(_endpointDataSources != null, "Endpoint data sources should have been set in DI.");
            return _endpointDataSources;
        }
        set => _endpointDataSources = value;
    }
                        
    public bool SuppressCheckForUnhandledSecurityMetadata { get; set; }                
    */
}

```

##### 3.3.2 configured route options

```c#
internal class ConfigureRouteOptions : IConfigureOptions<RouteOptions>
{
    private readonly ICollection<EndpointDataSource> _dataSources;
    
    public ConfigureRouteOptions(ICollection<EndpointDataSource> dataSources)
    {
        if (dataSources == null)
        {
            throw new ArgumentNullException(nameof(dataSources));
        }
        
        _dataSources = dataSources;
    }
    
    public void Configure(RouteOptions options)
    {
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        options.EndpointDataSources = _dataSources;
    }
}

```

##### 3.3.3 routing marker service

```c#
internal class RoutingMarkerService
{
}

```

#### 3.4 use router

##### 3.4.1 use router

```c#
public static class RoutingBuilderExtensions
{
    // by router
    public static IApplicationBuilder UseRouter(
        this IApplicationBuilder builder, 
        IRouter router)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }    
        if (router == null)
        {
            throw new ArgumentNullException(nameof(router));
        }
        
        // 如果没有注册 routing marker service，抛出异常
        if (builder.ApplicationServices.GetService(typeof(RoutingMarkerService)) == null)
        {
            throw new InvalidOperationException(
                Resources.FormatUnableToFindServices(
                    nameof(IServiceCollection),
                    nameof(RoutingServiceCollectionExtensions.AddRouting),
                    "ConfigureServices(...)"));
        }
        
        // 注入 router middleware
        return builder.UseMiddleware<RouterMiddleware>(router);
    }
        
    // by route builder action
    public static IApplicationBuilder UseRouter(
        this IApplicationBuilder builder, 
        Action<IRouteBuilder> action)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }
        
        // 如果没有注册 routing marker service，抛出异常
        if (builder.ApplicationServices
            	   .GetService(typeof(RoutingMarkerService)) == null)
        {
            throw new InvalidOperationException(
                Resources.FormatUnableToFindServices(
                    nameof(IServiceCollection),
                    nameof(RoutingServiceCollectionExtensions.AddRouting),
                    "ConfigureServices(...)"));
        }

        // 创建 route builder 并配置
        var routeBuilder = new RouteBuilder(builder);
        action(routeBuilder);
        
        // 由 route builder 创建 irouter（router collection），
        // 调用 use router（irouter）方法
        return builder.UseRouter(routeBuilder.Build());
    }
}

```

##### 3.4.2 router middleware

```c#
public class RouterMiddleware
{
    private readonly ILogger _logger;
    private readonly RequestDelegate _next;
    private readonly IRouter _router;
            
    public RouterMiddleware(
        RequestDelegate next,
        ILoggerFactory loggerFactory,
        IRouter router)
    {
        _next = next;
        _router = router;        
        _logger = loggerFactory.CreateLogger<RouterMiddleware>();
    }
        
    public async Task Invoke(HttpContext httpContext)
    {
        // 创建 route context，封装当前 http context
        var context = new RouteContext(httpContext);
        // 向 route context 注入 _router
        context.RouteData
               .Routers
               .Add(_router);
        
        // 执行 _router 的 route async 方法
        await _router.RouteAsync(context);
        
        // 如果没有 handler（ route 不匹配），转到 next
        if (context.Handler == null)
        {
            _logger.RequestNotMatched();
            await _next.Invoke(httpContext);
        }
        // 否则，即 route 匹配，
        else
        {
            // 封装 route data -> routing feature，           
            var routingFeature = new RoutingFeature()
            {
                RouteData = context.RouteData
            };
                        
            // Set the RouteValues on the current request, this is to keep the 
            // IRouteValuesFeature inline with the IRoutingFeature
            
            // 将 routing feature（route data）注入 http context，
            httpContext.Request.RouteValues = context.RouteData.Values;
            httpContext.Features.Set<IRoutingFeature>(routingFeature);
            
            // 执行 handler
            await context.Handler(context.HttpContext);
        }
    }
}

```

###### 3.4.2.1 routing feature

```c#
public interface IRoutingFeature
{        
    RouteData? RouteData { get; set; }
}

public class RoutingFeature : IRoutingFeature
{
    /// <inheritdoc />
    public RouteData? RouteData { get; set; }
}

```

### 4. attribute routing

#### 4.1 url matching tree

```c#
public class UrlMatchingTree
{
    public int Order { get; }        
    public UrlMatchingNode Root { get; } = new UrlMatchingNode(length: 0);
    
    public UrlMatchingTree(int order)
    {
        Order = order;
    }            
    
    internal void AddEntry(InboundRouteEntry entry)
    {        
        // example one: 'Customer/Index/{id}'
        //   Root ->
        //       Literals: Customer ->
        //       	 Literals: Index ->
        //           	 Parameters: {id}
        //   Matches: 'Customer/Index/{id}'
        //                                
        // example two: '{Controller}/{Action}/{*parameters}'               
        //   Parameters: {Controller} ->
        //       Parameters: {Action} ->
        // 	 Matches: '{Controller}/{Action}/{*parameters}'
        //
        //   CatchAlls: {*parameters}
        //   Matches: '{Controller}/{Action}/{*parameters}'
                    
        // 定位 tree root
        var current = Root;
        // 由 entry 的 route template、default 创建 template matcher
        var matcher = new TemplateMatcher(entry.RouteTemplate, entry.Defaults);
        
        // 遍历 entry 中 route template 的 segment，定位到适合的子节点（深度）
        for (var i = 0; i < entry.RouteTemplate.Segments.Count; i++)
        {
            var segment = entry.RouteTemplate.Segments[i];
            
            // 如果不是 simple segment，
            if (!segment.IsSimple)
            {
                /* 转到 current node 的 constrained parameters（子节点），
                   如果没有则创建，-> 下一个 segment */
                
                if (current.ConstrainedParameters == null)
                {
                    current.ConstrainedParameters = new UrlMatchingNode(length: i + 1);
                }
                
                current = current.ConstrainedParameters;
                continue;
            }
            
            // （否则）segment 是 simple segment，只有一个 part
            Debug.Assert(segment.Parts.Count == 1);
            var part = segment.Parts[0];
            
            // 如果是 literal part，
            if (part.IsLiteral)
            {
                /* 转到 current node 的 literals（子节点），
                   如果没有则创建，-> 下一个 segment */
                
                if (!current.Literals.TryGetValue(part.Text, out var next))
                {
                    next = new UrlMatchingNode(length: i + 1);
                    current.Literals.Add(part.Text, next);
                }
                
                current = next;
                continue;
            }
            
            // We accept templates that have intermediate optional values, but we ignore
            // those values for route matching. For that reason, we need to add the entry
            // to the list of matches, only if the remaining segments are optional. 
            // For example:
            //   /{controller}/{action=Index}/{id} will be equivalent to 
            //	 {controller}/{action}/{id}
            // for the purposes of route matching.
            
            // 如果是 parameter part，
            // 并且后续 segment 是可选的（即当前 part 是 optional、catch all 或 default，
            // -> 在 current node 注入 outbound match(entry)
            if (part.IsParameter &&
                RemainingSegmentsAreOptional(entry.RouteTemplate.Segments, i))
            {
                current.Matches.Add(
                    new InboundMatch() 
                    { 
                        Entry = entry, 
                        TemplateMatcher = matcher 
                    });
            }
            
            // 如果是 parameter part，
            // 并且 part 包含 inline constraint，
            // 并且 part 不是 catch all
            if (part.IsParameter && 
                part.InlineConstraints.Any() && 
                !part.IsCatchAll)
            {
                /* 转到 current node 的 constrained parameters（子节点），
                   如果没有则创建，-> 下一个 segment */
                if (current.ConstrainedParameters == null)
                {
                    current.ConstrainedParameters = new UrlMatchingNode(length: i + 1);
                }
                
                current = current.ConstrainedParameters;
                continue;
            }
            
            // 如果是 parameter part，并且 part 不是 catch all            
            if (part.IsParameter && 
                !part.IsCatchAll)
            {
                /* 转到 current node 的 parameters（子节点），
                   如果没有则创建，-> 下一个 segment */
                if (current.Parameters == null)
                {
                    current.Parameters = new UrlMatchingNode(length: i + 1);
                }
                
                current = current.Parameters;
                continue;
            }
            
            // 如果是 parameter part，
            // 并且包含 inline constraint，
            // 并且 part 是 catch all
            if (part.IsParameter && 
                part.InlineConstraints.Any() && 
                part.IsCatchAll)
            {
                /* 转到 current node 的 constrained catch all（子节点），
                   如果没有则创建，-> 下一个 segment */
                if (current.ConstrainedCatchAlls == null)
                {
                    current.ConstrainedCatchAlls = new UrlMatchingNode(length: i + 1) 
                    	{ 
                        	IsCatchAll = true 
	                    };
                }
                
                current = current.ConstrainedCatchAlls;
                continue;
            }
            
            // 如果是 parameter part，并且 part 是 catch all
            if (part.IsParameter && part.IsCatchAll)
            {
                if (current.CatchAlls == null)
                {    
                    current.CatchAlls = new UrlMatchingNode(length: i + 1) 
						                    { 
						                        IsCatchAll = true 
						                    };
                }
                
                current = current.CatchAlls;
                continue;
            }
            
            Debug.Fail("We shouldn't get here.");
        }
        
        // add inound match (entry)
        current.Matches.Add(
            new InboundMatch() 
            {
                Entry = entry, 
                TemplateMatcher = matcher 
            });
        
        // sort inbound match (entry)
        current.Matches.Sort((x, y) =>
            {
                var result = x.Entry.Precedence.CompareTo(y.Entry.Precedence);
                return result == 0 
                    ? string.Compare(
                    			x.Entry.RouteTemplate.TemplateText,
                    			y.Entry.RouteTemplate.TemplateText, 
                    			StringComparison.Ordinal) 
                    : result;
            });
    }
    
    // 判断后续 segment 是 optional
    private static bool RemainingSegmentsAreOptional(
        IList<TemplateSegment> segments, 
        int currentParameterIndex)
    {
        for (var i = currentParameterIndex; i < segments.Count; i++)
        {
            // 如果不是 simple segment（complex segment），-> false
            if (!segments[i].IsSimple)
            {
                // /{complex}-{segment}
                return false;
            }
            
            // 由上，是 simple segment，
            // 如果不是 parameter part，-> false
            var part = segments[i].Parts[0];
            if (!part.IsParameter)
            {
                // /literal
                return false;
            }
            
            // 如果 part 是 optional、catch all 或者 default values，
            var isOptionlCatchAllOrHasDefaultValue = part.IsOptional ||
                part.IsCatchAll ||
                part.DefaultValue != null;
            
            if (!isOptionlCatchAllOrHasDefaultValue)
            {
                // /{parameter}
                return false;
            }
        }
        
        return true;
    }
}

```

##### 4.1.1 inbound match

```c#
// inbound match
[DebuggerDisplay("{DebuggerToString(),nq}")]
public class InboundMatch
{    
    public InboundRouteEntry Entry { get; set; }        
    public TemplateMatcher TemplateMatcher { get; set; }
    
    private string DebuggerToString()
    {
        return TemplateMatcher?.Template?.TemplateText;
    }
}

// inbound route entry
public class InboundRouteEntry
{    
    public string RouteName { get; set; }      
    public int Order { get; set; }      
    public IRouter Handler { get; set; }                 
    public decimal Precedence { get; set; }        
           
    public RouteTemplate RouteTemplate { get; set; }
    public IDictionary<string, IRouteConstraint> Constraints { get; set; }   
    public RouteValueDictionary Defaults { get; set; }     
}

```

##### 4.1.2 url matching node

```c#
[DebuggerDisplay("{DebuggerToString(),nq}")]
public class UrlMatchingNode
{
    public int Depth { get; }
    public List<InboundMatch> Matches { get; }        
    public Dictionary<string, UrlMatchingNode> Literals { get; }    
    public bool IsCatchAll { get; set; }
    
    /* 子节点 */
    public UrlMatchingNode ConstrainedParameters { get; set; }        
    public UrlMatchingNode Parameters { get; set; }        
    public UrlMatchingNode ConstrainedCatchAlls { get; set; }        
    public UrlMatchingNode CatchAlls { get; set; }
    
    public UrlMatchingNode(int length)
    {
        Depth = length;
        
        Matches = new List<InboundMatch>();
        Literals = new Dictionary<string, UrlMatchingNode>(
            StringComparer.OrdinalIgnoreCase);
    }
    
    private string DebuggerToString()
    {
        return 
            $"Length: {Depth}, 
             "Matches: {string.Join(
            				" | ", 
        					"Matches?.Select(m => 
                                $"({m.TemplateMatcher
                                    ".Template
                                    ".TemplateText})"))}";
	}
}

```

##### 4.1.3 tree enumerator

```c#
internal struct TreeEnumerator : IEnumerator<UrlMatchingNode>
{
    private readonly Stack<UrlMatchingNode> _stack;
    private readonly PathTokenizer _tokenizer;
    
    public UrlMatchingNode Current { get; private set; }
    object IEnumerator.Current => Current;
    
    public TreeEnumerator(
        UrlMatchingNode root, 
        PathTokenizer tokenizer)
    {
        _stack = new Stack<UrlMatchingNode>();
        _tokenizer = tokenizer;
        Current = null;
        
        _stack.Push(root);
    }
                            
    public bool MoveNext()
    {
        if (_stack == null)
        {
            return false;
        }
        
        while (_stack.Count > 0)
        {
            var next = _stack.Pop();
            
            // In case of wild card segment, the request path segment length can be greater
            // Example:
            // Template:    a/{*path}
            // Request Url: a/b/c/d
            if (next.IsCatchAll && next.Matches.Count > 0)
            {
                Current = next;
                return true;
            }
            // Next template has the same length as the url we are trying to match
            // The only possible matching segments are either our current matches or
            // any catch-all segment after this segment in which the catch all is empty.
            else if (next.Depth == _tokenizer.Count)
            {
                if (next.Matches.Count > 0)
                {
                    Current = next;
                    return true;
                }
                else
                {
                    // We can stop looking as any other child node from this node will be
                    // either a literal, a constrained parameter or a parameter.
                    // (Catch alls and constrained catch alls will show up as candidate 
                    // matches).
                    continue;
                }
            }
            
            if (next.CatchAlls != null)
            {
                _stack.Push(next.CatchAlls);
            }
            
            if (next.ConstrainedCatchAlls != null)
            {
                _stack.Push(next.ConstrainedCatchAlls);
            }
            
            if (next.Parameters != null)
            {
                _stack.Push(next.Parameters);
            }
            
            if (next.ConstrainedParameters != null)
            {
                _stack.Push(next.ConstrainedParameters);
            }
            
            if (next.Literals.Count > 0)
            {
                Debug.Assert(next.Depth < _tokenizer.Count);
                if (next.Literals.TryGetValue(_tokenizer[next.Depth].Value, out var node))
                {
                    _stack.Push(node);
                }
            }
        }
        
        return false;
    }
    
    public void Reset()
    {
        _stack.Clear();
        Current = null;
    }
    
    public void Dispose()
    {
    }
}

```

#### 4.2 decision tree

##### 4.2.1 decision tree node

```c#
// tree node
internal class DecisionTreeNode<TItem>
{
    // matched item 集合（result）
    public IList<TItem> Matches { get; set; }    
    // criterion 集合
    public IList<DecisionCriterion<TItem>> Criteria { get; set; }
}

// tree decision criterion
internal class DecisionCriterion<TItem>
{
    public string Key { get; set; }    
    // 其他 decision node（branch）集合（类似导航属性）
    public Dictionary<object, DecisionTreeNode<TItem>> Branches { get; set; }
}

```

##### 4.2.2 decision tree builder

```c#
internal static class DecisionTreeBuilder<TItem>
{
    public static DecisionTreeNode<TItem> GenerateTree(
        IReadOnlyList<TItem> items, 
        IClassifier<TItem> classifier)
    {
        // 将传入的 TItems(objects) 集合转换为 item descirptor 集合
        var itemCount = items.Count;
        var itemDescriptors = new List<ItemDescriptor<TItem>>(itemCount);
        for (var i = 0; i < itemCount; i++)
        {
            var item = items[i];
            itemDescriptors.Add(
                new ItemDescriptor<TItem>()
                {
                    Criteria = classifier.GetCriteria(item),
                    Index = i,
                    Item = item,
                });
        }
        
        // 创建 比较器
        var comparer = new DecisionCriterionValueEqualityComparer(classifier.ValueComparer);
                
        return GenerateNode(
            new TreeBuilderContext(),
            comparer,
            itemDescriptors);
    }
    
    private static DecisionTreeNode<TItem> GenerateNode(
        TreeBuilderContext context,
        DecisionCriterionValueEqualityComparer comparer,
        List<ItemDescriptor<TItem>> items)
    {
        // 创建 criterion 字典（默认值 empty）
        var criteria = new Dictionary<string, Criterion>(StringComparer.OrdinalIgnoreCase);    
        // 创建 item 集合，预结果
        var matches = new List<TItem>();
        
        // For each item in the working set, we want to map it to it's possible 
        // criteria-branch pairings, then reduce that tree to the minimal set.
        
        // 遍历 item descriptor 并注入
        foreach (var item in items)
        {
            var unsatisfiedCriteria = 0;
            
            // 遍历 item 的 criteria
            foreach (var kvp in item.Criteria)
            {
                // context.CurrentCriteria is the logical 'stack' of criteria that we've 
                // already processed on this branch of the tree.
                
                // 如果 current(node) 的 criteria 包含 (item) decision criterion (key)，
                // -> 下一个 (item) criterion
                if (context.CurrentCriteria.Contains(kvp.Key))
                {
                    continue;
                }
                
                /* 当前 node 的 criteria 不包含 (item) decision criterion(key)。。。 */
                
                // 标记
                unsatisfiedCriteria++;
                
                // 将 (item) decision criterioin 封装为 criterion，
                // 注入 criteria 集合
                if (!criteria.TryGetValue(kvp.Key, out var criterion))
                {
                    criterion = new Criterion(comparer);
                    criteria.Add(kvp.Key, criterion);
                }
                
                if (!criterion.TryGetValue(kvp.Value, out var branch))
                {
                    branch = new List<ItemDescriptor<TItem>>();
                    criterion.Add(kvp.Value, branch);
                }
                
                branch.Add(item);
            }
            
            // If all of the criteria on item are satisfied by the 'stack' then this 
            // item is a match.
            if (unsatisfiedCriteria == 0)
            {
                matches.Add(item.Item);
            }
        }
        
        // Iterate criteria in order of branchiness to determine which one to explore next. 
        // If a criterion has no 'new' matches under it then we can just eliminate that 
        // part of the tree.
        var reducedCriteria = new List<DecisionCriterion<TItem>>();
        foreach (var criterion in criteria.OrderByDescending(c => c.Value.Count))
        {
            var reducedBranches = 
                new Dictionary<object, DecisionTreeNode<TItem>>(comparer.InnerComparer);
            
            foreach (var branch in criterion.Value)
            {
                bool hasReducedItems = false;
                
                foreach (var item in branch.Value)
                {
                    if (context.MatchedItems.Add(item))
                    {
                        hasReducedItems = true;
                    }
                }
                
                if (hasReducedItems)
                {
                    var childContext = new TreeBuilderContext(context);
                    childContext.CurrentCriteria.Add(criterion.Key);
                    
                    var newBranch = GenerateNode(childContext, comparer, branch.Value);
                    reducedBranches.Add(branch.Key.Value, newBranch);
                }
            }
            
            if (reducedBranches.Count > 0)
            {
                var newCriterion = new DecisionCriterion<TItem>()
                {
                    Key = criterion.Key,
                    Branches = reducedBranches,
                };
                
                reducedCriteria.Add(newCriterion);
            }
        }
        
        return new DecisionTreeNode<TItem>()
        {
            Criteria = reducedCriteria,
            Matches = matches,
        };
    }        
}

```

###### 4.2.2.1 item descriptor

```c#
internal class ItemDescriptor<TItem>
{
    public int Index { get; set; }    
    public TItem Item { get; set; }
    // criterion 字典
    public IDictionary<string, DecisionCriterionValue> Criteria { get; set; }       
}

internal readonly struct DecisionCriterionValue
{
    private readonly object _value;
    public object Value
    {
        get { return _value; }
    }
    
    public DecisionCriterionValue(object value)
    {
        _value = value;
    }        
}

```

###### 4.2.2.2 classifier 接口

```c#
internal interface IClassifier<TItem>
{
    IDictionary<string, DecisionCriterionValue> GetCriteria(TItem item);    
    IEqualityComparer<object> ValueComparer { get; }
}

```

###### 4.2.2.3 decision criterion value

```c#
internal readonly struct DecisionCriterionValue
{
    private readonly object _value;
    public object Value
    {
        get { return _value; }
    }
    
    public DecisionCriterionValue(object value)
    {
        _value = value;
    }        
}

```

###### 4.2.2.4 decision criterion value equality comparer

```c#
internal class DecisionCriterionValueEqualityComparer : 
	IEqualityComparer<DecisionCriterionValue>
{
    public IEqualityComparer<object> InnerComparer { get; private set; }
    
    public DecisionCriterionValueEqualityComparer(
        IEqualityComparer<object> innerComparer)
    {
        InnerComparer = innerComparer;
    }
            
    public bool Equals(
        DecisionCriterionValue x, 
        DecisionCriterionValue y)
    {
        return InnerComparer.Equals(x.Value, y.Value);
    }
    
    public int GetHashCode(DecisionCriterionValue obj)
    {
        return InnerComparer.GetHashCode(obj.Value);
    }
}

```

###### 4.2.2.4 criterion

```c#
internal static class DecisionTreeBuilder<TItem>
{
    private class Criterion : 
    	Dictionary<DecisionCriterionValue, List<ItemDescriptor<TItem>>>
    {
        public Criterion(DecisionCriterionValueEqualityComparer comparer)
            : base(comparer)
        {
        }
    }
}

```

###### 4.2.2.5 tree builder context

```c#
internal static class DecisionTreeBuilder<TItem>
{
    private class TreeBuilderContext
    {
        public HashSet<string> CurrentCriteria { get; private set; }        
        public HashSet<ItemDescriptor<TItem>> MatchedItems { get; private set; }
        
        public TreeBuilderContext()
        {
            CurrentCriteria = 
                new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            
            MatchedItems = new HashSet<ItemDescriptor<TItem>>();
        }
        
        public TreeBuilderContext(TreeBuilderContext other)
        {
            CurrentCriteria = 
                new HashSet<string>(
                	other.CurrentCriteria, 
                	StringComparer.OrdinalIgnoreCase);
            
            MatchedItems = new HashSet<ItemDescriptor<TItem>>();
        }                
    }    
}

```

#### 4.3 link generation decision tree

```c#
[DebuggerDisplay("{DebuggerDisplayString,nq}")]
internal class LinkGenerationDecisionTree
{
    // Fallback value for cases where the ambient values weren't provided.    
    // This is safe because we don't mutate the route values in here.
    private static readonly RouteValueDictionary 
        EmptyAmbientValues = new RouteValueDictionary();
    
    // decision tree 根节点，for attribute routing
    private readonly DecisionTreeNode<OutboundMatch> _root;
    // outbound match 集合，for conventional routing
    private readonly List<OutboundMatch> _conventionalEntries;
    
    public LinkGenerationDecisionTree(IReadOnlyList<OutboundMatch> entries)
    {
        // 创建 attribute entry 集合（默认值 empty）
        var attributedEntries = new List<OutboundMatch>();
        // 创建 conventional entry 集合（默认值 empty）
        _conventionalEntries = new List<OutboundMatch>();
        
        // Anything with a RoutePattern.RequiredValueAny as a RequiredValue is a 
        // conventional route. This is because RequiredValueAny acts as a wildcard, 
        // whereas an attribute route entry is denormalized to contain an exact 
        // set of required values.
        //
        // We will only see conventional routes show up here for endpoint routing.
        
        // 遍历传入的 outbound match，
        for (var i = 0; i < entries.Count; i++)
        {
            var isAttributeRoute = true;
            
            // 遍历 outbound match 的 entry 的 required value
            var entry = entries[i];                        
            foreach (var kvp in entry.Entry.RequiredLinkValues)
            {
                // 如果包含通配符（required value any），-> 不是 attribute route
                if (RoutePattern.IsRequiredValueAny(kvp.Value))
                {
                    isAttributeRoute = false;
                    break;
                }
            }
            
            // 如果是 attribute route，注入 attribute entry 集合
            if (isAttributeRoute)
            {
                attributedEntries.Add(entry);
            }
            // 否则，即是 conventional route，注入 conventional entry 集合
            else
            {
                _conventionalEntries.Add(entry);
            }
        }
        
        // 由 attribute entry 构建 decision tree
        _root = DecisionTreeBuilder<OutboundMatch>.GenerateTree(
            attributedEntries,
            new OutboundMatchClassifier());
    }
    
    private class OutboundMatchClassifier : IClassifier<OutboundMatch>
    {
        public IEqualityComparer<object> ValueComparer => 
            RouteValueEqualityComparer.Default;
        
        public IDictionary<string, DecisionCriterionValue> GetCriteria(OutboundMatch item)
        {
            var results = 
                new Dictionary<string, DecisionCriterionValue>(
                	StringComparer.OrdinalIgnoreCase);
            
            foreach (var kvp in item.Entry.RequiredLinkValues)
            {
                results.Add(
                    kvp.Key, 
                    new DecisionCriterionValue(kvp.Value ?? string.Empty));
            }
            
            return results;
        }
    }
    
    
    
    
    private class OutboundMatchResultComparer : IComparer<OutboundMatchResult>
    {
        public static readonly OutboundMatchResultComparer 
            Instance = new OutboundMatchResultComparer();
        
        public int Compare(OutboundMatchResult x, OutboundMatchResult y)
        {
            // For this comparison lower is better.
            if (x.Match.Entry.Order != y.Match.Entry.Order)
            {
                return x.Match.Entry.Order.CompareTo(y.Match.Entry.Order);
            }
            
            if (x.Match.Entry.Precedence != y.Match.Entry.Precedence)
            {
                // Reversed because higher is better
                return y.Match.Entry.Precedence.CompareTo(x.Match.Entry.Precedence);
            }
            
            if (x.IsFallbackMatch != y.IsFallbackMatch)
            {
                // A fallback match is worse than a non-fallback
                return x.IsFallbackMatch.CompareTo(y.IsFallbackMatch);
            }
            
            return string.Compare(
                x.Match.Entry.RouteTemplate.TemplateText,
                y.Match.Entry.RouteTemplate.TemplateText,
                StringComparison.Ordinal);
        }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    // Example output:
    //
    // => action: Buy => controller: Store => version: V1(Matches: Store/Buy/V1)
    // => action: Buy => controller: Store => version: V2(Matches: Store/Buy/V2)
    // => action: Buy => controller: Store => area: Admin(Matches: Admin/Store/Buy)        
    // => action: Buy => controller: Products(Matches: Products/Buy)
    // => action: Cart => controller: Store(Matches: Store/Cart)
    internal string DebuggerDisplayString
    {
        get
        {
            var sb = new StringBuilder();
            var branchStack = new Stack<string>();
            branchStack.Push(string.Empty);
            FlattenTree(branchStack, sb, _root);
            return sb.ToString();
        }
    }
    
    private void FlattenTree(
        Stack<string> branchStack, 
        StringBuilder sb, 
        DecisionTreeNode<OutboundMatch> node)
    {
        // leaf node
        if (node.Criteria.Count == 0)
        {
            var matchesSb = new StringBuilder();
            foreach (var branch in branchStack)
            {
                matchesSb.Insert(0, branch);
            }
            sb.Append(matchesSb.ToString());
            sb.Append(" (Matches: ");
            sb.AppendJoin(
                ", ", 
                node.Matches
                	.Select(m => m.Entry.RouteTemplate.TemplateText));
            sb.AppendLine(")");
        }
        
        foreach (var criterion in node.Criteria)
        {
            foreach (var branch in criterion.Branches)
            {
                branchStack.Push($" => {criterion.Key}: {branch.Key}");
                FlattenTree(branchStack, sb, branch.Value);
                branchStack.Pop();
            }
        }
    }
}

```

##### 4.3.1 get matches

```c#
internal class LinkGenerationDecisionTree
{
    public IList<OutboundMatchResult> GetMatches(
        RouteValueDictionary values, 
        RouteValueDictionary ambientValues)
    {
        // Perf: Avoid allocation for List if there aren't any Matches or Criteria
        if (_root.Matches.Count > 0 || 
            _root.Criteria.Count > 0 || 
            _conventionalEntries.Count > 0)
        {
            // 预结果
            var results = new List<OutboundMatchResult>();
            
            Walk(
                results, 
                values, 
                ambientValues ?? EmptyAmbientValues, 
                _root, 
                isFallbackPath: false);
            
            ProcessConventionalEntries(
                results, 
                values, 
                ambientValues ?? EmptyAmbientValues);
            
            results.Sort(OutboundMatchResultComparer.Instance);
            
            return results;
        }
        
        return null;
    }    
       
    // We need to recursively walk the decision tree based on the provided route data
    // (context.Values + context.AmbientValues) to find all entries that match. This process is
    // virtually identical to action selection.
    //
    // Each entry has a collection of 'required link values' that must be satisfied. These are
    // key-value pairs that make up the decision tree.
    //
    // A 'require link value' is considered satisfied IF:
    //  1. The value in context.Values matches the required value OR
    //  2. There is no value in context.Values and the value in context.AmbientValues 
    //     matches OR
    //  3. The required value is 'null' and there is no value in context.Values.
    //
    // Ex:
    //  entry requires { area = null, controller = Store, action = Buy }
    //  context.Values = { controller = Store, action = Buy }
    //  context.AmbientValues = { area = Help, controller = AboutStore, 
    //                           action = HowToBuyThings }
    //
    //  In this case the entry is a match. The 'controller' and 'action' are both supplied 
    //  by context.Values, and the 'area' is satisfied because there's NOT a value in 
    //  context.Values. It's OK to ignore ambient values in link generation.
    //
    //  If another entry existed like { area = Help, controller = Store, action = Buy }, 
    //  this would also match.
    //
    // The decision tree uses a tree data structure to execute these rules across all 
    // candidates at once.
    
    private void Walk(
        List<OutboundMatchResult> results,
        RouteValueDictionary values,
        RouteValueDictionary ambientValues,
        DecisionTreeNode<OutboundMatch> node,
        bool isFallbackPath)
    {
        // Any entries in node.Matches have had all their required values satisfied, 
        // so add them to the results.
        
        // 将当前 node 的 matches 封装为 outbound match result，注入 result
        var matches = node.Matches;       
        var matchesCount = matches.Count;
        for (var i = 0; i < matchesCount; i++)
        {
            results.Add(new OutboundMatchResult(matches[i], isFallbackPath));
        }
        
        // 遍历 decision tree node <outbound match> 的 criteria，        
        var criteria = node.Criteria;        
        var criteriaCount = criteria.Count;
        for (var i = 0; i < criteriaCount; i++)
        {
            var criterion = criteria[i];
            var key = criterion.Key;
            
            // 如果能够从传入的 values 按照 key 解析 value，
            // 认为匹配，
            // -> 从 criterion 的 branches 中按照 value 解析 branch，
            //    由 branch 递归（将 node 下的 matches 注入 result）
            if (values.TryGetValue(key, out var value))
            {
                if (criterion.Branches.TryGetValue(value ?? string.Empty, out var branch))
                {
                    Walk(results, values, ambientValues, branch, isFallbackPath);
                }
            }
            // 否则，即不能从传入的 values 中按照 key 解析 value，
            // 即 values 没有提供 node 所定义的 (parameter)
            else
            {
                // If a value wasn't explicitly supplied, match BOTH the ambient value 
                // and the empty value if an ambient value was supplied. 
                // The path explored with the empty value is considered the fallback path.
                DecisionTreeNode<OutboundMatch> branch;
                
                // 如果能从传入的 ambient values 解析 value，且不为 string.empty，
                // 认为匹配，
                // -> 从 criterion 的 branches 中按照 ambient values 解析 branch，
                //    由 branch 递归（将 node 下的 matches 注入 result）
                if (ambientValues.TryGetValue(key, out value) &&
                    !criterion.Branches.Comparer.Equals(value, string.Empty))
                {
                    if (criterion.Branches.TryGetValue(value, out branch))
                    {
                        Walk(results, values, ambientValues, branch, isFallbackPath);
                    }
                }
                
                // 从 criterion 的 branches 中按照 string.empty 解析 branch，
                // 由 branch 递归（将 node 下的 matches 注入 result
                if (criterion.Branches.TryGetValue(string.Empty, out branch))
                {
                    Walk(results, values, ambientValues, branch, isFallbackPath: true);
                }
            }
        }
    }
    
    private void ProcessConventionalEntries(
        List<OutboundMatchResult> results,
        RouteValueDictionary values,
        RouteValueDictionary ambientvalues)
    {
        for (var i = 0; i < _conventionalEntries.Count; i++)
        {
            results.Add(
                new OutboundMatchResult(
                    _conventionalEntries[i], 
                    isFallbackMatch: false));
        }
    }
}
    
```

##### 4.3.2 outbound match

```c#
// outbound match
public class OutboundMatch
{     
    public OutboundRouteEntry Entry { get; set; }         
    public TemplateBinder TemplateBinder { get; set; }    
}

// outbound route entry
public class OutboundRouteEntry
{
    public string RouteName { get; set; }
    public int Order { get; set; }
    public IRouter Handler { get; set; }
    public decimal Precedence { get; set; }
    
    public object Data { get; set; }
    
    public RouteTemplate RouteTemplate { get; set; }
    public IDictionary<string, IRouteConstraint> Constraints { get; set; }        
    public RouteValueDictionary Defaults { get; set; }
    
    public RouteValueDictionary RequiredLinkValues { get; set; }                               
}

```

##### 4.3.3 outbound match result

```c#
internal readonly struct OutboundMatchResult
{
    public OutboundMatch Match { get; }    
    public bool IsFallbackMatch { get; }
    
    public OutboundMatchResult(
        OutboundMatch match, 
        bool isFallbackMatch)
    {
        Match = match;
        IsFallbackMatch = isFallbackMatch;
    }        
}

```

#### 4.4 tree router

##### 4.1.1 tree router

```c#
public class TreeRouter : IRouter
{    
    // Key used by routing and action selection to match an attribute
    // route entry to a group of action descriptors.    
    public static readonly string RouteGroupKey = "!__route_group";
    
    private readonly UrlMatchingTree[] _trees;
    internal IEnumerable<UrlMatchingTree> MatchingTrees => _trees;    
    private readonly LinkGenerationDecisionTree _linkGenerationTree;   
    
    private readonly IDictionary<string, OutboundMatch> _namedEntries;
            
    private readonly ILogger _logger;
    private readonly ILogger _constraintLogger;
    
    public int Version { get; }    
           
    internal TreeRouter(
        UrlMatchingTree[] trees,
        IEnumerable<OutboundRouteEntry> linkGenerationEntries,
        UrlEncoder urlEncoder,
        ObjectPool<UriBuildingContext> objectPool,
        ILogger routeLogger,
        ILogger constraintLogger,
        int version)
    {
        if (trees == null)
        {
            throw new ArgumentNullException(nameof(trees));
        }        
        if (linkGenerationEntries == null)
        {
            throw new ArgumentNullException(nameof(linkGenerationEntries));
        }        
        if (urlEncoder == null)
        {
            throw new ArgumentNullException(nameof(urlEncoder));
        }        
        if (objectPool == null)
        {
            throw new ArgumentNullException(nameof(objectPool));
        }        
        if (routeLogger == null)
        {
            throw new ArgumentNullException(nameof(routeLogger));
        }        
        if (constraintLogger == null)
        {
            throw new ArgumentNullException(nameof(constraintLogger));
        }
        
        // 注入 url matching tree 集合
        _trees = trees;
        
        _logger = routeLogger;
        _constraintLogger = constraintLogger;
        
        /* 注入 named outbound matches，创建 link decision tree */                
        _namedEntries = new Dictionary<string, OutboundMatch>(StringComparer.OrdinalIgnoreCase);		
        var outboundMatches = new List<OutboundMatch>();
        
        // 遍历 传入 outbound route entry 集合，注入 outbound matches
        foreach (var entry in linkGenerationEntries)
        {
            /* 封装 outbound route entry 为 outbound match */
            var binder = new TemplateBinder(
                urlEncoder, 
                objectPool, 
                entry.RouteTemplate, 
                entry.Defaults);
            
            var outboundMatch = 
                new OutboundMatch() 
            	{
                	Entry = entry, 
                	TemplateBinder = binder 
            	};
            
            /* 注入 outbound matches */
            outboundMatches.Add(outboundMatch);
                        
            /* 忽略没有 route name 的 entry*/
            // Skip unnamed entries
            if (entry.RouteName == null)
            {
                continue;
            }
            
            // We only need to keep one OutboundMatch per route template
            // so in case two entries have the same name and the same template we only keep
            // the first entry.
            
            /* 如果 outbound route entry 重名，抛出异常，
               否则 注入 named entries */
            if (_namedEntries.TryGetValue(
                	entry.RouteName, 
                	out var namedMatch) &&
                !string.Equals(
                    namedMatch.Entry.RouteTemplate.TemplateText,
                    entry.RouteTemplate.TemplateText,
                    StringComparison.OrdinalIgnoreCase))
            {
                throw new ArgumentException(
                    Resources.FormatAttributeRoute
                    		 _DifferentLinkGenerationEntries
                    		 _SameName(entry.RouteName),
                    nameof(linkGenerationEntries));
            }
            else if (namedMatch == null)
            {
                _namedEntries.Add(entry.RouteName, outboundMatch);
            }
        }
                
        // The decision tree will take care of ordering for these entries.
        
        /* 由上，由outbound matches 创建 link generation tree */
        _linkGenerationTree = new LinkGenerationDecisionTree(outboundMatches.ToArray());
        
        Version = version;
    }                                                             
}

```

###### 4.1.1.1 接口方法 - route async

```c#
public class TreeRouter : IRouter
{    
    public async Task RouteAsync(RouteContext context)
    {
        // 遍历 url matching tree 集合，
        foreach (var tree in _trees)
        {
            /* 为 url matching tree 创建 tree enumerator */
            var tokenizer = new PathTokenizer(context.HttpContext.Request.Path);
            var root = tree.Root;            
            var treeEnumerator = new TreeEnumerator(root, tokenizer);
            
            // Create a snapshot before processing the route. 
            // We'll restore this snapshot before running each to restore the state. 
            // This is likely an "empty" snapshot, which doesn't allocate.
            
            // 创建 route data 的 snapshot
            var snapshot = context.RouteData.PushState(
                router: null, 
                values: null, 
                dataTokens: null);
            
            // 遍历 url matching node，
            while (treeEnumerator.MoveNext())
            {
                var node = treeEnumerator.Current;
                
                // 遍历 node 中的 matches
                foreach (var item in node.Matches)
                {                    
                    var entry = item.Entry;
                    var matcher = item.TemplateMatcher;
                    
                    try
                    {
                        // 如果 request 不能通过 matcher 匹配，下一个 inbound match
                        if (!matcher.TryMatch(
                            	context.HttpContext.Request.Path, 
                            	context.RouteData.Values))
                        {
                            continue;
                        }
                        
                        // 如果 (request) 不能通过 route constraint matcher 匹配，
                        // 下一个 inbound match
                        if (!RouteConstraintMatcher.Match(
	                            entry.Constraints,
    	                        context.RouteData.Values,
        	                    context.HttpContext,
            	                this,
                	            RouteDirection.IncomingRequest,
                    	        _constraintLogger))
                        {
                            continue;
                        }
                        
                        /* inbound match 匹配 request */
                        
                        // 日志
                        _logger.RequestMatchedRoute(
                            entry.RouteName, 
                            entry.RouteTemplate.TemplateText);
                        
                        // 向 route data 注入该 inbound route entry 的 handler(irouter)
                        context.RouteData.Routers.Add(entry.Handler);
                        // 执行 irouter
                        await entry.Handler.RouteAsync(context);
                        if (context.Handler != null)
                        {
                            return;
                        }
                    }
                    finally
                    {                        
                        if (context.Handler == null)
                        {
                            // Restore the original values to prevent polluting the route data.
                            snapshot.Restore();
                        }
                    }
                }
            }
        }
    }
}

```

###### 4.1.1.2 接口方法 - get virtual path

```c#
public class TreeRouter : IRouter
{       
    public VirtualPathData GetVirtualPath(VirtualPathContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        // If it's a named route we will try to generate a link directly and
        // if we can't, we will not try to generate it using an unnamed route.
        
        // 如果 route name 不为 null，调用 get virtual path for named route
        if (context.RouteName != null)
        {
            return GetVirtualPathForNamedRoute(context);
        }
        
        // The decision tree will give us back all entries that match the provided 
        // route data in the correct order. 
        // We just need to iterate them and use the first one that can generate a link.
        
        /* route name 不为 null，使用 outbound match 创建 virtual path */
        
        // 解析 outbound match
        var matches = _linkGenerationTree.GetMatches(
            context.Values, 
            context.AmbientValues);
        
        if (matches == null)
        {
            return null;
        }
        
        // 遍历 outbound match，调用 generate virtual path 方法
        for (var i = 0; i < matches.Count; i++)
        {
            var path = GenerateVirtualPath(
                context, 
                matches[i].Match.Entry, 
                matches[i].Match.TemplateBinder);
            
            if (path != null)
            {
                return path;
            }
        }
        
        return null;
    }
    
    // get virtual path for named route
    private VirtualPathData GetVirtualPathForNamedRoute(VirtualPathContext context)
    {
        if (_namedEntries.TryGetValue(
	            context.RouteName, 
    	        out var match))
        {
            // 调用 generate virtual path 方法
            var path = GenerateVirtualPath(
                context, 
                match.Entry, 
                match.TemplateBinder);
            if (path != null)
            {
                return path;
            }
        }
        return null;
    }
    
    // 创建 virtual path
    private VirtualPathData GenerateVirtualPath(
        VirtualPathContext context,
        OutboundRouteEntry entry,
        TemplateBinder binder)
    {
        // In attribute the context includes the values that are used to select this 
        // entry - typically these will be the standard 'action', 'controller' and 
        // maybe 'area' tokens. 
        // However, we don't want to pass these to the link generation code, or else 
        // they will end up as query parameters.
        //
        // So, we need to exclude from here any values that are 'required link values', 
        // but aren't parameters in the template.
        //
        // Ex:
        //      template: api/Products/{action}
        //      required values: { id = "5", action = "Buy", Controller = "CoolProducts" }
        //
        //      result: { id = "5", action = "Buy" }
        
        /* 将 outbound route entry 的 required link value（用于属性注入）
           注入 input values */
        var inputValues = new RouteValueDictionary();
        foreach (var kvp in context.Values)
        {
            if (entry.RequiredLinkValues.ContainsKey(kvp.Key))
            {
                var parameter = entry.RouteTemplate.GetParameter(kvp.Key);
                
                if (parameter == null)
                {
                    continue;
                }
            }
            
            inputValues.Add(kvp.Key, kvp.Value);
        }
        
        // 使用 template binder 合并 values
        var bindingResult = binder.GetValues(context.AmbientValues, inputValues);
        if (bindingResult == null)
        {
            // A required parameter in the template didn't get a value.
            return null;
        }
        
        // constraint matcher 验证 constraint
        var matched = RouteConstraintMatcher.Match(
            entry.Constraints,
            bindingResult.CombinedValues,
            context.HttpContext,
            this,
            RouteDirection.UrlGeneration,
            _constraintLogger);
        
        if (!matched)
        {
            // A constraint rejected this link.
            return null;
        }
        
        // 获取 outbound route entry 中 iroute 的virtual path，
        // 如果不为 null，直接返回结果
        var pathData = entry.Handler.GetVirtualPath(context);
        if (pathData != null)
        {
            // If path is non-null then the target router short-circuited, we don't expect this
            // in typical MVC scenarios.
            return pathData;
        }
        
        // 否则，即 irouter 无法创建 path data，
        // 由 template binder 创建 virtual path data 并返回
        var path = binder.BindValues(bindingResult.AcceptedValues);
        if (path == null)
        {
            return null;
        }        
        return new VirtualPathData(this, path);
    }
}

```

##### 4.1.2 tree router builder

```c#
public class TreeRouteBuilder
{
    private readonly ILogger _logger;
    private readonly ILogger _constraintLogger;
    private readonly UrlEncoder _urlEncoder;
    private readonly ObjectPool<UriBuildingContext> _objectPool;
    private readonly IInlineConstraintResolver _constraintResolver;
    
    // inbound route entry 集合
    public IList<InboundRouteEntry> InboundEntries { get; } = new List<InboundRouteEntry>();  
    // outbound route entry 集合
    public IList<OutboundRouteEntry> OutboundEntries { get; } = new List<OutboundRouteEntry>();
    
    internal TreeRouteBuilder(
        ILoggerFactory loggerFactory,
        ObjectPool<UriBuildingContext> objectPool,
        IInlineConstraintResolver constraintResolver)
    {
        if (loggerFactory == null)
        {
            throw new ArgumentNullException(nameof(loggerFactory));
        }        
        if (objectPool == null)
        {
            throw new ArgumentNullException(nameof(objectPool));
        }        
        if (constraintResolver == null)
        {
            throw new ArgumentNullException(nameof(constraintResolver));
        }
        
        _urlEncoder = UrlEncoder.Default;
        _objectPool = objectPool;
        _constraintResolver = constraintResolver;
        
        _logger = loggerFactory.CreateLogger<TreeRouter>();
        _constraintLogger = 
            loggerFactory.CreateLogger(typeof(RouteConstraintMatcher).FullName);
    }
                                                     
    public void Clear()
    {
        InboundEntries.Clear();
        OutboundEntries.Clear();
    }
}

```

###### 4.1.2.1 map inbound

```c#
public class TreeRouteBuilder
{
    public InboundRouteEntry MapInbound(
        IRouter handler,
        RouteTemplate routeTemplate,
        string routeName,
        int order)
    {
        if (handler == null)
        {
            throw new ArgumentNullException(nameof(handler));
        }        
        if (routeTemplate == null)
        {
            throw new ArgumentNullException(nameof(routeTemplate));
        }
        
        var entry = new InboundRouteEntry()
        {
            Handler = handler,
            Order = order,
            Precedence = RoutePrecedence.ComputeInbound(routeTemplate),
            RouteName = routeName,
            RouteTemplate = routeTemplate,
        };
        
        var constraintBuilder = new RouteConstraintBuilder(
            _constraintResolver, 
            routeTemplate.TemplateText);
        
        foreach (var parameter in routeTemplate.Parameters)
        {
            if (parameter.InlineConstraints != null)
            {
                if (parameter.IsOptional)
                {
                    constraintBuilder.SetOptional(parameter.Name);
                }
                
                foreach (var constraint in parameter.InlineConstraints)
                {
                    constraintBuilder.AddResolvedConstraint(
                        parameter.Name, 
                        constraint.Constraint);
                }
            }
        }
        entry.Constraints = constraintBuilder.Build();
        
        entry.Defaults = new RouteValueDictionary();
        foreach (var parameter in entry.RouteTemplate.Parameters)
        {
            if (parameter.DefaultValue != null)
            {
                entry.Defaults.Add(parameter.Name, parameter.DefaultValue);
            }           
        }
        InboundEntries.Add(entry);
        return entry;
    }
}

```

###### 4.1.2.2 map outbound

```c#
public class TreeRouteBuilder
{
    public OutboundRouteEntry MapOutbound(
        IRouter handler,
        RouteTemplate routeTemplate,
        RouteValueDictionary requiredLinkValues,
        string routeName,
        int order)
    {
        if (handler == null)
        {
            throw new ArgumentNullException(nameof(handler));
        }        
        if (routeTemplate == null)
        {
            throw new ArgumentNullException(nameof(routeTemplate));
        }        
        if (requiredLinkValues == null)
        {                
            throw new ArgumentNullException(nameof(requiredLinkValues));
            
        }
        
        var entry = new OutboundRouteEntry()            
        {
            Handler = handler,
            Order = order,
            Precedence = RoutePrecedence.ComputeOutbound(routeTemplate),
            RequiredLinkValues = requiredLinkValues,
            RouteName = routeName,
            RouteTemplate = routeTemplate,
        };
        
        var constraintBuilder = new RouteConstraintBuilder(
            _constraintResolver, 
            routeTemplate.TemplateText);
        
        foreach (var parameter in routeTemplate.Parameters)
        {
            if (parameter.InlineConstraints != null)
            {
                if (parameter.IsOptional)
                {
                    constraintBuilder.SetOptional(parameter.Name);
                }
                
                foreach (var constraint in parameter.InlineConstraints)
                {
                    constraintBuilder.AddResolvedConstraint(
                        parameter.Name, 
                        constraint.Constraint);
                }
            }
        }
        
        entry.Constraints = constraintBuilder.Build();

        entry.Defaults = new RouteValueDictionary();
        foreach (var parameter in entry.RouteTemplate.Parameters)
        {
            if (parameter.DefaultValue != null)
            {
                entry.Defaults
                     .Add(
                    	  parameter.Name, 
                    	  parameter.DefaultValue);
            }
        }
        
        OutboundEntries.Add(entry);
        return entry;
    }
}

```

###### 4.1.2.3 build

```c#
public class TreeRouteBuilder
{
    public TreeRouter Build()
    {
        return Build(version: 0);
    }
           
    public TreeRouter Build(int version)
    {
        // Tree route builder builds a tree for each of the different route orders defined 
        // by the user. When a route needs to be matched, the matching algorithm in tree 
        // router just iterates over the trees in ascending order when it tries to match 
        // the route.
        var trees = new Dictionary<int, UrlMatchingTree>();
        
        foreach (var entry in InboundEntries)
        {
            if (!trees.TryGetValue(entry.Order, out var tree))
            {                    
                tree = new UrlMatchingTree(entry.Order);
                trees.Add(entry.Order, tree);
            }
            
            tree.AddEntry(entry);
        }
                
        return new TreeRouter(
            trees.Values.OrderBy(tree => tree.Order).ToArray(),
            OutboundEntries,
            _urlEncoder,
            _objectPool,
            _logger,
            _constraintLogger,
            version);
    }
}

```

#### 4.5 attribute route

##### 4.5.1 attribute route

```c#
internal class AttributeRoute : IRouter
{
    private readonly IActionDescriptorCollectionProvider _actionDescriptorCollectionProvider;
    private readonly IServiceProvider _services;
    private readonly Func<ActionDescriptor[], IRouter> _handlerFactory;
    
    private TreeRouter? _router;
    
    public AttributeRoute(
        IActionDescriptorCollectionProvider actionDescriptorCollectionProvider,
        IServiceProvider services,
        Func<ActionDescriptor[], IRouter> handlerFactory)
    {
        if (actionDescriptorCollectionProvider == null)
        {
            throw new ArgumentNullException(nameof(actionDescriptorCollectionProvider));
        }        
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }        
        if (handlerFactory == null)
        {
            throw new ArgumentNullException(nameof(handlerFactory));
        }
        
        // 注入 action desc collection provider
        _actionDescriptorCollectionProvider = actionDescriptorCollectionProvider;
        // 注入 services
        _services = services;
        // 注入 action desc - router 字典
        _handlerFactory = handlerFactory;
    }
    
    private TreeRouter GetTreeRouter()
    {
        // 解析 action descriptor 集合
        var actions = _actionDescriptorCollectionProvider.ActionDescriptors;
        
        // This is a safe-race. We'll never set router back to null after initializing
        // it on startup.
        if (_router == null || 
            _router.Version != actions.Version)
        {
            // 解析 tree route builder
            var builder = _services.GetRequiredService<TreeRouteBuilder>();
            // 向 tree route builder 注入 action desciptor
            AddEntries(builder, actions);
            // 构建 tree route
            _router = builder.Build(actions.Version);
        }
        
        return _router;
    }
                
    /// <inheritdoc />
    public Task RouteAsync(RouteContext context)
    {
        // 解析 tree router，
        var router = GetTreeRouter();
        // 使用 tree router 的 route async 方法
        return router.RouteAsync(context);
    }
    
    /// <inheritdoc />
    public VirtualPathData GetVirtualPath(VirtualPathContext context)
    {
        // 解析 tree router，
        var router = GetTreeRouter();            
        // 使用 tree router 的 get virtual path 方法
        return router.GetVirtualPath(context);
    }                                           
}

```

###### 4.5.1.1 add entry

```c#
internal class AttributeRoute : IRouter
{
    internal void AddEntries(
        TreeRouteBuilder builder, 
        ActionDescriptorCollection actions)
    {
        // 由 action descriptor 解析 route infos
        var routeInfos = GetRouteInfos(actions.Items);
        
        // We're creating one TreeRouteLinkGenerationEntry per action. 
        // This allows us to match the intended action by expected route values, and then 
        // use the TemplateBinder to generate the link.
        
        // 遍历 route info，
        foreach (var routeInfo in routeInfos)
        {
            // 如果 route info 标记了 suppress link generation，-> 下一个 route info
            if (routeInfo.SuppressLinkGeneration)
            {
                continue;
            }
            
            // 遍历 route info 的 action descriptor 的 route value，
            // 注入 defaults（解析 route 的 default）
            var defaults = new RouteValueDictionary();
            foreach (var kvp in routeInfo.ActionDescriptor.RouteValues)
            {
                defaults.Add(kvp.Key, kvp.Value);
            }
            
            try
            {
                // We use the `NullRouter` as the route handler because we don't need to do 
                // anything for link generations. The TreeRouter does it all for us.
                
                // 向 tree router build 注入 outbound
                builder.MapOutbound(
                    NullRouter.Instance,
                    routeInfo.RouteTemplate,
                    defaults,
                    routeInfo.RouteName,
                    routeInfo.Order);
            }
            catch (RouteCreationException routeCreationException)
            {
                throw new RouteCreationException(
                    "An error occurred while adding a route to the route builder. " +
                    $"Route name '{routeInfo.RouteName}' and template 
                    "'{routeInfo.RouteTemplate!.TemplateText}'.",
                    routeCreationException);
            }
        }
        
        // We're creating one AttributeRouteMatchingEntry per group, so we need to identify 
        // the distinct set of groups. It's guaranteed that all members of the group have 
        // the same template and precedence, so we only need to hang on to a single instance 
        // of the RouteInfo for each group.
        
        // 解析 inbound route groups
        var groups = GetInboundRouteGroups(routeInfos);
        // 遍历 inbound route group，
        foreach (var group in groups)
        {
            // 由 inbound route group 创建 route handler
            var handler = _handlerFactory(group.ToArray());
            
            // Note that because we only support 'inline' defaults, each routeInfo group 
            // also has the same set of defaults.
            //
            // We then inject the route group as a default for the matcher so it gets passed 
            // back to MVC for use in action selection.
            
            // 向 tree router builder 注入 inbound
            builder.MapInbound(
                handler,
                group.Key.RouteTemplate,
                group.Key.RouteName,
                group.Key.Order);
        }
    }
    
    // Used only to hook up link generation, and it doesn't need to do anything.
    private class NullRouter : IRouter
    {
        public static readonly NullRouter Instance = new NullRouter();
        
        public VirtualPathData? GetVirtualPath(VirtualPathContext context)
        {
            return null;
        }
        
        public Task RouteAsync(RouteContext context)
        {
            throw new NotImplementedException();
        }
    }
}

```

###### 4.5.1.2 get route infos

```c#
internal class AttributeRoute : IRouter
{
    private static List<RouteInfo> GetRouteInfos(IReadOnlyList<ActionDescriptor> actions)
    {
        // 预结果
        var routeInfos = new List<RouteInfo>();
        var errors = new List<RouteInfo>();                
        var templateCache = 
            new Dictionary<string, RouteTemplate>(StringComparer.OrdinalIgnoreCase);
        
        // 过滤 包含 template 不为 null 的 action descriptor
        var attributeRoutedActions = 
            actions.Where(a => a.AttributeRouteInfo?.Template != null);
        
        // 遍历 action descriptor，
        foreach (var action in attributeRoutedActions)
        {
            // 由 action descriptor、template cache 创建 route info
            var routeInfo = GetRouteInfo(templateCache, action);
            
            if (routeInfo.ErrorMessage == null)
            {
                // 注入 error
                routeInfos.Add(routeInfo);
            }
            else
            {
                // 注入 route info
                errors.Add(routeInfo);
            }
        }
        
        // 如果有 error，-> 抛出异常
        if (errors.Count > 0)
        {
            var allErrors = string.Join(
                Environment.NewLine + Environment.NewLine,
                errors.Select(
                    e => Resources.FormatAttributeRoute_IndividualErrorMessage(
                        e.ActionDescriptor.DisplayName,
                        Environment.NewLine,
                        e.ErrorMessage)));
            
            var message = Resources.FormatAttributeRoute
                				   _AggregateErrorMessage(
                					   Environment.NewLine, 
                					   allErrors);
            
            throw new RouteCreationException(message);
        }
        
        return routeInfos;
    }
    
    private static RouteInfo GetRouteInfo(
        Dictionary<string, RouteTemplate> templateCache,
        ActionDescriptor action)
    {
        // 创建 route info（预结果），封装 action descriptor
        var routeInfo = new RouteInfo()
        {
            ActionDescriptor = action,
        };
        
        try
        {
            // 解析 action 的 attribute route info 的 template（字符串）            
            var template = action.AttributeRouteInfo!.Template!;
            // 解析 route template，注入 template cache
            if (!templateCache.TryGetValue(
                	template, 
                	out var parsedTemplate))
            {
                // Parsing with throw if the template is invalid.
                parsedTemplate = TemplateParser.Parse(template);
                templateCache.Add(template, parsedTemplate);
            }
            
            // 向 route info 注入 route template
            routeInfo.RouteTemplate = parsedTemplate;
            // 解析 action 的 attribute route info 的 suppres path matching，
            // 注入 route info
            routeInfo.SuppressPathMatching = action.AttributeRouteInfo
                								   .SuppressPathMatching;
            // 解析 action 的 attribute route info 的 suppress link generation，
            // 注入 route info
            routeInfo.SuppressLinkGeneration = action.AttributeRouteInfo
                									 .SuppressLinkGeneration;
        }
        catch (Exception ex)
        {
            routeInfo.ErrorMessage = ex.Message;
            return routeInfo;
        }
        
        // 遍历 action descriptor 的 route value，
        foreach (var kvp in action.RouteValues)
        {
            // 遍历 route info 的 route template 的 parameters，
            foreach (var parameter in routeInfo.RouteTemplate
                     						   .Parameters)
            {
                // 如果 route info template 中包含，
                // 与 action descriptor 的 route value 同名的 key,
                // -> 错误，注入errors
                if (string.Equals(
                    	kvp.Key, 
	                    parameter.Name, 
    	                StringComparison.OrdinalIgnoreCase))
                {
                    routeInfo.ErrorMessage = Resources.FormatAttributeRoute
                        							  _CannotContainParameter(
                        								  routeInfo.RouteTemplate
                        										   .TemplateText,
                        								  kvp.Key,
							      	                      kvp.Value);
                    
                    return routeInfo;
                }
            }
        }
        
        routeInfo.Order = action.AttributeRouteInfo.Order;
        routeInfo.RouteName = action.AttributeRouteInfo.Name;
        
        return routeInfo;
    }
    
    private class RouteInfo
    {
        public ActionDescriptor ActionDescriptor { get; init; } = default!;     
        
        public string? ErrorMessage { get; set; }
        
        public int Order { get; set; }        
        public string? RouteName { get; set; }        
        public RouteTemplate? RouteTemplate { get; set; }        
        
        public bool SuppressPathMatching { get; set; }        
        public bool SuppressLinkGeneration { get; set; }
    }        
}

```

###### 4.5.1.3 get inbound route groups

```c#
internal class AttributeRoute : IRouter
{
    private static IEnumerable<IGrouping<RouteInfo, ActionDescriptor>> 
        GetInboundRouteGroups(List<RouteInfo> routeInfos)
    {
        // 过滤 route info，没有标记 suppress path matching
        return routeInfos.Where(routeInfo => 
                         	  !routeInfo.SuppressPathMatching)
            			 // 按照 action descriptor 排序
            			 .GroupBy(
            				  r => r, 
            				  r => r.ActionDescriptor, 
            				  RouteInfoEqualityComparer.Instance);
    }
                            
    private class RouteInfoEqualityComparer : IEqualityComparer<RouteInfo>
    {
        public static readonly RouteInfoEqualityComparer Instance = new();
        
        public bool Equals(RouteInfo? x, RouteInfo? y)
        {
            if (x == null && y == null)
            {
                return true;
            }
            else if (x == null || y == null)
            {
                return false;
            }
            else if (x.Order != y.Order)
            {
                return false;
            }
            else
            {
                return string.Equals(
                    x.RouteTemplate!.TemplateText,
                    y.RouteTemplate!.TemplateText,
                    StringComparison.OrdinalIgnoreCase);
            }
        }
        
        public int GetHashCode(RouteInfo obj)
        {
            if (obj == null)
            {
                return 0;
            }
            
            var hash = new HashCode();
            hash.Add(obj.Order);
            hash.Add(
                obj.RouteTemplate!.TemplateText, 
                StringComparer.OrdinalIgnoreCase);
            
            return hash.ToHashCode();
        }
    }
}

```

##### 4.5.2 mvc attribute route handler

* attribute route 真正执行 request delegate 的 router

```c#
internal class MvcAttributeRouteHandler : IRouter
{
    private readonly IActionInvokerFactory _actionInvokerFactory;
    private readonly IActionSelector _actionSelector;
    
    private readonly ILogger _logger;
    private readonly DiagnosticListener _diagnosticListener;
    
    public ActionDescriptor[]? Actions { get; set; }
    
    public MvcAttributeRouteHandler(
        IActionInvokerFactory actionInvokerFactory,
        IActionSelector actionSelector,
        DiagnosticListener diagnosticListener,
        ILoggerFactory loggerFactory)
    {
        _actionInvokerFactory = actionInvokerFactory;
        _actionSelector = actionSelector;
        
        _diagnosticListener = diagnosticListener;
        _logger = loggerFactory.CreateLogger<MvcAttributeRouteHandler>();
    }    
}

```

###### 4.5.2.1 接口方法 - route async

```c#
internal class MvcAttributeRouteHandler : IRouter
{
    public Task RouteAsync(RouteContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }        
        if (Actions == null)
        {
            var message = Resources.FormatPropertyOfTypeCannotBeNull(
                nameof(Actions),
                nameof(MvcAttributeRouteHandler));
            
            throw new InvalidOperationException(message);
        }
        
        // 从 action descriptor 集合中解析 best candidate
        var actionDescriptor = _actionSelector.SelectBestCandidate(context, Actions);
        // 如果 best candidate 为 null，-> 结束
        if (actionDescriptor == null)
        {
            _logger.NoActionsMatched(context.RouteData.Values);
            return Task.CompletedTask;
        }
        
        // 遍历 best candidate 的 route value，注入 route context
        foreach (var kvp in actionDescriptor.RouteValues)
        {
            if (!string.IsNullOrEmpty(kvp.Value))
            {
                context.RouteData.Values[kvp.Key] = kvp.Value;
            }
        }
        
        // 创建 request delegate（action invoker），注入 route context
        context.Handler = (c) =>
        {
            // 从 route context 解析 route data
            var routeData = c.GetRouteData();
            // 封装 http context、route data、action descriptor -> action context           
            var actionContext = new ActionContext(
                context.HttpContext, 
                routeData, 
                actionDescriptor);
            // 创建 action invoker（如果为 null，-> 抛出异常）
            var invoker = _actionInvokerFactory.CreateInvoker(actionContext);
            if (invoker == null)
            {
                throw new InvalidOperationException(
                    Resources.FormatActionInvokerFactory_CouldNotCreateInvoker(
                        actionDescriptor.DisplayName));
            }
            
            // 调用 action invoker 的 invoke 方法
            return invoker.InvokeAsync();
        };
        
        return Task.CompletedTask;
    }
}

```

###### 4.5.2.2 接口方法 - get virtual path

```c#
internal class MvcAttributeRouteHandler : IRouter
{
    public VirtualPathData? GetVirtualPath(VirtualPathContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        // We return null here because we're not responsible for generating the url, 
        // the route is.
        return null;
    }
}

```

##### 4.5.3 attribute routing 

* 创建 attribute route，封装 mvc attribute route handler

```c#
internal static class AttributeRouting
{    
    public static IRouter CreateAttributeMegaRoute(IServiceProvider services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        return new AttributeRoute(
            // 解析 action descriptor collection provider
            services.GetRequiredService<IActionDescriptorCollectionProvider>(),
            services,
            actions =>
            {
                // 解析 mvc attribute route handler
                var handler = services.GetRequiredService<MvcAttributeRouteHandler>();
                // 向 mvc attribute route handler 注入 action descriptor 集合
                handler.Actions = actions;
                
                return handler;
            });
    }
}

```

#### 4.6 add mvc routing service?

##### 4.6.1 add mvc

```c#
public static class MvcServiceCollectionExtensions
{    
    public static IMvcBuilder AddMvc(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        services.AddControllersWithViews();
        return services.AddRazorPages();
    }
        
    public static IMvcBuilder AddMvc(this IServiceCollection services, Action<MvcOptions> setupAction)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }        
        if (setupAction == null)
        {
            throw new ArgumentNullException(nameof(setupAction));
        }
        
        var builder = services.AddMvc();
        builder.Services.Configure(setupAction);
        
        return builder;
    }

        
    public static IMvcBuilder AddControllers(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        var builder = AddControllersCore(services);
        return new MvcBuilder(builder.Services, builder.PartManager);
    }
        
    public static IMvcBuilder AddControllers(this IServiceCollection services, Action<MvcOptions> configure)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        // This method excludes all of the view-related services by default.
        var builder = AddControllersCore(services);
        if (configure != null)
        {
            builder.AddMvcOptions(configure);
        }
        
        return new MvcBuilder(builder.Services, builder.PartManager);
    }
    
    private static IMvcCoreBuilder AddControllersCore(IServiceCollection services)
    {
        // This method excludes all of the view-related services by default.
        return services.AddMvcCore()
            		  .AddApiExplorer()
            		  .AddAuthorization()
            		  .AddCors()
            		  .AddDataAnnotations()
            		  .AddFormatterMappings();
    }
    
    public static IMvcBuilder AddControllersWithViews(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        var builder = AddControllersWithViewsCore(services);
        return new MvcBuilder(builder.Services, builder.PartManager);
    }

        
    public static IMvcBuilder AddControllersWithViews(this IServiceCollection services, Action<MvcOptions> configure)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        // This method excludes all of the view-related services by default.
        var builder = AddControllersWithViewsCore(services);
        if (configure != null)
        {
            builder.AddMvcOptions(configure);
        }
        
        return new MvcBuilder(builder.Services, builder.PartManager);
    }
    
    private static IMvcCoreBuilder AddControllersWithViewsCore(IServiceCollection services)
    {
        var builder = AddControllersCore(services).AddViews()
            								   .AddRazorViewEngine()
            								   .AddCacheTagHelper();
        
        AddTagHelpersFrameworkParts(builder.PartManager);        
        return builder;
    }

        
    public static IMvcBuilder AddRazorPages(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        var builder = AddRazorPagesCore(services);
        return new MvcBuilder(builder.Services, builder.PartManager);
    }
            
    public static IMvcBuilder AddRazorPages(this IServiceCollection services, Action<RazorPagesOptions> configure)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        var builder = AddRazorPagesCore(services);
        if (configure != null)
        {
            builder.AddRazorPages(configure);
        }
        
        return new MvcBuilder(builder.Services, builder.PartManager);        
    }
    
    private static IMvcCoreBuilder AddRazorPagesCore(IServiceCollection services)
    {
        // This method includes the minimal things controllers need. It's not really feasible to exclude the services
        // for controllers.
        var builder = services.AddMvcCore()
        				    .AddAuthorization()
				            .AddDataAnnotations()
				            .AddRazorPages()
				            .AddCacheTagHelper();
        
        AddTagHelpersFrameworkParts(builder.PartManager);        
        return builder;
    }
    
    internal static void AddTagHelpersFrameworkParts(ApplicationPartManager partManager)
    {
        var mvcTagHelpersAssembly = typeof(InputTagHelper).Assembly;
        if (!partManager.ApplicationParts
            		   .OfType<AssemblyPart>()
            		   .Any(p => p.Assembly == mvcTagHelpersAssembly))
        {
            partManager.ApplicationParts
                	  .Add(new FrameworkAssemblyPart(mvcTagHelpersAssembly));
        }
        
        var mvcRazorAssembly = typeof(UrlResolutionTagHelper).Assembly;
        if (!partManager.ApplicationParts
            		   .OfType<AssemblyPart>()
            		   .Any(p => p.Assembly == mvcRazorAssembly))
        {
            partManager.ApplicationParts
                	  .Add(new FrameworkAssemblyPart(mvcRazorAssembly));
        }
    }
    
    [DebuggerDisplay("{Name}")]
    private class FrameworkAssemblyPart : 
    	AssemblyPart, 
    	ICompilationReferencesProvider
    {
        public FrameworkAssemblyPart(Assembly assembly) : base(assembly) 
        {
        }
        
        IEnumerable<string> ICompilationReferencesProvider.GetReferencePaths() => Enumerable.Empty<string>();
    }
}

```



mvc options

```c#

```



mvc marker service

```c#

```



#### 4.7 use mvc (routing)

```c#
public static class MvcApplicationBuilderExtensions
{    
    // use mvc，仅使用 mvc route handler 和 attribute route
    public static IApplicationBuilder UseMvc(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMvc(routes => {});
    }
        
    // 注入 default route template for mvc，即 {controller=Home}/{action=Index}/{id?}
    public static IApplicationBuilder UseMvcWithDefaultRoute(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMvc(routes =>
                          {
                              routes.MapRoute(
                                  name: "default",
                                  template: "{controller=Home}/{action=Index}/{id?}");
                          });
    }
        
    public static IApplicationBuilder UseMvc(
        this IApplicationBuilder app,
        Action<IRouteBuilder> configureRoutes)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }        
        if (configureRoutes == null)
        {
            throw new ArgumentNullException(nameof(configureRoutes));
        }
        
        // 确认注册了 mvc service
        VerifyMvcIsRegistered(app);
        
        // 解析 mvc options
        var options = app.ApplicationServices
            			.GetRequiredService<IOptions<MvcOptions>>();
        
        // 如果 mvc options 标记了 enable endpoint routing，
        // 即如果使用 endpoint routing，-> 抛出异常
        if (options.Value.EnableEndpointRouting)
        {
            var message =
                "Endpoint Routing does not support 'IApplicationBuilder.UseMvc(...)'.To use " +
                "'IApplicationBuilder.UseMvc' set 'MvcOptions.EnableEndpointRouting = false' inside " +
                "'ConfigureServices(...).";
            
            throw new InvalidOperationException(message);
        }
        
        // 创建 route builder，
        var routes = new RouteBuilder(app)
        {
            // 解析 mvc route handler，作为 default handler
            DefaultHandler = app.ApplicationServices
                			   .GetRequiredService<MvcRouteHandler>(),
        };
        
        // 配置 route builder        
        configureRoutes(routes);
        
        // 创建 attribute mega route，注入 route builder
        //（默认的特性路由，不可以更改）
        routes.Routes.Insert(
            0, 
            AttributeRouting.CreateAttributeMegaRoute(app.ApplicationServices));
        
        return app.UseRouter(routes.Build());
    }        
}

```

##### 4.7.1 verify mvc is registered

```c#
public static class MvcApplicationBuilderExtensions
{
    private static void VerifyMvcIsRegistered(IApplicationBuilder app)
    {
        // Verify if AddMvc was done before calling UseMvc
        // We use the MvcMarkerService to make sure if all the services were added.
        if (app.ApplicationServices.GetService(typeof(MvcMarkerService)) == null)
        {
            throw new InvalidOperationException(
                Resources.FormatUnableToFindServices(
                    nameof(IServiceCollection),
                    "AddMvc",
                    "ConfigureServices(...)"));
        }
    }
}

internal class MvcMarkerService
{
}

```

##### 4.7.2 mvc route hander

```c#
internal class MvcRouteHandler : IRouter
{
    private readonly IActionInvokerFactory _actionInvokerFactory;
    private readonly IActionSelector _actionSelector;
    
    private readonly ILogger _logger;
    private readonly DiagnosticListener _diagnosticListener;
    
    public MvcRouteHandler(
        IActionInvokerFactory actionInvokerFactory,
        IActionSelector actionSelector,
        DiagnosticListener diagnosticListener,
        ILoggerFactory loggerFactory)
    {
        _actionInvokerFactory = actionInvokerFactory;
        _actionSelector = actionSelector;
        
        _diagnosticListener = diagnosticListener;
        _logger = loggerFactory.CreateLogger<MvcRouteHandler>();
    }                
}

```

###### 4.7.2.1 接口方法 - route async

```c#
internal class MvcRouteHandler : IRouter
{
    public Task RouteAsync(RouteContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        var candidates = _actionSelector.SelectCandidates(context);
        if (candidates == null || candidates.Count == 0)
        {
            _logger.NoActionsMatched(context.RouteData.Values);
            return Task.CompletedTask;
        }
        
        var actionDescriptor = _actionSelector.SelectBestCandidate(context, candidates);
        if (actionDescriptor == null)
        {
            _logger.NoActionsMatched(context.RouteData.Values);
            return Task.CompletedTask;
        }
        
        context.Handler = (c) =>
        {
            var routeData = c.GetRouteData();

            var actionContext = new ActionContext(
                context.HttpContext, 
                routeData, 
                actionDescriptor);
            
            var invoker = _actionInvokerFactory.CreateInvoker(actionContext);
            if (invoker == null)
            {
                throw new InvalidOperationException(
                    Resources.FormatActionInvokerFactory_CouldNotCreateInvoker(
                        actionDescriptor.DisplayName));
            }
            
            return invoker.InvokeAsync();
        };
        
        return Task.CompletedTask;
    }
}

```

###### 4.7.2.2 接口方法 - get virtual path

```c#
internal class MvcRouteHandler : IRouter
{
    public VirtualPathData? GetVirtualPath(VirtualPathContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        // We return null here because we're not responsible for generating the url, the route is.
        return null;
    }
}

```











