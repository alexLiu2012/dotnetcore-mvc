## about endpoint routing and mvc



### 1. about

#### 1.1 endpoint

* endpoint 类似 terminal middleware，是 http request pipeline 中最后执行的单元。
  它封装了 request delegate 和 metadata collection，后者用于携带所需数据。

* 通过 endpoint feature，可以在 http context 读写 endpoint

##### 1.1.1 endpoint builder

* endpoint builder，endpoint 构建器，用于配置和创建 endpoint
* endpoint conventional builder，包含 endpoint builder 的 action 集合的构建器

##### 1.1.2 endpoint data source

endpoint 集合，派生出多种 data source

* default endpoint data source
  * 直接存储 endpoint 集合
* model endpoint data source
  * 存储 conventional builder，由 conventional builder 创建 endpoint 并对外提供
* composite endpoint data source
  * 复合的 data source，即存储 data source，又存储 conventional builder
* data source dependent cache
  * 监听 data source change 的 cache，即 data source 变动时，自动更新 cache

#### 1.2 matcher

根据 request path，从 endpoint 集合源解析适合的 endpoint，并注入 http context

##### 1.2.1 endpoint selector

从备选的 endpoint 中选择适合的 endpoint 并注入 http context

##### 1.2.2 dfa state

以 dfa 算法存储的 endpoint 集合（源）

##### 1.2.3 matcher policy

endpoint 匹配策略，同时实现多个特定接口，从而控制 endpoint 匹配过程

* host matcher policy
  * 根据 host 匹配 endpoint
* http method matcher policy
  * 根据 http method 匹配 endpoint

##### 1.2.4 dfa matcher & builder

利用 dfa 算法存储 pattern，构建 endpoint 和解析 request path

##### 1.2.5 data source dependent matcher builder

利用 data source dependent cache 缓存了 matcher builder

#### 1.3 link generator



### 2. endpoint 

#### 2.1 endpoint

##### 2.1.1 endpoint (基类)

```c#
public class Endpoint
{
    // name
    public string? DisplayName { get; }        
    // metadata 集合
    public EndpointMetadataCollection Metadata { get; }        
    // 处理（请求）的 request delegate
    public RequestDelegate? RequestDelegate { get; }
    
    public Endpoint(
        RequestDelegate? requestDelegate,
        EndpointMetadataCollection? metadata,
        string? displayName)
    {
        // All are allowed to be null
        RequestDelegate = requestDelegate;
        Metadata = metadata ?? EndpointMetadataCollection.Empty;
        DisplayName = displayName;
    }
                    
    public override string? ToString() => 
        DisplayName ?? base.ToString();
}

```

###### 2.1.1.1 endpoint metadata collection

```c#
public sealed class EndpointMetadataCollection : IReadOnlyList<object>
{    
    // 静态 empty 实例
    public static readonly EndpointMetadataCollection 
        Empty = new EndpointMetadataCollection(Array.Empty<object>());
    
    // metadata 容器
    private readonly object[] _items;    
    // metadata 缓存容器
    private readonly ConcurrentDictionary<Type, object[]> _cache;
    
    public object this[int index] => _items[index];        
    public int Count => _items.Length;
    
    public EndpointMetadataCollection(IEnumerable<object> items)
    {
        if (items == null)
        {
            throw new ArgumentNullException(nameof(items));
        }
        
        _items = items.ToArray();
        _cache = new ConcurrentDictionary<Type, object[]>();
    }
           
    public EndpointMetadataCollection(params object[] items)
        : this((IEnumerable<object>)items)
    {
    }
                
    /* get metadata */   
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? GetMetadata<T>() where T : class
    {
        if (_cache.TryGetValue(typeof(T), out var obj))
        {
            var result = (T[])obj;
            var length = result.Length;
            return length > 0 ? result[length - 1] : default;
        }
        
        return GetMetadataSlow<T>();
    }
    
    private T? GetMetadataSlow<T>() where T : class
    {
        var result = GetOrderedMetadataSlow<T>();
        var length = result.Length;
        return length > 0 ? result[length - 1] : default;
    }
    
    /* get ordered  metadata */
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public IReadOnlyList<T> GetOrderedMetadata<T>() where T : class
    {
        if (_cache.TryGetValue(typeof(T), out var result))
        {
            return (T[])result;
        }
        
        return GetOrderedMetadataSlow<T>();
    }        
    
    private T[] GetOrderedMetadataSlow<T>() where T : class
    {
        
        List<T>? matches = null;
        
        var items = _items;
        for (var i = 0; i < items.Length; i++)
        {
            if (items[i] is T item)
            {
                matches ??= new List<T>();
                matches.Add(item);
            }
        }
        
        var results = matches == null ? Array.Empty<T>() : matches.ToArray();
        _cache.TryAdd(typeof(T), results);
        return results;
    }
    
    /* get enumerator */
    
    public Enumerator GetEnumerator() => new Enumerator(this);
    
    IEnumerator<object> IEnumerable<object>.GetEnumerator() => 
        GetEnumerator();    
    
    IEnumerator IEnumerable.GetEnumerator() => 
        GetEnumerator();
    
    // enumerator 结构体    
    public struct Enumerator : IEnumerator<object?>
    {
        // Intentionally not readonly to prevent defensive struct copies
        private object[] _items;
        private int _index;
        public object? Current { get; private set; }
        
        internal Enumerator(EndpointMetadataCollection collection)
        {
            _items = collection._items;
            _index = 0;
            Current = null;
        }                                                       
            
        public bool MoveNext()
        {
            if (_index < _items.Length)
            {
                Current = _items[_index++];
                return true;
            }
            
            Current = null;
            return false;
        }
                
        public void Reset()
        {
            _index = 0;
            Current = null;
        }
        
        public void Dispose()
        {
        }
    }
}

```

###### 2.1.1.2 variety ？？

##### 2.1.2 endpoint feature

```c#
// 接口
public interface IEndpointFeature
{    
    Endpoint? Endpoint { get; set; }
}

// 实现
public static class EndpointHttpContextExtensions
{
    private class EndpointFeature : IEndpointFeature
    {
        public Endpoint? Endpoint { get; set; }
    }
}

// get & set in http context
public static class EndpointHttpContextExtensions
{
    // get endpoint
    public static Endpoint? GetEndpoint(this HttpContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        return context.Features.Get<IEndpointFeature>()?.Endpoint;
    }
    
    // set endpoint
    public static void SetEndpoint(
        this HttpContext context, 
        Endpoint? endpoint)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        var feature = context.Features
            				 .Get<IEndpointFeature>();
        
        if (endpoint != null)
        {
            if (feature == null)
            {
                feature = new EndpointFeature();
                context.Features.Set(feature);
            }
            
            feature.Endpoint = endpoint;
        }
        else
        {
            if (feature == null)
            {
                // No endpoint to set and no feature on context. Do othing
                return;
            }
            
            feature.Endpoint = null;
        }
    }            
}


```

#### 2.2 endpoint builder

##### 2.2.1 endpoint builder（抽象基类）

```c#
public abstract class EndpointBuilder
{                
    public string? DisplayName { get; set; }        
    public IList<object> Metadata { get; } = new List<object>();
    public RequestDelegate? RequestDelegate { get; set; }
    
    public abstract Endpoint Build();
}

```

##### 2.2.2 endpoint conventional builder

###### 2.2.2.1 接口

```c#
public interface IEndpointConventionBuilder
{    
    // 注入配置 endpint builder 的 action
    void Add(Action<EndpointBuilder> convention);
}

```

###### 2.2.2.2 扩展方法 - metadata pros

```c#
public static class RoutingEndpointConventionBuilderExtensions
{    
    // required host
    public static TBuilder RequireHost<TBuilder>(
        this TBuilder builder, 
        params string[] hosts) 
        	where TBuilder : IEndpointConventionBuilder
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (hosts == null)
        {
            throw new ArgumentNullException(nameof(hosts));
        }
        
        builder.Add(endpointBuilder =>
                    {
                        endpointBuilder.Metadata.Add(new HostAttribute(hosts));
                    });
        return builder;
    }
        
    // display name (by string)
    public static TBuilder WithDisplayName<TBuilder>(
        this TBuilder builder, 
        string displayName) 
        	where TBuilder : IEndpointConventionBuilder 
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }
        
        builder.Add(b =>
                    {
                        b.DisplayName = displayName;
                    });
        
        return builder;
    }
    
    // display name (by func)   
    public static TBuilder WithDisplayName<TBuilder>(
        this TBuilder builder,
        Func<EndpointBuilder, string> func) 
        	where TBuilder : IEndpointConventionBuilder
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (func == null)
        {
            throw new ArgumentNullException(nameof(func));
        }
        
        builder.Add(b =>
                    {
                        b.DisplayName = func(b);
                    });
        
        return builder;
    }
    
    // with maetadata
    public static TBuilder WithMetadata<TBuilder>(
        this TBuilder builder, 
        params object[] items) 
        	where TBuilder : IEndpointConventionBuilder
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (items == null)
        {
            throw new ArgumentNullException(nameof(items));
        }
        
        builder.Add(b =>
                    {
                        foreach (var item in items)
                        {
                            b.Metadata.Add(item);
                        }
                    });
        
        return builder;
    }
}

```

###### 2.2.2.3 default endpoint convention builder

```c#
internal class DefaultEndpointConventionBuilder : IEndpointConventionBuilder
{
    // 配置 endpoint builder 的 action 集合
    private readonly List<Action<EndpointBuilder>> _conventions;
    // endpoint builder
    internal EndpointBuilder EndpointBuilder { get; }
    
    public DefaultEndpointConventionBuilder(EndpointBuilder endpointBuilder)
    {
        EndpointBuilder = endpointBuilder;
        _conventions = new List<Action<EndpointBuilder>>();
    }
    
    public void Add(Action<EndpointBuilder> convention)
    {
        _conventions.Add(convention);
    }
    
    public Endpoint Build()
    {
        foreach (var convention in _conventions)
        {
            convention(EndpointBuilder);
        }
        
        return EndpointBuilder.Build();
    }
}

```

###### 2.2.2.4 map action endpoint convention builder

```c#
public sealed class MapActionEndpointConventionBuilder : IEndpointConventionBuilder
{
    // 配置 endpoint conventional builder 的 action 集合
    private readonly List<IEndpointConventionBuilder> _endpointConventionBuilders;
    
    internal MapActionEndpointConventionBuilder(
        IEndpointConventionBuilder endpointConventionBuilder)
    {
        _endpointConventionBuilders = new List<IEndpointConventionBuilder>() 
        { 
            endpointConventionBuilder 
        };
    }
    
    internal MapActionEndpointConventionBuilder(
        List<IEndpointConventionBuilder> endpointConventionBuilders)
    {
        _endpointConventionBuilders = endpointConventionBuilders;
    }
        
    public void Add(Action<EndpointBuilder> convention)
    {
        foreach (var endpointConventionBuilder in _endpointConventionBuilders)
        {
            endpointConventionBuilder.Add(convention);
        }
    }
}

```

#### 2.3 endpoint data source

##### 2.3.1 抽象基类

```c#
public abstract class EndpointDataSource
{
    public abstract IReadOnlyList<Endpoint> Endpoints { get; }
    public abstract IChangeToken GetChangeToken();            
}

```

##### 2.3.2 default endpoint data source

* 空实现，没有实现 get change token 方法

```c#
public sealed class DefaultEndpointDataSource : EndpointDataSource
{
    private readonly IReadOnlyList<Endpoint> _endpoints;
    public override IReadOnlyList<Endpoint> Endpoints => _endpoints;
    
    public DefaultEndpointDataSource(params Endpoint[] endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        _endpoints = (Endpoint[])endpoints.Clone();
    }
        
    public DefaultEndpointDataSource(IEnumerable<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        _endpoints = new List<Endpoint>(endpoints);
    }
        
    public override IChangeToken GetChangeToken() => 
        NullChangeToken.Singleton;            
}

```

##### 2.3.3 model endpoint data source

* 包含配置 endpoint builder 的 action 集合，
* 由 endpoint builder 创建 endpoint，从而实现了 endpoint 属性
* 没有实现 get change token 方法

```c#
internal class ModelEndpointDataSource : EndpointDataSource
{
    private List<DefaultEndpointConventionBuilder> _endpointConventionBuilders;
    
    internal IEnumerable<EndpointBuilder> EndpointBuilders => 
        _endpointConventionBuilders.Select(b => b.EndpointBuilder);
    
    public override IReadOnlyList<Endpoint> Endpoints => 
        _endpointConventionBuilders.Select(e => e.Build()).ToArray();
    
    
    public ModelEndpointDataSource()
    {
        _endpointConventionBuilders = new List<DefaultEndpointConventionBuilder>();
    }
    
    public IEndpointConventionBuilder AddEndpointBuilder(EndpointBuilder endpointBuilder)
    {
        var builder = new DefaultEndpointConventionBuilder(endpointBuilder);
        _endpointConventionBuilders.Add(builder);
        
        return builder;
    }
    
    public override IChangeToken GetChangeToken()
    {
        return NullChangeToken.Singleton;
    }        
}

```

##### 2.3.4 composite endpoint data source

```c#
[DebuggerDisplay("{DebuggerDisplayString,nq}")]
public sealed class CompositeEndpointDataSource : EndpointDataSource
{
    private readonly object _lock;
    
    private readonly ICollection<EndpointDataSource> _dataSources = default!;
    public IEnumerable<EndpointDataSource> DataSources => _dataSources;
    
    private IReadOnlyList<Endpoint> _endpoints = default!;
    public override IReadOnlyList<Endpoint> Endpoints
    {
        get
        {
            EnsureInitialized();
            return _endpoints;
        }
    }
        
    private IChangeToken _consumerChangeToken;
    private CancellationTokenSource _cts;
    
    private CompositeEndpointDataSource()
    {
        CreateChangeToken();
        _lock = new object();
    }
    
    internal CompositeEndpointDataSource(
        ObservableCollection<EndpointDataSource> dataSources) : this()
    {
        _dataSources = dataSources;
        dataSources.CollectionChanged += OnDataSourcesChanged;                
    }
    
    private void OnDataSourcesChanged(
        object? sender, 
        NotifyCollectionChangedEventArgs e)
    {
        lock (_lock)
        {
            // Only trigger changes if composite data source has already initialized endpoints
            if (_endpoints != null)
            {
                HandleChange();
            }
        }        
    }
        
    public CompositeEndpointDataSource(
        IEnumerable<EndpointDataSource> endpointDataSources) : this()
    {
        _dataSources = new List<EndpointDataSource>();        
        foreach (var dataSource in endpointDataSources)
        {
            _dataSources.Add(dataSource);
        }
    }
                           
    public override IChangeToken GetChangeToken()
    {
        EnsureInitialized();
        return _consumerChangeToken;
    }
               
    // Defer initialization to avoid doing lots of reflection on startup.
    private void EnsureInitialized()
    {
        if (_endpoints == null)
        {
            Initialize();
        }
    }
    
    // Note: we can't use DataSourceDependentCache here because we also need to 
    // handle a list of change tokens, which is a complication most of our code 
    // doesn't have.
    private void Initialize()
    {
        lock (_lock)
        {
            if (_endpoints == null)
            {
                _endpoints = _dataSources.SelectMany(d => d.Endpoints).ToArray();
                
                foreach (var dataSource in _dataSources)
                {
                    ChangeToken.OnChange(
                        dataSource.GetChangeToken,
                        HandleChange);
                }
            }
        }
    }
    
    private void HandleChange()
    {
        lock (_lock)
        {
            // Refresh the endpoints from datasource so that callbacks can get the 
            // latest endpoints
            _endpoints = _dataSources.SelectMany(d => d.Endpoints).ToArray();
            
            // Prevent consumers from re-registering callback to inflight events as that can
            // cause a stackoverflow
            // Example:
            // 1. B registers A
            // 2. A fires event causing B's callback to get called
            // 3. B executes some code in its callback, but needs to re-register callback
            //    in the same callback
            var oldTokenSource = _cts;
            var oldToken = _consumerChangeToken;
            
            CreateChangeToken();
            
            // Raise consumer callbacks. Any new callback registration would happen on 
            // the new token created in earlier step.
            oldTokenSource.Cancel();
        }
    }
    
    [MemberNotNull(nameof(_cts), nameof(_consumerChangeToken))]
    private void CreateChangeToken()
    {
        _cts = new CancellationTokenSource();
        _consumerChangeToken = new CancellationChangeToken(_cts.Token);
    }
    
    private string DebuggerDisplayString
    {
        get
        {
            // Try using private variable '_endpoints' to avoid initialization
            if (_endpoints == null)
            {
                return "No endpoints";
            }
            
            var sb = new StringBuilder();
            foreach (var endpoint in _endpoints)
            {
                if (endpoint is RouteEndpoint routeEndpoint)
                {
                    var template = routeEndpoint.RoutePattern.RawText;                    
                    template = string.IsNullOrEmpty(template) 
                        ? "\"\"" 
                        : template;
                    
                    sb.Append(template);
                    sb.Append(", Defaults: new { ");
                    sb.AppendJoin(
                        ", ", 
                        FormatValues(routeEndpoint.RoutePattern.Defaults));
                    sb.Append(" }");
                    
                    var routeNameMetadata = routeEndpoint.Metadata
                        								 .GetMetadata<IRouteNameMetadata>();
                    sb.Append(", Route Name: ");
                    sb.Append(routeNameMetadata?.RouteName);
                    
                    var routeValues = routeEndpoint.RoutePattern.RequiredValues;
                    if (routeValues.Count > 0)
                    {
                        sb.Append(", Required Values: new { ");
                        sb.AppendJoin(", ", FormatValues(routeValues));
                        sb.Append(" }");
                    }
                    sb.Append(", Order: ");
                    sb.Append(routeEndpoint.Order);
                    
                    var httpMethodMetadata = routeEndpoint.Metadata
                        								  .GetMetadata<IHttpMethodMetadata>();
                    if (httpMethodMetadata != null)
                    {
                        sb.Append(", Http Methods: ");
                        sb.AppendJoin(", ", httpMethodMetadata.HttpMethods);
                    }
                    sb.Append(", Display Name: ");
                    sb.Append(routeEndpoint.DisplayName);
                    sb.AppendLine();
                }
                else
                {
                    sb.Append("Non-RouteEndpoint. DisplayName:");
                    sb.AppendLine(endpoint.DisplayName);
                }
            }
            return sb.ToString();
            
            IEnumerable<string> FormatValues(
                IEnumerable<KeyValuePair<string, object?>> values)
            {
                return values.Select(
                    kvp =>
                    {
                        var value = "null";
                        if (kvp.Value != null)
                        {
                            value = "\"" + kvp.Value.ToString() + "\"";
                        }
                        return kvp.Key + " = " + value;
                    });
            }
        }
    }
}

```

##### 2.3.5 data source dependent cache?

```c#
internal sealed class DataSourceDependentCache<T> : IDisposable where T : class
{
    private readonly EndpointDataSource _dataSource;
    private readonly Func<IReadOnlyList<Endpoint>, T> _initializeCore;
    private readonly Func<T> _initializer;
    private readonly Action<object> _initializerWithState;
    
    private object _lock;
    private bool _initialized;
    
    private IDisposable? _disposable;
    private bool _disposed;
    
    private T? _value;
    // Note that we don't lock here, and think about that in the context of a 'push'. So when data gets 'pushed'
    // we start computing a new state, but we're still able to perform operations on the old state until we've
    // processed the update.
    [NotNullIfNotNull(nameof(_value))]
    public T? Value => _value;
        
    public DataSourceDependentCache(EndpointDataSource dataSource, Func<IReadOnlyList<Endpoint>, T> initialize)
    {
        if (dataSource == null)
        {
            throw new ArgumentNullException(nameof(dataSource));
        }        
        if (initialize == null)
        {
            throw new ArgumentNullException(nameof(initialize));
        }
        
        // 注入 endpoint data source
        _dataSource = dataSource;
        // 注入 T 委托，from <endpoints> to T
        _initializeCore = initialize;
        
        _initializer = Initialize;
        _initializerWithState = (state) => Initialize();
        _lock = new object();
    }
    
    private T Initialize()
    {
        lock (_lock)
        {
            var changeToken = _dataSource.GetChangeToken();
            _value = _initializeCore(_dataSource.Endpoints);
            
            // Don't resubscribe if we're already disposed.
            if (_disposed)
            {
                return _value;
            }
            
            _disposable = changeToken.RegisterChangeCallback(_initializerWithState, null);
            return _value;
        }
    }
    
    [MemberNotNull(nameof(_value))]
    public T EnsureInitialized()
    {
        return LazyInitializer.EnsureInitialized<T>(ref _value, ref _initialized, ref _lock, _initializer);
    }
            
    public void Dispose()
    {
        lock (_lock)
        {
            if (!_disposed)
            {
                _disposable?.Dispose();
                _disposable = null;
                
                // Tracking whether we're disposed or not prevents a race-condition
                // between disposal and Initialize(). If a change callback fires after
                // we dispose, then we don't want to reregister.
                _disposed = true;
            }
        }
    }
}

```

### 3.  (endpoint) matcher

#### 3.1 endpoint selector

##### 3.1.1 抽象基类

```c#
public abstract class EndpointSelector
{    
    public abstract Task SelectAsync(
        HttpContext httpContext, 
        CandidateSet candidates);
}

```

###### 3.1.1.1 candidate set

```c#
public sealed class CandidateSet
{
    internal CandidateState[] Candidates;
    public int Count => Candidates.Length;        
    public ref CandidateState this[int index]
    {
        // Note that this is a ref-return because of performance.
        // We don't want to copy these fat structs if it can be avoided.        
        // PERF: Force inlining
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            // Friendliness for inlining
            if ((uint)index >= Count)
            {
                ThrowIndexArgumentOutOfRangeException();
            }
            
            return ref Candidates[index];
        }
    }
    
    /* 构造函数 */
    
    public CandidateSet(
        Endpoint[] endpoints, 
        RouteValueDictionary[] values, 
        int[] scores)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (values == null)
        {
            throw new ArgumentNullException(nameof(values));
        }        
        if (scores == null)
        {
            throw new ArgumentNullException(nameof(scores));
        }
        
        if (endpoints.Length != values.Length || 
            endpoints.Length != scores.Length)
        {
            throw new ArgumentException(
                $"The provided {nameof(endpoints)}, {nameof(values)}, and 
                "{nameof(scores)} must have the same length.");
        }
        
        Candidates = new CandidateState[endpoints.Length];
        for (var i = 0; i < endpoints.Length; i++)
        {
            Candidates[i] = new CandidateState(
                endpoints[i], 
                values[i], 
                scores[i]);
        }
    }
    
    // Used in tests.
    internal CandidateSet(Candidate[] candidates)
    {
        Candidates = new CandidateState[candidates.Length];
        for (var i = 0; i < candidates.Length; i++)
        {
            Candidates[i] = new CandidateState(
                candidates[i].Endpoint, 
                candidates[i].Score);
        }
    }
    
    internal CandidateSet(CandidateState[] candidates)
    {
        Candidates = candidates;
    }
    
    /* 方法 */    
            
    public bool IsValidCandidate(int index)
    {
        // Friendliness for inlining
        if ((uint)index >= Count)
        {
            ThrowIndexArgumentOutOfRangeException();
        }
        
        return IsValidCandidate(ref Candidates[index]);
    }
    
    internal static bool IsValidCandidate(ref CandidateState candidate)
    {
        return candidate.Score >= 0;
    }
        
    public void SetValidity(int index, bool value)
    {
        // Friendliness for inlining
        if ((uint)index >= Count)
        {
            ThrowIndexArgumentOutOfRangeException();
        }
        
        ref var original = ref Candidates[index];
        SetValidity(ref original, value);
    }
    
    internal static void SetValidity(
        ref CandidateState candidate, 
        bool value)
    {
        var originalScore = candidate.Score;
        
        var score = originalScore >= 0 ^ value 
            ? ~originalScore 
            : originalScore;
        
        candidate = new CandidateState(
            candidate.Endpoint, 
            candidate.Values, 
            score);
    }
        
    public void ReplaceEndpoint(
        int index, 
        Endpoint? endpoint, 
        RouteValueDictionary? values)
    {
        // Friendliness for inlining
        if ((uint)index >= Count)
        {
            ThrowIndexArgumentOutOfRangeException();
        }
        
        // CandidateState allows a null-valued endpoint. 
        // However a validate candidate should never have a null endpoint
        // We'll make lives easier for matcher policies by declaring it as non-null.
        Candidates[index] = new CandidateState(
            endpoint!, 
            values, 
            Candidates[index].Score);
        
        if (endpoint == null)
        {
            SetValidity(index, false);
        }
    }
        
    public void ExpandEndpoint(
        int index, 
        IReadOnlyList<Endpoint> endpoints, IComparer<Endpoint> comparer)
    {
        // Friendliness for inlining
        if ((uint)index >= Count)
        {
            ThrowIndexArgumentOutOfRangeException();
        }        
        if (endpoints == null)
        {
            ThrowArgumentNullException(nameof(endpoints));
        }        
        if (comparer == null)
        {
            ThrowArgumentNullException(nameof(comparer));
        }
        
        // First we need to verify that the score of what we're replacing is unique.
        ValidateUniqueScore(index);
        
        switch (endpoints.Count)
        {
            case 0:
                ReplaceEndpoint(index, null, null);
                break;
                
            case 1:
                ReplaceEndpoint(index, endpoints[0], Candidates[index].Values);
                break;
                
            default:
                
                var score = GetOriginalScore(index);
                var values = Candidates[index].Values;
                
                // Adding candidates requires expanding the array and computing 
                // new score values for the new candidates.
                var original = Candidates;
                var candidates = new CandidateState[original.Length - 1 + endpoints.Count];
                Candidates = candidates;
                
                // Since the new endpoints have an unknown ordering relationship to 
                // each other, we need to:
                // - order them
                // - assign scores
                // - offset everything that comes after
                //
                // If the inputs look like:
                //
                // score 0: A1
                // score 0: A2
                // score 1: B
                // score 2: C <-- being expanded
                // score 3: D
                //
                // Then the result should look like:
                //
                // score 0: A1
                // score 0: A2
                // score 1: B
                // score 2: `C1
                // score 3: `C2
                // score 4: D
                
                // Candidates before index can be copied unchanged.
                for (var i = 0; i < index; i++)
                {
                    candidates[i] = original[i];
                }
                
                var buffer = endpoints.ToArray();
                Array.Sort<Endpoint>(buffer, comparer);
                
                // Add the first new endpoint with the current score
                candidates[index] = new CandidateState(buffer[0], values, score);
                
                var scoreOffset = 0;
                for (var i = 1; i < buffer.Length; i++)
                {
                    var cmp = comparer.Compare(buffer[i - 1], buffer[i]);
                    
                    // This should not be possible. This would mean that sorting is wrong.
                    Debug.Assert(cmp <= 0);
                    if (cmp == 0)
                    {
                        // Score is unchanged.
                    }
                    else if (cmp < 0)
                    {
                        // Endpoint is lower priority, higher score.
                        scoreOffset++;
                    }
                    
                    Candidates[i + index] = new CandidateState(
                        buffer[i], 
                        values, 
                        score + scoreOffset);
                }
                
                for (var i = index + 1; i < original.Length; i++)
                {
                    Candidates[i + endpoints.Count - 1] = new CandidateState(
                        original[i].Endpoint, 
                        original[i].Values, 
                        original[i].Score + scoreOffset);
                }
                
                break;
                
        }
    }
    
    // Returns the *positive* score value. 
    // Score is used to track valid/invalid which can cause it to be negative.
    //
    // This is the original score and used to determine if there are ambiguities.
    private int GetOriginalScore(int index)
    {
        var score = Candidates[index].Score;
        return score >= 0 ? score : ~score;
    }
    
    private void ValidateUniqueScore(int index)
    {
        var score = GetOriginalScore(index);
        
        var count = 0;
        var candidates = Candidates;
        for (var i = 0; i < candidates.Length; i++)
        {
            if (GetOriginalScore(i) == score)
            {
                count++;
            }
        }
        
        Debug.Assert(count > 0);
        if (count > 1)
        {
            // Uh-oh. We don't allow duplicates with ExpandEndpoint because that 
            // will do unpredictable things.
            var duplicates = new List<Endpoint>();
            for (var i = 0; i < candidates.Length; i++)
            {
                if (GetOriginalScore(i) == score)
                {
                    duplicates.Add(candidates[i].Endpoint!);
                }
            }
            
            var message =
                    $"Using {nameof(ExpandEndpoint)} requires that the replaced 
                	"endpoint have a unique priority. " +
                    $"The following endpoints were found with the same priority:" + 
                	Environment.NewLine +
                    string.Join(
                		Environment.NewLine, 
                		duplicates.Select(e => e.DisplayName));
            
            throw new InvalidOperationException(message);
        }
    }
    
    [DoesNotReturn]
    private static void ThrowIndexArgumentOutOfRangeException()
    {
        throw new ArgumentOutOfRangeException("index");
    }
    
    [DoesNotReturn]
    private static void ThrowArgumentNullException(string parameter)
    {
        throw new ArgumentNullException(parameter);
    }
}

```

###### 3.1.1.2 candidate state

```c#
public struct CandidateState
{
    public Endpoint Endpoint { get; }    
    public int Score { get; }        
    public RouteValueDictionary? Values { get; internal set; }
    
    internal CandidateState(
        Endpoint endpoint, 
        int score)
    {
        Endpoint = endpoint;
        Score = score;
        Values = null;
    }
    
    internal CandidateState(
        Endpoint endpoint, 
        RouteValueDictionary? values, 
        int score)
    {
        Endpoint = endpoint;
        Values = values;
        Score = score;
    }                    
}

```

##### 3.1.2 default endpoint selector

* 按照 score 挑选 endpoint（score 最高的）

```c#
internal sealed class DefaultEndpointSelector : EndpointSelector
{
    public override Task SelectAsync(
        HttpContext httpContext,
        CandidateSet candidateSet)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }        
        if (candidateSet == null)
        {
            throw new ArgumentNullException(nameof(candidateSet));
        }
        
        Select(httpContext, candidateSet.Candidates);
        return Task.CompletedTask;
    }
    
    internal static void Select(
        HttpContext httpContext, 
        CandidateState[] candidateState)
    {
        // Fast path: We can specialize for trivial numbers of candidates 
        // since there can be no ambiguities
        switch (candidateState.Length)
        {
            case 0:
                {
                    /* 没有 candidate */
                    // Do nothing
                    break;
                }                
            case 1:
                {
                    /* 只有1个 candidate，*/
                    // 验证 validate，如果 valid，注入 http context
                    ref var state = ref candidateState[0];
                    if (CandidateSet.IsValidCandidate(ref state))
                    {
                        httpContext.SetEndpoint(state.Endpoint);
                        httpContext.Request.RouteValues = state.Values!;
                    }
                    
                    break;
                }                
            default:
                {
                    /* 多个 candidate */
                    // Slow path: 
                    //   There's more than one candidate (to say nothing of validity) 
                    //   so we have to process for ambiguities.
                    ProcessFinalCandidates(httpContext, candidateState);
                    break;
                }
        }
    }   
        
    private static void ProcessFinalCandidates(
        HttpContext httpContext,
        CandidateState[] candidateState)
    {
        // 初始化，置 null
        Endpoint? endpoint = null;
        RouteValueDictionary? values = null;
        int? foundScore = null;
        
        // 遍历 candidate state 集合，
        // 按 score 查找 endpoint（score 较小的）       
        for (var i = 0; i < candidateState.Length; i++)
        {
            ref var state = ref candidateState[i];
            
            if (!CandidateSet.IsValidCandidate(ref state))
            {
                continue;
            }
            
            if (foundScore == null)
            {
                // This is the first match we've seen - speculatively assign it.
                endpoint = state.Endpoint;
                values = state.Values;
                foundScore = state.Score;
            }
            else if (foundScore < state.Score)
            {
                // This candidate is lower priority than the one we've seen
                // so far, we can stop.
                //
                // Don't worry about the 'null < state.Score' case, it returns false.
                break;
            }
            else if (foundScore == state.Score)
            {
                // This is the second match we've found of the same score, so there
                // must be an ambiguity.
                //
                // Don't worry about the 'null == state.Score' case, it returns false.
                
                ReportAmbiguity(candidateState);
                
                // Unreachable, ReportAmbiguity always throws.
                throw new NotSupportedException();
            }
        }
        
        // 向 http context 注入 endpoint 和 route value dictionary
        if (endpoint != null)
        {
            httpContext.SetEndpoint(endpoint);
            httpContext.Request.RouteValues = values!;
        }
    }
    
    private static void ReportAmbiguity(CandidateState[] candidateState)
    {
        // If we get here it's the result of an ambiguity - we're OK with this
        // being a littler slower and more allocatey.
        var matches = new List<Endpoint>();
        for (var i = 0; i < candidateState.Length; i++)
        {
            ref var state = ref candidateState[i];
            if (CandidateSet.IsValidCandidate(ref state))
            {
                matches.Add(state.Endpoint);
            }
        }
        
        var message = Resources.FormatAmbiguousEndpoints(
            Environment.NewLine,
            string.Join(
                Environment.NewLine, 
                matches.Select(e => e.DisplayName)));
        
        throw new AmbiguousMatchException(message);
    }
}

```

#### 3.2 dfa state

```c#
[DebuggerDisplay("{DebuggerToString(),nq}")]
internal readonly struct DfaState
{
    // candidate 集合
    public readonly Candidate[] Candidates;
    // endpoint selectory
    public readonly IEndpointSelectorPolicy[] Policies;
    // path jump
    public readonly JumpTable PathTransitions;
    // policy jump
    public readonly PolicyJumpTable PolicyTransitions;
    
    public DfaState(        
        Candidate[] candidates,
        IEndpointSelectorPolicy[] policies,
        JumpTable pathTransitions,
        PolicyJumpTable policyTransitions)
    {
        Candidates = candidates;
        Policies = policies;
        PathTransitions = pathTransitions;
        PolicyTransitions = policyTransitions;
    }
    
    public string DebuggerToString()
    {
        return
            $"matches: {Candidates?.Length ?? 0}, " +
            $"path: ({PathTransitions?.DebuggerToString()}), " +
            $"policy: ({PolicyTransitions?.DebuggerToString()})";
    }
}

```

##### 3.2.1 candidate

```c#
internal readonly struct Candidate
{
    public readonly Endpoint Endpoint;        
    public readonly CandidateFlags Flags;
    public readonly int Score;

    // for defaults
    public readonly KeyValuePair<string, object>[] Slots;    
    // List of parameters to capture.     
    public readonly (string parameterName, int segmentIndex, int slotIndex)[] Captures;    
    // Catchall parameter to capture (limit one per template).
    public readonly (string parameterName, int segmentIndex, int slotIndex) CatchAll;    
    // Complex segments 
    public readonly (RoutePatternPathSegment pathSegment, int segmentIndex)[] ComplexSegments;
    // constraints
    public readonly KeyValuePair<string, IRouteConstraint>[] Constraints;
       
    public Candidate(Endpoint endpoint)
    {
        Endpoint = endpoint;
        
        Slots = Array.Empty<KeyValuePair<string, object>>();
        Captures = Array.Empty<(string parameterName, int segmentIndex, int slotIndex)>();
        CatchAll = default;
        ComplexSegments = Array.Empty<(
            RoutePatternPathSegment pathSegment, int segmentIndex)>();
        Constraints = Array.Empty<KeyValuePair<string, IRouteConstraint>>();
        Score = 0;        
        Flags = CandidateFlags.None;
    }
    
    public Candidate(
        Endpoint endpoint,
        int score,
        KeyValuePair<string, object>[] slots,
        (string parameterName, int segmentIndex, int slotIndex)[] captures,
        in (string parameterName, int segmentIndex, int slotIndex) catchAll,
        (RoutePatternPathSegment pathSegment, int segmentIndex)[] complexSegments,
        KeyValuePair<string, IRouteConstraint>[] constraints)
    {
        Endpoint = endpoint;
        Score = score;
        
        Slots = slots;
        Captures = captures;
        CatchAll = catchAll;
        ComplexSegments = complexSegments;
        Constraints = constraints;
        
        Flags = CandidateFlags.None;
        
        /* 设置 flags */
        for (var i = 0; i < slots.Length; i++)
        {
            if (slots[i].Key != null)
            {
                Flags |= CandidateFlags.HasDefaults;
            }
        }        
        if (captures.Length > 0)
        {
            Flags |= CandidateFlags.HasCaptures;
        }        
        if (catchAll.parameterName != null)
        {
            Flags |= CandidateFlags.HasCatchAll;
        }        
        if (complexSegments.Length > 0)
        {
            Flags |= CandidateFlags.HasComplexSegments;
        }        
        if (constraints.Length > 0)
        {
            Flags |= CandidateFlags.HasConstraints;
        }
    }  
    
    [Flags]
    public enum CandidateFlags
    {
        None = 0,
        HasDefaults = 1,
        HasCaptures = 2,
        HasCatchAll = 4,
        HasSlots = HasDefaults | HasCaptures | HasCatchAll,
        HasComplexSegments = 8,
        HasConstraints = 16,
    }
}

```

##### 3.2.2 endpoint selector policy

```c#
public interface IEndpointSelectorPolicy
{    
    bool AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints);        
    Task ApplyAsync(HttpContext httpContext, CandidateSet candidates);
}

```

##### 3.2.3 jump table

```c#
[DebuggerDisplay("{DebuggerToString(),nq}")]
internal abstract class JumpTable
{
    public abstract int GetDestination(
        string path, 
        PathSegment segment);
    
    public virtual string DebuggerToString()
    {
        return GetType().Name;
    }
}

```

###### 3.2.3.1 single entry jump table

```c#
internal class SingleEntryJumpTable : JumpTable
{
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    private readonly string _text;
    private readonly int _destination;
    
    public SingleEntryJumpTable(
        int defaultDestination,            
        int exitDestination,
        string text,
        int destination)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
        _text = text;
        _destination = destination;
    }
    
    public override int GetDestination(string path, PathSegment segment)
    {
        if (segment.Length == 0)
        {
            return _exitDestination;
        }
        
        if (segment.Length == _text.Length &&
            string.Compare(
                path,
                segment.Start,
                _text,
                0,
                segment.Length,
                StringComparison.OrdinalIgnoreCase) == 0)
        {
            return _destination;
        }
        
        return _defaultDestination;
    }
    
    public override string DebuggerToString()
    {
        return $"{{ {_text}: {_destination}, 
            "$+: {_defaultDestination}, $0: {_exitDestination} }}";
    }
}

```

###### 3.2.3.2 single entry ascii jump table

```c#
internal class SingleEntryAsciiJumpTable : JumpTable
{
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    private readonly string _text;
    private readonly int _destination;
    
    public SingleEntryAsciiJumpTable(
        int defaultDestination,
        int exitDestination,
        string text,
        int destination)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
        _text = text;
        _destination = destination;
    }
    
    public unsafe override int GetDestination(
        string path, 
        PathSegment segment)
    {
        var length = segment.Length;
        if (length == 0)
        {
            return _exitDestination;
        }
        
        var text = _text;
        if (length != text.Length)
        {
            return _defaultDestination;
        }
        
        var a = path.AsSpan(segment.Start, length);
        var b = text.AsSpan();
        
        return Ascii.AsciiIgnoreCaseEquals(a, b, length) 
            ? _destination 
            : _defaultDestination;
    }
    
    public override string DebuggerToString()
    {
        return $"{{ {_text}: {_destination}, 
            "$+: {_defaultDestination}, $0: {_exitDestination} }}";
    }
}

```

###### 3.2.3.3 dictionary jump table

```c#
internal class DictionaryJumpTable : JumpTable
{
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    private readonly Dictionary<string, int> _dictionary;
    
    public DictionaryJumpTable(
        int defaultDestination,
        int exitDestination,
        (string text, int destination)[] entries)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
        
        _dictionary = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        for (var i = 0; i < entries.Length; i++)
        {
            _dictionary.Add(entries[i].text, entries[i].destination);
        }
    }
    
    public override int GetDestination(string path, PathSegment segment)
    {
        if (segment.Length == 0)
        {
            return _exitDestination;
        }
        
        var text = path.Substring(segment.Start, segment.Length);
        if (_dictionary.TryGetValue(text, out var destination))
        {
            return destination;
        }
        
        return _defaultDestination;
    }
    
    public override string DebuggerToString()
    {
        var builder = new StringBuilder();
        builder.Append("{ ");
        
        builder.AppendJoin(
            ", ", 
            _dictionary.Select(kvp => $"{kvp.Key}: {kvp.Value}"));
        
        builder.Append("$+: ");
        builder.Append(_defaultDestination);
        builder.Append(", ");
        
        builder.Append("$0: ");
        builder.Append(_defaultDestination);
        
        builder.Append(" }");
        
        
        return builder.ToString();
    }
}

```

###### 3.2.3.4 linear search jump table

```c#
internal class LinearSearchJumpTable : JumpTable
{
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    private readonly (string text, int destination)[] _entries;
    
    public LinearSearchJumpTable(
        int defaultDestination,
        int exitDestination,
        (string text, int destination)[] entries)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
        _entries = entries;
    }
    
    public override int GetDestination(string path, PathSegment segment)
    {
        if (segment.Length == 0)
        {
            return _exitDestination;
        }
        
        var entries = _entries;
        for (var i = 0; i < entries.Length; i++)
        {
            var text = entries[i].text;
            if (segment.Length == text.Length &&
                string.Compare(
                    path,
                    segment.Start,
                    text,
                    0,
                    segment.Length,
                    StringComparison.OrdinalIgnoreCase) == 0)
            {
                return entries[i].destination;
            }
        }
        
        return _defaultDestination;
    }
    
    public override string DebuggerToString()
    {
        var builder = new StringBuilder();
        builder.Append("{ ");
        
        builder.AppendJoin(", ", _entries.Select(e => $"{e.text}: {e.destination}"));
        
        builder.Append("$+: ");
        builder.Append(_defaultDestination);
        builder.Append(", ");
        
        builder.Append("$0: ");
        builder.Append(_defaultDestination);
        
        builder.Append(" }");
        
        return builder.ToString();
    }
}

```

###### 3.2.3.5 il emit trie jump table

```c#
internal class ILEmitTrieJumpTable : JumpTable
{
    private const int NotAscii = int.MinValue;
    
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    private readonly (string text, int destination)[] _entries;
    
    private readonly bool? _vectorize;
    private readonly JumpTable _fallback;
    
    // Used to protect the initialization of the compiled delegate
    private object _lock;
    private bool _initializing;
    private Task _task;
    
    // Will be replaced at runtime by the generated code.
    //
    // Internal for testing
    internal Func<string, PathSegment, int> _getDestination;
    
    public ILEmitTrieJumpTable(
        int defaultDestination,
        int exitDestination,
        (string text, int destination)[] entries,
        bool? vectorize,
        JumpTable fallback)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
        _entries = entries;
        _vectorize = vectorize;
        _fallback = fallback;
        
        _getDestination = FallbackGetDestination;
    }
    
    public override int GetDestination(string path, PathSegment segment)
    {
        return _getDestination(path, segment);
    }
    
    // Used when we haven't yet initialized the IL trie. We defer compilation of the IL 
    // for startup performance.
    private int FallbackGetDestination(string path, PathSegment segment)
    {
        if (path.Length == 0)
        {
            return _exitDestination;
        }
        
        // We only hit this code path if the IL delegate is still initializing.
        LazyInitializer.EnsureInitialized(
            ref _task, 
            ref _initializing, 
            ref _lock, 
            InitializeILDelegateAsync);
        
        return _fallback.GetDestination(path, segment);
    }
    
    // Internal for testing
    internal async Task InitializeILDelegateAsync()
    {
        // Offload the creation of the IL delegate to the thread pool.
        await Task.Run(() =>
                       {
                           InitializeILDelegate();
                       });
    }
    
    // Internal for testing
    internal void InitializeILDelegate()
    {
        var generated = ILEmitTrieFactory.Create(
            _defaultDestination, 
            _exitDestination, 
            _entries, 
            _vectorize);
        
        _getDestination = (string path, PathSegment segment) =>
        {
            if (segment.Length == 0)
            {
                return _exitDestination;
            }
            
            var result = generated(path, segment.Start, segment.Length);
            if (result == ILEmitTrieFactory.NotAscii)
            {
                result = _fallback.GetDestination(path, segment);
            }
            
            return result;
        };
    }
}

```

###### 3.2.3.6 zero jump table

```c#
internal class ZeroEntryJumpTable : JumpTable
{
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    
    public ZeroEntryJumpTable(int defaultDestination, int exitDestination)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
    }
    
    public override int GetDestination(string path, PathSegment segment)
    {
        return segment.Length == 0 ? _exitDestination : _defaultDestination;
    }
    
    public override string DebuggerToString()
    {
        return $"{{ $+: {_defaultDestination}, $0: {_exitDestination} }}";
    }
}

```

###### 3.2.3.7 jump table builder

```c#
internal static class JumpTableBuilder
{
    public static readonly int InvalidDestination = -1;
    
    public static JumpTable Build(
        int defaultDestination, 
        int exitDestination, 
        (string text, int destination)[] pathEntries)
    {
        if (defaultDestination == InvalidDestination)
        {
            var message = 
                $"{nameof(defaultDestination)} is not set. Please report this as a bug.";
            
            throw new InvalidOperationException(message);
        }
        
        if (exitDestination == InvalidDestination)
        {
            var message = 
                $"{nameof(exitDestination)} is not set. Please report this as a bug.";
            
            throw new InvalidOperationException(message);
        }
        
        // The JumpTable implementation is chosen based on the number of entries.
        //
        // Basically the concerns that we're juggling here are that different implementations
        // make sense depending on the characteristics of the entries.
        //
        // On netcoreapp we support IL generation of optimized tries that is much faster
        // than anything we can do with string.Compare or dictionaries. However the IL emit
        // strategy requires us to produce a fallback jump table - see comments on the class.
        //
        // We have an optimized fast path for zero entries since we don't have to
        // do any string comparisons.
        if (pathEntries == null || pathEntries.Length == 0)
        {
            return new ZeroEntryJumpTable(defaultDestination, exitDestination);
        }
        
        // The IL Emit jump table is not faster for a single entry - but we have an 
        // optimized version when all text is ASCII
        if (pathEntries.Length == 1 && Ascii.IsAscii(pathEntries[0].text))
        {
            var entry = pathEntries[0];
            return new SingleEntryAsciiJumpTable(
                defaultDestination, 
                exitDestination, 
                entry.text, 
                entry.destination);
        }
        
        // We have a fallback that works for non-ASCII
        if (pathEntries.Length == 1)
        {
            var entry = pathEntries[0];
            return new SingleEntryJumpTable(
                defaultDestination, 
                exitDestination, 
                entry.text, 
                entry.destination);
        }
        
        // We choose a hard upper bound of 100 as the limit for when we switch to a dictionary
        // over a trie. The reason is that while the dictionary has a bigger constant factor,
        // it is O(1) vs a trie which is O(M * log(N)). Our perf testing shows that the trie
        // is better for ~90 entries based on all of Azure's route table. Anything above 
        // 100 edges we'd consider to be a very very large node, and so while we don't think 
        // anyone will have a node this large in practice, we want to make sure the 
        // performance is reasonable for any size.
        //
        // Additionally if we're on 32bit, the scalability is worse, so switch to the 
        // dictionary at 50 entries.
        var threshold = IntPtr.Size == 8 ? 100 : 50;
        if (pathEntries.Length >= threshold)
        {
            return new DictionaryJumpTable(
                defaultDestination, 
                exitDestination, 
                pathEntries);
        }
        
        // If we have more than a single string, the IL emit strategy is the fastest - but 
        // we need to decide what do for the fallback case.
        JumpTable fallback;
        
        // Based on our testing a linear search is still faster than a dictionary at ten 
        // entries.
        if (pathEntries.Length <= 10)
        {
            fallback = new LinearSearchJumpTable(
                defaultDestination, 
                exitDestination, 
                pathEntries);
        }
        else
        {
            fallback = new DictionaryJumpTable(
                defaultDestination, 
                exitDestination, 
                pathEntries);
        }
        
        // Use the ILEmitTrieJumpTable if the IL is going to be compiled (not interpreted)
        if (RuntimeFeature.IsDynamicCodeCompiled)
        {
            return new ILEmitTrieJumpTable(
                defaultDestination, 
                exitDestination, 
                pathEntries, 
                vectorize: null, 
                fallback);
        }
        
        return fallback;
    }
}

```



##### 3.2.4 policy jump table

```c#
public abstract class PolicyJumpTable
{    
    public abstract int GetDestination(HttpContext httpContext);
    
    internal virtual string DebuggerToString()
    {
        return GetType().Name;
    }
}

```

###### 3.2.4.1 http method single entry policy jump table

```c#
internal sealed class HttpMethodSingleEntryPolicyJumpTable : PolicyJumpTable
{
    private readonly int _exitDestination;
    private readonly string _method;
    private readonly int _destination;
    private readonly int _corsPreflightExitDestination;
    private readonly int _corsPreflightDestination;
    
    private readonly bool _supportsCorsPreflight;
    
    public HttpMethodSingleEntryPolicyJumpTable(
        int exitDestination,
        string method,
        int destination,
        bool supportsCorsPreflight,
        int corsPreflightExitDestination,
        int corsPreflightDestination)
    {
        _exitDestination = exitDestination;
        _method = method;
        _destination = destination;
        _supportsCorsPreflight = supportsCorsPreflight;
        _corsPreflightExitDestination = corsPreflightExitDestination;
        _corsPreflightDestination = corsPreflightDestination;
    }
    
    public override int GetDestination(HttpContext httpContext)
    {
        var httpMethod = httpContext.Request.Method;
        if (_supportsCorsPreflight && 
            HttpMethodMatcherPolicy.IsCorsPreflightRequest(
                httpContext, 
                httpMethod, 
                out var accessControlRequestMethod))
        {
            return HttpMethods.Equals(accessControlRequestMethod, _method) 
                ? _corsPreflightDestination 
                : _corsPreflightExitDestination;
        }
        
        return HttpMethods.Equals(httpMethod, _method) 
            ? _destination 
            : _exitDestination;
    }
}

```

###### 3.2.4.2 http method dictionary entry jump table

```c#
internal sealed class HttpMethodDictionaryPolicyJumpTable : PolicyJumpTable
{
    private readonly int _exitDestination;
    private readonly Dictionary<string, int>? _destinations;
    private readonly int _corsPreflightExitDestination;
    private readonly Dictionary<string, int>? _corsPreflightDestinations;
    
    private readonly bool _supportsCorsPreflight;
    
    public HttpMethodDictionaryPolicyJumpTable(
        int exitDestination,
        Dictionary<string, int>? destinations,
        int corsPreflightExitDestination,
        Dictionary<string, int>? corsPreflightDestinations)
    {
        _exitDestination = exitDestination;
        _destinations = destinations;
        _corsPreflightExitDestination = corsPreflightExitDestination;
        _corsPreflightDestinations = corsPreflightDestinations;
        
        _supportsCorsPreflight = _corsPreflightDestinations != null && _corsPreflightDestinations.Count > 0;
    }
    
    public override int GetDestination(HttpContext httpContext)
    {
        int destination;
        
        var httpMethod = httpContext.Request.Method;
        if (_supportsCorsPreflight && 
            HttpMethodMatcherPolicy.IsCorsPreflightRequest(
                httpContext, 
                httpMethod, 
                out var accessControlRequestMethod))
        {
            return _corsPreflightDestinations!.TryGetValue(accessControlRequestMethod, out destination)
                ? destination
                : _corsPreflightExitDestination;
        }
        
        return _destinations != null && _destinations.TryGetValue(httpMethod, out destination) 
            ? destination 
            : _exitDestination;
    }
}

```



#### 3.3 matcher

##### 3.3.1 抽象

###### 3.3.1.1 matcher

```c#
internal abstract class Matcher
{        
    public abstract Task MatchAsync(HttpContext httpContext);
}

```

###### 3.3.1.2 matcher builder

```c#
internal abstract class MatcherBuilder
{
    public abstract void AddEndpoint(RouteEndpoint endpoint);   
    public abstract Matcher Build();
}

```

###### 3.3.1.3 matcher factory

```c#
internal abstract class MatcherFactory
{
    public abstract Matcher CreateMatcher(EndpointDataSource dataSource);
}

```

##### 3.3.2 dfa matcher

```c#
internal sealed class DfaMatcher : Matcher
{
    private readonly ILogger _logger;
    private readonly EndpointSelector _selector;
    private readonly DfaState[] _states;
    
    private readonly int _maxSegmentCount;    
    private readonly bool _isDefaultEndpointSelector;
    
    public DfaMatcher(
        ILogger<DfaMatcher> logger, 
        EndpointSelector selector,
        DfaState[] states, 
        int maxSegmentCount)
    {          
        _logger = logger;
        // 注入 endpoint selector
        _selector = selector;
        // 注入 dfa state 集合
        _states = states;
        _maxSegmentCount = maxSegmentCount;
        
        // 标记 endpoint selector 是否是 default endpoint selector
        _isDefaultEndpointSelector = selector is DefaultEndpointSelector;
    }     
       
    internal static class EventIds
    {
        public static readonly EventId CandidatesNotFound = 
            new EventId(1000, "CandidatesNotFound");
        public static readonly EventId CandidatesFound = 
            new EventId(1001, "CandidatesFound");        
        public static readonly EventId CandidateRejectedByComplexSegment = 
            new EventId(1002, "CandidateRejectedByComplexSegment");
        public static readonly EventId CandidateRejectedByConstraint = 
            new EventId(1003, "CandidateRejectedByConstraint");        
        public static readonly EventId CandidateNotValid = 
            new EventId(1004, "CandiateNotValid");
        public static readonly EventId CandidateValid = 
            new EventId(1005, "CandiateValid");
    }
    
    #nullable disable
    private static class Logger
    {
        private static readonly Action<ILogger, string, Exception> 
            _candidatesNotFound = LoggerMessage.Define<string>(
            	LogLevel.Debug,
            	EventIds.CandidatesNotFound,
	            "No candidates found for the request path '{Path}'");
        
        private static readonly Action<ILogger, int, string, Exception> 
            _candidatesFound = LoggerMessage.Define<int, string>(
            	LogLevel.Debug,
	            EventIds.CandidatesFound,
    	        "{CandidateCount} candidate(s) found for the request path '{Path}'");
        
        private static readonly Action<ILogger, string, string, string, string, Exception> 
            _candidateRejectedByComplexSegment = 
            	LoggerMessage.Define<string, string, string, string>(
            		LogLevel.Debug,
		            EventIds.CandidateRejectedByComplexSegment,
		            "Endpoint '{Endpoint}' with route pattern '{RoutePattern}' was rejected by complex segment '{Segment}' for the request path '{Path}'");
        
        private static readonly 
            Action<ILogger, string, string, string, string, object, string, Exception> 
            	_candidateRejectedByConstraint = 
            		LoggerMessage.Define<string, string, string, string, object, string>(
			            LogLevel.Debug,
            			EventIds.CandidateRejectedByConstraint,
			            "Endpoint '{Endpoint}' with route pattern '{RoutePattern}' was rejected by constraint '{ConstraintName}':'{Constraint}' with value '{RouteValue}' for the request path '{Path}'");
        
        private static readonly Action<ILogger, string, string, string, Exception> 
            _candidateNotValid = LoggerMessage.Define<string, string, string>(
            	LogLevel.Debug,
	            EventIds.CandidateNotValid,
    	        "Endpoint '{Endpoint}' with route pattern '{RoutePattern}' is not valid for the request path '{Path}'");
        
        private static readonly Action<ILogger, string, string, string, Exception> 
            _candidateValid = LoggerMessage.Define<string, string, string>(
            	LogLevel.Debug,
            	EventIds.CandidateValid,
	            "Endpoint '{Endpoint}' with route pattern '{RoutePattern}' is valid for the request path '{Path}'");
        
        public static void CandidatesNotFound(
            ILogger logger, 
            string path)
        {
            _candidatesNotFound(logger, path, null);
        }
        
        public static void CandidatesFound(
            ILogger logger, 
            string path, 
            Candidate[] candidates)
        {
            _candidatesFound(logger, candidates.Length, path, null);
        }
        
        public static void CandidateRejectedByComplexSegment(
            ILogger logger, 
            string path, 
            Endpoint endpoint, 
            RoutePatternPathSegment segment)
        {
            // This should return a real pattern 
            // since we're processing complex segments.... but just in case.
            if (logger.IsEnabled(LogLevel.Debug))
            {
                var routePattern = GetRoutePattern(endpoint);
                _candidateRejectedByComplexSegment(
                    logger, 
                    endpoint.DisplayName, 
                    routePattern, 
                    segment.DebuggerToString(), 
                    path, 
                    null);
            }
        }
        
        public static void CandidateRejectedByConstraint(
            ILogger logger, 
            string path, 
            Endpoint endpoint, 
            string constraintName, 
            IRouteConstraint constraint, 
            object value)
        {
            // This should return a real pattern 
            // since we're processing constraints.... but just in case.
            if (logger.IsEnabled(LogLevel.Debug))
            {
                var routePattern = GetRoutePattern(endpoint);
                _candidateRejectedByConstraint(
                    logger, 
                    endpoint.DisplayName, 
                    routePattern, 
                    constraintName, 
                    constraint.ToString(), 
                    value, 
                    path, 
                    null);
            }
        }
        
        public static void CandidateNotValid(
            ILogger logger, 
            string path, 
            Endpoint endpoint)
        {
            // This can be the fallback value because it really might not be a route endpoint
            if (logger.IsEnabled(LogLevel.Debug))
            {
                var routePattern = GetRoutePattern(endpoint);
                _candidateNotValid(
                    logger, 
                    endpoint.DisplayName, 
                    routePattern, 
                    path, 
                    null);
            }
        }
        
        public static void CandidateValid(
            ILogger logger, 
            string path, 
            Endpoint endpoint)
        {
            // This can be the fallback value because it really might not be a route endpoint
            if (logger.IsEnabled(LogLevel.Debug))
            {
                var routePattern = GetRoutePattern(endpoint);
                _candidateValid(
                    logger, 
                    endpoint.DisplayName, 
                    routePattern, 
                    path, 
                    null);
            }
        }
        
        private static string GetRoutePattern(Endpoint endpoint)
        {
            return (endpoint as RouteEndpoint)
                ?.RoutePattern
                ?.RawText 
                ?? "(none)";
        }
    }
}

```

###### 3.3.2.1 match

```c#
internal sealed class DfaMatcher : Matcher
{
    public sealed override Task MatchAsync(HttpContext httpContext)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
                
        var log = _logger.IsEnabled(LogLevel.Debug);     
        
        // 解析 http request path 到 segments 
        var path = httpContext.Request.Path.Value!;                               
        Span<PathSegment> buffer = stackalloc PathSegment[_maxSegmentCount];        
        var count = FastPathTokenizer.Tokenize(path, buffer);
        var segments = buffer.Slice(0, count);                 
        
        // 解析 candicate、policy 集合
        var (candidates, policies) = FindCandidateSet(httpContext, path, segments);
        
        /* a- 如果 candidate 为空，即没找到适合的 candidate，*/
        // -> 没找到，记录日志，返回
        var candidateCount = candidates.Length;
        if (candidateCount == 0)
        {
            if (log)
            {
                Logger.CandidatesNotFound(_logger, path);
            }
            
            return Task.CompletedTask;
        }
        
        // （找到了 candidate），-> 记录日志
        if (log)
        {
            Logger.CandidatesFound(_logger, path, candidates);
        }
               
        /* b- 如果只有 1 个 candidate、没有 endpoint selector policy、且使用 default endpoint selector，*/
        var policyCount = policies.Length;                
        if (candidateCount == 1 && 
            policyCount == 0 && 
            _isDefaultEndpointSelector)
        {
            // 解析 candidate，
            ref readonly var candidate = ref candidates[0];            
           
            // 如果 candidate flag = none，即 candidate 匹配 request path，没有 route value，
            // -> 向 http context 注入 candidate 的 endpoint，返回
            if (candidate.Flags == Candidate.CandidateFlags.None)
            {
                httpContext.SetEndpoint(candidate.Endpoint);                                
                return Task.CompletedTask;
            }
        }
                                        
        /* c- 至此，由多个 candidate，
        	  或者有 1 个 candidate 并且具有没有处理的 value（candidate flag != none)
        	  或者有 1 个 candidate 并且有 policy selector policy */      
        
        /* c1- 处理 candidate（解析 default、*/
        
        var candidateState = new CandidateState[candidateCount];        
        // 遍历 candidate，        
        for (var i = 0; i < candidateCount; i++)
        {       
            // 解析 candidate，
            ref readonly var candidate = ref candidates[i];
            // 创建 candidate state，封装对应 candidate 的 endpoint、score
            ref var state = ref candidateState[i];
            state = new CandidateState(candidate.Endpoint, candidate.Score);
            
            /*根据 candidate flag 处理 candidate ... */
            var flags = candidate.Flags;
                                   
            /* 1st- 处理 candidate 中的 default value、parameter value (capture 和 catch all) */
            // 如果 candidate 包含 slot
            if ((flags & Candidate.CandidateFlags.HasSlots) != 0)
            {
                // 获取 candidate 的 slots（引用原型）
                var prototype = candidate.Slots;
                // 目标 slots（kv pair）
                var slots = new KeyValuePair<string, object?>[prototype.Length];
                
                // 如果 candidate 包含 default（candidate 的 flag 标记了 HasDefault），
                // -> 复制 proto slots 到目标 slots
                if ((flags & Candidate.CandidateFlags.HasDefaults) != 0)
                {
                    Array.Copy(prototype, 0, slots, 0, prototype.Length);
                }
                
                // 如果 candidate 包含 capture（candidate 的 flag 标记了 HasCaptures），
                // 使用 process captures
                if ((flags & Candidate.CandidateFlags.HasCaptures) != 0)
                {
                    ProcessCaptures(slots, candidate.Captures, path, segments);
                }
                
                // 如果 candidate 包含 catch all（candidate 的 flag 标记了 HasCatchAll），
                // 使用 process catch all
                if ((flags & Candidate.CandidateFlags.HasCatchAll) != 0)
                {
                    ProcessCatchAll(slots, candidate.CatchAll, path, segments);
                }
                
                // 将处理后的 slot 注回到 candidate state 中
                state.Values = RouteValueDictionary.FromArray(slots);
            }
                        
            /* 2nd- 处理 candidate 中的 complex segment、constraint */
            var isMatch = true;            
            // 如果 candidate 包含 complex segment（candidate 的 flag 标记了 HasComplexSegment），
            if ((flags & Candidate.CandidateFlags.HasComplexSegments) != 0)
            {
                // 调用 process complex segment，
                // 如果不成功，-> isMatch 置 false
                state.Values ??= new RouteValueDictionary();
                if (!ProcessComplexSegments(
                    	candidate.Endpoint, 
                    	candidate.ComplexSegments, 
                    	path, 
                    	segments, 
                    	state.Values))
                {
                    CandidateSet.SetValidity(ref state, false);
                    isMatch = false;
                }
            }
            // 如果 candidate 包含 constraint（candidate 的 flag 标记了 HasConstraint），
            if ((flags & Candidate.CandidateFlags.HasConstraints) != 0)
            {
                // 调用 process constraint，
                // 如果不成功，-> isMatch 置 false
                state.Values ??= new RouteValueDictionary();
                if (!ProcessConstraints(
                    	candidate.Endpoint, 
                    	candidate.Constraints, 
                    	httpContext, 
                    	state.Values))
                {
                    CandidateSet.SetValidity(ref state, false);
                    isMatch = false;
                }
            }
            // 记录日志
            if (log)
            {
                if (isMatch)
                {
                    Logger.CandidateValid(_logger, path, candidate.Endpoint);
                }
                else
                {
                    Logger.CandidateNotValid(_logger, path, candidate.Endpoint);
                }
            }
        }
        
        /* c2- 处理 candidate 对应的 endpoint selector policy */
       
        // 如果 policy=0，即没有 endpoint selector policy，
        // 并且标记了使用 default endpoint selector（没有提供 endpoint selector）
        if (policyCount == 0 && _isDefaultEndpointSelector)
        {            
            // 使用 default endpoint selector 的 select 方法
            DefaultEndpointSelector.Select(httpContext, candidateState);
            return Task.CompletedTask;
        }
        // 否则，如果 policy=0，
        // （但是没有标记使用 default endpoint selector），        
        else if (policyCount == 0)
        {
            // 使用注入的 endpoint selector 的 select 方法
            return _selector.SelectAsync(
                httpContext, 
                new CandidateSet(candidateState));
        }               
        // 由上，policy != 0，即有 endpoint selector policy，
        // 使用 select endpoint with policy 方法
        return SelectEndpointWithPoliciesAsync(
            httpContext, 
            policies, 
            new CandidateSet(candidateState));
    }    
    
    private async Task SelectEndpointWithPoliciesAsync(
        HttpContext httpContext,
        IEndpointSelectorPolicy[] policies,
        CandidateSet candidateSet)
    {
        // 遍历 endpoint selector policy，
        for (var i = 0; i < policies.Length; i++)
        {
            var policy = policies[i];
            // 使用 policy 的 apply 方法，
            await policy.ApplyAsync(httpContext, candidateSet);
            // 一旦 policy 的 apply 成功注入 endpoint，-> 结束遍历
            if (httpContext.GetEndpoint() != null)
            {                
                return;
            }        }
        // fallback, 如果 endpoint selector policy 没有注入 endpoint，
        // 使用 endpoint selector 的 select 方法
        await _selector.SelectAsync(httpContext, candidateSet);
    }            
}

```

###### 3.3.2.2 find candidates

```c#
internal sealed class DfaMatcher : Matcher
{
    internal (Candidate[] candidates, IEndpointSelectorPolicy[] policies) FindCandidateSet(
        HttpContext httpContext,
        string path,
        ReadOnlySpan<PathSegment> segments)
    {
        // 获取 dfa states 引用
        var states = _states;        
        // destination（预结果）
        var destination = 0;
        
        /* 沿着 request path segment 找到适合的 destination */        
        for (var i = 0; i < segments.Length; i++)
        {            
            destination = states[destination].PathTransitions.GetDestination(path, segments[i]);
        }
        
        // jump (follow candidate state 的 policy transition)
        /* 沿着 dfa n*/
        var policyTransitions = states[destination].PolicyTransitions;
        while (policyTransitions != null)
        {
            destination = policyTransitions.GetDestination(httpContext);
            policyTransitions = states[destination].PolicyTransitions;
        }
        
        return (states[destination].Candidates, states[destination].Policies);
    }
}

```

###### 3.3.2.3 process candidate (by flags)

```c#
internal sealed class DfaMatcher : Matcher
{
    private void ProcessCaptures(
        KeyValuePair<string, object?>[] slots,
        (string parameterName, int segmentIndex, int slotIndex)[] captures,
        string path,
        ReadOnlySpan<PathSegment> segments)
    {
        // 遍历  capture，
        for (var i = 0; i < captures.Length; i++)
        {
            // 解析 parameter name、segment index、slot index
            (var parameterName, var segmentIndex, var slotIndex) = captures[i];
            
            if ((uint)segmentIndex < (uint)segments.Length)
            {
                // 解析 segment
                var segment = segments[segmentIndex];
                // parameter name 不为 null，且 segment 不为空
                if (parameterName != null && segment.Length > 0)
                {
                    // 向 slot 注入 (parameter name, sub path)
                    slots[slotIndex] = new KeyValuePair<string, object?>(
                        parameterName,
                        path.Substring(segment.Start, segment.Length));
                }
            }
        }
    }
        
    private void ProcessCatchAll(
        KeyValuePair<string, object?>[] slots,
        in (string parameterName, int segmentIndex, int slotIndex) catchAll,
        string path,
        ReadOnlySpan<PathSegment> segments)
    {
        // Read segmentIndex to local both to skip double read from stack value
        // and to use the same in-bounds validated variable to access the array.
        var segmentIndex = catchAll.segmentIndex;
        if ((uint)segmentIndex < (uint)segments.Length)
        {
            var segment = segments[segmentIndex];
            slots[catchAll.slotIndex] = new KeyValuePair<string, object?>(
                catchAll.parameterName,
                path.Substring(segment.Start));
        }
    }
	
    private bool ProcessComplexSegments(
        Endpoint endpoint,
        (RoutePatternPathSegment pathSegment, int segmentIndex)[] complexSegments,
        string path,
        ReadOnlySpan<PathSegment> segments,
        RouteValueDictionary values)
    {
        for (var i = 0; i < complexSegments.Length; i++)
        {
            (var complexSegment, var segmentIndex) = complexSegments[i];
            var segment = segments[segmentIndex];
            var text = path.AsSpan(segment.Start, segment.Length);
            if (!RoutePatternMatcher
                .MatchComplexSegment(complexSegment, text, values))
            {
                Logger.CandidateRejectedByComplexSegment(
                    _logger, 
                    path, 
                    endpoint, 
                    complexSegment);
                return false;
            }
        }
        
        return true;
    }

    private bool ProcessConstraints(
        Endpoint endpoint,
        KeyValuePair<string, IRouteConstraint>[] constraints,
        HttpContext httpContext,
        RouteValueDictionary values)
    {
        for (var i = 0; i < constraints.Length; i++)
        {
            var constraint = constraints[i];
            if (!constraint.Value.Match(
                	httpContext, 
                	NullRouter.Instance, 
                	constraint.Key, 
                	values, 
                	RouteDirection.IncomingRequest))
            {
                Logger.CandidateRejectedByConstraint(
                    _logger, 
                    httpContext.Request.Path, 
                    endpoint, 
                    constraint.Key, 
                    constraint.Value, 
                    values[constraint.Key]);
                return false;
            }
        }
        
        return true;
    }    
}

```

##### 3.3.3 matcher policy

```c#
public abstract class MatcherPolicy
{    
    public abstract int Order { get; }
           
    protected static bool ContainsDynamicEndpoints(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        for (var i = 0; i < endpoints.Count; i++)
        {
            var metadata = endpoints[i].Metadata
                					 .GetMetadata<IDynamicEndpointMetadata>();
            if (metadata?.IsDynamic == true)
            {
                return true;
            }
        }
        
        return false;
    }
}

```

###### 3.3.3.1 dynamic endpoint metadata

```c#
public interface IDynamicEndpointMetadata
{    
    bool IsDynamic { get; }
}

```

##### 3.3.4 host matcher policy

```c#
public sealed class HostMatcherPolicy : 
	MatcherPolicy, 
	IEndpointComparerPolicy, 
	INodeBuilderPolicy, 
	IEndpointSelectorPolicy
{
    private const string WildcardHost = "*";
    private const string WildcardPrefix = "*.";
    
    /* matcher policy */
    public override int Order { get; } = -100;    
      
    private static EdgeKey CreateEdgeKey(string host)
    {
        if (host == null)
        {
            return EdgeKey.WildcardEdgeKey;
        }
        
        var hostParts = host.Split(':');
        if (hostParts.Length == 1)
        {
            if (!string.IsNullOrEmpty(hostParts[0]))
            {
                return new EdgeKey(hostParts[0], null);
            }
        }
        if (hostParts.Length == 2)
        {
            if (!string.IsNullOrEmpty(hostParts[0]))
            {
                if (int.TryParse(hostParts[1], out var port))
                {
                    return new EdgeKey(hostParts[0], port);
                }
                else if (string.Equals(
                    		hostParts[1], 
                    		WildcardHost, 
                    		StringComparison.Ordinal))
                {
                    return new EdgeKey(hostParts[0], null);
                }
            }
        }
        
        throw new InvalidOperationException($"Could not parse host: {host}");
    }
    
    private readonly struct EdgeKey : 
    	IEquatable<EdgeKey>, 
    	IComparable<EdgeKey>, 
    	IComparable
    {
        internal static readonly EdgeKey WildcardEdgeKey = new EdgeKey(null, null);
        
        public readonly int? Port;                    
        public readonly string Host;
            
        private readonly string? _wildcardEndsWith;
            
        public bool HasHostWildcard { get; }        
        public bool MatchesHost => !string.Equals(Host, WildcardHost, StringComparison.Ordinal);
        public bool MatchesPort => Port != null;                
        public bool MatchesAll => !MatchesHost && !MatchesPort;
            
        public EdgeKey(string? host, int? port)
        {
            Host = host ?? WildcardHost;
            Port = port;
            
            HasHostWildcard = Host.StartsWith(WildcardPrefix, StringComparison.Ordinal);
            _wildcardEndsWith = HasHostWildcard ? Host.Substring(1) : null;
        }
                       
        public int CompareTo(EdgeKey other)
        {
            var result = Comparer<string>.Default.Compare(Host, other.Host);
            if (result != 0)
            {
                return result;
            }
            
            return Comparer<int?>.Default.Compare(Port, other.Port);
        }
        
        public int CompareTo(object? obj)
        {
            return CompareTo((EdgeKey)obj!);
        }
        
        public bool Equals(EdgeKey other)
        {
            return string.Equals(
                		Host, 
                		other.Host, 
                		StringComparison.Ordinal) && 
                   Port == other.Port;
        }
        
        public bool MatchHost(string host)
        {
            if (MatchesHost)
            {
                if (HasHostWildcard)
                {
                    return host.EndsWith(
                        _wildcardEndsWith!, 
                        StringComparison.OrdinalIgnoreCase);
                }
                else
                {
                    return string.Equals(
                        host, 
                        Host, 
                        StringComparison.OrdinalIgnoreCase);
                }
            }
            
            return true;
        }
        
        
        public override int GetHashCode()
        {
            return (Host?.GetHashCode() ?? 0) ^ (Port?.GetHashCode() ?? 0);
        }
        
        public override bool Equals(object? obj)
        {
            if (obj is EdgeKey key)
            {
                return Equals(key);
            }
            
            return false;
        }
        
        public override string ToString()
        {
            return $"{Host}:{Port?.ToString(CultureInfo.InvariantCulture) ?? WildcardHost}";
        }
    }
        
    private int GetScore(in EdgeKey key)
    {
        // Higher score == lower priority.
        if (key.MatchesHost && !key.HasHostWildcard && key.MatchesPort)
        {
            return 1; // Has host AND port, e.g. www.consoto.com:8080
        }
        else if (key.MatchesHost && !key.HasHostWildcard)
        {
            return 2; // Has host, e.g. www.consoto.com
        }
        else if (key.MatchesHost && key.MatchesPort)
        {
            return 3; // Has wildcard host AND port, e.g. *.consoto.com:8080
        }
        else if (key.MatchesHost)
        {
            return 4; // Has wildcard host, e.g. *.consoto.com
        }
        else if (key.MatchesPort)
        {
            return 5; // Has port, e.g. *:8080
        }
        else
        {
            return 6; // Has neither, e.g. *:* (or no metadata)
        }
    }
        
    // get host and port
    private static (string host, int? port) GetHostAndPort(HttpContext httpContext)
    {
        var hostString = httpContext.Request.Host;
        if (hostString.Port != null)
        {
            return (hostString.Host, hostString.Port);
        }
        else if (string.Equals(
            		"https", 
            		httpContext.Request.Scheme, 
            		StringComparison.OrdinalIgnoreCase))
        {
            return (hostString.Host, 443);
        }
        else if (string.Equals(
            		"http", 
            		httpContext.Request.Scheme, 
            		StringComparison.OrdinalIgnoreCase))
        {
            return (hostString.Host, 80);
        }
        else
        {
            return (hostString.Host, null);
        }
    }
}

```

###### 3.3.4.1 实现 endpoint comparer policy 接口

```c#
public sealed class HostMatcherPolicy 
{
    public IComparer<Endpoint> Comparer { get; } = new HostMetadataEndpointComparer();
       
    private class HostMetadataEndpointComparer : EndpointMetadataComparer<IHostMetadata>
    {
        protected override int CompareMetadata(IHostMetadata? x, IHostMetadata? y)
        {
            // Ignore the metadata if it has an empty list of hosts.
            return base.CompareMetadata(
                x?.Hosts.Count > 0 ? x : null,
                y?.Hosts.Count > 0 ? y : null);
        }
    }
}

// host metadata

```

###### 3.3.4.2 实现 node builder policy接口

```c#
public sealed class HostMatcherPolicy 
{
    /* apply to endpoint */
    bool INodeBuilderPolicy.AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        return !ContainsDynamicEndpoints(endpoints) && 
               AppliesToEndpointsCore(endpoints);        
    }
     
    /* get edges */
    public IReadOnlyList<PolicyNodeEdge> GetEdges(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        // The algorithm here is designed to be preserve the order of the endpoints
        // while also being relatively simple. Preserving order is important.
        
        // First, build a dictionary of all of the hosts that are included at this node.        
        // For now we're just building up the set of keys. We don't add any endpoints
        // to lists now because we don't want ordering problems.
        
        var edges = new Dictionary<EdgeKey, List<Endpoint>>();
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            var hosts = endpoint.Metadata
                			   .GetMetadata<IHostMetadata>()?
                			   .Hosts.Select(h => CreateEdgeKey(h))
                			   .ToArray();
            if (hosts == null || hosts.Length == 0)
            {
                hosts = new[] { EdgeKey.WildcardEdgeKey };
            }
            
            for (var j = 0; j < hosts.Length; j++)
            {
                var host = hosts[j];
                if (!edges.ContainsKey(host))
                {
                    edges.Add(host, new List<Endpoint>());
                }
            }
        }
        
        // Now in a second loop, add endpoints to these lists. We've enumerated all of
        // the states, so we want to see which states this endpoint matches.
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];            
            var endpointKeys = endpoint.Metadata
                					 .GetMetadata<IHostMetadata>()?
                					 .Hosts.Select(h => CreateEdgeKey(h))
                					 .ToArray() 
                						  ?? Array.Empty<EdgeKey>();
            if (endpointKeys.Length == 0)
            {
                // OK this means that this endpoint matches *all* hosts.
                // So, loop and add it to all states.
                foreach (var kvp in edges)
                {
                    kvp.Value.Add(endpoint);
                }
            }
            else
            {
                // OK this endpoint matches specific hosts
                foreach (var kvp in edges)
                {
                    // The edgeKey maps to a possible request header value
                    var edgeKey = kvp.Key;
                    
                    for (var j = 0; j < endpointKeys.Length; j++)
                    {
                        var endpointKey = endpointKeys[j];
                        
                        if (edgeKey.Equals(endpointKey))
                        {
                            kvp.Value.Add(endpoint);
                            break;
                        }
                        else if (edgeKey.HasHostWildcard && 
                                 endpointKey.HasHostWildcard &&
                                 edgeKey.Port == endpointKey.Port && 
                                 edgeKey.MatchHost(endpointKey.Host))
                        {
                            kvp.Value.Add(endpoint);
                            break;
                        }
                    }
                }
            }
        }
        
        return edges.Select(kvp => new PolicyNodeEdge(kvp.Key, kvp.Value))
            	    .ToArray();
    }            
    
    /* build jump table */
    public PolicyJumpTable BuildJumpTable(int exitDestination, IReadOnlyList<PolicyJumpTableEdge> edges)
    {
        if (edges == null)
        {
            throw new ArgumentNullException(nameof(edges));
        }
        
        // Since our 'edges' can have wildcards, we do a sort based on how wildcard-ey they
        // are then then execute them in linear order.
        var ordered = edges.Select(e => (host: (EdgeKey)e.State, destination: e.Destination))
            			  .OrderBy(e => GetScore(e.host))
            			  .ToArray();
        
        return new HostPolicyJumpTable(exitDestination, ordered);
    }   
        
    private class HostPolicyJumpTable : PolicyJumpTable
    {
        private (EdgeKey host, int destination)[] _destinations;
        private int _exitDestination;
        
        public HostPolicyJumpTable(
            int exitDestination, 
            (EdgeKey host, int destination)[] destinations)
        {
            _exitDestination = exitDestination;
            _destinations = destinations;
        }
        
        public override int GetDestination(HttpContext httpContext)
        {
            // HostString can allocate when accessing the host or port
            // Store host and port locally and reuse
            var (host, port) = GetHostAndPort(httpContext);
            
            var destinations = _destinations;
            for (var i = 0; i < destinations.Length; i++)
            {
                var destination = destinations[i];
                
                if ((!destination.host.MatchesPort || destination.host.Port == port) &&
                    destination.host.MatchHost(host))
                {
                    return destination.destination;
                }
            }
            
            return _exitDestination;
        }
    }
}

```

###### 3.3.4.3 实现 endpoint selector policy 接口

```c#
public sealed class HostMatcherPolicy 
{
    /* applies to endpoint */
    bool IEndpointSelectorPolicy.AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints)
    {
        // When the node contains dynamic endpoints we can't make any assumptions.
        var applies = ContainsDynamicEndpoints(endpoints);
        if (applies)
        {
            // Run for the side-effect of validating metadata.
            AppliesToEndpointsCore(endpoints);
        }
        
        return applies;
    }
        
    private bool AppliesToEndpointsCore(IReadOnlyList<Endpoint> endpoints)
    {
        return endpoints.Any(e =>
        	{
                var hosts = e.Metadata.GetMetadata<IHostMetadata>()?.Hosts;
                if (hosts == null || hosts.Count == 0)
                {
                    return false;
                }
                
                foreach (var host in hosts)
                {
                    // Don't run policy on endpoints that match everything
                    var key = CreateEdgeKey(host);
                    if (!key.MatchesAll)
                    {
                        return true;
                    }
                }
                
                return false;
            });
    }
       
    /* apply async */
    public Task ApplyAsync(HttpContext httpContext, CandidateSet candidates)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }        
        if (candidates == null)
        {
            throw new ArgumentNullException(nameof(candidates));
        }
        
        for (var i = 0; i < candidates.Count; i++)
        {
            if (!candidates.IsValidCandidate(i))
            {
                continue;
            }
            
            var hosts = candidates[i].Endpoint
                				   .Metadata
                				   .GetMetadata<IHostMetadata>()?
                				   .Hosts;
            if (hosts == null || hosts.Count == 0)
            {
                // Can match any host.
                continue;
            }
            
            var matched = false;
            var (requestHost, requestPort) = GetHostAndPort(httpContext);
            for (var j = 0; j < hosts.Count; j++)
            {
                var host = hosts[j].AsSpan();
                var port = ReadOnlySpan<char>.Empty;
                
                // Split into host and port
                var pivot = host.IndexOf(':');
                if (pivot >= 0)
                {
                    port = host.Slice(pivot + 1);
                    host = host.Slice(0, pivot);
                }
                
                if (host == null || 
                    MemoryExtensions.Equals(
                        host, 
                        WildcardHost, S
                        tringComparison.OrdinalIgnoreCase))
                {
                    // Can match any host
                }
                else if (host.StartsWith(WildcardPrefix) &&
                         // Note that we only slice off the `*`. We want to match the leading `.` also.
                         MemoryExtensions.EndsWith(
                             requestHost, 
                             host.Slice(WildcardHost.Length), 
                             StringComparison.OrdinalIgnoreCase))
                {
                    // Matches a suffix wildcard.
                }
                else if (MemoryExtensions.Equals(
                    		requestHost, 
                    		host, 
                    		StringComparison.OrdinalIgnoreCase))
                {
                    // Matches exactly
                }
                else
                {
                    // If we get here then the host doesn't match.
                    continue;
                }
                
                if (MemoryExtensions.Equals(
                    	port, 
                    	WildcardHost, 
                    	StringComparison.OrdinalIgnoreCase))
                {
                    // Port is a wildcard, we allow any port.
                }
                else if (port.Length > 0 && 
                         (!int.TryParse(port, out var parsed) || parsed != requestPort))
                {
                    // If we get here then the port doesn't match.
                    continue;
                }
                
                matched = true;
                break;
            }
            
            if (!matched)
            {
                candidates.SetValidity(i, false);
            }
        }
        
        return Task.CompletedTask;
    }                        
}

```

###### 3.3.4.4 host metadata

```c#
public interface IHostMetadata
{    
    IReadOnlyList<string> Hosts { get; }
}

[DebuggerDisplay("{DebuggerToString(),nq}")]
[AttributeUsage(
    AttributeTargets.Class | AttributeTargets.Method, 
    AllowMultiple = false, 
    Inherited = false)]
public sealed class HostAttribute : Attribute, IHostMetadata
{    
    public IReadOnlyList<string> Hosts { get; }

    public HostAttribute(string host) : this(new[] { host })
    {
        if (host == null)
        {
            throw new ArgumentNullException(nameof(host));
        }
    }
        
    public HostAttribute(params string[] hosts)
    {
        if (hosts == null)
        {
            throw new ArgumentNullException(nameof(hosts));
        }
        
        Hosts = hosts.ToArray();
    }
                
    private string DebuggerToString()
    {
        var hostsDisplay = (Hosts.Count == 0)
            ? "*:*"
            : string.Join(",", Hosts.Select(h => h.Contains(':') ? h : h + ":*"));
        
        return $"Hosts: {hostsDisplay}";
    }
}

```

##### 3.3.5 http method matcher policy

```c#
public sealed class HttpMethodMatcherPolicy : MatcherPolicy, IEndpointComparerPolicy, INodeBuilderPolicy, IEndpointSelectorPolicy
{    
    internal static readonly string OriginHeader = "Origin";
    internal static readonly string AccessControlRequestMethod = "Access-Control-Request-Method";
    internal static readonly string PreflightHttpMethod = HttpMethods.Options;
    
    internal const string Http405EndpointDisplayName = "405 HTTP Method Not Supported";       
    internal const string AnyMethod = "*";
    
    // matcher policy              
    public override int Order => -1000;
                                                       
    private Endpoint CreateRejectionEndpoint(IEnumerable<string> httpMethods)
    {
        var allow = string.Join(", ", httpMethods);
        return new Endpoint(
            (context) =>
            {
                context.Response.StatusCode = 405;
                
                // Prevent ArgumentException from duplicate key if header already added, such as when the
                // request is re-executed by an error handler (see https://github.com/dotnet/aspnetcore/issues/6415)
                context.Response.Headers[HeaderNames.Allow] = allow;
                
                return Task.CompletedTask;
            },
            EndpointMetadataCollection.Empty,
            Http405EndpointDisplayName);
    }
    
    internal readonly struct EdgeKey : IEquatable<EdgeKey>, IComparable<EdgeKey>, IComparable
    {
        // Note that in contrast with the metadata, the edge represents a possible state change
        // rather than a list of what's allowed. We represent CORS and non-CORS requests as separate
        // states.
        public readonly bool IsCorsPreflightRequest;
        public readonly string HttpMethod;
        
        public EdgeKey(string httpMethod, bool isCorsPreflightRequest)
        {
            HttpMethod = httpMethod;
            IsCorsPreflightRequest = isCorsPreflightRequest;
        }
        
        // These are comparable so they can be sorted in tests.
        public int CompareTo(EdgeKey other)
        {
            var compare = string.Compare(
                HttpMethod, 
                other.HttpMethod, 
                StringComparison.Ordinal);
            if (compare != 0)
            {
                return compare;
            }
            
            return IsCorsPreflightRequest.CompareTo(other.IsCorsPreflightRequest);
        }
        
        public int CompareTo(object? obj)
        {
            return CompareTo((EdgeKey)obj!);
        }
        
        public bool Equals(EdgeKey other)
        {
            return IsCorsPreflightRequest == other.IsCorsPreflightRequest &&
                   HttpMethods.Equals(HttpMethod, other.HttpMethod);
        }
        
        public override bool Equals(object? obj)
        {
            var other = obj as EdgeKey?;
            return other == null ? false : Equals(other.Value);
        }
        
        public override int GetHashCode()
        {
            var hash = new HashCodeCombiner();
            hash.Add(IsCorsPreflightRequest ? 1 : 0);
            hash.Add(HttpMethod, StringComparer.Ordinal);
            return hash;
        }
        
        // Used in GraphViz output.
        public override string ToString()
        {
            return IsCorsPreflightRequest ? $"CORS: {HttpMethod}" : $"HTTP: {HttpMethod}";
        }
    }
    
    internal static bool IsCorsPreflightRequest(
        HttpContext httpContext, 
        string httpMethod, 
        out StringValues accessControlRequestMethod)
    {
        accessControlRequestMethod = default;
        var headers = httpContext.Request.Headers;
        
        return HttpMethods.Equals(httpMethod, PreflightHttpMethod) &&
               headers.ContainsKey(HeaderNames.Origin) &&
               headers.TryGetValue(HeaderNames.AccessControlRequestMethod, out accessControlRequestMethod) &&
               !StringValues.IsNullOrEmpty(accessControlRequestMethod);
    }    
}

```

###### 3.3.5.1 实现 endpoint comparer policy 接口

```c#
public sealed class HttpMethodMatcherPolicy 
{
    public IComparer<Endpoint> Comparer => new HttpMethodMetadataEndpointComparer();
    
    private class HttpMethodMetadataEndpointComparer : EndpointMetadataComparer<IHttpMethodMetadata>
    {
        protected override int CompareMetadata(IHttpMethodMetadata? x, IHttpMethodMetadata? y)
        {
            // Ignore the metadata if it has an empty list of HTTP methods.
            return base.CompareMetadata(
                x?.HttpMethods.Count > 0 ? x : null,
                y?.HttpMethods.Count > 0 ? y : null);
        }
    }
}

```

###### 3.3.5.2 实现 node builder policy 接口

```c#
public sealed class HttpMethodMatcherPolicy 
{
    /* applies to endpoint */
    bool INodeBuilderPolicy.AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        if (ContainsDynamicEndpoints(endpoints))
        {
            return false;
        }
        
        return AppliesToEndpointsCore(endpoints);
    }
            
    private bool AppliesToEndpointsCore(IReadOnlyList<Endpoint> endpoints)
    {
        for (var i = 0; i < endpoints.Count; i++)
        {
            if (endpoints[i].Metadata
                		   .GetMetadata<IHttpMethodMetadata>()?
                		   .HttpMethods.Count > 0)
            {
                return true;
            }
        }
        
        return false;
    }
    
    /* get edges */
    public IReadOnlyList<PolicyNodeEdge> GetEdges(IReadOnlyList<Endpoint> endpoints)
    {
        // The algorithm here is designed to be preserve the order of the endpoints
        // while also being relatively simple. Preserving order is important.
        //
        // First, build a dictionary of all possible HTTP method/CORS combinations
        // that exist in this list of endpoints.
        //
        // For now we're just building up the set of keys. We don't add any endpoints
        // to lists now because we don't want ordering problems.
        var allHttpMethods = new List<string>();
        var edges = new Dictionary<EdgeKey, List<Endpoint>>();
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            var (httpMethods, acceptCorsPreFlight) = GetHttpMethods(endpoint);
            
            // If the action doesn't list HTTP methods then it supports all methods.
            // In this phase we use a sentinel value to represent the *other* HTTP method
            // a state that represents any HTTP method that doesn't have a match.
            if (httpMethods.Count == 0)
            {
                httpMethods = new[] { AnyMethod, };
            }
            
            for (var j = 0; j < httpMethods.Count; j++)
            {
                // An endpoint that allows CORS reqests will match both CORS and non-CORS
                // so we model it as both.
                var httpMethod = httpMethods[j];
                var key = new EdgeKey(httpMethod, acceptCorsPreFlight);
                if (!edges.ContainsKey(key))
                {
                    edges.Add(key, new List<Endpoint>());
                }
                
                // An endpoint that allows CORS reqests will match both CORS and non-CORS
                // so we model it as both.
                if (acceptCorsPreFlight)
                {
                    key = new EdgeKey(httpMethod, false);
                    if (!edges.ContainsKey(key))
                    {
                        edges.Add(key, new List<Endpoint>());
                    }
                }
                
                // Also if it's not the *any* method key, then track it.
                if (!string.Equals(
                    	AnyMethod, 
                    	httpMethod, 
                    	StringComparison.OrdinalIgnoreCase))
                {
                    if (!ContainsHttpMethod(allHttpMethods, httpMethod))
                    {
                        allHttpMethods.Add(httpMethod);
                    }
                }
            }
        }
        
        allHttpMethods.Sort(StringComparer.OrdinalIgnoreCase);
        
        // Now in a second loop, add endpoints to these lists. We've enumerated all of
        // the states, so we want to see which states this endpoint matches.
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            var (httpMethods, acceptCorsPreFlight) = GetHttpMethods(endpoint);
            
            if (httpMethods.Count == 0)
            {
                // OK this means that this endpoint matches *all* HTTP methods.
                // So, loop and add it to all states.
                foreach (var kvp in edges)
                {
                    if (acceptCorsPreFlight || !kvp.Key.IsCorsPreflightRequest)
                    {
                        kvp.Value.Add(endpoint);
                    }
                }
            }
            else
            {
                // OK this endpoint matches specific methods.
                for (var j = 0; j < httpMethods.Count; j++)
                {
                    var httpMethod = httpMethods[j];
                    var key = new EdgeKey(httpMethod, acceptCorsPreFlight);
                    
                    edges[key].Add(endpoint);
                    
                    // An endpoint that allows CORS reqests will match both CORS and non-CORS
                    // so we model it as both.
                    if (acceptCorsPreFlight)
                    {
                        key = new EdgeKey(httpMethod, false);
                        edges[key].Add(endpoint);
                    }
                }
            }
        }
        
        // Adds a very low priority endpoint that will reject the request with
        // a 405 if nothing else can handle this verb. This is only done if
        // no other actions exist that handle the 'all verbs'.
        //
        // The rationale for this is that we want to report a 405 if none of
        // the supported methods match, but we don't want to report a 405 in a
        // case where an application defines an endpoint that handles all verbs, but
        // a constraint rejects the request, or a complex segment fails to parse. We
        // consider a case like that a 'user input validation' failure  rather than
        // a semantic violation of HTTP.
        //
        // This will make 405 much more likely in API-focused applications, and somewhat
        // unlikely in a traditional MVC application. That's good.
        //
        // We don't bother returning a 405 when the CORS preflight method doesn't exist.
        // The developer calling the API will see it as a CORS error, which is fine because
        // there isn't an endpoint to check for a CORS policy.
        if (!edges.TryGetValue(new EdgeKey(AnyMethod, false), out var matches))
        {
            // Methods sorted for testability.
            var endpoint = CreateRejectionEndpoint(allHttpMethods);
            matches = new List<Endpoint>() { endpoint, };
            edges[new EdgeKey(AnyMethod, false)] = matches;
        }
        
        var policyNodeEdges = new PolicyNodeEdge[edges.Count];
        var index = 0;
        foreach (var kvp in edges)
        {
            policyNodeEdges[index++] = new PolicyNodeEdge(kvp.Key, kvp.Value);
        }
        
        return policyNodeEdges;
        
        // get http method 方法
        (IReadOnlyList<string> httpMethods, bool acceptCorsPreflight) GetHttpMethods(Endpoint e)
        {
            var metadata = e.Metadata.GetMetadata<IHttpMethodMetadata>();
            return metadata == null 
                ? (Array.Empty<string>(), false) 
                : (metadata.HttpMethods, metadata.AcceptCorsPreflight);
        }
    }
        
    private static bool ContainsHttpMethod(List<string> httpMethods, string httpMethod)
    {
        var methods = CollectionsMarshal.AsSpan(httpMethods);
        for (var i = 0; i < methods.Length; i++)
        {
            // This is a fast path for when everything is using static HttpMethods instances.
            if (object.ReferenceEquals(methods[i], httpMethod))
            {
                return true;
            }
        }
        
        for (var i = 0; i < methods.Length; i++)
        {
            if (HttpMethods.Equals(methods[i], httpMethod))
            {
                return true;
            }
        }
        
        return false;
    }            
    
    /* build jump table */
    public PolicyJumpTable BuildJumpTable(int exitDestination, IReadOnlyList<PolicyJumpTableEdge> edges)
    {
        Dictionary<string, int>? destinations = null;
        Dictionary<string, int>? corsPreflightDestinations = null;
        for (var i = 0; i < edges.Count; i++)
        {
            // We create this data, so it's safe to cast it.
            var key = (EdgeKey)edges[i].State;
            if (key.IsCorsPreflightRequest)
            {
                if (corsPreflightDestinations == null)
                {
                    corsPreflightDestinations = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                }
                
                corsPreflightDestinations.Add(key.HttpMethod, edges[i].Destination);
            }
            else
            {
                if (destinations == null)
                {
                    destinations = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                }
                
                destinations.Add(key.HttpMethod, edges[i].Destination);
            }
        }
        
        int corsPreflightExitDestination = exitDestination;
        if (corsPreflightDestinations != null && 
            corsPreflightDestinations.TryGetValue(AnyMethod, out var matchesAnyVerb))
        {
            // If we have endpoints that match any HTTP method, use that as the exit.
            corsPreflightExitDestination = matchesAnyVerb;
            corsPreflightDestinations.Remove(AnyMethod);
        }
        
        if (destinations != null && 
            destinations.TryGetValue(AnyMethod, out matchesAnyVerb))
        {
            // If we have endpoints that match any HTTP method, use that as the exit.
            exitDestination = matchesAnyVerb;
            destinations.Remove(AnyMethod);
        }
        
        if (destinations?.Count == 1)
        {
            // If there is only a single valid HTTP method then use an optimized jump table.
            // It avoids unnecessary dictionary lookups with the method name.
            var httpMethodDestination = destinations.Single();
            var method = httpMethodDestination.Key;
            var destination = httpMethodDestination.Value;
            var supportsCorsPreflight = false;
            var corsPreflightDestination = 0;
            
            if (corsPreflightDestinations?.Count > 0)
            {
                supportsCorsPreflight = true;
                corsPreflightDestination = corsPreflightDestinations.Single().Value;
            }
            
            return new HttpMethodSingleEntryPolicyJumpTable(
                exitDestination,
                method,
                destination,
                supportsCorsPreflight,
                corsPreflightExitDestination,
                corsPreflightDestination);
        }
        else
        {
            return new HttpMethodDictionaryPolicyJumpTable(
                exitDestination,
                destinations,
                corsPreflightExitDestination,
                corsPreflightDestinations);
        }
    }
}

```

###### 3.3.5.3 实现 endpoint selector policy 接口

```c#
public sealed class HttpMethodMatcherPolicy 
{
    bool IEndpointSelectorPolicy.AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        // When the node contains dynamic endpoints we can't make any assumptions.
        return ContainsDynamicEndpoints(endpoints);
    }
    
    public Task ApplyAsync(HttpContext httpContext, CandidateSet candidates)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }        
        if (candidates == null)
        {
            throw new ArgumentNullException(nameof(candidates));
        }
        
        // Returning a 405 here requires us to return keep track of all 'seen' HTTP methods. We allocate to
        // keep track of this beause we either need to keep track of the HTTP methods or keep track of the
        // endpoints - both allocate.
        //
        // Those code only runs in the presence of dynamic endpoints anyway.
        //
        // We want to return a 405 iff we eliminated ALL of the currently valid endpoints due to HTTP method
            // mismatch.
        bool? needs405Endpoint = null;
        HashSet<string>? methods = null;
        
        for (var i = 0; i < candidates.Count; i++)
        {
            // We do this check first for consistency with how 405 is implemented for the graph version
            // of this code. We still want to know if any endpoints in this set require an HTTP method
            // even if those endpoints are already invalid - hence the null-check.
            var metadata = candidates[i].Endpoint?
                					  .Metadata.GetMetadata<IHttpMethodMetadata>();
            if (metadata == null || metadata.HttpMethods.Count == 0)
            {
                // Can match any method.
                needs405Endpoint = false;
                continue;
            }
            
            // Saw a valid endpoint.
            needs405Endpoint = needs405Endpoint ?? true;
            
            if (!candidates.IsValidCandidate(i))
            {
                continue;
            }
            
            var httpMethod = httpContext.Request.Method;
            var headers = httpContext.Request.Headers;
            if (metadata.AcceptCorsPreflight &&
                HttpMethods.Equals(httpMethod, PreflightHttpMethod) &&
                headers.ContainsKey(HeaderNames.Origin) &&
                headers.TryGetValue(HeaderNames.AccessControlRequestMethod, out var accessControlRequestMethod) &&
                !StringValues.IsNullOrEmpty(accessControlRequestMethod))
            {
                needs405Endpoint = false; // We don't return a 405 for a CORS preflight request when the endpoints accept CORS preflight.
                httpMethod = accessControlRequestMethod;
            }
            
            var matched = false;
            for (var j = 0; j < metadata.HttpMethods.Count; j++)
            {
                var candidateMethod = metadata.HttpMethods[j];
                if (!HttpMethods.Equals(httpMethod, candidateMethod))
                {
                    methods = methods ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    methods.Add(candidateMethod);
                    continue;
                }
                
                matched = true;
                needs405Endpoint = false;
                break;
            }
            
            if (!matched)
            {
                candidates.SetValidity(i, false);
            }
        }
        
        if (needs405Endpoint == true)
        {
            // We saw some endpoints coming in, and we eliminated them all.
            httpContext.SetEndpoint(CreateRejectionEndpoint(methods!.OrderBy(m => m, StringComparer.OrdinalIgnoreCase)));
            httpContext.Request.RouteValues = null!;
        }
        
        return Task.CompletedTask;
    }
}

```

###### 3.3.5.4 http method metadata

```c#
public interface IHttpMethodMetadata
{    
    bool AcceptCorsPreflight { get; }        
    IReadOnlyList<string> HttpMethods { get; }
}
    
[DebuggerDisplay("{DebuggerToString(),nq}")]
public sealed class HttpMethodMetadata : IHttpMethodMetadata
{
    public bool AcceptCorsPreflight { get; }        
    public IReadOnlyList<string> HttpMethods { get; }
    
    public HttpMethodMetadata(IEnumerable<string> httpMethods)
        : this(httpMethods, acceptCorsPreflight: false)
        {
        }
        
    public HttpMethodMetadata(IEnumerable<string> httpMethods, bool acceptCorsPreflight)
    {
        if (httpMethods == null)
        {
            throw new ArgumentNullException(nameof(httpMethods));
        }
        
        HttpMethods = httpMethods.Select(GetCanonicalizedValue).ToArray();
        AcceptCorsPreflight = acceptCorsPreflight;
    }
                    
    private string DebuggerToString()
    {
        return $"HttpMethods: {string.Join(",", HttpMethods)} - Cors: {AcceptCorsPreflight}";
    }
}

```

##### 3.3.6 dfa matcher builder

```c#
internal class DfaMatcherBuilder : MatcherBuilder
{
    // endpoint 集合
    private readonly List<RouteEndpoint> _endpoints = new List<RouteEndpoint>();
    
    private readonly ILoggerFactory _loggerFactory;
    private readonly ParameterPolicyFactory _parameterPolicyFactory;
    private readonly EndpointSelector _selector;
    private readonly IEndpointSelectorPolicy[] _endpointSelectorPolicies;
    private readonly INodeBuilderPolicy[] _nodeBuilders;
    private readonly EndpointComparer _comparer;
    internal EndpointComparer Comparer => _comparer;  
    
    // These collections are reused when building candidates
    private readonly Dictionary<string, int> _assignments;
    private readonly List<KeyValuePair<string, object>> _slots;
    private readonly List<(string parameterName, int segmentIndex, int slotIndex)> _captures;
    private readonly List<(RoutePatternPathSegment pathSegment, int segmentIndex)> _complexSegments;
    private readonly List<KeyValuePair<string, IRouteConstraint>> _constraints;
    
    private int _stateIndex;        
    internal bool UseCorrectCatchAllBehavior { get; set; }
    
    public DfaMatcherBuilder(
        ILoggerFactory loggerFactory,
        ParameterPolicyFactory parameterPolicyFactory,
        EndpointSelector selector,
        IEnumerable<MatcherPolicy> policies)
    {        
        _loggerFactory = loggerFactory;        
        // 注入 parameter policy factory
        _parameterPolicyFactory = parameterPolicyFactory;
        // 注入 endpoint selector
        _selector = selector;
        // 解析 use correct catch all behavior
        if (AppContext.TryGetSwitch(
            	"Microsoft.AspNetCore.Routing.UseCorrectCatchAllBehavior", 
            	out var enabled))
        {
            UseCorrectCatchAllBehavior = enabled;
        }
        else
        {
            UseCorrectCatchAllBehavior = true; // default to correct behavior
        }
        
        // 从注入的 matcher policies 中抽取，
        //   1- node builder policy，
        //	 2- endpoint comparer policy，
        //	 3- endpointselector policy
        var (nodeBuilderPolicies, 
             endpointComparerPolicies, 
             endpointSelectorPolicies) = ExtractPolicies(policies.OrderBy(p => p.Order));               
        _endpointSelectorPolicies = endpointSelectorPolicies;
        _nodeBuilders = nodeBuilderPolicies;
        
        // 创建 candidate value 组件（empty，预结果）        
        _comparer = new EndpointComparer(endpointComparerPolicies);        
        _assignments = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        _slots = new List<KeyValuePair<string, object>>();
        _captures = new List<(string parameterName, int segmentIndex, int slotIndex)>();
        _complexSegments = new List<(RoutePatternPathSegment pathSegment, int segmentIndex)>();
        _constraints = new List<KeyValuePair<string, IRouteConstraint>>();
    }    
    
    private static (INodeBuilderPolicy[] nodeBuilderPolicies, 
                    IEndpointComparerPolicy[] endpointComparerPolicies, 
                    IEndpointSelectorPolicy[] endpointSelectorPolicies) 
        ExtractPolicies(IEnumerable<MatcherPolicy> policies)
    {
        // 创建预结果
        var nodeBuilderPolicies = new List<INodeBuilderPolicy>();
        var endpointComparerPolicies = new List<IEndpointComparerPolicy>();
        var endpointSelectorPolicies = new List<IEndpointSelectorPolicy>();
        
        // 遍历 matcher policy，
        foreach (var policy in policies)
        {
            // 如果 matcher policy 实现了 node builder policy，-> 注入 node builder policy 集合
            if (policy is INodeBuilderPolicy nodeBuilderPolicy)
            {
                nodeBuilderPolicies.Add(nodeBuilderPolicy);
            }
            // 如果 matcher policy 实现了 endpoint comparer policy，-> 注入 endpoint comparer policy 集合
            if (policy is IEndpointComparerPolicy endpointComparerPolicy)
            {
                endpointComparerPolicies.Add(endpointComparerPolicy);
            }
            // 如果 matcher policy 实现了 endpoint selector policy，-> 注入 endpoint selector policy 集合
            if (policy is IEndpointSelectorPolicy endpointSelectorPolicy)
            {
                endpointSelectorPolicies.Add(endpointSelectorPolicy);
            }
        }
        
        return (nodeBuilderPolicies.ToArray(), 
                endpointComparerPolicies.ToArray(), 
                endpointSelectorPolicies.ToArray());
    }
}

```

###### 3.3.6.1 endpoint comparer & comparer policy

```c#
// comparer policy 
public interface IEndpointComparerPolicy
{     
    IComparer<Endpoint> Comparer { get; }
}

// endpoint comparer
internal class EndpointComparer : IComparer<Endpoint>, IEqualityComparer<Endpoint>
{
    private readonly IComparer<Endpoint>[] _comparers;

        public EndpointComparer(IEndpointComparerPolicy[] policies)
        {
            // Order, Precedence, (others)...
            _comparers = new IComparer<Endpoint>[2 + policies.Length];
            _comparers[0] = OrderComparer.Instance;
            _comparers[1] = PrecedenceComparer.Instance;
            for (var i = 0; i < policies.Length; i++)
            {
                _comparers[i + 2] = policies[i].Comparer;
            }
        }

        public int Compare(Endpoint? x, Endpoint? y)
        {
            // We don't expose this publicly, and we should never call it on
            // a null endpoint.
            Debug.Assert(x != null);
            Debug.Assert(y != null);

            var compare = CompareCore(x, y);

            // Since we're sorting, use the route template as a last resort.
            return compare == 0 ? ComparePattern(x, y) : compare;
        }

        private int ComparePattern(Endpoint x, Endpoint y)
        {
            // A RouteEndpoint always comes before a non-RouteEndpoint, regardless of its RawText value
            var routeEndpointX = x as RouteEndpoint;
            var routeEndpointY = y as RouteEndpoint;

            if (routeEndpointX != null)
            {
                if (routeEndpointY != null)
                {
                    return string.Compare(routeEndpointX.RoutePattern.RawText, routeEndpointY.RoutePattern.RawText, StringComparison.OrdinalIgnoreCase);
                }

                return 1;
            }
            else if (routeEndpointY != null)
            {
                return -1;
            }

            return 0;
        }

        public bool Equals(Endpoint? x, Endpoint? y)
        {
            // We don't expose this publicly, and we should never call it on
            // a null endpoint.
            Debug.Assert(x != null);
            Debug.Assert(y != null);

            return CompareCore(x, y) == 0;
        }
        
        public int GetHashCode(Endpoint obj)
        {
            // This should not be possible to call publicly.
            Debug.Fail("We don't expect this to be called.");
            throw new System.NotImplementedException();
        }

        private int CompareCore(Endpoint x, Endpoint y)
        {
            for (var i = 0; i < _comparers.Length; i++)
            {
                var compare = _comparers[i].Compare(x, y);
                if (compare != 0)
                {
                    return compare;
                }
            }

            return 0;
        }

        private class OrderComparer : IComparer<Endpoint>
        {
            public static readonly IComparer<Endpoint> Instance = new OrderComparer();

            public int Compare(Endpoint? x, Endpoint? y)
            {
                var routeEndpointX = x as RouteEndpoint;
                var routeEndpointY = y as RouteEndpoint;

                if (routeEndpointX != null)
                {
                    if (routeEndpointY != null)
                    {
                        return routeEndpointX.Order.CompareTo(routeEndpointY.Order);
                    }

                    return 1;
                }
                else if (routeEndpointY != null)
                {
                    return -1;
                }

                return 0;
            }
        }

        private class PrecedenceComparer : IComparer<Endpoint>
        {
            public static readonly IComparer<Endpoint> Instance = new PrecedenceComparer();

            public int Compare(Endpoint? x, Endpoint? y)
            {
                var routeEndpointX = x as RouteEndpoint;
                var routeEndpointY = y as RouteEndpoint;

                if (routeEndpointX != null)
                {
                    if (routeEndpointY != null)
                    {
                        return routeEndpointX.RoutePattern.InboundPrecedence
                            .CompareTo(routeEndpointY.RoutePattern.InboundPrecedence);
                    }

                    return 1;
                }
                else if (routeEndpointY != null)
                {
                    return -1;
                }

                return 0;
            }
        }
    }
```

###### 3.3.6.2 基类方法 - add endpoint

```c#
internal class DfaMatcherBuilder : MatcherBuilder
{
    public override void AddEndpoint(RouteEndpoint endpoint)
    {
        _endpoints.Add(endpoint);
    }
}

```

###### 3.3.6.3 基类方法 - build

```c#
internal class DfaMatcherBuilder : MatcherBuilder
{
    public override Matcher Build()
    {
#if DEBUG
    	var includeLabel = true;
#else
	    var includeLabel = false;
#endif
    
    	/* a - 构建 dfa tree（dfa node 根节点）*/
    
    	var root = BuildDfaTree(includeLabel);       
        
        // State count is the number of nodes plus an exit state
        var stateCount = 1;
        var maxSegmentCount = 0;
        root.Visit((node) =>
        	{
                stateCount++;
                maxSegmentCount = Math.Max(maxSegmentCount, node.PathDepth);
            });
        _stateIndex = 0;
        
        // The max segment count is the maximum path-node-depth +1. 
        // We need the +1 to capture any additional content after the 'last' segment.
        maxSegmentCount++;
        
        /* b - 创建 dfa state 集合 */
        var states = new DfaState[stateCount];
        var exitDestination = stateCount - 1;
        AddNode(root, states, exitDestination);
        
        // The root state only has a jump table.        
        states[exitDestination] = new DfaState(
            Array.Empty<Candidate>(),
            Array.Empty<IEndpointSelectorPolicy>(),
            JumpTableBuilder.Build(exitDestination, exitDestination, null),
            null);
        
        /* 创建 dfa matcher */
        return new DfaMatcher(
            _loggerFactory.CreateLogger<DfaMatcher>(), 
            _selector, 
            states, 
            maxSegmentCount);
    }  
    
    private int AddNode(
        DfaNode node,
        DfaState[] states,
        int exitDestination)
    {
        // 使用 endpoint comparer，排序 dfa node（root）中的 endpoints
        node.Matches?.Sort(_comparer);
        
        // 游标
        var currentStateIndex = _stateIndex;        
        var currentDefaultDestination = exitDestination;
        var currentExitDestination = exitDestination;
        
        // path entry 集合（预结果）
        (string text, int destination)[] pathEntries = null;
        // policy entry 集合（预结果）
        PolicyJumpTableEdge[] policyEntries = null;
        
        // 如果 node 的 literals 不为 null，
        // 遍历 literals，将 path 注入 path entrie 集合
        if (node.Literals != null)
        {
            pathEntries = new (string text, int destination)[node.Literals.Count];
            
            var index = 0;
            foreach (var kvp in node.Literals)
            {
                var transition = Transition(kvp.Value);
                pathEntries[index++] = (kvp.Key, transition);
            }
        }
        
        // 如果 node 包含 parameter、catch all，并且 parameter 和 catch all 是同一个 node，        
        if (node.Parameters != null &&
            node.CatchAll != null &&
            ReferenceEquals(node.Parameters, node.CatchAll))
        {
            // This node has a single transition to but it should accept zero-width segments
            // this can happen when a node only has catchall parameters.
            currentExitDestination = currentDefaultDestination 
                				  = Transition(node.Parameters);
        }
        // 否则，如果 node 包含 parameter、catch all（parameter 和 catch all 不是同一个 node），        
        else if (node.Parameters != null && 
                 node.CatchAll != null)
        {
            // This node has a separate transition for zero-width segments
            // this can happen when a node has both parameters and catchall parameters.
            currentDefaultDestination = Transition(node.Parameters);
            currentExitDestination = Transition(node.CatchAll);
        }
        // 否则，如果 node 包含 parameter（不包含 catch all），
        else if (node.Parameters != null)
        {
            // This node has paramters but no catchall.
            currentDefaultDestination = Transition(node.Parameters);
        }
        // 否则，如果 node 包含 catch all（不包含 parameter），
        else if (node.CatchAll != null)
        {
            // This node has a catchall but no parameters
            currentExitDestination = currentDefaultDestination 
                				  = Transition(node.CatchAll);
        }
        
        // 如果 node 的 policy edges 不为空，注入 policy entry 集合
        if (node.PolicyEdges != null && 
            node.PolicyEdges.Count > 0)
        {
            policyEntries = new PolicyJumpTableEdge[node.PolicyEdges.Count];
            
            var index = 0;
            foreach (var kvp in node.PolicyEdges)
            {
                policyEntries[index++] = new PolicyJumpTableEdge(
                    kvp.Key, 
                    Transition(kvp.Value));
            }
        }
        
        // 由 node.matches（endpoint 集合）创建 candidate 集合
        var candidates = CreateCandidates(node.Matches);
        
        // 遍历传入的 endpoint selector policy 集合，
        // 如果 endpoint selector policy 可以应用于 node.matches（endpoints 集合），
        // -> 将（传入的）endpoint selector policy 注入 endpoint selector policy 集合
        List<IEndpointSelectorPolicy> endpointSelectorPolicies = null;
        if (node.Matches?.Count > 0)
        {
            for (var i = 0; i < _endpointSelectorPolicies.Length; i++)
            {
                var endpointSelectorPolicy = _endpointSelectorPolicies[i];
                if (endpointSelectorPolicy.AppliesToEndpoints(node.Matches))
                {
                    if (endpointSelectorPolicies == null)
                    {
                        endpointSelectorPolicies = new List<IEndpointSelectorPolicy>();
                    }
                    
                    endpointSelectorPolicies.Add(endpointSelectorPolicy);
                }
            }
        }
        
        // 创建 dfa state，注入 candidate state 集合
        states[currentStateIndex] = new DfaState(
            candidates,
            endpointSelectorPolicies?.ToArray() ?? Array.Empty<IEndpointSelectorPolicy>(),
            JumpTableBuilder.Build(
                currentDefaultDestination, 
                currentExitDestination, 
                pathEntries),
            // Use the final exit destination when building the policy state.
            // We don't want to use either of the current destinations 
            // because they refer routing states,
            // and a policy state should never transition back to a routing state.
            BuildPolicy(exitDestination, node.NodeBuilder, policyEntries));
        
        return currentStateIndex;
        
        int Transition(DfaNode next)
        {
            // Break cycles
            if (ReferenceEquals(node, next))
            {
                return _stateIndex;
            }
            else
            {
                _stateIndex++;
                return AddNode(next, states, exitDestination);
            }
        }
    }
    
    internal Candidate[] CreateCandidates(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null || endpoints.Count == 0)
        {
            return Array.Empty<Candidate>();
        }
        
        var candiates = new Candidate[endpoints.Count];
        
        var score = 0;
        var examplar = endpoints[0];
        candiates[0] = CreateCandidate(examplar, score);
        
        for (var i = 1; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            if (!_comparer.Equals(examplar, endpoint))
            {
                // This endpoint doesn't have the same priority.
                examplar = endpoint;
                score++;
            }
            
            candiates[i] = CreateCandidate(endpoint, score);
        }
        
        return candiates;
    }

    internal Candidate CreateCandidate(Endpoint endpoint, int score)
    {
        (string parameterName, 
         int segmentIndex, 
         int slotIndex) catchAll = default;
        
        if (endpoint is RouteEndpoint routeEndpoint)
        {
            _assignments.Clear();
            _slots.Clear();
            _captures.Clear();
            _complexSegments.Clear();
            _constraints.Clear();
            
            foreach (var kvp in routeEndpoint.RoutePattern.Defaults)
            {
                _assignments.Add(kvp.Key, _assignments.Count);
                _slots.Add(kvp);
            }
            
            for (var i = 0; i < routeEndpoint.RoutePattern.PathSegments.Count; i++)
            {
                var segment = routeEndpoint.RoutePattern.PathSegments[i];
                if (!segment.IsSimple)
                {
                    continue;
                }
                
                var parameterPart = segment.Parts[0] as RoutePatternParameterPart;
                if (parameterPart == null)
                {
                    continue;
                }
                
                if (!_assignments.TryGetValue(
                    	parameterPart.Name, 
                    	out var slotIndex))
                {
                    slotIndex = _assignments.Count;
                    _assignments.Add(parameterPart.Name, slotIndex);
                    
                    // A parameter can have a required value, default value/catch all, 
                    // or be a normal parameter
                    // Add the required value or default value as the slot's initial value
                    if (TryGetRequiredValue(
                        	routeEndpoint.RoutePattern, 
                        	parameterPart, 
                        	out var requiredValue))
                    {
                        _slots.Add(
                            new KeyValuePair<string, object>(
                                parameterPart.Name, 
                                requiredValue));
                    }
                    else
                    {
                        var hasDefaultValue = 
                            parameterPart.Default != null || 
                            parameterPart.IsCatchAll;
                        
                        _slots.Add(hasDefaultValue 
                                       ? new KeyValuePair<string, object>(
                                           parameterPart.Name, 
                                           parameterPart.Default) 
                                   	   : default);
                    }
                }
                
                if (TryGetRequiredValue(
                    	routeEndpoint.RoutePattern, 
                    	parameterPart, 
                    	out _))
                {
                    // Don't capture a parameter if it has a required value
                    // There is no need because a parameter 
                    // with a required value is matched as a literal
                }
                else if (parameterPart.IsCatchAll)
                {
                    catchAll = (parameterPart.Name, i, slotIndex);
                }
                else
                {
                    _captures.Add((parameterPart.Name, i, slotIndex));
                }
            }
            
            for (var i = 0; i < routeEndpoint.RoutePattern.PathSegments.Count; i++)
            {
                var segment = routeEndpoint.RoutePattern.PathSegments[i];
                if (segment.IsSimple)
                {
                    continue;
                }
                
                _complexSegments.Add((segment, i));
            }
            
            foreach (var kvp in routeEndpoint.RoutePattern.ParameterPolicies)
            {
                // may be null, that's ok
                var parameter = 
                    routeEndpoint
                    	.RoutePattern
                    	.GetParameter(kvp.Key); 
                var parameterPolicyReferences = kvp.Value;
                for (var i = 0; i < parameterPolicyReferences.Count; i++)
                {
                    var reference = parameterPolicyReferences[i];
                    var parameterPolicy =
                        _parameterPolicyFactory
                        	.Create(parameter, reference);
                    if (parameterPolicy is IRouteConstraint routeConstraint)
                    {
                        _constraints.Add(
                            new KeyValuePair<string, IRouteConstraint>(
                                kvp.Key, 
                                routeConstraint));
                    }
                }
            }
            
            return new Candidate(
                endpoint,
                score,
                _slots.ToArray(),
                _captures.ToArray(),
                catchAll,
                _complexSegments.ToArray(),
                _constraints.ToArray());
        }
        else
        {
            return new Candidate(
                endpoint,
                score,
                Array.Empty<KeyValuePair<string, object>>(),
                Array.Empty<(string parameterName, int segmentIndex, int slotIndex)>(),
                catchAll,
                Array.Empty<(RoutePatternPathSegment pathSegment, int segmentIndex)>(),
                Array.Empty<KeyValuePair<string, IRouteConstraint>>());
        }
    }
    
    private static PolicyJumpTable BuildPolicy(
        int exitDestination, 
        INodeBuilderPolicy nodeBuilder, 
        PolicyJumpTableEdge[] policyEntries)
    {
        if (policyEntries == null)
        {
            return null;
        }
        
        return nodeBuilder.BuildJumpTable(exitDestination, policyEntries);
    }
}

```

###### 3.3.6.4 build dfa tree (dfa node)

```c#
internal class DfaMatcherBuilder : MatcherBuilder
{
    public DfaNode BuildDfaTree(bool includeLabel = false)
    {
        if (!UseCorrectCatchAllBehavior)
        {
            // In 3.0 we did a global sort of the endpoints up front. 
            // This was a bug, because we actually want
            // do do the sort at each level of the tree based on precedence.
            //
            // _useLegacy30Behavior enables opt-out via an AppContext switch.
            _endpoints.Sort(_comparer);
        }
        
        // Since we're doing a BFS we will process each 'level' of the tree in stages
        // this list will hold the set of items we need to process at the current
        // stage.
        var work = new List<(RouteEndpoint endpoint, 
                             int precedenceDigit, 
                             List<DfaNode> parents)>(_endpoints.Count);
        
        List<(RouteEndpoint endpoint, 
              int precedenceDigit, 
              List<DfaNode> parents)> previousWork = null;
        
        var root = new DfaNode() 
        { 
            PathDepth = 0, 
            Label = includeLabel ? "/" : null 
        };
        
        // To prepare for this we need to compute the max depth, as well as
        // a seed list of items to process (entry, root).
        var maxDepth = 0;
        for (var i = 0; i < _endpoints.Count; i++)
        {
            var endpoint = _endpoints[i];
            var precedenceDigit = 
                GetPrecedenceDigitAtDepth(endpoint, depth: 0);
            
            work.Add(
                (endpoint, 
                 precedenceDigit, 
                 new List<DfaNode>() { root, }));
            
            maxDepth = Math.Max(
                maxDepth, 
                endpoint.RoutePattern.PathSegments.Count);
        }
        
        var workCount = work.Count;
        
        // Sort work at each level by *PRECEDENCE OF THE CURRENT SEGMENT*.
        //
        // We build the tree by doing a BFS over the list of entries. This is important
        // because a 'parameter' node can also traverse the same paths that literal nodes
        // traverse. This means that we need to order the entries first, or else we will
        // miss possible edges in the DFA.
        //
        // We'll sort the matches again later using the *real* comparer once building the
        // precedence part of the DFA is over.
        var precedenceDigitComparer = Comparer<(RouteEndpoint endpoint, 
                                                int precedenceDigit, 
                                                List<DfaNode> parents)>
            									.Create((x, y) =>
                                                     {
                                                         return x.precedenceDigit      			  															 .CompareTo(y.precedenceDigit);
                                                     });
        
        // Now we process the entries a level at a time.
        for (var depth = 0; depth <= maxDepth; depth++)
        {
            // As we process items, collect the next set of items.
            List<(RouteEndpoint endpoint, 
                  int precedenceDigit, 
                  List<DfaNode> parents)> nextWork;
            
            var nextWorkCount = 0;
            if (previousWork == null)
            {
                nextWork = 
                    new List<(RouteEndpoint endpoint, 
                              int precedenceDigit, 
                              List<DfaNode> parents)>();
            }
            else
            {
                // Reuse previous collection for the next collection
                // Don't clear the list so nested lists can be reused
                nextWork = previousWork;
            }
            
            if (UseCorrectCatchAllBehavior)
            {
                // The fix for the 3.0 sorting behavior bug.
                
                // See comments on precedenceDigitComparer
                work.Sort(
                    0, 
                    workCount, 
                    precedenceDigitComparer);
            }
            
            for (var i = 0; i < workCount; i++)
            {
                var (endpoint, _, parents) = work[i];
                
                if (!HasAdditionalRequiredSegments(endpoint, depth))
                {
                    for (var j = 0; j < parents.Count; j++)
                    {
                        var parent = parents[j];
                        parent.AddMatch(endpoint);
                    }
                }
                
                // Find the parents of this edge at the current depth
                List<DfaNode> nextParents;
                if (nextWorkCount < nextWork.Count)
                {
                    nextParents = nextWork[nextWorkCount].parents;
                    nextParents.Clear();
                    
                    var nextPrecedenceDigit = GetPrecedenceDigitAtDepth(endpoint, depth + 1);
                    nextWork[nextWorkCount] = (endpoint, nextPrecedenceDigit, nextParents);
                }
                else
                {
                    nextParents = new List<DfaNode>();
                    
                    // Add to the next set of work now so the list will be reused
                    // even if there are no parents
                    var nextPrecedenceDigit = GetPrecedenceDigitAtDepth(endpoint, depth + 1);
                    nextWork.Add((endpoint, nextPrecedenceDigit, nextParents));
                }
                
                var segment = GetCurrentSegment(endpoint, depth);
                if (segment == null)
                {
                    continue;
                }
                
                for (var j = 0; j < parents.Count; j++)
                {
                    var parent = parents[j];
                    var part = segment.Parts[0];
                    var parameterPart = part as RoutePatternParameterPart;
                    if (segment.IsSimple && 
                        part is RoutePatternLiteralPart literalPart)
                    {
                        AddLiteralNode(
                            includeLabel, 
                            nextParents, 
                            parent, 
                            literalPart.Content);
                    }
                    else if (segment.IsSimple && 
                             parameterPart != null && 
                             parameterPart.IsCatchAll)
                    {
                        // A catch all should traverse all literal nodes 
                        // as well as parameter nodes we don't need 
                        // to create the parameter node here because of ordering
                        // all catchalls will be processed after all parameters.
                        if (parent.Literals != null)
                        {
                            nextParents.AddRange(parent.Literals.Values);
                        }
                        if (parent.Parameters != null)
                        {
                            nextParents.Add(parent.Parameters);
                        }
                        
                        // We also create a 'catchall' here. We don't do further traversals
                        // on the catchall node because only catchalls can end up here. The
                        // catchall node allows us to capture an unlimited amount of segments
                        // and also to match a zero-length segment, which a parameter node
                        // doesn't allow.
                        if (parent.CatchAll == null)
                        {
                            parent.CatchAll = new DfaNode()
                            {
                                PathDepth = parent.PathDepth + 1,
                                Label = includeLabel ? parent.Label + "{*...}/" : null,
                            };
                            
                            // The catchall node just loops.
                            parent.CatchAll.Parameters = parent.CatchAll;
                            parent.CatchAll.CatchAll = parent.CatchAll;
                        }
                        
                        parent.CatchAll.AddMatch(endpoint);
                    }
                    else if (segment.IsSimple && 
                             parameterPart != null && 
                             TryGetRequiredValue(
                                 endpoint.RoutePattern, 
                                 parameterPart, 
                                 out var requiredValue))
                    {
                        // If the parameter has a matching required value, 
                        // replace the parameter with the required value as a literal. 
                        // This should use the parameter's transformer (if present) e.g. 
                        // Template: Home/{action}, 
                        // Required values: { action = "Index" }, Result: Home/Index
                        
                        if (endpoint
                            	.RoutePattern
                            	.ParameterPolicies
                            	.TryGetValue(
                                    parameterPart.Name, 
                                    out var parameterPolicyReferences))
                        {
                            for (var k = 0; k < parameterPolicyReferences.Count; k++)
                            {
                                var reference = parameterPolicyReferences[k];
                                var parameterPolicy = _parameterPolicyFactory.Create(
                                    parameterPart, 
                                    reference);
                                if (parameterPolicy is 
                                    IOutboundParameterTransformer parameterTransformer)
                                {
                                    requiredValue = parameterTransformer
                                        .TransformOutbound(requiredValue);
                                    break;
                                }
                            }
                        }
                        
                        var literalValue = requiredValue
                            ?.ToString() 
                            ?? throw new InvalidOperationException(
                            	$"Required value for literal '{parameterPart.Name}' 
                            	"must evaluate to a non-null string.");
                        
                        AddLiteralNode(
                            includeLabel, 
                            nextParents, 
                            parent, 
                            literalValue);
                    }
                    else if (segment.IsSimple && 
                             parameterPart != null)
                    {
                        if (parent.Parameters == null)
                        {
                            parent.Parameters = new DfaNode()
                            {
                                PathDepth = parent.PathDepth + 1,
                                Label = includeLabel ? parent.Label + "{...}/" : null,
                            };
                        }
                        
                        // A parameter should traverse all literal nodes 
                        // as well as the parameter node
                        if (parent.Literals != null)
                        {
                            nextParents.AddRange(parent.Literals.Values);
                        }
                        nextParents.Add(parent.Parameters);
                    }
                    else
                    {
                        // Complex segment - we treat these are parameters here and do the
                        // expensive processing later. We don't want to spend time processing
                        // complex segments unless they are the best match, and treating them
                        // like parameters in the DFA allows us to do just that.
                        if (parent.Parameters == null)
                        {
                            parent.Parameters = new DfaNode()
                            {
                                PathDepth = parent.PathDepth + 1,
                                Label = includeLabel ? parent.Label + "{...}/" : null,
                            };
                        }
                        
                        if (parent.Literals != null)
                        {
                            nextParents.AddRange(parent.Literals.Values);
                        }
                        nextParents.Add(parent.Parameters);
                    }
                }
                
                if (nextParents.Count > 0)
                {
                    nextWorkCount++;
                }
            }
            
            // Prepare the process the next stage.
            previousWork = work;
            work = nextWork;
            workCount = nextWorkCount;
        }
        
        // Build the trees of policy nodes (like HTTP methods). Post-order traversal
        // means that we won't have infinite recursion.
        root.Visit(ApplyPolicies);
        
        return root;
    }       
    
    private static int GetPrecedenceDigitAtDepth(
        RouteEndpoint endpoint, 
        int depth)
    {
        var segment = GetCurrentSegment(endpoint, depth);
        if (segment is null)
        {
            // Treat "no segment" as high priority. 
            // it won't effect the algorithm, but we need to define a sort-order.
            return 0;
        }
        
        return RoutePrecedence.ComputeInboundPrecedenceDigit(
            endpoint.RoutePattern, 
            segment);
    }
    
    private static bool HasAdditionalRequiredSegments(
        RouteEndpoint endpoint, 
        int depth)
    {
        for (var i = depth; i < endpoint.RoutePattern
             							.PathSegments
             							.Count; i++)
        {
            var segment = endpoint.RoutePattern
                				  .PathSegments[i];
            if (!segment.IsSimple)
            {
                // Complex segments always require more processing
                return true;
            }
            
            var parameterPart = segment.Parts[0] as RoutePatternParameterPart;
            if (parameterPart == null)
            {
                // It's a literal
                return true;
            }
            
            if (!parameterPart.IsOptional &&
                !parameterPart.IsCatchAll &&
                parameterPart.Default == null)
            {
                return true;
            }
        }
        
        return false;
    }
    
    private static RoutePatternPathSegment GetCurrentSegment(
        RouteEndpoint endpoint, 
        int depth)
    {
        if (depth < endpoint.RoutePattern
            				.PathSegments
            				.Count)
        {
            return endpoint.RoutePattern
                		   .PathSegments[depth];
        }
        
        if (endpoint.RoutePattern.PathSegments.Count == 0)
        {
            return null;
        }
        
        var lastSegment = endpoint.RoutePattern
            					  .PathSegments[endpoint.RoutePattern
                                                		.PathSegments.Count - 1];
        
        if (lastSegment.IsSimple && 
            lastSegment.Parts[0] is RoutePatternParameterPart parameterPart && 
            parameterPart.IsCatchAll)
        {
            return lastSegment;
        }
        
        return null;
    }
    
    private static void AddLiteralNode(
        bool includeLabel, 
        List<DfaNode> nextParents, 
        DfaNode parent, 
        string literal)
    {
        DfaNode next = null;
        if (parent.Literals == null ||
            !parent.Literals.TryGetValue(literal, out next))
        {
            next = new DfaNode()
            {
                PathDepth = parent.PathDepth + 1,
                Label = includeLabel ? parent.Label + literal + "/" : null,
            };
            parent.AddLiteral(literal, next);
        }
        
        nextParents.Add(next);
    }
    
    private static bool TryGetRequiredValue(
        RoutePattern routePattern, 
        RoutePatternParameterPart parameterPart, 
        out object value)
    {
        if (!routePattern
            	.RequiredValues
            	.TryGetValue(parameterPart.Name, out value))
        {
            return false;
        }
        
        return !RouteValueEqualityComparer
            .Default
            .Equals(value, string.Empty);
    }
    
    private void ApplyPolicies(DfaNode node)
    {
        if (node.Matches == null || node.Matches.Count == 0)
        {
            return;
        }
        
        // We're done with the precedence based work. Sort the endpoints
        // before applying policies for simplicity in policy-related code.
        node.Matches.Sort(_comparer);
        
        // Start with the current node as the root.
        var work = new List<DfaNode>() { node, };
        List<DfaNode> previousWork = null;
        for (var i = 0; i < _nodeBuilders.Length; i++)
        {
            var nodeBuilder = _nodeBuilders[i];
            
            // Build a list of each
            List<DfaNode> nextWork;
            if (previousWork == null)
            {
                nextWork = new List<DfaNode>();
            }
            else
            {
                // Reuse previous collection for the next collection
                previousWork.Clear();
                nextWork = previousWork;
            }
            
            for (var j = 0; j < work.Count; j++)
            {
                var parent = work[j];
                if (!nodeBuilder
                    	.AppliesToEndpoints(
                            parent.Matches 
                            	?? (IReadOnlyList<Endpoint>)Array.Empty<Endpoint>()))
                {
                    // This node-builder doesn't care about this node, so add it to the list
                    // to be processed by the next node-builder.
                    nextWork.Add(parent);
                    continue;
                }
                
                // This node-builder does apply to this node, 
                // so we need to create new nodes for each edge,
                // and then attach them to the parent.
                var edges = nodeBuilder.GetEdges(
                    parent.Matches 
                    	?? (IReadOnlyList<Endpoint>)Array.Empty<Endpoint>());
                for (var k = 0; k < edges.Count; k++)
                {
                    var edge = edges[k];
                    
                    var next = new DfaNode()
                    {
                        // If parent label is null then labels are not being included
                        Label = (parent.Label != null) 
                            ? parent.Label + " " + edge.State.ToString() 
                            : null,
                    };
                    
                    if (edge.Endpoints.Count > 0)
                    {
                        next.AddMatches(edge.Endpoints);
                    }
                    nextWork.Add(next);
                    
                    parent.AddPolicyEdge(edge.State, next);
                }
                
                // Associate the node-builder so we can build a jump table later.
                parent.NodeBuilder = nodeBuilder;
                
                // The parent no longer has matches, it's not considered a terminal node.
                parent.Matches?.Clear();
            }
            
            previousWork = work;
            work = nextWork;
        }
    }                        
}

```

###### a- dfa node

```c#
[DebuggerDisplay("{DebuggerToString(),nq}")]
internal class DfaNode
{   
    // This value is not computed for Policy nodes and will be set to -1.
    public int PathDepth { get; set; } = -1;    
    // Just for diagnostics and debugging
    public string Label { get; set; }
    
    /* 路由数据，类似 segment，包含多个 part (literal、parameter、catch all) */
    // 当前 node 的 endpoint 集合
    public List<Endpoint> Matches { get; private set; }        
    // literals 节点（part）
    public Dictionary<string, DfaNode> Literals { get; private set; }    
    // parameter 节点（part，只有 1 个）
    public DfaNode Parameters { get; set; }    
    // catch all 节点（part，只有 1 个）
    public DfaNode CatchAll { get; set; }
    
    /* dfa 边模型 */
    public Dictionary<object, DfaNode> PolicyEdges { get; private set; }
    public INodeBuilderPolicy NodeBuilder { get; set; }    
        
    // 注入 policy edge
    public void AddPolicyEdge(object state, DfaNode node)
    {
        if (PolicyEdges == null)
        {
            PolicyEdges = new Dictionary<object, DfaNode>();
        }
        
        PolicyEdges.Add(state, node);
    }
    
    // 注入 literal
    public void AddLiteral(string literal, DfaNode node)
    {
        if (Literals == null)
        {
            Literals = new Dictionary<string, DfaNode>(StringComparer.OrdinalIgnoreCase);
        }
        
        Literals.Add(literal, node);
    }
    // 注入 endpoint
    public void AddMatch(Endpoint endpoint)
    {
        if (Matches == null)
        {
            Matches = new List<Endpoint>();
        }
        
        Matches.Add(endpoint);
    }
    // 注入 endpoint 集合
    public void AddMatches(IEnumerable<Endpoint> endpoints)
    {
        if (Matches == null)
        {
            Matches = new List<Endpoint>(endpoints);
        }
        else
        {
            Matches.AddRange(endpoints);
        }
    }
    
    // 遍历 dfa node
    public void Visit(Action<DfaNode> visitor)
    {
        // 如果包含 literal node，遍历 literal node 的 visit 方法
        if (Literals != null)
        {
            foreach (var kvp in Literals)
            {
                kvp.Value.Visit(visitor);
            }
        }        
        // Break cycles
        // 如果包含 parameter node， 且不是自身，调用 parameter node 的 visit 方法
        if (Parameters != null && !ReferenceEquals(this, Parameters))
        {
            Parameters.Visit(visitor);
        }        
        // Break cycles
        // 如果包含 catch all node，且不是自身，调用 catch all node 的 visit 方法
        if (CatchAll != null && !ReferenceEquals(this, CatchAll))
        {
            CatchAll.Visit(visitor);
        }        
        // 如果包含 policy edge，遍历 policy edge 的 visit 方法
        if (PolicyEdges != null)
        {
            foreach (var kvp in PolicyEdges)
            {
                kvp.Value.Visit(visitor);
            }
        }
        
        visitor(this);
    }
    
    private string DebuggerToString()
    {
        var builder = new StringBuilder();
        
        builder.Append(Label);
        builder.Append(" d:");
        builder.Append(PathDepth);
        builder.Append(" m:");
        builder.Append(Matches?.Count ?? 0);
        builder.Append(" c: ");
        
        if (Literals != null)
        {
            builder.AppendJoin(
                ", ", 
                Literals.Select(kvp => $"{kvp.Key}->({FormatNode(kvp.Value)})"));
        }
        
        return builder.ToString();
        
        // DfaNodes can be self-referential, don't traverse cycles.
        string FormatNode(DfaNode other)
        {
            return ReferenceEquals(this, other) 
                ? "this" 
                : other.DebuggerToString();
        }
    }    
}

```

###### b- node builder policy

```c#
public interface INodeBuilderPolicy
{    
    bool AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints);       
    
    IReadOnlyList<PolicyNodeEdge> GetEdges(IReadOnlyList<Endpoint> endpoints);        
    PolicyJumpTable BuildJumpTable(
        int exitDestination, 
        IReadOnlyList<PolicyJumpTableEdge> edges);
}

public readonly struct PolicyJumpTableEdge
{
    public object State { get; }        
    public int Destination { get; }
    public PolicyJumpTableEdge(
        object state, 
        int destination)
    {
        State = state ?? throw new System.ArgumentNullException(nameof(state));
        Destination = destination;
    }            
}

public readonly struct PolicyNodeEdge
{
    public IReadOnlyList<Endpoint> Endpoints { get; }        
    public object State { get; }
    
    public PolicyNodeEdge(object state, IReadOnlyList<Endpoint> endpoints)
    {
        State = state ?? throw new System.ArgumentNullException(nameof(state));
        Endpoints = endpoints ?? throw new System.ArgumentNullException(nameof(endpoints));
    }               
}

```

##### 3.3.7 dfa matcher factory

```c#
internal class DfaMatcherFactory : MatcherFactory
{
    private readonly IServiceProvider _services;
    
    // Using the service provider here so we can avoid coupling to the dependencies
    // of DfaMatcherBuilder.
    public DfaMatcherFactory(IServiceProvider services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        _services = services;
    }
    
    public override Matcher CreateMatcher(EndpointDataSource dataSource)
    {
        if (dataSource == null)
        {
            throw new ArgumentNullException(nameof(dataSource));
        }
        
        // Creates a tracking entry in DI to stop listening for change events
        // when the services are disposed.
        var lifetime = _services.GetRequiredService<DataSourceDependentMatcher.Lifetime>();
        
        return new DataSourceDependentMatcher(
            dataSource, 
            lifetime, 
            () =>
            	{
                    return _services.GetRequiredService<DfaMatcherBuilder>();
                });
    }
}

```

##### 3.3.8 data source dependent matcher

* 封装了 matcher builder（dfa matcher buildder？）
* 由 endpoint data source 提供 endpoints 集合
* 缓存了 matcher

```c#
internal sealed class DataSourceDependentMatcher : Matcher
{
    private readonly Func<MatcherBuilder> _matcherBuilderFactory;
    
    private readonly DataSourceDependentCache<Matcher> _cache;
    internal Matcher CurrentMatcher => _cache.Value!;
    
    public DataSourceDependentMatcher(
        EndpointDataSource dataSource,
        Lifetime lifetime,
        Func<MatcherBuilder> matcherBuilderFactory)
    {
        // 注入 matcher builder 委托
        _matcherBuilderFactory = matcherBuilderFactory;
        // 创建 data source dependent cache
        _cache = new DataSourceDependentCache<Matcher>(dataSource, CreateMatcher);
        // cache initialized
        _cache.EnsureInitialized();
        
        // This will Dispose the cache when the lifetime is disposed, this allows
        // the service provider to manage the lifetime of the cache.
        lifetime.Cache = _cache;
    }
    
    private Matcher CreateMatcher(IReadOnlyList<Endpoint> endpoints)
    {        
        // 创建 matcher builder
        var builder = _matcherBuilderFactory();
        
        // 遍历 endpoints 集合，
        for (var i = 0; i < endpoints.Count; i++)
        {            
            // 如果 endpoint 是 route endpoint，
            // 并且 endpoint 的 metadata 中没有标记 suppress matching，
            // -> 注入 matcher builder
            if (endpoints[i] is RouteEndpoint endpoint && 
                endpoint.Metadata
                		.GetMetadata<ISuppressMatchingMetadata>()
                		?.SuppressMatching != true)
            {
                builder.AddEndpoint(endpoint);
            }
        }
        
        // 由 matcher builder 构建 matcher
        return builder.Build();
    }
    
    // Used to tie the lifetime of a DataSourceDependentCache to the service provider
    public sealed class Lifetime : IDisposable
    {
        private readonly object _lock = new object();
        private DataSourceDependentCache<Matcher>? _cache;
        private bool _disposed;
        
        public DataSourceDependentCache<Matcher>? Cache
        {
            get => _cache;
            set
            {
                lock (_lock)
                {
                    if (_disposed)
                    {
                        value?.Dispose();
                    }
                    
                    _cache = value;
                }
            }
        }
        
        public void Dispose()
        {
            lock (_lock)
            {
                _cache?.Dispose();
                _cache = null;
                
                _disposed = true;
            }
        }
    }
    
    public override Task MatchAsync(HttpContext httpContext)
    {
        return CurrentMatcher.MatchAsync(httpContext);
    }            
}

```

###### 3.3.8.1 suppress matching metadata

```c#
public interface ISuppressMatchingMetadata
{   
    bool SuppressMatching { get; }
}

public sealed class SuppressMatchingMetadata : ISuppressMatchingMetadata
{   
    public bool SuppressMatching => true;
}

```

### 4. for link

#### 4.1 endpoint address scheme

##### 4.1.1 接口

```c#
public interface IEndpointAddressScheme<TAddress>
{    
    IEnumerable<Endpoint> FindEndpoints(TAddress address);
}

```

##### 4.1.2 endpoint address scheme

```c#
internal sealed class EndpointNameAddressScheme : IEndpointAddressScheme<string>, IDisposable
{
    // 缓存 endpoints 集合
    private readonly DataSourceDependentCache<Dictionary<string, Endpoint[]>> _cache;
    internal Dictionary<string, Endpoint[]> Entries => _cache.EnsureInitialized();
    
    public EndpointNameAddressScheme(EndpointDataSource dataSource)
    {
        _cache = new DataSourceDependentCache<Dictionary<string, Endpoint[]>>(dataSource, Initialize);
    }
                
    private static Dictionary<string, Endpoint[]> Initialize(IReadOnlyList<Endpoint> endpoints)
    {
        // Collect duplicates as we go, blow up on startup if we find any.
        var hasDuplicates = false;
        
        var entries = new Dictionary<string, Endpoint[]>(StringComparer.Ordinal);
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            
            var endpointName = GetEndpointName(endpoint);
            if (endpointName == null)
            {
                continue;
            }
            
            if (!entries.TryGetValue(endpointName, out var existing))
            {
                // This isn't a duplicate (so far)
                entries[endpointName] = new[] { endpoint };
                continue;
            }
            
            // Ok this is a duplicate, because we have two endpoints with the same name. Bail out, because we
            // are just going to throw, we don't need to finish collecting data.
            hasDuplicates = true;
            break;
        }
        
        if (!hasDuplicates)
        {
            // No duplicates, success!
            return entries;
        }
        
        // OK we need to report some duplicates.
        var duplicates = endpoints.GroupBy(e => GetEndpointName(e))
            					.Where(g => g.Key != null && g.Count() > 1);
        
        var builder = new StringBuilder();
        builder.AppendLine(Resources.DuplicateEndpointNameHeader);
        
        foreach (var group in duplicates)
        {
            builder.AppendLine();
            builder.AppendLine(Resources.FormatDuplicateEndpointNameEntry(group.Key));
            
            foreach (var endpoint in group)
            {
                builder.AppendLine(endpoint.DisplayName);
            }
        }
        
        throw new InvalidOperationException(builder.ToString());
        
        // 方法 - get endpoint name
        string? GetEndpointName(Endpoint endpoint)
        {
            if (endpoint.Metadata
                	    .GetMetadata<ISuppressLinkGenerationMetadata>()?
                	    .SuppressLinkGeneration == true)
            {
                // Skip anything that's suppressed for linking.
                return null;
            }
            
            return endpoint.Metadata
                		  .GetMetadata<IEndpointNameMetadata>()?
                		  .EndpointName;
        }
    }
    
    public IEnumerable<Endpoint> FindEndpoints(string address)
    {
        if (address == null)
        {
            throw new ArgumentNullException(nameof(address));
        }
        
        // Capture the current value of the cache
        var entries = Entries;
        
        entries.TryGetValue(address, out var result);
        return result ?? Array.Empty<Endpoint>();
    }
            
    public void Dispose()
    {
        _cache.Dispose();
    }
}

```

###### 4.1.2.1 endpoint name metadata

```c#
public interface IEndpointNameMetadata
{    
    string EndpointName { get; }
}

public class EndpointNameMetadata : IEndpointNameMetadata
{
    public string EndpointName { get; }
    public EndpointNameMetadata(string endpointName)
    {
        if (endpointName == null)
        {
            throw new ArgumentNullException(nameof(endpointName));
        }
        
        EndpointName = endpointName;
    }    
}

```

##### 4.1.3 route value address scheme

```c#
internal sealed class RouteValuesAddressScheme : IEndpointAddressScheme<RouteValuesAddress>, IDisposable
{
    /* 缓存 state entry */
    private readonly DataSourceDependentCache<StateEntry> _cache;
    internal StateEntry State => _cache.EnsureInitialized();
            
    internal class StateEntry
    {        
        public readonly List<OutboundMatch> AllMatches;
        public readonly LinkGenerationDecisionTree AllMatchesLinkGenerationTree;
        public readonly Dictionary<string, List<OutboundMatchResult>> NamedMatches;
        
        public StateEntry(
            List<OutboundMatch> allMatches,
            LinkGenerationDecisionTree allMatchesLinkGenerationTree,
            Dictionary<string, List<OutboundMatchResult>> namedMatches)
        {
            AllMatches = allMatches;
            AllMatchesLinkGenerationTree = allMatchesLinkGenerationTree;
            NamedMatches = namedMatches;
        }
    }
    
    public RouteValuesAddressScheme(EndpointDataSource dataSource)
    {
        // 创建 state entry 缓存（空的，lazy create）
        _cache = new DataSourceDependentCache<StateEntry>(dataSource, Initialize);
    }
    
    private StateEntry Initialize(IReadOnlyList<Endpoint> endpoints)
    {
        var allOutboundMatches = new List<OutboundMatch>();
        var namedOutboundMatchResults = new Dictionary<string, List<OutboundMatchResult>>(StringComparer.OrdinalIgnoreCase);
        
        // Decision tree is built using the 'required values' of actions.
        // - When generating a url using route values, decision tree checks the explicitly supplied route values +
        //   ambient values to see if they have a match for the required-values-based-tree.
        // - When generating a url using route name, route values for controller, action etc.might not be provided
        //   (this is expected because as a user I want to avoid writing all those and instead chose to use a
        //   routename which is quick). So since these values are not provided and might not be even in ambient
        //   values, decision tree would fail to find a match. So for this reason decision tree is not used for named
        //   matches. Instead all named matches are returned as is and the LinkGenerator uses a TemplateBinder to
        //   decide which of the matches can generate a url.
        //   For example, for a route defined like below with current ambient values like new { controller = "Home",
        //   action = "Index" }
        //     "api/orders/{id}",
        //     routeName: "OrdersApi",
        //     defaults: new { controller = "Orders", action = "GetById" },
        //     requiredValues: new { controller = "Orders", action = "GetById" },
        //   A call to GetLink("OrdersApi", new { id = "10" }) cannot generate url as neither the supplied values or
        //   current ambient values do not satisfy the decision tree that is built based on the required values.
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            if (!(endpoint is RouteEndpoint routeEndpoint))
            {
                continue;
            }
            
            var metadata = endpoint.Metadata
                				  .GetMetadata<IRouteNameMetadata>();
            if (metadata == null && 
                routeEndpoint.RoutePattern.RequiredValues.Count == 0)
            {
                continue;
            }
            
            if (endpoint.Metadata
                	    .GetMetadata<ISuppressLinkGenerationMetadata>()?
                	    .SuppressLinkGeneration == true)
            {
                continue;
            }
            
            var entry = CreateOutboundRouteEntry(
                routeEndpoint,
                routeEndpoint.RoutePattern.RequiredValues,
                metadata?.RouteName);
            
            var outboundMatch = new OutboundMatch() { Entry = entry };
            allOutboundMatches.Add(outboundMatch);
            
            if (string.IsNullOrEmpty(entry.RouteName))
            {
                continue;
            }
            
            if (!namedOutboundMatchResults.TryGetValue(entry.RouteName, out var matchResults))
            {
                matchResults = new List<OutboundMatchResult>();
                namedOutboundMatchResults.Add(entry.RouteName, matchResults);
            }
            
            matchResults.Add(new OutboundMatchResult(outboundMatch, isFallbackMatch: false));
        }
        
        return new StateEntry(
            allOutboundMatches,
            new LinkGenerationDecisionTree(allOutboundMatches),
            namedOutboundMatchResults);
    }
                
    public IEnumerable<Endpoint> FindEndpoints(RouteValuesAddress address)
    {
        if (address == null)
        {
            throw new ArgumentNullException(nameof(address));
        }
        
        var state = State;
        
        IList<OutboundMatchResult>? matchResults = null;
        if (string.IsNullOrEmpty(address.RouteName))
        {
            matchResults = state.AllMatchesLinkGenerationTree.GetMatches(
                address.ExplicitValues,
                address.AmbientValues);
        }
        else if (state.NamedMatches.TryGetValue(address.RouteName, out var namedMatchResults))
        {
            matchResults = namedMatchResults;
        }
        
        if (matchResults != null)
        {
            var matchCount = matchResults.Count;
            if (matchCount > 0)
            {
                if (matchResults.Count == 1)
                {
                    // Special case having a single result to avoid creating iterator state machine
                    return new[] { (RouteEndpoint)matchResults[0].Match.Entry.Data };
                }
                else
                {
                    // Use separate method since one cannot have regular returns in an iterator method
                    return GetEndpoints(matchResults, matchCount);
                }
            }
        }
        
        return Array.Empty<Endpoint>();
    }
    
    private static IEnumerable<Endpoint> GetEndpoints(
        IList<OutboundMatchResult> matchResults, 
        int matchCount)
    {
        for (var i = 0; i < matchCount; i++)
        {
            yield return (RouteEndpoint)matchResults[i].Match.Entry.Data;
        }
    }
                            
    private OutboundRouteEntry CreateOutboundRouteEntry(
        RouteEndpoint endpoint,
        IReadOnlyDictionary<string, object?> requiredValues,
        string? routeName)
    {
        var entry = new OutboundRouteEntry()
        {
            Handler = NullRouter.Instance,
            Order = endpoint.Order,
            Precedence = RoutePrecedence.ComputeOutbound(endpoint.RoutePattern),
            RequiredLinkValues = new RouteValueDictionary(requiredValues),
            RouteTemplate = new RouteTemplate(endpoint.RoutePattern),
            Data = endpoint,
            RouteName = routeName,
        };
        
        entry.Defaults = new RouteValueDictionary(endpoint.RoutePattern.Defaults);
        return entry;
    }
    
    public void Dispose()
    {
        _cache.Dispose();
    }
        
}

```

###### 4.1.3.1 route value address

```c#
public class RouteValuesAddress
{    
    public string? RouteName { get; set; }        
    public RouteValueDictionary ExplicitValues { get; set; } = default!;        
    public RouteValueDictionary? AmbientValues { get; set; }
}

```

###### 4.1.3.2 suppress link generator metadata

```c#
public interface ISuppressLinkGenerationMetadata
{    
    bool SuppressLinkGeneration { get; }
}

public sealed class SuppressLinkGenerationMetadata : ISuppressLinkGenerationMetadata
{    
    public bool SuppressLinkGeneration => true;
}

```

###### 4.1.3.3 route name metadata

```c#
public interface IRouteNameMetadata
{    
    string? RouteName { get; }
}

[DebuggerDisplay("{DebuggerToString(),nq}")]
public sealed class RouteNameMetadata : IRouteNameMetadata
{
    public string? RouteName { get; }
    
    public RouteNameMetadata(string? routeName)
    {
        RouteName = routeName;
    }
                
    internal string DebuggerToString()
    {
        return $"Name: {RouteName}";
    }
}

```



#### 4.2 link parser

##### 4.2.1 抽象

```c#
public abstract class LinkParser
{        
    public abstract RouteValueDictionary? ParsePathByAddress<TAddress>(TAddress address, PathString path);
}

public static class LinkParserEndpointNameAddressExtensions
{        
    public static RouteValueDictionary? ParsePathByEndpointName(
        this LinkParser parser,
        string endpointName,
        PathString path)
    {
        if (parser == null)
        {
            throw new ArgumentNullException(nameof(parser));
        }        
        if (endpointName == null)
        {
            throw new ArgumentNullException(nameof(endpointName));
        }
        
        return parser.ParsePathByAddress<string>(endpointName, path);
    }
}

```

##### 4.2.2 default link parser

```c#
internal class DefaultLinkParser : LinkParser, IDisposable
{
    private readonly ParameterPolicyFactory _parameterPolicyFactory;
    private readonly ILogger<DefaultLinkParser> _logger;
    private readonly IServiceProvider _serviceProvider;
    
    // route pattern matcher 缓存
    private readonly DataSourceDependentCache<ConcurrentDictionary<RouteEndpoint, MatcherState>> _matcherCache;    
    // 创建 router patter matcher 的委托
    private readonly Func<RouteEndpoint, MatcherState> _createMatcher;
    
    public DefaultLinkParser(
        ParameterPolicyFactory parameterPolicyFactory,
        // 注入 endpoint 集合，从中解析 route pattern 从而验证 request path
        EndpointDataSource dataSource,
        ILogger<DefaultLinkParser> logger,
        IServiceProvider serviceProvider)
    {
        _parameterPolicyFactory = parameterPolicyFactory;
        _logger = logger;
        _serviceProvider = serviceProvider;
        
        // 创建 route pattern matcher cache（空的、lazy create）
        _matcherCache = new DataSourceDependentCache<ConcurrentDictionary<RouteEndpoint, MatcherState>>(
            dataSource, 
            (_) =>
            	{
                    // We don't eagerly fill this cache because there's no real reason to. 
                    // Unlike URL matching, we don't need to build a big data structure up front to be correct.
                    return new ConcurrentDictionary<RouteEndpoint, MatcherState>();
                });
        
        //注入 route pattern matcher 创建委托
        _createMatcher = CreateRoutePatternMatcher;
    }
    
    /* 创建 route pattern matcher */
    private MatcherState CreateRoutePatternMatcher(RouteEndpoint endpoint)
    {       
        // route constraints（预结果）
        var constraints = new Dictionary<string, List<IRouteConstraint>>(StringComparer.OrdinalIgnoreCase);        
        
        // 遍历 route endpoint 的 route pattern 的 parameter policy，
        // 如果是 route constraint，注入 route constraints 结果集
        var policies = endpoint.RoutePattern.ParameterPolicies;
        foreach (var kvp in policies)
        {
            var constraintsForParameter = new List<IRouteConstraint>();
            var parameter = endpoint.RoutePattern.GetParameter(kvp.Key);
            for (var i = 0; i < kvp.Value.Count; i++)
            {
                var policy = _parameterPolicyFactory.Create(parameter, kvp.Value[i]);
                if (policy is IRouteConstraint constraint)
                {
                    constraintsForParameter.Add(constraint);
                }
            }
            
            if (constraintsForParameter.Count > 0)
            {
                constraints.Add(kvp.Key, constraintsForParameter);
            }
        }
        
        // 创建 pattern matcher
        var matcher = new RoutePatternMatcher(
            endpoint.RoutePattern, 
            new RouteValueDictionary(endpoint.RoutePattern.Defaults));
        
        // 封装 route pattern matcher、route constraint 到 matcher state
        return new MatcherState(matcher, constraints);
    }
        
    internal readonly struct MatcherState
    {
        public readonly RoutePatternMatcher Matcher;
        public readonly Dictionary<string, List<IRouteConstraint>> Constraints;
        
        public MatcherState(
            RoutePatternMatcher matcher, 
            Dictionary<string, List<IRouteConstraint>> constraints)
        {
            Matcher = matcher;
            Constraints = constraints;
        }
        
        public void Deconstruct(
            out RoutePatternMatcher matcher, 
            out Dictionary<string, List<IRouteConstraint>> constraints)
        {
            matcher = Matcher;
            constraints = Constraints;
        }
    }
    
    
    
    
    
    
    
    // Internal for testing
    
    // Internal for testing
    internal bool TryParse(
        RouteEndpoint endpoint, 
        PathString path, 
        [NotNullWhen(true)] out RouteValueDictionary? values)
    {
        var (matcher, constraints) = GetMatcherState(endpoint);
        
        values = new RouteValueDictionary();
        if (!matcher.TryMatch(path, values))
        {
            values = null;
            return false;
        }
        
        foreach (var kvp in constraints)
        {
            for (var i = 0; i < kvp.Value.Count; i++)
            {
                var constraint = kvp.Value[i];
                if (!constraint.Match(
	                    httpContext: null, 
    	                NullRouter.Instance, 
        	            kvp.Key, 
            	        values, 
                	    RouteDirection.IncomingRequest))
                {
                    values = null;
                    return false;
                }
            }
        }
        
        return true;
    }
    
    public void Dispose()
    {
        _matcherCache.Dispose();
    }
    
    
    
#nullable disable
    private static class Log
    {
        public static class EventIds
        {
            public static readonly EventId EndpointsFound = new EventId(100, "EndpointsFound");
            public static readonly EventId EndpointsNotFound = new EventId(101, "EndpointsNotFound");            
            public static readonly EventId PathParsingSucceeded = new EventId(102, "PathParsingSucceeded");
            public static readonly EventId PathParsingFailed = new EventId(103, "PathParsingFailed");
        }
        
        private static readonly Action<ILogger, IEnumerable<string>, object, Exception> _endpointsFound = 
            LoggerMessage.Define<IEnumerable<string>, object>(
            	LogLevel.Debug,
	            EventIds.EndpointsFound,
    	        "Found the endpoints {Endpoints} for address {Address}");

        private static readonly Action<ILogger, object, Exception> _endpointsNotFound = 
            LoggerMessage.Define<object>(
	            LogLevel.Debug,
            	EventIds.EndpointsNotFound,
            	"No endpoints found for address {Address}");
        
        private static readonly Action<ILogger, string, string, Exception> _pathParsingSucceeded = 
            LoggerMessage.Define<string, string>(
	            LogLevel.Debug,
            	EventIds.PathParsingSucceeded,
            	"Path parsing succeeded for endpoint {Endpoint} and URI path {URI}");
        
        private static readonly Action<ILogger, IEnumerable<string>, string, Exception> _pathParsingFailed = 
            LoggerMessage.Define<IEnumerable<string>, string>(
                LogLevel.Debug,
                EventIds.PathParsingFailed,
                "Path parsing failed for endpoints {Endpoints} and URI path {URI}");

        public static void EndpointsFound(ILogger logger, object address, IEnumerable<Endpoint> endpoints)
        {
            // Checking level again to avoid allocation on the common path
            if (logger.IsEnabled(LogLevel.Debug))
            {
                _endpointsFound(logger, endpoints.Select(e => e.DisplayName), address, null);
            }
        }
        
        public static void EndpointsNotFound(ILogger logger, object address)
        {
            _endpointsNotFound(logger, address, null);
        }
        
        public static void PathParsingSucceeded(ILogger logger, PathString path, Endpoint endpoint)
        {
            // Checking level again to avoid allocation on the common path
            if (logger.IsEnabled(LogLevel.Debug))
            {
                _pathParsingSucceeded(logger, endpoint.DisplayName, path.Value, null);
            }
        }
        
        public static void PathParsingFailed(ILogger logger, PathString path, IEnumerable<Endpoint> endpoints)
        {
            // Checking level again to avoid allocation on the common path
            if (logger.IsEnabled(LogLevel.Debug))
            {
                _pathParsingFailed(logger, endpoints.Select(e => e.DisplayName), path.Value, null);
            }
        }
    }
}

```

###### 4.2.2.1 parse path by address

```c#
internal class DefaultLinkParser : LinkParser, IDisposable
{    
    public override RouteValueDictionary? ParsePathByAddress<TAddress>(
        TAddress address, 
        PathString path)
    {
        var endpoints = GetEndpoints(address);
        if (endpoints.Count == 0)
        {
            return null;
        }
        
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            if (TryParse(endpoint, path, out var values))
            {
                Log.PathParsingSucceeded(_logger, path, endpoint);
                return values;
            }
        }
        
        Log.PathParsingFailed(_logger, path, endpoints);
        return null;
    }
    
    // get endpoints
    private List<RouteEndpoint> GetEndpoints<TAddress>(TAddress address)
    {
        // 解析 address scheme
        var addressingScheme = _serviceProvider.GetRequiredService<IEndpointAddressScheme<TAddress>>();
        // 从 address scheme 解析 endpoint
        var endpoints = addressingScheme.FindEndpoints(address)
            						  .OfType<RouteEndpoint>()
            						  .ToList();
        
        if (endpoints.Count == 0)
        {
            Log.EndpointsNotFound(_logger, address);
        }
        else
        {
            Log.EndpointsFound(_logger, address, endpoints);
        }
        
        return endpoints;
    }
        
    internal bool TryParse(
        RouteEndpoint endpoint, 
        PathString path, 
        [NotNullWhen(true)] out RouteValueDictionary? values)
    {
        var (matcher, constraints) = GetMatcherState(endpoint);
        
        // 由 route pattern matcher 解析 route value
        values = new RouteValueDictionary();
        if (!matcher.TryMatch(path, values))
        {
            values = null;
            return false;
        }
        
        // 遍历 constraint matcher，验证 route value 符合 constraint
        foreach (var kvp in constraints)
        {
            for (var i = 0; i < kvp.Value.Count; i++)
            {
                var constraint = kvp.Value[i];
                if (!constraint.Match(
	                    httpContext: null, 
    	                NullRouter.Instance, 
        	            kvp.Key, 
            	        values, 
                	    RouteDirection.IncomingRequest))
                {
                    values = null;
                    return false;
                }
            }
        }
        
        return true;
    }
    
    // 从 matcher state cache 解析 matcher state
    internal MatcherState GetMatcherState(RouteEndpoint endpoint) => 
        _matcherCache.EnsureInitialized().GetOrAdd(endpoint, _createMatcher);    
}

```

#### 4.3 link generator

##### 4.3.1 抽象

###### 4.3.1.1 link generator

```c#
public abstract class LinkGenerator
{    
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public abstract string? GetPathByAddress<TAddress>(
        HttpContext httpContext,
        TAddress address,
        RouteValueDictionary values,
        RouteValueDictionary? ambientValues = default,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default);
    
   
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public abstract string? GetPathByAddress<TAddress>(
        TAddress address,
        RouteValueDictionary values,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default);
        
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public abstract string? GetUriByAddress<TAddress>(
        HttpContext httpContext,
        TAddress address,
        RouteValueDictionary values,
        RouteValueDictionary? ambientValues = default,
        string? scheme = default,
        HostString? host = default,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default);
        
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public abstract string? GetUriByAddress<TAddress>(
        TAddress address,
        RouteValueDictionary values,
        string? scheme,
        HostString host,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default);
}

```

###### 4.3.1.2 扩展方法 - by endpoint name address

```c#
public static class LinkGeneratorEndpointNameAddressExtensions
{    
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetPathByName(
        this LinkGenerator generator,
        HttpContext httpContext,
        string endpointName,
        object? values,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }        
        if (endpointName == null)
        {
            throw new ArgumentNullException(nameof(endpointName));
        }
        
        return generator.GetPathByAddress<string>(
            httpContext,
            endpointName,
            new RouteValueDictionary(values),
            ambientValues: null,
            pathBase,
            fragment,
            options);
    }
            
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetPathByName(
        this LinkGenerator generator,
        string endpointName,
        object? values,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (endpointName == null)
        {
            throw new ArgumentNullException(nameof(endpointName));
        }
        
        return generator.GetPathByAddress<string>(
            endpointName, 
            new RouteValueDictionary(values), 
            pathBase, 
            fragment, 
            options);
    }
        
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetUriByName(
        this LinkGenerator generator,
        HttpContext httpContext,
        string endpointName,
        object? values,
        string? scheme = default,
        HostString? host = default,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }        
        if (endpointName == null)
        {
            throw new ArgumentNullException(nameof(endpointName));
        }
        
        return generator.GetUriByAddress<string>(
            httpContext,
            endpointName,
            new RouteValueDictionary(values),
            ambientValues: null,
            scheme,
            host,
            pathBase,
            fragment,
            options);
    }
            
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetUriByName(
        this LinkGenerator generator,
        string endpointName,
        object? values,
        string scheme,
        HostString host,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (endpointName == null)
        {
            throw new ArgumentNullException(nameof(endpointName));
        }        
        if (string.IsNullOrEmpty(scheme))
        {
            throw new ArgumentException("A scheme must be provided.", nameof(scheme));
        }        
        if (!host.HasValue)
        {
            throw new ArgumentException("A host must be provided.", nameof(host));
        }
        
        return generator.GetUriByAddress<string>(
            endpointName, 
            new RouteValueDictionary(values), 
            scheme, 
            host, 
            pathBase, 
            fragment, 
            options);
    }
}

```

###### 4.3.1.3 扩展方法 - by route value address

```c#
public static class LinkGeneratorRouteValuesAddressExtensions
{    
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetPathByRouteValues(
        this LinkGenerator generator,
        HttpContext httpContext,
        string? routeName,
        object? values,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }       
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        var address = CreateAddress(httpContext, routeName, values);
        return generator.GetPathByAddress<RouteValuesAddress>(
            httpContext,
            address,
            address.ExplicitValues,
            address.AmbientValues,
            pathBase,
            fragment,
            options);
    }
            
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetPathByRouteValues(
        this LinkGenerator generator,
        string? routeName,
        object? values,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }
        
        var address = CreateAddress(httpContext: null, routeName, values);
        return generator.GetPathByAddress<RouteValuesAddress>(
            address, 
            address.ExplicitValues, 
            pathBase, 
            fragment, 
            options);
    }
    
       
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetUriByRouteValues(
        this LinkGenerator generator,
        HttpContext httpContext,
        string? routeName,
        object? values,
        string? scheme = default,
        HostString? host = default,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        var address = CreateAddress(httpContext, routeName, values);
        return generator.GetUriByAddress<RouteValuesAddress>(
            httpContext,
            address,
            address.ExplicitValues,
            address.AmbientValues,
            scheme,
            host,
            pathBase,
            fragment,
            options);
    }
        
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetUriByRouteValues(
        this LinkGenerator generator,
        string? routeName,
        object? values,
        string scheme,
        HostString host,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }
        
        var address = CreateAddress(httpContext: null, routeName, values);
        return generator.GetUriByAddress<RouteValuesAddress>(
            address, 
            address.ExplicitValues, 
            scheme, 
            host, 
            pathBase, 
            fragment, 
            options);
    }
    
    private static RouteValuesAddress CreateAddress(
        HttpContext? httpContext, 
        string? routeName, 
        object? values)
    {
        return new RouteValuesAddress()
        {
            AmbientValues = DefaultLinkGenerator.GetAmbientValues(httpContext),
            ExplicitValues = new RouteValueDictionary(values),
            RouteName = routeName,
        };
    }
}

```

##### 4.3.2 default link generator

```c#
internal sealed class DefaultLinkGenerator : 
	LinkGenerator, 
	IDisposable
{
    private readonly ParameterPolicyFactory _parameterPolicyFactory;
    private readonly TemplateBinderFactory _binderFactory;
    private readonly ILogger<DefaultLinkGenerator> _logger;
    private readonly IServiceProvider _serviceProvider;
    
    // A LinkOptions object initialized with the values from RouteOptions
    // Used when the user didn't specify something more global.
    private readonly LinkOptions _globalLinkOptions;
    
    // template binder 缓存
    private readonly DataSourceDependentCache<ConcurrentDictionary<RouteEndpoint, TemplateBinder>> _cache;    
    // 创建 template binder 的委托
    private readonly Func<RouteEndpoint, TemplateBinder> _createTemplateBinder;
    
    public DefaultLinkGenerator(
        ParameterPolicyFactory parameterPolicyFactory,
        TemplateBinderFactory binderFactory,
        EndpointDataSource dataSource,
        IOptions<RouteOptions> routeOptions,
        ILogger<DefaultLinkGenerator> logger,
        IServiceProvider serviceProvider)
    {
        _parameterPolicyFactory = parameterPolicyFactory;
        _binderFactory = binderFactory;
        _logger = logger;
        _serviceProvider = serviceProvider;
        
        // 创建 template binder 缓存（空的，lazy create）
        _cache = new DataSourceDependentCache<ConcurrentDictionary<RouteEndpoint, TemplateBinder>>(
            dataSource, 
            (_) =>
            	{                    
                    return new ConcurrentDictionary<RouteEndpoint, TemplateBinder>();
                });
        
        // 注入 template binder 委托
        _createTemplateBinder = CreateTemplateBinder;
        
        // 由 route options 创建 link options
        _globalLinkOptions = new LinkOptions()
        {
            AppendTrailingSlash = routeOptions.Value.AppendTrailingSlash,
            LowercaseQueryStrings = routeOptions.Value.LowercaseQueryStrings,
            LowercaseUrls = routeOptions.Value.LowercaseUrls,
        };
    }
    
    private TemplateBinder CreateTemplateBinder(RouteEndpoint endpoint)
    {
        return _binderFactory.Create(endpoint.RoutePattern);
    }
                                                
    // Also called from DefaultLinkGenerationTemplate
    public static RouteValueDictionary? GetAmbientValues(HttpContext? httpContext)
    {
        return httpContext?.Features.Get<IRouteValuesFeature>()?.RouteValues;
    }
    
    public void Dispose()
    {
        _cache.Dispose();
    }
    
#nullable disable
    private static class Log
    {
        public static class EventIds
        {
            public static readonly EventId EndpointsFound = new EventId(100, "EndpointsFound");
            public static readonly EventId EndpointsNotFound = new EventId(101, "EndpointsNotFound");
            
            public static readonly EventId TemplateSucceeded = new EventId(102, "TemplateSucceeded");
            public static readonly EventId TemplateFailedRequiredValues = new EventId(103, "TemplateFailedRequiredValues");
            public static readonly EventId TemplateFailedConstraint = new EventId(103, "TemplateFailedConstraint");
            public static readonly EventId TemplateFailedExpansion = new EventId(104, "TemplateFailedExpansion");
            
            public static readonly EventId LinkGenerationSucceeded = new EventId(105, "LinkGenerationSucceeded");
            public static readonly EventId LinkGenerationFailed = new EventId(106, "LinkGenerationFailed");
        }
        
        private static readonly Action<ILogger, IEnumerable<string>, object, Exception> _endpointsFound = 
            LoggerMessage.Define<IEnumerable<string>, object>(
                LogLevel.Debug,
                EventIds.EndpointsFound,
                "Found the endpoints {Endpoints} for address {Address}");

        private static readonly Action<ILogger, object, Exception> _endpointsNotFound = 
            LoggerMessage.Define<object>(
                LogLevel.Debug,
                EventIds.EndpointsNotFound,
                "No endpoints found for address {Address}");

        private static readonly Action<ILogger, string, string, string, string, Exception> _templateSucceeded = 
            LoggerMessage.Define<string, string, string, string>(
                LogLevel.Debug,
                EventIds.TemplateSucceeded,
                "Successfully processed template {Template} for {Endpoint} resulting in {Path} and {Query}");

        private static readonly Action<ILogger, string, string, string, string, string, Exception> _templateFailedRequiredValues = 
            LoggerMessage.Define<string, string, string, string, string>(
                LogLevel.Debug,
                EventIds.TemplateFailedRequiredValues,
                "Failed to process the template {Template} for {Endpoint}. " +
                "A required route value is missing, or has a different value from the required default values. " +
                "Supplied ambient values {AmbientValues} and {Values} with default values {Defaults}");

        private static readonly Action<ILogger, string, string, IRouteConstraint, string, string, Exception> _templateFailedConstraint = 
            LoggerMessage.Define<string, string, IRouteConstraint, string, string>(
                LogLevel.Debug,
                EventIds.TemplateFailedConstraint,
                "Failed to process the template {Template} for {Endpoint}. " +
                "The constraint {Constraint} for parameter {ParameterName} failed with values {Values}");

        private static readonly Action<ILogger, string, string, string, Exception> _templateFailedExpansion = 
            LoggerMessage.Define<string, string, string>(
                LogLevel.Debug,
                EventIds.TemplateFailedExpansion,
                "Failed to process the template {Template} for {Endpoint}. " +
                "The failure occurred while expanding the template with values {Values} " +
                "This is usually due to a missing or empty value in a complex segment");

        private static readonly Action<ILogger, IEnumerable<string>, string, Exception> _linkGenerationSucceeded = 
            LoggerMessage.Define<IEnumerable<string>, string>(
                LogLevel.Debug,
                EventIds.LinkGenerationSucceeded,
                "Link generation succeeded for endpoints {Endpoints} with result {URI}");

        private static readonly Action<ILogger, IEnumerable<string>, Exception> _linkGenerationFailed = 
            LoggerMessage.Define<IEnumerable<string>>(
                LogLevel.Debug,
                EventIds.LinkGenerationFailed,
                "Link generation failed for endpoints {Endpoints}");

        public static void EndpointsFound(ILogger logger, object address, IEnumerable<Endpoint> endpoints)
        {
            // Checking level again to avoid allocation on the common path
            if (logger.IsEnabled(LogLevel.Debug))
            {
                _endpointsFound(logger, endpoints.Select(e => e.DisplayName), address, null);
            }
        }
        
        public static void EndpointsNotFound(ILogger logger, object address)
        {
            _endpointsNotFound(logger, address, null);
        }
        
        public static void TemplateSucceeded(
            ILogger logger, RouteEndpoint endpoint, PathString path, QueryString query)
        {
            _templateSucceeded(logger, endpoint.RoutePattern.RawText, endpoint.DisplayName, path.Value, query.Value, null);
        }
        
        public static void TemplateFailedRequiredValues(
            ILogger logger, RouteEndpoint endpoint, RouteValueDictionary ambientValues, RouteValueDictionary values)
        {
            // Checking level again to avoid allocation on the common path
            if (logger.IsEnabled(LogLevel.Debug))
            {
                _templateFailedRequiredValues(
                    logger, 
                    endpoint.RoutePattern.RawText, 
                    endpoint.DisplayName, 
                    FormatRouteValues(ambientValues), 
                    FormatRouteValues(values), 
                    FormatRouteValues(endpoint.RoutePattern.Defaults), null);
            }
        }
        
        public static void TemplateFailedConstraint(
            ILogger logger, RouteEndpoint endpoint, string parameterName, IRouteConstraint constraint, RouteValueDictionary values)
        {
            // Checking level again to avoid allocation on the common path
            if (logger.IsEnabled(LogLevel.Debug))
            {
                _templateFailedConstraint(
                    logger, 
                    endpoint.RoutePattern.RawText, 
                    endpoint.DisplayName, 
                    constraint, 
                    parameterName, 
                    FormatRouteValues(values), null);
            }
        }
        
        public static void TemplateFailedExpansion(ILogger logger, RouteEndpoint endpoint, RouteValueDictionary values)
        {
            // Checking level again to avoid allocation on the common path
            if (logger.IsEnabled(LogLevel.Debug))
            {
                _templateFailedExpansion(logger, endpoint.RoutePattern.RawText, endpoint.DisplayName, FormatRouteValues(values), null);
            }
        }
        
        public static void LinkGenerationSucceeded(ILogger logger, IEnumerable<Endpoint> endpoints, string uri)
        {
            // Checking level again to avoid allocation on the common path
            if (logger.IsEnabled(LogLevel.Debug))
            {
                _linkGenerationSucceeded(logger, endpoints.Select(e => e.DisplayName), uri, null);
            }
        }
        
        public static void LinkGenerationFailed(ILogger logger, IEnumerable<Endpoint> endpoints)
        {
            // Checking level again to avoid allocation on the common path
            if (logger.IsEnabled(LogLevel.Debug))
            {
                _linkGenerationFailed(logger, endpoints.Select(e => e.DisplayName), null);
            }
        }
        
        // EXPENSIVE: should only be used at Debug and higher levels of logging.
        private static string FormatRouteValues(IReadOnlyDictionary<string, object> values)
        {
            if (values == null || values.Count == 0)
            {
                return "{ }";
            }
            
            var builder = new StringBuilder();
            builder.Append("{ ");
            
            foreach (var kvp in values.OrderBy(kvp => kvp.Key))
            {
                builder.Append("\"");
                builder.Append(kvp.Key);
                builder.Append("\"");
                builder.Append(":");
                builder.Append(" ");
                builder.Append("\"");
                builder.Append(kvp.Value);
                builder.Append("\"");
                builder.Append(", ");
            }
            
            // Trim trailing ", "
            builder.Remove(builder.Length - 2, 2);
            
            builder.Append(" }");
            
            return builder.ToString();
        }
    }
}

```

###### 4.3.2.1 try process template

```c#
internal sealed class DefaultLinkGenerator    
{
    // get endpoint
    private List<RouteEndpoint> GetEndpoints<TAddress>(TAddress address)
    {
        // endpoint address scheme
        var addressingScheme = _serviceProvider.GetRequiredService<IEndpointAddressScheme<TAddress>>();
        // 从 endpoint address scheme 中解析 route endpoint
        var endpoints = addressingScheme.FindEndpoints(address).OfType<RouteEndpoint>().ToList();
        
        if (endpoints.Count == 0)
        {
            Log.EndpointsNotFound(_logger, address);
        }
        else
        {
            Log.EndpointsFound(_logger, address, endpoints);
        }
        
        return endpoints;
    }
    
    // try process template
    internal bool TryProcessTemplate(
        HttpContext? httpContext,
        RouteEndpoint endpoint,
        RouteValueDictionary values,
        RouteValueDictionary? ambientValues,
        LinkOptions? options,
        out (PathString path, QueryString query) result)
    {
        // 从 cache 中解析 template binder
        var templateBinder = GetTemplateBinder(endpoint);
        
        // 调用 template binder 的 get value 方法，-> 获得 template value result
        var templateValuesResult = templateBinder.GetValues(ambientValues, values);
        if (templateValuesResult == null)
        {
            // We're missing one of the required values for this route.
            result = default;
            Log.TemplateFailedRequiredValues(_logger, endpoint, ambientValues, values);
            return false;
        }
        
        // 调用 tmeplate binder 的 process constraint 方法，-> 验证
        if (!templateBinder.TryProcessConstraints(
            	httpContext, 
	            templateValuesResult.CombinedValues, 
    	        out var parameterName, 
        	    out var constraint))
        {
            result = default;
            Log.TemplateFailedConstraint(
                _logger, 
                endpoint, 
                parameterName, 
                constraint, 
                templateValuesResult.CombinedValues);
            
            return false;
        }
        
        if (!templateBinder.TryBindValues(
            	templateValuesResult.AcceptedValues, 
            	options, _globalLinkOptions, 
            	out result))
        {
            Log.TemplateFailedExpansion(_logger, endpoint, templateValuesResult.AcceptedValues);
            return false;
        }
        
        Log.TemplateSucceeded(_logger, endpoint, result.path, result.query);
        return true;
    }
    
    // 从 cache 解析 template binder
    internal TemplateBinder GetTemplateBinder(RouteEndpoint endpoint) => 
        _cache.EnsureInitialized().GetOrAdd(endpoint, _createTemplateBinder);        
}

```



###### 4.3.2.2 get path by address

```c#
internal sealed class DefaultLinkGenerator    
{
    public override string? GetPathByAddress<TAddress>(
        HttpContext httpContext,
        TAddress address,
        RouteValueDictionary values,
        RouteValueDictionary? ambientValues = default,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = null)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        var endpoints = GetEndpoints(address);
        if (endpoints.Count == 0)
        {
            return null;
        }
        
        return GetPathByEndpoints(
            httpContext,
            endpoints,
            values,
            ambientValues,
            pathBase ?? httpContext.Request.PathBase,
            fragment,
            options);
    }
    
    public override string? GetPathByAddress<TAddress>(
        TAddress address,
        RouteValueDictionary values,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = null)
    {
        var endpoints = GetEndpoints(address);
        if (endpoints.Count == 0)
        {
            return null;
        }
        
        return GetPathByEndpoints(
            httpContext: null,
            endpoints,
            values,
            ambientValues: null,
            pathBase: pathBase,
            fragment: fragment,
            options: options);
    }
    
    private string? GetPathByEndpoints(
        HttpContext? httpContext,
        List<RouteEndpoint> endpoints,
        RouteValueDictionary values,
        RouteValueDictionary? ambientValues,
        PathString pathBase,
        FragmentString fragment,
        LinkOptions? options)
    {
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            if (TryProcessTemplate(
                httpContext: httpContext,
                endpoint: endpoint,
                values: values,
                ambientValues: ambientValues,
                options: options,
                result: out var result))
            {
                var uri = UriHelper.BuildRelative(
                    pathBase,
                    result.path,
                    result.query,
                    fragment);
                Log.LinkGenerationSucceeded(_logger, endpoints, uri);
                return uri;
            }
        }
        
        Log.LinkGenerationFailed(_logger, endpoints);
        return null;
    }
}

```



###### 4.3.2.3 get uri by address

```c#
internal sealed class DefaultLinkGenerator    
{
    public override string? GetUriByAddress<TAddress>(
        HttpContext httpContext,
        TAddress address,
        RouteValueDictionary values,
        RouteValueDictionary? ambientValues = default,
        string? scheme = default,
        HostString? host = default,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = null)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        var endpoints = GetEndpoints(address);
        if (endpoints.Count == 0)
        {
            return null;
        }
        
        return GetUriByEndpoints(
            endpoints,
            values,
            ambientValues,
            scheme ?? httpContext.Request.Scheme,
            host ?? httpContext.Request.Host,
            pathBase ?? httpContext.Request.PathBase,
            fragment,
            options);
    }
    
    public override string? GetUriByAddress<TAddress>(
        TAddress address,
        RouteValueDictionary values,
        string? scheme,
        HostString host,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = null)
    {
        if (string.IsNullOrEmpty(scheme))
        {
            throw new ArgumentException("A scheme must be provided.", nameof(scheme));
        }        
        if (!host.HasValue)
        {
            throw new ArgumentException("A host must be provided.", nameof(host));
        }
        
        var endpoints = GetEndpoints(address);
        if (endpoints.Count == 0)
        {
            return null;
        }
        
        return GetUriByEndpoints(
            endpoints,
            values,
            ambientValues: null,
            scheme: scheme,
            host: host,
            pathBase: pathBase,
            fragment: fragment,
            options: options);
    }
    
    public string? GetUriByEndpoints(
        List<RouteEndpoint> endpoints,
        RouteValueDictionary values,
        RouteValueDictionary? ambientValues,
        string scheme,
        HostString host,
        PathString pathBase,
        FragmentString fragment,
        LinkOptions? options)
    {
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            if (TryProcessTemplate(
                httpContext: null,
                endpoint: endpoint,
                values: values,
                ambientValues: ambientValues,
                options: options,
                result: out var result))
            {
                var uri = UriHelper.BuildAbsolute(
                    scheme,
                    host,
                    pathBase,
                    result.path,
                    result.query,
                    fragment);
                Log.LinkGenerationSucceeded(_logger, endpoints, uri);
                return uri;
            }
        }
        
        Log.LinkGenerationFailed(_logger, endpoints);
        return null;
    }
}

```

### 5. endpoint routing

#### 5.1 route endpoint

##### 5.1.1 route endpoint

```c#
public sealed class RouteEndpoint : Endpoint
{          
    public RoutePattern RoutePattern { get; }
    public int Order { get; }  
    
    public RouteEndpoint(
        RequestDelegate requestDelegate,
        RoutePattern routePattern,
        int order,
        EndpointMetadataCollection? metadata,
        string? displayName)            
        	: base(requestDelegate, metadata, displayName)
    {
        if (requestDelegate == null)
        {
            throw new ArgumentNullException(nameof(requestDelegate));
        }        
        if (routePattern == null)
        {
            throw new ArgumentNullException(nameof(routePattern));
        }
        
        RoutePattern = routePattern;
        Order = order;
    }            
}

```

##### 5.1.2 route endpoint builder

```c#
public sealed class RouteEndpointBuilder : EndpointBuilder
{    
    public RoutePattern RoutePattern { get; set; }        
    public int Order { get; set; }
        
    public RouteEndpointBuilder(
        RequestDelegate requestDelegate,
        RoutePattern routePattern,
        int order)
    {
        RequestDelegate = requestDelegate;
        RoutePattern = routePattern;
        Order = order;
    }
    
    /// <inheritdoc />
    public override Endpoint Build()
    {
        if (RequestDelegate is null)
        {
            throw new InvalidOperationException(
                $"{nameof(RequestDelegate)} must be specified to construct a 
                "{nameof(RouteEndpoint)}.");
        }
        
        var routeEndpoint = new RouteEndpoint(
            RequestDelegate,
            RoutePattern,
            Order,
            new EndpointMetadataCollection(Metadata),
            DisplayName);
        
        return routeEndpoint;
    }
}

```

#### 5.2 endpoint route builder

* 封装 application builder 和 (route) endpoint data source，为了共享

##### 5.2.1 接口

```c#
public interface IEndpointRouteBuilder
{       
    // service provider
    IServiceProvider ServiceProvider { get; }        
    // endpoint data source 集合
    ICollection<EndpointDataSource> DataSources { get; }
    
    IApplicationBuilder CreateApplicationBuilder();        
}

```

##### 5.2.2 default endpoint route builder

```c#
internal class DefaultEndpointRouteBuilder : IEndpointRouteBuilder
{
    public IApplicationBuilder ApplicationBuilder { get; }
    public ICollection<EndpointDataSource> DataSources { get; }
    public IServiceProvider ServiceProvider => ApplicationBuilder.ApplicationServices;
    
    public DefaultEndpointRouteBuilder(IApplicationBuilder applicationBuilder)
    {
        ApplicationBuilder = applicationBuilder 
            ?? throw new ArgumentNullException(nameof(applicationBuilder));
        DataSources = new List<EndpointDataSource>();
    }
        
    public IApplicationBuilder CreateApplicationBuilder() => ApplicationBuilder.New(); 
}

```

##### 5.2.3 扩展方法 - to conventional endpoint builder

###### 5.2.3.1 map

```c#
public static class EndpointRouteBuilderExtensions
{   
    // map with pattern string & requrest delegate
    public static IEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return Map(
            endpoints, 
            RoutePatternFactory.Parse(pattern), 
            requestDelegate);
    }
        
    // map with pattern & request delegate
    public static IEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        RoutePattern pattern,
        RequestDelegate requestDelegate)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }        
        if (requestDelegate == null)
        {
            throw new ArgumentNullException(nameof(requestDelegate));
        }
        
        const int defaultOrder = 0;
        
        var builder = new RouteEndpointBuilder(
            requestDelegate,
            pattern,
            defaultOrder)
        {
            DisplayName = pattern.RawText ?? pattern.DebuggerToString(),
        };
        
        // Add delegate attributes as metadata
        var attributes = requestDelegate.Method.GetCustomAttributes();
        
        // This can be null if the delegate is a dynamic method or compiled from 
        // an expression tree
        if (attributes != null)
        {
            foreach (var attribute in attributes)
            {
                builder.Metadata.Add(attribute);                            
            }
        }
        
        // 解析 endpoint 的 model endpoint data source，
        // 如果没有则创建
        var dataSource = endpoints.DataSources
            					  .OfType<ModelEndpointDataSource>()
            					  .FirstOrDefault();
        if (dataSource == null)
        {
            dataSource = new ModelEndpointDataSource();
            endpoints.DataSources.Add(dataSource);
        }
        
        // 将 builder 注入 model endpoint data source
        return dataSource.AddEndpointBuilder(builder);
    }
}

```

###### 5.2.3.2 map method

```c#
public static class EndpointRouteBuilderExtensions
{    
    public static IEndpointConventionBuilder MapMethods(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        IEnumerable<string> httpMethods,
        RequestDelegate requestDelegate)
    {
        if (httpMethods == null)
        {
            throw new ArgumentNullException(nameof(httpMethods));
        }
        
        // map pattern
        var builder = endpoints.Map(RoutePatternFactory.Parse(pattern), requestDelegate);
        // 配置 display name
        builder.WithDisplayName($"{pattern} HTTP: {string.Join(", ", httpMethods)}");
        // 配置 http method metadata
        builder.WithMetadata(new HttpMethodMetadata(httpMethods));
        
        return builder;
    }
    
    /* map get */
    private static readonly string[] GetVerb = new[] { "GET" };        
    public static IEndpointConventionBuilder MapGet(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(
            endpoints, 
            pattern, 
            GetVerb, 
            requestDelegate);
    }
    
    /* map post */
    private static readonly string[] PostVerb = new[] { "POST" };
    public static IEndpointConventionBuilder MapPost(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(
            endpoints, 
            pattern, 
            PostVerb, 
            requestDelegate);
    }
    
    /* map put */
    private static readonly string[] PutVerb = new[] { "PUT" };
    public static IEndpointConventionBuilder MapPut(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(
            endpoints, 
            pattern, 
            PutVerb, 
            requestDelegate);
    }
    
    /* map delete */
    private static readonly string[] DeleteVerb = new[] { "DELETE" };     
    public static IEndpointConventionBuilder MapDelete(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(
            endpoints, 
            pattern, 
            DeleteVerb, 
            requestDelegate);
    }
}

```

###### 5.2.3.3 map fallback

```c#
public static class FallbackEndpointRouteBuilderExtensions
{    
    public static readonly string DefaultPattern = "{*path:nonfile}";
        
    // "MapFallback" is intended to handle cases where URL path of the request 
    // does not contain a file name, and no other endpoint has matched. 
    // This is convenient for routing requests for dynamic content to a SPA framework, 
    // while also allowing requests for non-existent files to result in an HTTP 404.
    //
    // "MapFallback" registers an endpoint using the pattern "{*path:nonfile}". 
    // The order of the registered endpoint will be "int.MaxValue".    
    public static IEndpointConventionBuilder MapFallback(
        this IEndpointRouteBuilder endpoints, 
        RequestDelegate requestDelegate)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (requestDelegate == null)
        {
            throw new ArgumentNullException(nameof(requestDelegate));
        }
        
        return endpoints.MapFallback("{*path:nonfile}", requestDelegate);
    }

        
    // "MapFallback" is intended to handle cases where no other endpoint has matched. 
    // This is convenient for routing requests to a SPA framework.
    // The order of the registered endpoint will be "int.MaxValue".
    //
    // This overload will use the provided "pattern" verbatim. 
    // Use the ":nonfile" route contraint to exclude requests for static files.    
    public static IEndpointConventionBuilder MapFallback(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }        
        if (requestDelegate == null)
        {
            throw new ArgumentNullException(nameof(requestDelegate));
        }
        
        // map pattern
        var conventionBuilder = endpoints.Map(pattern, requestDelegate);
        // 配置 display name、order
        conventionBuilder.WithDisplayName("Fallback " + pattern);
        conventionBuilder.Add(b => ((RouteEndpointBuilder)b).Order = int.MaxValue);
        
        return conventionBuilder;
    }
}

```

##### 5.2.4 扩展方法 - to map action endpoint conventional builder

###### 5.2.4.1 map

```c#
public static class MapActionEndpointRouteBuilderExtensions
{
     public static MapActionEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate action)
    {
        return Map(endpoints, RoutePatternFactory.Parse(pattern), action);
    }
    
    
    public static MapActionEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        RoutePattern pattern,
        Delegate action)
    {
        if (endpoints is null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (pattern is null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }        
        if (action is null)
        {
            throw new ArgumentNullException(nameof(action));
        }
        
        const int defaultOrder = 0;
        
        var builder = new RouteEndpointBuilder(
            MapActionExpressionTreeBuilder.BuildRequestDelegate(action),
            pattern,
            defaultOrder)
        {
            DisplayName = pattern.RawText ?? pattern.DebuggerToString(),
        };
        
        // Add delegate attributes as metadata
        var attributes = action.Method.GetCustomAttributes();
        
        // This can be null if the delegate is a dynamic method or compiled from
        // an expression tree
        if (attributes is not null)
        {
            foreach (var attribute in attributes)
            {
                builder.Metadata.Add(attribute);
            }
        }
        
        var dataSource = endpoints.DataSources
            					  .OfType<ModelEndpointDataSource>()
            					  .FirstOrDefault();
        if (dataSource is null)
        {
            dataSource = new ModelEndpointDataSource();
            endpoints.DataSources.Add(dataSource);
        }
        
        return new MapActionEndpointConventionBuilder(
            dataSource.AddEndpointBuilder(builder));
    }                                   
}

```

###### 5.2.4.2 map method

```c#
public static class MapActionEndpointRouteBuilderExtensions
{
    public static MapActionEndpointConventionBuilder MapMethods(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        IEnumerable<string> httpMethods,
        Delegate action)
    {
        if (httpMethods is null)
        {
            throw new ArgumentNullException(nameof(httpMethods));
        }
        
        // map pattern
        var builder = endpoints.Map(RoutePatternFactory.Parse(pattern), action);
        // 配置 display name
        builder.WithDisplayName($"{pattern} HTTP: {string.Join(", ", httpMethods)}");
        // 配置 http method metadata
        builder.WithMetadata(new HttpMethodMetadata(httpMethods));
        
        return builder;
    }
            
    /* map get */
    private static readonly string[] GetVerb = new[] { "GET" };
    public static MapActionEndpointConventionBuilder MapGet(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate action)
    {
        return MapMethods(endpoints, pattern, GetVerb, action);
    }
    
    /* map post */
    private static readonly string[] PostVerb = new[] { "POST" };
    public static MapActionEndpointConventionBuilder MapPost(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate action)
    {
        return MapMethods(endpoints, pattern, PostVerb, action);
    }
    
    /* map put */
    private static readonly string[] PutVerb = new[] { "PUT" };
    public static MapActionEndpointConventionBuilder MapPut(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate action)
    {
        return MapMethods(endpoints, pattern, PutVerb, action);
    }
        
    /* map delete */
    private static readonly string[] DeleteVerb = new[] { "DELETE" };                           
    public static MapActionEndpointConventionBuilder MapDelete(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate action)
    {
        return MapMethods(endpoints, pattern, DeleteVerb, action);
    }    
}

```

#### 5.3 add routing service (endpoint routing)

```c#
public static class RoutingServiceCollectionExtensions
{    
    public static IServiceCollection AddRouting(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
                                   
        // 注入 routing marker service
        services.TryAddSingleton(typeof(RoutingMarkerService));
        
        // Setup global collection of endpoint data sources                                                
        // 注入 route options，包含 endpoint data source 集合
        var dataSources = new ObservableCollection<EndpointDataSource>();
        services.TryAddEnumerable(
            ServiceDescriptor.Transient<IConfigureOptions<RouteOptions>, ConfigureRouteOptions>(
                    serviceProvider => new ConfigureRouteOptions(dataSources)));
        
        // Allow global access to the list of endpoints.
        services.TryAddSingleton<EndpointDataSource>(s =>
        	{
                // Call internal ctor and pass global collection
                return new CompositeEndpointDataSource(dataSources);
            });
        
        //
        // Default matcher implementation
        //
        services.TryAddSingleton<ParameterPolicyFactory, DefaultParameterPolicyFactory>();
        services.TryAddSingleton<MatcherFactory, DfaMatcherFactory>();
        services.TryAddTransient<DfaMatcherBuilder>();
        services.TryAddSingleton<DfaGraphWriter>();
        services.TryAddTransient<DataSourceDependentMatcher.Lifetime>();
        services.TryAddSingleton<EndpointMetadataComparer>(services =>
        	{
                // This has no public constructor. 
                return new EndpointMetadataComparer(services);
            });
        
        //
        // Link generation related services
        //
        services.TryAddSingleton<LinkGenerator, DefaultLinkGenerator>();
        services.TryAddSingleton<IEndpointAddressScheme<string>, EndpointNameAddressScheme>();
        services.TryAddSingleton<IEndpointAddressScheme<RouteValuesAddress>, RouteValuesAddressScheme>();
        services.TryAddSingleton<LinkParser, DefaultLinkParser>();
        
        //
        // Endpoint Selection
        //
        services.TryAddSingleton<EndpointSelector, DefaultEndpointSelector>();
        services.TryAddEnumerable(ServiceDescriptor.Singleton<MatcherPolicy, HttpMethodMatcherPolicy>());
        services.TryAddEnumerable(ServiceDescriptor.Singleton<MatcherPolicy, HostMatcherPolicy>());
                
        // 注入 route pattern transformer（link generation）
        services.TryAddSingleton<RoutePatternTransformer, DefaultRoutePatternTransformer>();
        
        return services;
    }
    
    // add routing by action    
    public static IServiceCollection AddRouting(
        this IServiceCollection services,
        Action<RouteOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        services.Configure(configureOptions);
        services.AddRouting();
        
        return services;
    }
}

```

##### 5.3.1 routing options

```c#
public class RouteOptions
{    
    private ICollection<EndpointDataSource> _endpointDataSources = default!;       
    internal ICollection<EndpointDataSource> EndpointDataSources
    {
        get
        {
            Debug.Assert(_endpointDataSources != null, "Endpoint data sources should have been set in DI.");
            return _endpointDataSources;
        }
        set => _endpointDataSources = value;
    }
                        
    public bool SuppressCheckForUnhandledSecurityMetadata { get; set; }                
        
    /*    
    private IDictionary<string, Type> _constraintTypeMap = GetDefaultConstraintMap();
    
    private static IDictionary<string, Type> GetDefaultConstraintMap()
    {
        var defaults = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
        
        // Type-specific constraints
        AddConstraint<IntRouteConstraint>(defaults, "int");
        AddConstraint<BoolRouteConstraint>(defaults, "bool");
        AddConstraint<DateTimeRouteConstraint>(defaults, "datetime");
        AddConstraint<DecimalRouteConstraint>(defaults, "decimal");
        AddConstraint<DoubleRouteConstraint>(defaults, "double");
        AddConstraint<FloatRouteConstraint>(defaults, "float");
        AddConstraint<GuidRouteConstraint>(defaults, "guid");
        AddConstraint<LongRouteConstraint>(defaults, "long");
        
        // Length constraints
        AddConstraint<MinLengthRouteConstraint>(defaults, "minlength");
        AddConstraint<MaxLengthRouteConstraint>(defaults, "maxlength");
        AddConstraint<LengthRouteConstraint>(defaults, "length");
        
        // Min/Max value constraints
        AddConstraint<MinRouteConstraint>(defaults, "min");
        AddConstraint<MaxRouteConstraint>(defaults, "max");
        AddConstraint<RangeRouteConstraint>(defaults, "range");
        
        // Regex-based constraints
        AddConstraint<AlphaRouteConstraint>(defaults, "alpha");
        AddConstraint<RegexInlineRouteConstraint>(defaults, "regex");
        
        AddConstraint<RequiredRouteConstraint>(defaults, "required");
        
        // Files
        AddConstraint<FileNameRouteConstraint>(defaults, "file");
        AddConstraint<NonFileNameRouteConstraint>(defaults, "nonfile");
        
        return defaults;
    }
        
    private static void AddConstraint<
        [DynamicallyAccessedMembers(
            DynamicallyAccessedMemberTypes.PublicConstructors)]TConstraint>(
        Dictionary<string, Type> constraintMap, 
        string text) 
        	where TConstraint : IRouteConstraint
    {
        constraintMap[text] = typeof(TConstraint);
    }
    
    public IDictionary<string, Type> ConstraintMap
    {
        get
        {
            return _constraintTypeMap;
        }
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(ConstraintMap));
            }
            
            _constraintTypeMap = value;
        }
    }
        
    public bool LowercaseUrls { get; set; }        
    public bool LowercaseQueryStrings { get; set; }        
    public bool AppendTrailingSlash { get; set; }    
    */ 
}

```

##### 5.3.2 routing marker service

```c#
internal class RoutingMarkerService
{
}

```

#### 5.4 use (endpoint) routing

* 使用 matcher 择匹配的 endpoint 注入 http context

```c#
public static class EndpointRoutingApplicationBuilderExtensions
{
    private const string EndpointRouteBuilder = "__EndpointRouteBuilder";
    
    public static IApplicationBuilder UseRouting(
        this IApplicationBuilder builder)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }
        
        // 确认 routing service 已经注册
        VerifyRoutingServicesAreRegistered(builder);
        
        // 创建 default endpoint route builder，并注入 application builder
        var endpointRouteBuilder = new DefaultEndpointRouteBuilder(builder);                
        builder.Properties[EndpointRouteBuilder] = endpointRouteBuilder;
        
        // 注入 endpoint routing middleware
        return builder.UseMiddleware<EndpointRoutingMiddleware>(endpointRouteBuilder);
    }
}

```

##### 5.4.1 routing middleware

```c#
internal sealed class EndpointRoutingMiddleware
{
    private const string 
        DiagnosticsEndpointMatchedKey = "Microsoft.AspNetCore.Routing.EndpointMatched";
    
    private readonly MatcherFactory _matcherFactory;
    private readonly ILogger _logger;
    private readonly EndpointDataSource _endpointDataSource;
    private readonly DiagnosticListener _diagnosticListener;
    private readonly RequestDelegate _next;
    
    private Task<Matcher>? _initializationTask;
    
    public EndpointRoutingMiddleware(
        MatcherFactory matcherFactory,
        ILogger<EndpointRoutingMiddleware> logger,
        IEndpointRouteBuilder endpointRouteBuilder,
        DiagnosticListener diagnosticListener,
        RequestDelegate next)
    {
        if (endpointRouteBuilder == null)
        {
            throw new ArgumentNullException(nameof(endpointRouteBuilder));
        }
        
        // 注入服务
        _matcherFactory = matcherFactory 
            ?? throw new ArgumentNullException(nameof(matcherFactory));
        _logger = logger 
            ?? throw new ArgumentNullException(nameof(logger));
        _diagnosticListener = diagnosticListener 
            ?? throw new ArgumentNullException(nameof(diagnosticListener));
        _next = next 
            ?? throw new ArgumentNullException(nameof(next));    
        
        // 创建 endpoint data source（默认值，empty）
        _endpointDataSource = new CompositeEndpointDataSource(
            endpointRouteBuilder.DataSources);
    }
    
    public Task Invoke(HttpContext httpContext)
    {
        /* 如果 http context 中已经注入了 endpoint，返回 */
        // There's already an endpoint, skip matching completely
        var endpoint = httpContext.GetEndpoint();
        if (endpoint != null)
        {
            Log.MatchSkipped(_logger, endpoint);
            return _next(httpContext);
        }
        
        /* 找到适合的 endpoint */           
        
        // There's an inherent race condition between waiting for init and accessing the matcher
        // this is OK because once `_matcher` is initialized, it will not be set to null again.
        var matcherTask = InitializeAsync();
        if (!matcherTask.IsCompletedSuccessfully)
        {
            // matcher task 赢得异步执行
            return AwaitMatcher(this, httpContext, matcherTask);
        }
        
        var matchTask = matcherTask.Result.MatchAsync(httpContext);
        if (!matchTask.IsCompletedSuccessfully)
        {
            // match task 赢得异步执行
            return AwaitMatch(this, httpContext, matchTask);
        }
        
        return SetRoutingAndContinue(httpContext);
        
        // Awaited fallbacks for when the Tasks do not synchronously complete
        static async Task AwaitMatcher(
            EndpointRoutingMiddleware middleware, 
            HttpContext httpContext, 
            Task<Matcher> matcherTask)
        {
            // 获取 matcher
            var matcher = await matcherTask;
            // 调用 matcher 的 match 方法（寻找适合的 endpoint，注入 http context）
            await matcher.MatchAsync(httpContext);
            // 调用 set routing and continue 方法
            await middleware.SetRoutingAndContinue(httpContext);
        }
        
        static async Task AwaitMatch(
            EndpointRoutingMiddleware middleware, 
            HttpContext httpContext, 
            Task matchTask)
        {
            await matchTask;
            await middleware.SetRoutingAndContinue(httpContext);
        }        
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Task SetRoutingAndContinue(HttpContext httpContext)
    {
        // If there was no mutation of the endpoint then log failure
        var endpoint = httpContext.GetEndpoint();
        if (endpoint == null)
        {
            Log.MatchFailure(_logger);
        }
        else
        {
            // Raise an event if the route matched
            if (_diagnosticListener.IsEnabled() && 
                _diagnosticListener.IsEnabled(DiagnosticsEndpointMatchedKey))
            {
                // We're just going to send the HttpContext 
                // since it has all of the relevant information
                _diagnosticListener.Write(DiagnosticsEndpointMatchedKey, httpContext);
            }
            
            Log.MatchSuccess(_logger, endpoint);
        }
        
        return _next(httpContext);
    }
    
    /* 从 matcher factory 解析 matcher */
    
    // Initialization is async to avoid blocking threads while reflection and things
    // of that nature take place.
    //
    // We've seen cases where startup is very slow if we  allow multiple threads to race
    // while initializing the set of endpoints/routes. Doing CPU intensive work is a
    // blocking operation if you have a low core count and enough work to do.
    private Task<Matcher> InitializeAsync()
    {
        var initializationTask = _initializationTask;
        if (initializationTask != null)
        {
            return initializationTask;
        }
        
        return InitializeCoreAsync();
    }
    
    private Task<Matcher> InitializeCoreAsync()
    {
        var initialization = 
            new TaskCompletionSource<Matcher>(
	            TaskCreationOptions.RunContinuationsAsynchronously);
        var initializationTask = 
            Interlocked.CompareExchange(
            	ref _initializationTask, 
            initialization.Task, null);
        
        if (initializationTask != null)
        {
            // This thread lost the race, join the existing task.
            return initializationTask;
        }
        
        // This thread won the race, do the initialization.
        try
        {
            var matcher = _matcherFactory.CreateMatcher(_endpointDataSource);
            
            // Now replace the initialization task with one created 
            // with the default execution context.
            // This is important because capturing the execution context 
            // will leak memory in ASP.NET Core.
            using (ExecutionContext.SuppressFlow())
            {
                _initializationTask = Task.FromResult(matcher);
            }
            
            // Complete the task, 
            // this will unblock any requests that came in while initializing.
            initialization.SetResult(matcher);
            return initialization.Task;
        }
        catch (Exception ex)
        {
            // Allow initialization to occur again. Since DataSources can change, it's possible
            // for the developer to correct the data causing the failure.
            _initializationTask = null;
            
            // Complete the task, 
            // this will throw for any requests that came in while initializing.
            initialization.SetException(ex);
            return initialization.Task;
        }
    }
    
#nullable disable
    private static class Log
    {
        private static readonly Action<ILogger, string, Exception> 
            _matchSuccess = LoggerMessage.Define<string>(
            	LogLevel.Debug,
	            new EventId(1, "MatchSuccess"),
    	        "Request matched endpoint '{EndpointName}'");
        
        private static readonly Action<ILogger, Exception> 
            _matchFailure = LoggerMessage.Define(
	            LogLevel.Debug,
    	        new EventId(2, "MatchFailure"),
        	    "Request did not match any endpoints");
        
        private static readonly Action<ILogger, string, Exception> 
            _matchingSkipped = LoggerMessage.Define<string>(
            	LogLevel.Debug,
	            new EventId(3, "MatchingSkipped"),
    	        "Endpoint '{EndpointName}' already set, skipping route matching.");
        
        public static void MatchSuccess(ILogger logger, Endpoint endpoint)
        {
            _matchSuccess(logger, endpoint.DisplayName, null);
        }
        
        public static void MatchFailure(ILogger logger)
        {
            _matchFailure(logger, null);
        }
        
        public static void MatchSkipped(ILogger logger, Endpoint endpoint)
        {
            _matchingSkipped(logger, endpoint.DisplayName, null);
        }
    }
}

```

#### 5.5 use endpoint

```c#
public static class EndpointRoutingApplicationBuilderExtensions
{
    private const string EndpointRouteBuilder = "__EndpointRouteBuilder";
    
    public static IApplicationBuilder UseEndpoints(
        this IApplicationBuilder builder, 
        Action<IEndpointRouteBuilder> configure)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (configure == null)
        {
            throw new ArgumentNullException(nameof(configure));
        
        }
        
        // 确认 routing service 已经注册
        VerifyRoutingServicesAreRegistered(builder);
        
        /* 确认已经调用了 use routing，
           此时可以使用注入的 use routing 方法创建的 endpoint route builder，
           从而保证是 endpoint route builder 是 global，
           此处（use endpoint 方法）注入的 endpoint 可以在 use routing 发现并匹配 request */
        VerifyEndpointRoutingMiddlewareIsRegistered(builder, out var endpointRouteBuilder);
        
        // 配置 endpoint route builder，即注入 endpoint！
        configure(endpointRouteBuilder);
                        
        /* 将 endpoint route builder 的 endpoint data source 注入 route options */
        
        // 解析 route options
        var routeOptions = builder.ApplicationServices
            					.GetRequiredService<IOptions<RouteOptions>>();
        // 遍历 endpoint route builder 的 data source，
        // 注入 route options 的 value
        foreach (var dataSource in endpointRouteBuilder.DataSources)
        {
            routeOptions.Value.EndpointDataSources.Add(dataSource);
        }
        
        // 注入 endpoint middleware 
        return builder.UseMiddleware<EndpointMiddleware>();
    }
}

```

##### 5.5.1 endpoint middleware 

```c#
internal sealed class EndpointMiddleware
{
    internal const string 
        AuthorizationMiddlewareInvokedKey = 
        	"__AuthorizationMiddlewareWithEndpointInvoked";
    internal const string 
        CorsMiddlewareInvokedKey = 
        	"__CorsMiddlewareWithEndpointInvoked";
    
    private readonly ILogger _logger;
    private readonly RequestDelegate _next;
    private readonly RouteOptions _routeOptions;
    
    public EndpointMiddleware(
        ILogger<EndpointMiddleware> logger,
        RequestDelegate next,
        IOptions<RouteOptions> routeOptions)
    {
        _logger = logger 
            ?? throw new ArgumentNullException(nameof(logger));
        _next = next 
            ?? throw new ArgumentNullException(nameof(next));
        _routeOptions = routeOptions?.Value 
            ?? throw new ArgumentNullException(nameof(routeOptions));
    }
    
    public Task Invoke(HttpContext httpContext)
    {
        var endpoint = httpContext.GetEndpoint();
        if (endpoint?.RequestDelegate != null)
        {
            // 如果 route options 标记了 suppres check for unhandle security
            if (!_routeOptions.SuppressCheckForUnhandledSecurityMetadata)
            {
                // 如果 endpoint 包含 IAuthordata，
                // 但是 httpContext 的 items 没有注入对应的 key --
                //   “__AuthorizationMiddlewareWithEndpointInvoked”，抛出异常                
                if (endpoint.Metadata
	                    	.GetMetadata<IAuthorizeData>() != null &&
                    !httpContext.Items
		                    	.ContainsKey(AuthorizationMiddlewareInvokedKey))
                {
                    ThrowMissingAuthMiddlewareException(endpoint);
                }
                
                // 如果 endpoint 包含 ICorsMetadata，
                // 但是 http context 的 items 没有注入对应的 key --
                //   “__CorsMiddlewareWithEndpointInvoked”，抛出异常                
                if (endpoint.Metadata
                    		.GetMetadata<ICorsMetadata>() != null &&
                    !httpContext.Items
	                    	.ContainsKey(CorsMiddlewareInvokedKey))
                {
                    ThrowMissingCorsMiddlewareException(endpoint);
                }
            }
            
            Log.ExecutingEndpoint(_logger, endpoint);
            
            try
            {
                // 获取 endpoint 中的的 request delegate 并执行
                var requestTask = endpoint.RequestDelegate(httpContext);
                if (!requestTask.IsCompletedSuccessfully)
                {
                    return AwaitRequestTask(endpoint, requestTask, _logger);
                }
            }
            catch (Exception exception)
            {
                Log.ExecutedEndpoint(_logger, endpoint);
                return Task.FromException(exception);
            }
            
            Log.ExecutedEndpoint(_logger, endpoint);
            return Task.CompletedTask;
        }
        
        return _next(httpContext);
        
        // 异步执行等待
        static async Task AwaitRequestTask(
            Endpoint endpoint, 
            Task requestTask, 
            ILogger logger)
        {
            try
            {
                await requestTask;
            }
            finally
            {
                Log.ExecutedEndpoint(logger, endpoint);
            }
        }
    }
    
    private static void ThrowMissingAuthMiddlewareException(Endpoint endpoint)
    {
        throw new InvalidOperationException(
            $"Endpoint {endpoint.DisplayName} contains authorization metadata, " +                         "but a middleware was not found that supports authorization." +                                 Environment.NewLine +
            "Configure your application startup by adding app.UseAuthorization() inside the all to Configure(..) in the application startup code. The call to app.UseAuthorization() must appear between app.UseRouting() and app.UseEndpoints(...).");
    }
    
    private static void ThrowMissingCorsMiddlewareException(Endpoint endpoint)
    {
        throw new InvalidOperationException(
            $"Endpoint {endpoint.DisplayName} contains CORS metadata, " +                                   "but a middleware was not found that supports CORS." +                                         Environment.NewLine +
            "Configure your application startup by adding app.UseCors() inside the call to Configure(..) in the application startup code. The call to app.UseCors() must appear between app.UseRouting() and app.UseEndpoints(...).");
    }
    
#nullable disable
    private static class Log
    {
        private static readonly Action<ILogger, string, Exception> 
            _executingEndpoint = LoggerMessage.Define<string>(
            	LogLevel.Information,
            	new EventId(0, "ExecutingEndpoint"),
            	"Executing endpoint '{EndpointName}'");
        
        private static readonly Action<ILogger, string, Exception> 
            _executedEndpoint = LoggerMessage.Define<string>(
            	LogLevel.Information,
            	new EventId(1, "ExecutedEndpoint"),
            	"Executed endpoint '{EndpointName}'");
        
        public static void ExecutingEndpoint(ILogger logger, Endpoint endpoint)
        {
            _executingEndpoint(logger, endpoint.DisplayName, null);
        }
        
        public static void ExecutedEndpoint(ILogger logger, Endpoint endpoint)
        {
            _executedEndpoint(logger, endpoint.DisplayName, null);
        }
    }
}

```





### 6. mvc

#### 6.1 action endpoint factory

```c#
internal class ActionEndpointFactory
{
    private readonly RoutePatternTransformer _routePatternTransformer;
    private readonly RequestDelegate _requestDelegate;
    private readonly IRequestDelegateFactory[] _requestDelegateFactories;
    
    public ActionEndpointFactory(
        RoutePatternTransformer routePatternTransformer, 
        IEnumerable<IRequestDelegateFactory> requestDelegateFactories)
    {
        if (routePatternTransformer == null)
        {
            throw new ArgumentNullException(nameof(routePatternTransformer));
        }
        
        // 注入 route pattern transformer
        _routePatternTransformer = routePatternTransformer;
        // 创建（默认的）request delegate
        _requestDelegate = CreateRequestDelegate();
        // 注入 request delegate factory 集合
        _requestDelegateFactories = requestDelegateFactories.ToArray();
    }
    
    private static RequestDelegate CreateRequestDelegate()
    {
        // We don't want to close over the Invoker Factory in ActionEndpointFactory as
        // that creates cycles in DI. Since we're creating this delegate at startup time
        // we don't want to create all of the things we use at runtime until the action
        // actually matches.
        //
        // The request delegate is already a closure here because we close over
        // the action descriptor.
        
        IActionInvokerFactory? invokerFactory = null;
        
        return (context) =>
        {
            // 从 http context 解析 endpoint 的 data token metadata
            var endpoint = context.GetEndpoint()!;            
            var dataTokens = endpoint.Metadata
                				    .GetMetadata<IDataTokensMetadata>();            
            // 解析 http context 中的 request route data
            var routeData = new RouteData();
            routeData.PushState(
                router: null, 
                context.Request.RouteValues, 
                new RouteValueDictionary(dataTokens?.DataTokens));                        
		   // 解析 endpoint 中的 action descriptor
            var action = endpoint.Metadata
                				.GetMetadata<ActionDescriptor>()!;
            
            // 创建 action context，注入 route data、action descriptor
            var actionContext = new ActionContext(
                context, 
                routeData, 
                action);
            
            // 解析 action invoker factory
            if (invokerFactory == null)
            {
                invokerFactory = context.RequestServices
                    				  .GetRequiredService<IActionInvokerFactory>();
            }
            // 创建 action invoker
            var invoker = invokerFactory.CreateInvoker(actionContext);
            // 执行 action invoker 的 invoker 方法（return void）
            return invoker!.InvokeAsync();
        };
    }                                                                                       
}

```

##### 6.1.1 data token metadata

```c#
public interface IDataTokensMetadata
{    
    IReadOnlyDictionary<string, object?> DataTokens { get; }
}

public sealed class DataTokensMetadata : IDataTokensMetadata
{
    public IReadOnlyDictionary<string, object?> DataTokens { get; }
    
    public DataTokensMetadata(IReadOnlyDictionary<string, object?> dataTokens)
    {
        DataTokens = dataTokens ?? throw new ArgumentNullException(nameof(dataTokens));
    }            
}

```

##### 6.1.2 request delegate factory

###### 6.1.2.1 接口

```c#
internal interface IRequestDelegateFactory
{
    RequestDelegate? CreateRequestDelegate(
        ActionDescriptor actionDescriptor, 
        RouteValueDictionary? dataTokens);
}

```

###### 6.1.2.2 controller request delegate factory

```c#
internal class ControllerRequestDelegateFactory : IRequestDelegateFactory
{
    private readonly ControllerActionInvokerCache _controllerActionInvokerCache;
    private readonly IReadOnlyList<IValueProviderFactory> _valueProviderFactories;
    private readonly int _maxModelValidationErrors;
    private readonly ILogger _logger;
    private readonly DiagnosticListener _diagnosticListener;
    private readonly IActionResultTypeMapper _mapper;
    private readonly IActionContextAccessor _actionContextAccessor;
    private readonly bool _enableActionInvokers;
    
    public ControllerRequestDelegateFactory(
        ControllerActionInvokerCache controllerActionInvokerCache,
        IOptions<MvcOptions> optionsAccessor,
        ILoggerFactory loggerFactory,
        DiagnosticListener diagnosticListener,
        IActionResultTypeMapper mapper)        
        	: this(
                controllerActionInvokerCache, 
                optionsAccessor, 
                loggerFactory, 
                diagnosticListener, 
                mapper, 
                null)
    {
    }
    
    public ControllerRequestDelegateFactory(
        ControllerActionInvokerCache controllerActionInvokerCache,
        IOptions<MvcOptions> optionsAccessor,
        ILoggerFactory loggerFactory,
        DiagnosticListener diagnosticListener,
        IActionResultTypeMapper mapper,
        IActionContextAccessor? actionContextAccessor)
    {
        // 注入 controller action invoker cache
        _controllerActionInvokerCache = controllerActionInvokerCache;
        // 从 mvc options 中提取并注入 value provider factory 集合
        _valueProviderFactories = optionsAccessor.Value.ValueProviderFactories.ToArray();
        // 从 mvc options 中提取并注入 max model validation errors（int）
        _maxModelValidationErrors = optionsAccessor.Value.MaxModelValidationErrors;
        // 从 mvc options 中提取并注入 enable action invoker（bool）
        _enableActionInvokers = optionsAccessor.Value.EnableActionInvokers;
        
        _logger = loggerFactory.CreateLogger<ControllerActionInvoker>();
        _diagnosticListener = diagnosticListener;
        
        // 注入 action result type mapper 
        _mapper = mapper;
        // 注入 action context accessor
        _actionContextAccessor = actionContextAccessor ?? ActionContextAccessor.Null;
    }
    
    public RequestDelegate? CreateRequestDelegate(
        ActionDescriptor actionDescriptor, 
        RouteValueDictionary? dataTokens)
    {
        // Fallback to action invoker extensibility so that invokers can override any default behaviors
        if (_enableActionInvokers || 
            actionDescriptor is not ControllerActionDescriptor)
        {
            return null;
        }
        
        return context =>
        {
            // 创建 route data
            RouteData routeData;
            
            if (dataTokens is null or { Count: 0 })
            {
                routeData = new RouteData(context.Request.RouteValues);
            }
            else
            {
                routeData = new RouteData();
                routeData.PushState(
                    router: null, 
                    context.Request.RouteValues, 
                    dataTokens);
            }
            
            // 创建 action context
            var actionContext = new ActionContext(
                context, 
                routeData, 
                actionDescriptor);
            
            // 创建 controller  context
            var controllerContext = new ControllerContext(actionContext)
            {
                // PERF: These are rarely going to be changed, so let's go copy-on-write.
                ValueProviderFactories =
                    new CopyOnWriteList<IValueProviderFactory>(_valueProviderFactories)
            };
            
            controllerContext.ModelState.MaxAllowedErrors = _maxModelValidationErrors;
            
            // 缓存 controller context
            var (cacheEntry, filters) = 
                _controllerActionInvokerCache.GetCachedResult(controllerContext);
            
            // 创建 controller action invoker
            var invoker = new ControllerActionInvoker(
                _logger,
                _diagnosticListener,
                _actionContextAccessor,
                _mapper,
                controllerContext,
                cacheEntry,
                filters);
            
            // 调用 controller action invoker 的 invoke 方法
            return invoker.InvokeAsync();
        };
    }
}

```

##### 6.1.3 方法 - add endpoint

```c#
internal class ActionEndpointFactory
{
    public void AddEndpoints(
        // 结果集
        List<Endpoint> endpoints,
        // 注册过的 route name（避免重复、重名）
        HashSet<string> routeNames,
        // 要转化为 endpoint 的 action
        ActionDescriptor action,
        IReadOnlyList<ConventionalRouteEntry> routes,
        IReadOnlyList<Action<EndpointBuilder>> conventions,
        bool createInertEndpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (routeNames == null)
        {
            throw new ArgumentNullException(nameof(routeNames));
        }        
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }        
        if (routes == null)
        {
            throw new ArgumentNullException(nameof(routes));
        }        
        if (conventions == null)
        {
            throw new ArgumentNullException(nameof(conventions));
        }
        
        // 如果标记了create inert endpoint
        if (createInertEndpoints)
        {
            // 创建 inert endpoint builder
            var builder = new InertEndpointBuilder()
            {
                DisplayName = action.DisplayName,
                RequestDelegate = _requestDelegate,
            };
            
            // 将 action (data) 注入 inert endpoint builder
            AddActionDataToBuilder(
                builder,
                routeNames,
                action,
                routeName: null,
                dataTokens: null,
                suppressLinkGeneration: false,
                suppressPathMatching: false,
                conventions,        
                Array.Empty<Action<EndpointBuilder>>());
            
            // 由 inert end point builder 构建 endpoint，注入 endpoints 结果集            
            endpoints.Add(builder.Build());
        }                

        /* 如果传入的 action descriptor 的 attribute route info 的 template 为 null，
           即没有定义 attribute route，-> 使用 conventional route */
        if (action.AttributeRouteInfo?.Template == null)
        {
            // Check each of the conventional patterns to see if the action would be reachable.
            // If the action and pattern are compatible then create an endpoint with action
            // route values on the pattern.
            
            // 遍历传入的 conventional route entry
            foreach (var route in routes)
            {
                // A route is applicable if:
                //   1. It has a parameter (or default value) for 'required' non-null 
                // 		route value
                //   2. It does not have a parameter (or default value) for 'required' 
                // 		null route value
                
                // 使用 route pattern transformer 解析 update route pattern
                var updatedRoutePattern = _routePatternTransformer.SubstituteRequiredValues(
                    route.Pattern, 
                    action.RouteValues);
                
                // 如果不能解析，-> 下一个 conventional route entry
                if (updatedRoutePattern == null)
                {
                    continue;
                }
                
                // 由上，能够解析到 updated route pattern
                // 由 updated route pattern 创建 request delegate，
                // 如果不成功，设置为 _request delegate（默认值）
                var requestDelegate = CreateRequestDelegate(action, route.DataTokens) ?? _requestDelegate;
                
                // We suppress link generation for each conventionally routed endpoint. 
                // We generate a single endpoint per-route to handle link generation.
                
                // 由 request delegate、route pattern 创建 route endpoint builder，
                // 注入 action 的 display name 作为 route 的 display name
                var builder = new RouteEndpointBuilder(
                    requestDelegate, 
                    updatedRoutePattern, 
                    route.Order)
                {
                    DisplayName = action.DisplayName,
                };
                
                // 将 action 注入到创建的 route endpoint builder
                AddActionDataToBuilder(
                    // 目标 route endpoint builder
                    builder,
                    routeNames,                    
                    action,
                    route.RouteName,
                    route.DataTokens,
                    suppressLinkGeneration: true,
                    suppressPathMatching: false,
                    conventions,
                    route.Conventions);
                
                // 由创建的 route endpoint builder 创建 route endpoint，注入 endpoint 结果集               
                endpoints.Add(builder.Build());
            }
        }
        // 否则，
        // 即 action descriptor 的 attribute route info 的 template 不为 null，
        // 即定义了 attribute route，-> 使用 attribute route
        else
        {
            // 创建 request delegate
            var requestDelegate = CreateRequestDelegate(action) ?? _requestDelegate;
            // 由 action 的 attribute route info 的 template 创建 route pattern
            var attributeRoutePattern = 
                RoutePatternFactory.Parse(action.AttributeRouteInfo.Template);
            
            // Modify the route and required values to ensure required values 
            // can be successfully subsituted.
            // Subsitituting required values into an attribute route pattern should 
            // always succeed.
            
            // 从 attribute route pattern 解析 
            //   - resolved route pattern,
            //   - resolved route value
            var (resolvedRoutePattern, resolvedRouteValues) = 
                ResolveDefaultsAndRequiredValues(action, attributeRoutePattern);
            
            // 使用 route pattern transformer，
            // 由 resolved route pattern、resolved route value，
            // 解析 updated route pattern
            var updatedRoutePattern = 
                _routePatternTransformer.SubstituteRequiredValues(
                	resolvedRoutePattern, 
                	resolvedRouteValues);            
            // 如果解析失败，即 updated route pattern 为 null，抛出异常
            if (updatedRoutePattern == null)
            {
                // This kind of thing can happen when a route pattern uses a *reserved* 
                // route value such as `action`.
                // See: https://github.com/dotnet/aspnetcore/issues/14789
                var formattedRouteKeys = string.Join(
                    ", ", 
                    resolvedRouteValues.Keys.Select(k => $"'{k}'"));
                
                throw new InvalidOperationException(
                    $"Failed to update the route pattern '{resolvedRoutePattern.RawText}' 
                    "with required route values. " +
                    $"This can occur when the route pattern contains parameters with reserved 
                    "names such as: {formattedRouteKeys} " +
                    $"and also uses route constraints such as '{{action:int}}'. " +
                    $"To fix this error, choose a different parameter name.");
            }
            
            // 由上，能够解析到 updated route pattern
            
            // 由 request delegate、updated route pattern 创建 route endpoint builder，            
            var builder = new RouteEndpointBuilder(
                requestDelegate, 
                updatedRoutePattern, 
                action.AttributeRouteInfo.Order)
            {
                DisplayName = action.DisplayName,
            };
            
            // 将 action 注入创建的 route endpoint builder
            AddActionDataToBuilder(
                builder,
                routeNames,
                action,
                action.AttributeRouteInfo.Name,
                dataTokens: null,
                action.AttributeRouteInfo.SuppressLinkGeneration,
                action.AttributeRouteInfo.SuppressPathMatching,
                conventions,
                perRouteConventions: Array.Empty<Action<EndpointBuilder>>());
            
            // 由创建的 route endpoint builder 构建 route endpoint，注入 endpoint 结果集           
            endpoints.Add(builder.Build());
        }
    }
}

```

###### 6.1.3.1 add action data to builder

```c#
internal class ActionEndpointFactory
{
    private void AddActionDataToBuilder(
        // builder
        EndpointBuilder builder,
        // 已经注册的 route name 集合
        HashSet<string> routeNames,
        ActionDescriptor action,
        string? routeName,
        RouteValueDictionary? dataTokens,
        bool suppressLinkGeneration,
        bool suppressPathMatching,
        IReadOnlyList<Action<EndpointBuilder>> conventions,
        IReadOnlyList<Action<EndpointBuilder>> perRouteConventions)
    {
        // 如果 action descriptor 的 endpoint metadata 不为 null，
        if (action.EndpointMetadata != null)
        {
            // 遍历 endpoint metadata，注入 route endpoint builder 的 metadata
            foreach (var d in action.EndpointMetadata)
            {
                builder.Metadata.Add(d);
            }
        }
        
        // 将 action descriptor 本身注入 route endpoint builder 的 metadata
        builder.Metadata.Add(action);
        
        // MVC guarantees that when two of it's endpoints have the same route name 
        // they are equivalent.
        //
        // The case for this looks like:
        //
        //  [HttpGet]
        //  [HttpPost]
        //  [Route("/Foo", Name = "Foo")]
        //  public void DoStuff() { }
        //
        // However, Endpoint Routing requires Endpoint Names to be unique.
        //
        // We can use the route name as the endpoint name if it's not set. Note that 
        // there's no attribute for this today so it's unlikley. Using endpoint name on a
        
        // 如果，route name 不为 null，
        // 没有标记 suppress link generation，
        // route name 可以注入 route names（即不存在和 route name 同名的 endpoint 已经注册过），
        // builder 的 endpoint name metadata 的 endpoint name 为 null
        if (routeName != null &&
            !suppressLinkGeneration &&
            routeNames.Add(routeName) &&
            builder.Metadata
            	   .OfType<IEndpointNameMetadata>()
            	   .LastOrDefault()
            	   ?.EndpointName == null)
        {
            // 将 route name 封装为 endpoint name metadata，
            // 注入 route endpoint builder 的 metadata
            builder.Metadata.Add(new EndpointNameMetadata(routeName));
        }
                
        // 如果 data tokens 不为 null，
        // 注入 route endpoint builder 的 metadata
        if (dataTokens != null)
        {
            builder.Metadata.Add(new DataTokensMetadata(dataTokens));
        }
        
        // 将 route name 封装为 route name metadata，
        // 注入 route endpoint builder 的 metadata 
        builder.Metadata.Add(new RouteNameMetadata(routeName));                
        
        // 注入 action descriptor 的 filter descriptor（如果不为空）
        if (action.FilterDescriptors != null && 
            action.FilterDescriptors.Count > 0)
        {            
            foreach (var filter in 
                     action.FilterDescriptors
                     	   .OrderBy(
                               f => f, 
                               FilterDescriptorOrderComparer.Comparer)
                     	   .Select(f => f.Filter))
            {
                builder.Metadata.Add(filter);
            }
        }
        
        // 注入 action descriptor 的 action constraint（如果不为空）
        if (action.ActionConstraints != null && 
            action.ActionConstraints.Count > 0)
        {
            // We explicitly convert a few types of action constraints into 
            // MatcherPolicy+Metadata to better integrate with the DFA matcher.
            //
            // Other IActionConstraint data will trigger a back-compat path that can execute
            // action constraints.
            
            // 遍历 action constraint
            foreach (var actionConstraint in action.ActionConstraints)
            {
                // 如果 action constraint 是 http method action constraint，
                // -> 注入，
                // （builder 的 metadata 不包含，且需封装为 http method metadata）
                if (actionConstraint is 
                    HttpMethodActionConstraint httpMethodActionConstraint &&
                    !builder.Metadata
	                   	    .OfType<HttpMethodMetadata>()
                    	    .Any())
                {
                    builder.Metadata.Add(
                        new HttpMethodMetadata(httpMethodActionConstraint.HttpMethods));
                }
                // 否则，即 action constraint 不是 http method action constraint，
                // 但是如果 是 consume attribute，
                // -> 注入，
                // （builder的 metadata 不包含，且需封装为 consumes metadata）
                else if (actionConstraint is ConsumesAttribute consumesAttribute &&
                         !builder.Metadata
                         		 .OfType<ConsumesMetadata>()
                         		 .Any())
                {
                    builder.Metadata.Add(
                        new ConsumesMetadata(consumesAttribute.ContentTypes.ToArray()));
                }
                // 否则，将 action constraint 直接注入 builder 的 metadata
                // （如果 builder 的 metadata 不包含）
                else if (!builder.Metadata.Contains(actionConstraint))
                {
                    // The constraint might have been added earlier, 
                    // e.g. it is also a filter descriptor
                    builder.Metadata.Add(actionConstraint);
                }
            }
        }
        
        // 封装 suppress link generation（bool）为 metadata
        // 注入 route endpoint builder
        if (suppressLinkGeneration)
        {
            builder.Metadata.Add(new SuppressLinkGenerationMetadata());
        }
        
        // 封装 suppress path matching（bool）为 metadata，
        // 注入 route endpoint builder
        if (suppressPathMatching)
        {
            builder.Metadata.Add(new SuppressMatchingMetadata());
        }
        
        // 使用传入的 conventions (endpoint builder action) 配置 builder
        for (var i = 0; i < conventions.Count; i++)
        {
            conventions[i](builder);
        }
        
        // 使用传入的 perRouteConventions (endpoint builder action) 配置 builder
        for (var i = 0; i < perRouteConventions.Count; i++)
        {
            perRouteConventions[i](builder);
        }
    }
    
    private class InertEndpointBuilder : EndpointBuilder
    {
        public override Endpoint Build()
        {
            return new Endpoint(
                RequestDelegate, 
                new EndpointMetadataCollection(Metadata), 
                DisplayName);
        }
    }
}

```

###### 6.1.3.2  conventional route entry

```c#
internal readonly struct ConventionalRouteEntry
{
    public readonly RoutePattern Pattern;
    public readonly string RouteName;
    public readonly RouteValueDictionary DataTokens;
    public readonly int Order;
    public readonly IReadOnlyList<Action<EndpointBuilder>> Conventions;
    
    public ConventionalRouteEntry(
        string routeName,
        string pattern,
        RouteValueDictionary defaults,
        IDictionary<string, object> constraints,
        RouteValueDictionary dataTokens,
        int order,
        List<Action<EndpointBuilder>> conventions)
    {
        RouteName = routeName;
        DataTokens = dataTokens;
        Order = order;
        Conventions = conventions;
        
        try
        {
            // Data we parse from the pattern will be used to fill in the rest of 
            // the constraints or defaults. 
            // The parser will throw for invalid routes.
            Pattern = RoutePatternFactory.Parse(pattern, defaults, constraints);
        }
        catch (Exception exception)
        {
            throw new RouteCreationException(
                string.Format(
                    CultureInfo.CurrentCulture, 
                    "An error occurred while creating the route with name '{0}' and 
                    "pattern '{1}'.", 
                    routeName, 
                    pattern), 
                exception);
        }
    }
}

```

###### 6.1.3.3 create request delegate

```c#
internal class ActionEndpointFactory
{
    private RequestDelegate? CreateRequestDelegate(
        ActionDescriptor action, 
        RouteValueDictionary? dataTokens = null)
    {
        // 遍历 request delegate factory，
        foreach (var factory in _requestDelegateFactories)
        {
            // 使用 request delegate factory，
            // 为 action descriptor 创建 request delegate，           
            var requestDelegate = factory.CreateRequestDelegate(action, dataTokens);
            // 如果创建成功，-> 返回 request delegate（即一旦成功创建，结束遍历）
            if (requestDelegate != null)
            {
                return requestDelegate;
            }
        }
        
        return null;
    }
}

```

###### 6.1.4.4 resolve defaults & required values

```c#
internal class ActionEndpointFactory
{
    private static (RoutePattern resolvedRoutePattern, 
                    IDictionary<string, string> resolvedRequiredValues) 
        ResolveDefaultsAndRequiredValues(
        	ActionDescriptor action, 
        	RoutePattern attributeRoutePattern)
    {
        RouteValueDictionary? updatedDefaults = null;
        IDictionary<string, string>? resolvedRequiredValues = null;
        
        foreach (var routeValue in action.RouteValues)
        {
            var parameter = attributeRoutePattern.GetParameter(routeValue.Key);
            
            if (!RouteValueEqualityComparer.Default.Equals(
                	routeValue.Value, 
                	string.Empty))
            {
                if (parameter == null)
                {
                    // The attribute route has a required value with no matching parameter
                    // Add the required values without a parameter as a default
                    // e.g.
                    //   Template: "Login/{action}"
                    //   Required values: { controller = "Login", action = "Index" }
                    //   Updated defaults: { controller = "Login" }                    
                    if (updatedDefaults == null)
                    {
                        updatedDefaults = 
                            new RouteValueDictionary(attributeRoutePattern.Defaults);
                    }
                    
                    updatedDefaults[routeValue.Key] = routeValue.Value;
                }
            }
            else
            {
                if (parameter != null)
                {
                    // The attribute route has a null or empty required value with 
                    // a matching parameter
                    // Remove the required value from the route                    
                    if (resolvedRequiredValues == null)
                    {
                        resolvedRequiredValues = 
                            new Dictionary<string, string>(action.RouteValues);
                    }
                    
                    resolvedRequiredValues.Remove(parameter.Name);
                }
            }
        }
        if (updatedDefaults != null)
        {
            attributeRoutePattern = RoutePatternFactory.Parse(
                action.AttributeRouteInfo!.Template!, 
                updatedDefaults, 
                parameterPolicies: null);
        }
        
        return (attributeRoutePattern, resolvedRequiredValues ?? action.RouteValues);
    }
}
```

##### 6.1.4 方法 - add link generation route

```c#
internal class ActionEndpointFactory
{
    public void AddConventionalLinkGenerationRoute(
        // 结果集
        List<Endpoint> endpoints,
        // 已经注入的 route name 集合
        HashSet<string> routeNames,
        HashSet<string> keys,
        ConventionalRouteEntry route,
        IReadOnlyList<Action<EndpointBuilder>> conventions)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (keys == null)
        {
            throw new ArgumentNullException(nameof(keys));
        }        
        if (conventions == null)
        {
            throw new ArgumentNullException(nameof(conventions));
        }
        
        var requiredValues = new RouteValueDictionary();
        
        foreach (var key in keys)
        {
            if (route.Pattern.GetParameter(key) != null)
            {
                // Parameter (allow any)
                requiredValues[key] = RoutePattern.RequiredValueAny;
            }
            else if (route.Pattern
                     	  .Defaults
                     	  .TryGetValue(key, out var value))
            {
                requiredValues[key] = value;
            }
            else
            {
                requiredValues[key] = null;
            }
        }
        
        // We have to do some massaging of the pattern to try and get the
        // required values to be correct.
        var pattern = _routePatternTransformer.SubstituteRequiredValues(
            route.Pattern, 
            requiredValues);
        
        if (pattern == null)
        {
            // We don't expect this to happen, but we want to know if it does because 
            // it will help diagnose the bug.
            throw new InvalidOperationException(
                "Failed to create a conventional route for pattern: " + route.Pattern);
        }
        
        var builder = new RouteEndpointBuilder(
            context => Task.CompletedTask, 
            pattern,
            route.Order)
        {
            DisplayName = "Route: " + route.Pattern.RawText,
            Metadata =
            {
                new SuppressMatchingMetadata(),
            },
        };
        
        if (route.RouteName != null)
        {
            builder.Metadata.Add(new RouteNameMetadata(route.RouteName));
        }
        
        // See comments on the other usage of EndpointNameMetadata in this class.
        //
        // The set of cases for a conventional route are much simpler. We don't need to check
        // for Endpoint Name already exising here because there's no way to add an attribute to
        // a conventional route.
        if (route.RouteName != null && 
            routeNames.Add(route.RouteName))
        {
            builder.Metadata.Add(new EndpointNameMetadata(route.RouteName));
        }
        
        for (var i = 0; i < conventions.Count; i++)
        {
            conventions[i](builder);
        }
        
        for (var i = 0; i < route.Conventions.Count; i++)
        {
            route.Conventions[i](builder);
        }
        
        endpoints.Add((RouteEndpoint)builder.Build());
    }
}

```





#### 6.2 controller action endpoint conventional builder

```c#
public sealed class ControllerActionEndpointConventionBuilder : IEndpointConventionBuilder
{
    // The lock is shared with the data source.
    private readonly object _lock;
    private readonly List<Action<EndpointBuilder>> _conventions;
    
    internal ControllerActionEndpointConventionBuilder(
        object @lock, 
        List<Action<EndpointBuilder>> conventions)
    {
        _lock = @lock;
        _conventions = conventions;
    }
        
    public void Add(Action<EndpointBuilder> convention)
    {
        if (convention == null)
        {
            throw new ArgumentNullException(nameof(convention));
        }
        
        // The lock is shared with the data source. We want to lock here
        // to avoid mutating this list while its read in the data source.
        lock (_lock)
        {
            _conventions.Add(convention);
        }
    }
}

```

#### 6.3 action endpoint data source

##### 6.3.1 action endpoint data source  base

```c#
internal abstract class ActionEndpointDataSourceBase : 
	EndpointDataSource, 
	IDisposable
{
    private readonly IActionDescriptorCollectionProvider _actions;
    
    // The following are protected by this lock for WRITES only. This pattern is similar
    // to DefaultActionDescriptorChangeProvider - see comments there for details on
    // all of the threading behaviors.
    protected readonly object Lock = new object();    
    // Protected for READS and WRITES.
    protected readonly List<Action<EndpointBuilder>> Conventions;
    
    private CancellationTokenSource? _cancellationTokenSource;
    private IChangeToken? _changeToken;
    private IDisposable? _disposable;
    
    /* for endpoints */
    private List<Endpoint>? _endpoints;    
    public override IReadOnlyList<Endpoint> Endpoints
    {
        get
        {
            Initialize();
            Debug.Assert(_changeToken != null);
            Debug.Assert(_endpoints != null);
            return _endpoints;
        }
    }
    
    private void Initialize()
    {
        if (_endpoints == null)
        {
            lock (Lock)
            {
                if (_endpoints == null)
                {
                    UpdateEndpoints();
                }
            }
        }
    }
    
    private void UpdateEndpoints()
    {
        lock (Lock)
        {
            var endpoints = CreateEndpoints(
                _actions.ActionDescriptors.Items, 
                Conventions);
            
            // See comments in DefaultActionDescriptorCollectionProvider. These steps are done
            // in a specific order to ensure callers always see a consistent state.
            
            // Step 1 - capture old token
            var oldCancellationTokenSource = _cancellationTokenSource;
            
            // Step 2 - update endpoints
            _endpoints = endpoints;
            
            // Step 3 - create new change token
            _cancellationTokenSource = new CancellationTokenSource();
            _changeToken = new CancellationChangeToken(_cancellationTokenSource.Token);
            
            // Step 4 - trigger old token
            oldCancellationTokenSource?.Cancel();
        }
    }
    
    // Will be called with the lock.
    // 在派生类中实现
    protected abstract List<Endpoint> CreateEndpoints(
        IReadOnlyList<ActionDescriptor> actions, 
        IReadOnlyList<Action<EndpointBuilder>> conventions);
    
            
    public ActionEndpointDataSourceBase(IActionDescriptorCollectionProvider actions)
    {
        // 注入 action descriptor collection
        _actions = actions;
        // 创建 endpoint builder action 集合
        Conventions = new List<Action<EndpointBuilder>>();
    }
                   
    protected void Subscribe()
    {
        // IMPORTANT: this needs to be called by the derived class to avoid the fragile 
        // base class problem. We can't call this in the base-class constuctor because 
        // it's too early.
        //
        // It's possible for someone to override the collection provider without providing
        // change notifications. If that's the case we won't process changes.
        if (_actions is ActionDescriptorCollectionProvider collectionProviderWithChangeToken)
        {
            _disposable = ChangeToken.OnChange(
                () => collectionProviderWithChangeToken.GetChangeToken(),
                UpdateEndpoints);
        }
    }
    
    public override IChangeToken GetChangeToken()
    {
        Initialize();
        Debug.Assert(_changeToken != null);
        Debug.Assert(_endpoints != null);
        return _changeToken;
    }
    
    public void Dispose()
    {
        // Once disposed we won't process updates anymore, 
        // but we still allow access to the endpoints.
        _disposable?.Dispose();
        _disposable = null;
    }        
}

```

##### 6.3.2 controller action data source

```c#
internal class ControllerActionEndpointDataSource : ActionEndpointDataSourceBase
{
    private readonly ActionEndpointFactory _endpointFactory;
    private readonly OrderedEndpointsSequenceProvider _orderSequence;
    private readonly List<ConventionalRouteEntry> _routes;
    
    public int DataSourceId { get; }    
    public ControllerActionEndpointConventionBuilder DefaultBuilder { get; }    
    
    // Used to control whether we create 'inert' (non-routable) endpoints for use in dynamic selection. 
    // Set to true by builder methods that do dynamic/fallback selection.
    public bool CreateInertEndpoints { get; set; }
    
    public ControllerActionEndpointDataSource(
        ControllerActionEndpointDataSourceIdProvider dataSourceIdProvider,
        IActionDescriptorCollectionProvider actions,
        ActionEndpointFactory endpointFactory,
        OrderedEndpointsSequenceProvider orderSequence) : base(actions)
    {
        // 注入 action endpoint factory
        _endpointFactory = endpointFactory;
        // 由注入的 data source id provider 创建 data source id        
        DataSourceId = dataSourceIdProvider.CreateId();
        // 注入 ordered endpoint sequence provider
        _orderSequence = orderSequence;
        
        // 创建 conventional route entry 集合
        _routes = new List<ConventionalRouteEntry>();
        // 由 conventions (endpoint builder action 集合)，
        // 创建 controller action endpoint conventional builder
        DefaultBuilder = new ControllerActionEndpointConventionBuilder(Lock, Conventions);
        
        // IMPORTANT: this needs to be the last thing we do in the constructor.
        // Change notifications can happen immediately!
        Subscribe();
    }
    
    /* add route */           
    public ControllerActionEndpointConventionBuilder AddRoute(
        string routeName,
        string pattern,
        RouteValueDictionary defaults,
        IDictionary<string, object> constraints,
        RouteValueDictionary dataTokens)
    {
        lock (Lock)
        {
            var conventions = new List<Action<EndpointBuilder>>();
            
            _routes.Add(
                new ConventionalRouteEntry(
                    routeName, 
                    pattern, 
                    defaults, 
                    constraints, 
                    dataTokens, 
                    _orderSequence.GetNext(), 
                    conventions));
            
            return new ControllerActionEndpointConventionBuilder(Lock, conventions);
        }
    }
    
    /* create endpoints 集合 */
    protected override List<Endpoint> CreateEndpoints(
        IReadOnlyList<ActionDescriptor> actions, 
        IReadOnlyList<Action<EndpointBuilder>> conventions)
    {
        var endpoints = new List<Endpoint>();
        var keys = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        
        // MVC guarantees that when two of it's endpoints have the same route name 
        // they are equivalent.
        //
        // However, Endpoint Routing requires Endpoint Names to be unique.
        var routeNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        
        // For each controller action - add the relevant endpoints.
        //
        // 1. If the action is attribute routed, we use that information verbatim
        // 2. If the action is conventional routed
        //      a. Create a *matching only* endpoint for each action X route (if possible)
        //      b. Ignore link generation for now
        for (var i = 0; i < actions.Count; i++)
        {
            if (actions[i] is ControllerActionDescriptor action)
            {
                _endpointFactory.AddEndpoints(
                    endpoints, 
                    routeNames, 
                    action, 
                    _routes, 
                    conventions, 
                    CreateInertEndpoints);
                
                if (_routes.Count > 0)
                {
                    // If we have conventional routes, keep track of the keys so we can create
                    // the link generation routes later.
                    foreach (var kvp in action.RouteValues)
                    {
                        keys.Add(kvp.Key);
                    }
                }
            }
        }
        
        // Now create a *link generation only* endpoint for each route. This gives us a very
        // compatible experience to previous versions.
        for (var i = 0; i < _routes.Count; i++)
        {
            var route = _routes[i];
            _endpointFactory.AddConventionalLinkGenerationRoute(
                endpoints, 
                routeNames, 
                keys, 
                route, 
                conventions);
        }
        
        return endpoints;
    }
    
    /* add dynamic controller endpoint */
    internal void AddDynamicControllerEndpoint(
        IEndpointRouteBuilder endpoints, 
        string pattern, 
        Type transformerType, 
        object state, 
        int? order = null)
    {
        CreateInertEndpoints = true;
        lock (Lock)
        {
            order ??= _orderSequence.GetNext();
            
            endpoints.Map(
                pattern,
                context =>
                {
                    throw new InvalidOperationException(
                        "This endpoint is not expected to be executed directly.");
                })
                	 .Add(b =>
                          {
                              ((RouteEndpointBuilder)b).Order = order.Value;
                              // 注入 dynamic controller route value transformer metadata
                              b.Metadata.Add(
                                  new DynamicControllerRouteValueTransformerMetadata(transformerType, state));
                              // 注入 controller endpoint data source id metadata
                              b.Metadata.Add(
                                  new ControllerEndpointDataSourceIdMetadata(DataSourceId));
                          });
        }
    }
}

```

###### 6.3.2.1 controller action endpoint data source id provider

```c#
internal class ControllerActionEndpointDataSourceIdProvider
{
    private int _nextId = 1;
    
    internal int CreateId()
    {
        return Interlocked.Increment(ref _nextId);
    }
}

```

###### 6.3.2.2 ordered endpoint sequence provider?

```c#

```

###### 6.3.2.3 dynamic controller route value transformer metadata

```c#
internal class DynamicControllerRouteValueTransformerMetadata : IDynamicEndpointMetadata
{
    public Type SelectorType { get; }    
    public object State { get; }
    
    public bool IsDynamic => true;    
    
    public DynamicControllerRouteValueTransformerMetadata(
        Type selectorType, 
        object state)
    {
        if (selectorType == null)
        {
            throw new ArgumentNullException(nameof(selectorType));
        }
        
        if (!typeof(DynamicRouteValueTransformer).IsAssignableFrom(selectorType))
        {
            throw new ArgumentException(
                $"The provided type must be a subclass of 
                "{typeof(DynamicRouteValueTransformer)}",
                nameof(selectorType));
        }
        
        SelectorType = selectorType;
        State = state;
    }            
}

```

###### 6.3.2.4 controller endpoint data source id metadata

```c#
internal class ControllerEndpointDataSourceIdMetadata
{
    public int Id { get; }    
    public ControllerEndpointDataSourceIdMetadata(int id)
    {
        Id = id;
    }        
}

```

##### 6.3.3 controller action data source factory

```c#
internal class ControllerActionEndpointDataSourceFactory
{
    private readonly ControllerActionEndpointDataSourceIdProvider _dataSourceIdProvider;
    private readonly IActionDescriptorCollectionProvider _actions;
    private readonly ActionEndpointFactory _factory;
    
    public ControllerActionEndpointDataSourceFactory(
        ControllerActionEndpointDataSourceIdProvider dataSourceIdProvider,
        IActionDescriptorCollectionProvider actions,
        ActionEndpointFactory factory)
    {
        // 注入 controller action endpoint data source id provider
        _dataSourceIdProvider = dataSourceIdProvider;
        // 注入 action descriptor collection provider
        _actions = actions;
        // 注入 action endpoint factory
        _factory = factory;
    }
    
    public ControllerActionEndpointDataSource Create(
        OrderedEndpointsSequenceProvider orderProvider)
    {
        return new ControllerActionEndpointDataSource(
            _dataSourceIdProvider, 
            _actions, 
            _factory, 
            orderProvider);
    }
}

```

#### 6.4 ext matcher policy

##### 6.4.1 action constraint matcher policy

```c#
internal class ActionConstraintMatcherPolicy : 
	MatcherPolicy, 
	IEndpointSelectorPolicy
{
    private static readonly IReadOnlyList<Endpoint> EmptyEndpoints = Array.Empty<Endpoint>();        
    internal static readonly ActionDescriptor NonAction = new ActionDescriptor();
    
    private readonly ActionConstraintCache _actionConstraintCache;
    
    public ActionConstraintMatcherPolicy(ActionConstraintCache actionConstraintCache)
    {
        // 注入 action constraint cache
        _actionConstraintCache = actionConstraintCache;
    }
    
    /* matcher policy */   
    public override int Order => 100000;                        
}

```

###### 6.4.1.1 实现 endpoint selector policy

```c#
internal class ActionConstraintMatcherPolicy 
{
    /* applies to endpoint */
    public bool AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        // We can skip over action constraints when they aren't any for this set of endpoints. 
        // This happens once on startup so it removes this component from the code path in most scenarios.
        
        // 遍历传入的 endpoints，
        for (var i = 0; i < endpoints.Count; i++)
        {
            // 解析 endpoint 的 metadata 中的 action descriptor
            var endpoint = endpoints[i];
            var action = endpoint.Metadata.GetMetadata<ActionDescriptor>();
            // 如果 action descriptor 的 action constraint 是 action constraint metadata 集合，
            // 并且 has significant action constraint，-> 返回 true（可以应用 policy）
            // （http method、consumes 由特定 policy 处理）
            if (action?.ActionConstraints is IList<IActionConstraintMetadata> { Count: > 0} constraints && 
                HasSignificantActionConstraint(constraints))
            {
                // We need to check for some specific action constraint implementations.
                // We've implemented consumes, and HTTP method support inside endpoint routing, so
                // we don't need to run an 'action constraint phase' if those are the only constraints.
                return true;
            }
        }
        
        // 由上，action constraint 不是 action constraint metadata 集合，
        // 或者 has significant constraint = false，-> 返回 false（不可以应用 policy）
        return false;
        
        bool HasSignificantActionConstraint(IList<IActionConstraintMetadata> constraints)
        {
            // 遍历 constraint metadata，
            for (var i = 0; i < constraints.Count; i++)
            {
                var actionConstraint = constraints[i];
                
                // 如果 constraint metadata 是 http method action constraint，-> false
                if (actionConstraint.GetType() == typeof(HttpMethodActionConstraint))
                {
                    // This one is OK, we implement this in endpoint routing.
                }
                // 如果 constraint metadata 是 consume attribute，-> false
                else if (actionConstraint.GetType() == typeof(ConsumesAttribute))
                {
                    // This one is OK, we implement this in endpoint routing.
                }
                // 否则，即 constraint metadata 不是 http method action constraint，
                // 并且不是 consumes attribute，-> true
                else
                {
                    return true;
                }
            }
            
            return false;
        }
    }
    
    /* apply async */
    public Task ApplyAsync(HttpContext httpContext, CandidateSet candidateSet)
    {
        // 验证 action constraint，解析到 matched candidate
        var finalMatches = EvaluateActionConstraints(httpContext, candidateSet);
                
        // 全部 candidate 置为 invalid
        for (var i = 0; i < candidateSet.Count; i++)
        {
            candidateSet.SetValidity(i, false);
        }
        // 将 matched candidate 置为 valid
        if (finalMatches != null)
        {
            for (var i = 0; i < finalMatches.Count; i++)
            {
                candidateSet.SetValidity(finalMatches[i].index, true);
            }
        }
        
        return Task.CompletedTask;
    }
    
    // This is almost the same as the code in ActionSelector, but we can't really share the logic
    // because we need to track the index of each candidate - and, each candidate has its own route
    // values.
    private IReadOnlyList<(int index, ActionSelectorCandidate candidate)>? EvaluateActionConstraints(
        HttpContext httpContext,
        CandidateSet candidateSet)
    {
        var items = new List<(int index, ActionSelectorCandidate candidate)>();
        
        // We want to execute a group at a time (based on score) so keep track of the score that we've seen.
        int? score = null;
        
        // Perf: Avoid allocations
        for (var i = 0; i < candidateSet.Count; i++)
        {
            if (candidateSet.IsValidCandidate(i))
            {
                ref var candidate = ref candidateSet[i];
                if (score != null && score != candidate.Score)
                {
                    // This is the end of a group.
                    var matches = EvaluateActionConstraintsCore(
                        httpContext, 
                        candidateSet, 
                        items, 
                        startingOrder: null);
                    
                    if (matches?.Count > 0)
                    {
                        return matches;
                    }
                    
                    // If we didn't find matches, then reset.
                    items.Clear();
                }
                
                score = candidate.Score;
                
                // If we get here, this is either the first endpoint or the we just (unsuccessfully)
                // executed constraints for a group.                
                // So keep adding constraints.
                var endpoint = candidate.Endpoint;
                var actionDescriptor = endpoint.Metadata
                    						 .GetMetadata<ActionDescriptor>();
                
                IReadOnlyList<IActionConstraint>? constraints = Array.Empty<IActionConstraint>();
                if (actionDescriptor != null)
                {
                    constraints = _actionConstraintCache.GetActionConstraints(httpContext, actionDescriptor);
                }
                
                // Capture the index. We need this later to look up the endpoint/route values.                
                items.Add((i, new ActionSelectorCandidate(actionDescriptor ?? NonAction, constraints)));
            }
        }
        
        // Handle residue
        return EvaluateActionConstraintsCore(httpContext, candidateSet, items, startingOrder: null);
    }
    
    private IReadOnlyList<(int index, ActionSelectorCandidate candidate)>? EvaluateActionConstraintsCore(
        HttpContext httpContext,
        CandidateSet candidateSet,
        IReadOnlyList<(int index, ActionSelectorCandidate candidate)> items,
        int? startingOrder)
    {
        // Find the next group of constraints to process. This will be the lowest value of
        // order that is higher than startingOrder.
        int? order = null;
        
        // Perf: Avoid allocations
        for (var i = 0; i < items.Count; i++)
        {
            var item = items[i];
            var constraints = item.candidate.Constraints;
            if (constraints != null)
            {
                for (var j = 0; j < constraints.Count; j++)
                {
                    var constraint = constraints[j];
                    if ((startingOrder == null || constraint.Order > startingOrder) &&
                        (order == null || constraint.Order < order))
                    {
                        order = constraint.Order;
                    }
                }
            }
        }
        
        // If we don't find a next then there's nothing left to do.
        if (order == null)
        {
            return items;
        }
        
        // Since we have a constraint to process, bisect the set of endpoints into those with and without a
        // constraint for the current order.
        var endpointsWithConstraint = new List<(int index, ActionSelectorCandidate candidate)>();
        var endpointsWithoutConstraint = new List<(int index, ActionSelectorCandidate candidate)>();
        
        var constraintContext = new ActionConstraintContext
        {
            Candidates = items.Select(i => i.candidate).ToArray()
        };
        
        // Perf: Avoid allocations
        for (var i = 0; i < items.Count; i++)
        {
            var item = items[i];
            var isMatch = true;
            var foundMatchingConstraint = false;
            
            var constraints = item.candidate.Constraints;
            if (constraints != null)
            {
                constraintContext.CurrentCandidate = item.candidate;
                for (var j = 0; j < constraints.Count; j++)
                {
                    var constraint = constraints[j];
                    if (constraint.Order == order)
                    {
                        foundMatchingConstraint = true;
                        
                        ref var candidate = ref candidateSet[item.index];                        
                        var routeData = new RouteData(candidate.Values!);                        
                        var dataTokens = candidate.Endpoint
                            					.Metadata
                            					.GetMetadata<IDataTokensMetadata>()?
                            					.DataTokens;
                        
                        if (dataTokens != null)
                        {
                            // Set the data tokens if there are any for this candidate
                            routeData.PushState(
                                router: null, 
                                values: null, 
                                dataTokens: new RouteValueDictionary(dataTokens));
                        }
                        
                        // Before we run the constraint, we need to initialize the route values.
                        // In endpoint routing, the route values are per-endpoint.
                        constraintContext.RouteContext = new RouteContext(httpContext)
                        {
                            RouteData = routeData,
                        };
                        if (!constraint.Accept(constraintContext))
                        {
                            isMatch = false;
                            break;
                        }
                    }
                }
            }
            
            if (isMatch && foundMatchingConstraint)
            {
                endpointsWithConstraint.Add(item);
            }
            else if (isMatch)
            {
                endpointsWithoutConstraint.Add(item);
            }
        }
        
        // If we have matches with constraints, those are better so try to keep processing those
        if (endpointsWithConstraint.Count > 0)
        {
            var matches = EvaluateActionConstraintsCore(
                httpContext, 
                candidateSet, 
                endpointsWithConstraint, 
                order);
            if (matches?.Count > 0)
            {
                return matches;
            }
        }
        
        // If the set of matches with constraints can't work, then process the set without constraints.
        if (endpointsWithoutConstraint.Count == 0)
        {
            return null;
        }
        else
        {
            return EvaluateActionConstraintsCore(
                httpContext, 
                candidateSet, 
                endpointsWithoutConstraint, 
                order);
        }
    }
}
```



##### 6.4.2 consume matcher policy

```c#
internal class ConsumesMatcherPolicy : 
	MatcherPolicy, 
	IEndpointComparerPolicy, 
	INodeBuilderPolicy, 
	IEndpointSelectorPolicy
{
    internal const string Http415EndpointDisplayName = "415 HTTP Unsupported Media Type";
    internal const string AnyContentType = "*/*";
    
    /* matcher policy */   
    public override int Order { get; } = -100;                               
    
    private int GetScore(in MediaType mediaType)
    {
        // Higher score == lower priority - see comments on MediaType.
        if (mediaType.MatchesAllTypes)
        {
            return 4;
        }
        else if (mediaType.MatchesAllSubTypes)
        {
            return 3;
        }
        else if (mediaType.MatchesAllSubTypesWithoutSuffix)
        {
            return 2;
        }
        else
        {
            return 1;
        }
    }   
    
    private Endpoint CreateRejectionEndpoint()
    {
        return new Endpoint(
            (context) =>
            {
                context.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;
                return Task.CompletedTask;
            },
            EndpointMetadataCollection.Empty,
            Http415EndpointDisplayName);
    }
}

```

###### 6.4.2.1 实现 comparer policy

```c#
internal class ConsumesMatcherPolicy
{
    public IComparer<Endpoint> Comparer { get; } = new ConsumesMetadataEndpointComparer();    
    private class ConsumesMetadataEndpointComparer : EndpointMetadataComparer<IConsumesMetadata>
    {
        protected override int CompareMetadata(IConsumesMetadata? x, IConsumesMetadata? y)
        {
            // Ignore the metadata if it has an empty list of content types.
            return base.CompareMetadata(
                x?.ContentTypes.Count > 0 ? x : null,
                y?.ContentTypes.Count > 0 ? y : null);
        }
    }
    
}
```

###### 6.4.2.2 实现 node build policy

```c#
internal class ConsumesMatcherPolicy
{
    /* applies to endpoint */
    bool INodeBuilderPolicy.AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        if (ContainsDynamicEndpoints(endpoints))
        {
            return false;
        }
        
        return AppliesToEndpointsCore(endpoints);
    }
    
    private bool AppliesToEndpointsCore(IReadOnlyList<Endpoint> endpoints)
    {
        // 如果 endpoint 的 metadata 包含 consumes metadata，
        // -> ture，即可以应用 policy
        return endpoints.Any(e => e.Metadata
                             	   .GetMetadata<IConsumesMetadata>()?
                             	   .ContentTypes
                             	   .Count > 0);        
    }
    
    /* get edges */
    public IReadOnlyList<PolicyNodeEdge> GetEdges(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        // The algorithm here is designed to be preserve the order of the endpoints
        // while also being relatively simple. Preserving order is important.
        //
        // First, build a dictionary of all of the content-type patterns that are included
        // at this node.
        //
        // For now we're just building up the set of keys. We don't add any endpoints
        // to lists now because we don't want ordering problems.
        
        var edges = new Dictionary<string, List<Endpoint>>(StringComparer.OrdinalIgnoreCase);
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            var contentTypes = endpoint.Metadata
                					 .GetMetadata<IConsumesMetadata>()?
                					 .ContentTypes;
            if (contentTypes == null || contentTypes.Count == 0)
            {
                contentTypes = new string[] { AnyContentType, };
            }
            
            for (var j = 0; j < contentTypes.Count; j++)
            {
                var contentType = contentTypes[j];
                
                if (!edges.ContainsKey(contentType))
                {
                    edges.Add(contentType, new List<Endpoint>());
                }
            }
        }
        
        // Now in a second loop, add endpoints to these lists. We've enumerated all of
        // the states, so we want to see which states this endpoint matches.
        for (var i = 0; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            var contentTypes = endpoint.Metadata
                					 .GetMetadata<IConsumesMetadata>()?
                					 .ContentTypes ?? Array.Empty<string>();
            if (contentTypes.Count == 0)
            {
                // OK this means that this endpoint matches *all* content methods.
                // So, loop and add it to all states.
                foreach (var kvp in edges)
                {
                    kvp.Value.Add(endpoint);
                }
            }
            else
            {
                // OK this endpoint matches specific content types -- we have to loop through edges here
                // because content types could either be exact (like 'application/json') or they
                // could have wildcards (like 'text/*'). We don't expect wildcards to be especially common
                // with consumes, but we need to support it.
                foreach (var kvp in edges)
                {
                    // The edgeKey maps to a possible request header value
                    var edgeKey = new MediaType(kvp.Key);
                    
                    for (var j = 0; j < contentTypes.Count; j++)
                    {
                        var contentType = contentTypes[j];
                        
                        var mediaType = new MediaType(contentType);
                        
                        // Example: 'application/json' is subset of 'application/*'
                        //
                        // This means that when the request has content-type 'application/json' an endpoint
                        // what consumes 'application/*' should match.
                        if (edgeKey.IsSubsetOf(mediaType))
                        {
                            kvp.Value.Add(endpoint);
                            
                            // It's possible that a ConsumesMetadata defines overlapping wildcards. Don't add an endpoint
                            // to any edge twice
                            break;
                        }
                    }
                }
            }
        }
        
        // If after we're done there isn't any endpoint that accepts */*, then we'll synthesize an
        // endpoint that always returns a 415.
        if (!edges.TryGetValue(AnyContentType, out var anyEndpoints))
        {
            edges.Add(AnyContentType, new List<Endpoint>()
                      {
                          CreateRejectionEndpoint(),
                      });
            
            // Add a node to use when there is no request content type.
            // When there is no content type we want the policy to no-op
            edges.Add(string.Empty, endpoints.ToList());
        }
        else
        {
            // If there is an endpoint that accepts */* then it is also used when there is no content type
            edges.Add(string.Empty, anyEndpoints.ToList());
        }
        
        
        return edges.Select(kvp => new PolicyNodeEdge(kvp.Key, kvp.Value))
            	    .ToArray();
    }        
    
    /* build jump table */
    public PolicyJumpTable BuildJumpTable(int exitDestination, IReadOnlyList<PolicyJumpTableEdge> edges)
    {
        if (edges == null)
        {
            throw new ArgumentNullException(nameof(edges));
        }
        
        // Since our 'edges' can have wildcards, we do a sort based on how wildcard-ey they
        // are then then execute them in linear order.
        var ordered = edges.Select(e => (mediaType: CreateEdgeMediaType(ref e), destination: e.Destination))
            			  .OrderBy(e => GetScore(e.mediaType))
            			  .ToArray();
        
        // If any edge matches all content types, then treat that as the 'exit'. This will
        // always happen because we insert a 415 endpoint.
        for (var i = 0; i < ordered.Length; i++)
        {
            if (ordered[i].mediaType.MatchesAllTypes)
            {
                exitDestination = ordered[i].destination;
                break;
            }
        }
        
        var noContentTypeDestination = GetNoContentTypeDestination(ordered);
        
        return new ConsumesPolicyJumpTable(exitDestination, noContentTypeDestination, ordered);
    }
    
    private static MediaType CreateEdgeMediaType(ref PolicyJumpTableEdge e)
    {
        var mediaType = (string)e.State;
        return !string.IsNullOrEmpty(mediaType) ? new MediaType(mediaType) : default;
    }
        
    private static int GetNoContentTypeDestination((MediaType mediaType, int destination)[] destinations)
    {
        for (var i = 0; i < destinations.Length; i++)
        {
            if (!destinations[i].mediaType.Type.HasValue)
            {
                return destinations[i].destination;
            }
        }
        
        throw new InvalidOperationException("Could not find destination for no content type.");
    }
    
    private class ConsumesPolicyJumpTable : PolicyJumpTable
    {
        private readonly (MediaType mediaType, int destination)[] _destinations;
        private readonly int _exitDestination;
        private readonly int _noContentTypeDestination;
        
        public ConsumesPolicyJumpTable(
            int exitDestination, 
            int noContentTypeDestination, 
            (MediaType mediaType, int destination)[] destinations)
        {
            _exitDestination = exitDestination;
            _noContentTypeDestination = noContentTypeDestination;
            _destinations = destinations;
        }
        
        public override int GetDestination(HttpContext httpContext)
        {
            var contentType = httpContext.Request.ContentType;
            
            if (string.IsNullOrEmpty(contentType))
            {
                return _noContentTypeDestination;
            }
            
            var requestMediaType = new MediaType(contentType);
            var destinations = _destinations;
            for (var i = 0; i < destinations.Length; i++)
            {
                if (requestMediaType.IsSubsetOf(destinations[i].mediaType))
                {
                    return destinations[i].destination;
                }
            }
            
            return _exitDestination;
        }
    }
}

```

###### 6.4.2.3 实现 endpoint selector policy

```c#
internal class ConsumesMatcherPolicy
{
    /* applies to endpoint*/
    bool IEndpointSelectorPolicy.AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        // When the node contains dynamic endpoints we can't make any assumptions.
        return ContainsDynamicEndpoints(endpoints);
    }
    
    /* apply async */    
    public Task ApplyAsync(HttpContext httpContext, CandidateSet candidates)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }        
        if (candidates == null)
        {
            throw new ArgumentNullException(nameof(candidates));
        }
        
        // We want to return a 415 if we eliminated ALL of the currently valid endpoints due to content type
        // mismatch.
        bool? needs415Endpoint = null;
        
        for (var i = 0; i < candidates.Count; i++)
        {
            // We do this check first for consistency with how 415 is implemented for the graph version
            // of this code. We still want to know if any endpoints in this set require an a ContentType
            // even if those endpoints are already invalid - hence the null check.
            var metadata = candidates[i].Endpoint?
                					  .Metadata
                					  .GetMetadata<IConsumesMetadata>();
            if (metadata == null || 
                metadata.ContentTypes.Count == 0)
            {
                // Can match any content type.
                needs415Endpoint = false;
                continue;
            }
            
            // Saw a valid endpoint.
            needs415Endpoint = needs415Endpoint ?? true;
            
            if (!candidates.IsValidCandidate(i))
            {
                // If the candidate is already invalid, then do a search to see if it has a wildcard content type.                
                // We don't want to return a 415 if any content type could be accepted depending on other parameters.
                if (metadata != null)
                {
                    for (var j = 0; j < metadata.ContentTypes.Count; j++)
                    {
                        if (string.Equals(
                            "*/*", 
                            metadata.ContentTypes[j], 
                            StringComparison.Ordinal))
                        {
                            needs415Endpoint = false;
                            break;
                        }
                    }
                }
                
                continue;
            }
            
            var contentType = httpContext.Request.ContentType;
            var mediaType = string.IsNullOrEmpty(contentType) 
                ? (MediaType?)null 
                : new MediaType(contentType);
            
            var matched = false;
            for (var j = 0; j < metadata.ContentTypes.Count; j++)
            {
                var candidateMediaType = new MediaType(metadata.ContentTypes[j]);
                if (candidateMediaType.MatchesAllTypes)
                {
                    // We don't need a 415 response because there's an endpoint that would accept any type.
                    needs415Endpoint = false;
                }
                
                // If there's no ContentType, then then can only matched by a wildcard `*/*`.
                if (mediaType == null && 
                    !candidateMediaType.MatchesAllTypes)
                {
                    continue;
                }
                
                // We have a ContentType but it's not a match.
                else if (mediaType != null && !mediaType.Value.IsSubsetOf(candidateMediaType))
                {
                    continue;
                }
                
                // We have a ContentType and we accept any value OR we have a ContentType and it's a match.
                matched = true;
                needs415Endpoint = false;
                break;
            }
            
            if (!matched)
            {
                candidates.SetValidity(i, false);
            }
        }
        
        if (needs415Endpoint == true)
        {
            // We saw some endpoints coming in, and we eliminated them all.
            httpContext.SetEndpoint(CreateRejectionEndpoint());
        }
        
        return Task.CompletedTask;
    }
}
```

###### 6.4.2.4 consumes metadata

```c#
internal interface IConsumesMetadata
{
    IReadOnlyList<string> ContentTypes { get; }
}

internal class ConsumesMetadata : IConsumesMetadata
{
    public ConsumesMetadata(string[] contentTypes)
    {
        if (contentTypes == null)
        {
            throw new ArgumentNullException(nameof(contentTypes));
        }
        
        ContentTypes = contentTypes;
    }
    
    public IReadOnlyList<string> ContentTypes { get; }
}

```

##### 6.4.3 dynamic controller endpoint matcher policy

```c#
internal class DynamicControllerEndpointMatcherPolicy : MatcherPolicy, IEndpointSelectorPolicy
{
    private readonly DynamicControllerEndpointSelectorCache _selectorCache;
    private readonly EndpointMetadataComparer _comparer;
    
    /* matcher policy */
    public override int Order => int.MinValue + 100;
    
    public DynamicControllerEndpointMatcherPolicy(
        DynamicControllerEndpointSelectorCache selectorCache, 
        EndpointMetadataComparer comparer)
    {
        if (selectorCache == null)
        {
            throw new ArgumentNullException(nameof(selectorCache));
        }        
        if (comparer == null)
        {
            throw new ArgumentNullException(nameof(comparer));
        }
        
        // 注入 dynamic controller endpoint selector cache
        _selectorCache = selectorCache;
        // 注入 endpoint metadata comparer
        _comparer = comparer;
    }
        
    /* endpoint selector policy */
    public bool AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        // 使用 matcher policy 的 contains dynamic endpoint 方法判断
        // （即 endpoint 包含 dynamic endpoint metadata）
        if (!ContainsDynamicEndpoints(endpoints))
        {
            // Dynamic controller endpoints are always dynamic endpoints.
            return false;
        }
        
        for (var i = 0; i < endpoints.Count; i++)
        {
            // 如果 endpoint 包含 dynamic controller metadata，-> true
            if (endpoints[i].Metadata
                		   .GetMetadata<DynamicControllerMetadata>() != null)
            {
                // Found a dynamic controller endpoint
                return true;
            }
            // 如果 endpoint 包含 dynamic controller route value transformer metadata，-> true
            if (endpoints[i].Metadata
                		   .GetMetadata<DynamicControllerRouteValueTransformerMetadata>() != null)
            {
                // Found a dynamic controller endpoint
                return true;
            }
        }
        
        return false;
    }
    
    public async Task ApplyAsync(HttpContext httpContext, CandidateSet candidates)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }        
        if (candidates == null)
        {
            throw new ArgumentNullException(nameof(candidates));
        }
        
        // The per-route selector, must be the same for all the endpoints we are dealing with.
        DynamicControllerEndpointSelector? selector = null;
                
        // 遍历 candidate，
        for (var i = 0; i < candidates.Count; i++)
        {
            // 如果 candidate 不是 valid，-> 下一个 candidate
            if (!candidates.IsValidCandidate(i))
            {
                continue;
            }
            
            // 从 candidate 解析 endpoint
            var endpoint = candidates[i].Endpoint;
            // 从 candidate 解析 route value dictionary
            var originalValues = candidates[i].Values!;
            
            RouteValueDictionary? dynamicValues = null;
                        
            // 从 endpoint 解析 dynamic controller metadata
            var dynamicControllerMetadata = endpoint.Metadata
                								 .GetMetadata<DynamicControllerMetadata>();
            // 从 endpoint 解析 dynamic controller route value transformer metadata
            var transformerMetadata = endpoint.Metadata
                						    .GetMetadata<DynamicControllerRouteValueTransformerMetadata>();
            
            DynamicRouteValueTransformer? transformer = null;
            
            // 如果 dynmaic controller metadata 不为 null，-> 取值 dynamic values = metadata.values
            if (dynamicControllerMetadata != null)
            {
                dynamicValues = dynamicControllerMetadata.Values;
            }
            // 否则，即 dynamic controller metadata 为 null，
            // 但是 dynamic controller route value transform metadata 不为 null，
            else if (transformerMetadata != null)
            {
                // 从 service provider 解析 transformer，
                transformer = 
                    (DynamicRouteValueTransformer)httpContext.RequestServices
                     								      .GetRequiredService(transformerMetadata.SelectorType);                
                if (transformer.State != null)
                {
                    throw new InvalidOperationException(
                        Resources.FormatStateShouldBeNullForRouteValueTransformers(transformerMetadata.SelectorType.Name));
                }                
                transformer.State = transformerMetadata.State;
                
                // 由 transformer 变换得到 dynamic values
                dynamicValues = await transformer.TransformAsync(httpContext, originalValues);
            }
            // 否则，即 metadata 都为 null，-> 下一个 candidate
            else
            {
                // Not a dynamic controller.
                continue;
            }
            
            // dynamic vlaues 为 null，-> 下一个 candidate
            if (dynamicValues == null)
            {
                candidates.ReplaceEndpoint(i, null, null);
                continue;
            }
            
            // 由 endpoint （从 selector cache）解析 dynamic endpoint selector
            selector = ResolveSelector(selector, endpoint);
            // 使用 selector 的 select 方法
            var endpoints = selector.SelectEndpoints(dynamicValues);
            if (endpoints.Count == 0 && dynamicControllerMetadata != null)
            {
                // Naving no match for a fallback is a configuration error. We can't really check
                // during startup that the action you configured exists, so this is the best we can do.
                throw new InvalidOperationException(
                    "Cannot find the fallback endpoint specified by route values: " +
                    "{ " + 
                    string.Join(
                        ", ", 
                        dynamicValues.Select(kvp => $"{kvp.Key}: {kvp.Value}")) + 
                    " }.");
            }
            else if (endpoints.Count == 0)
            {
                candidates.ReplaceEndpoint(i, null, null);
                continue;
            }
            
            // We need to provide the route values associated with this endpoint, so that features
            // like URL generation work.
            
            // 封装 dynamaic route values
            var values = new RouteValueDictionary(dynamicValues);            
            // Include values that were matched by the fallback route.
            if (originalValues != null)
            {
                foreach (var kvp in originalValues)
                {
                    values.TryAdd(kvp.Key, kvp.Value);
                }
            }
            
            // 如果 transformer 不为 null，
            if (transformer != null)
            {
                // -> 使用 transformer 的 filter 方法过滤 endpoints
                endpoints = await transformer.FilterAsync(httpContext, values, endpoints);
                if (endpoints.Count == 0)
                {
                    candidates.ReplaceEndpoint(i, null, null);
                    continue;
                }
            }
            
            // Update the route values
            candidates.ReplaceEndpoint(i, endpoint, values);
            
            // Expand the list of endpoints
            candidates.ExpandEndpoint(i, endpoints, _comparer);
        }
    }
    
    private DynamicControllerEndpointSelector ResolveSelector(
        DynamicControllerEndpointSelector? currentSelector, 
        Endpoint endpoint)
    {
        var selector = _selectorCache.GetEndpointSelector(endpoint);        
        Debug.Assert(currentSelector == null || ReferenceEquals(currentSelector, selector));        
        return selector;
    }
}

```

###### 6.4.3.1 dynamic controller metadata

```c#
internal class DynamicControllerMetadata : IDynamicEndpointMetadata
{
    public bool IsDynamic => true;    
    public RouteValueDictionary Values { get; }
    
    public DynamicControllerMetadata(RouteValueDictionary values)
    {
        if (values == null)
        {
            throw new ArgumentNullException(nameof(values));
        }
        
        Values = values;
    }        
}

```

###### 6.4.3.2 dynamic controller route value transformer metadata

```c#
internal class DynamicControllerRouteValueTransformerMetadata : IDynamicEndpointMetadata
{
    public bool IsDynamic => true;    
    public Type SelectorType { get; }    
    public object? State { get; }
    
    public DynamicControllerRouteValueTransformerMetadata(Type selectorType, object? state)
    {
        if (selectorType == null)
        {
            throw new ArgumentNullException(nameof(selectorType));
        }        
        if (!typeof(DynamicRouteValueTransformer).IsAssignableFrom(selectorType))
        {
            throw new ArgumentException(
                $"The provided type must be a subclass of {typeof(DynamicRouteValueTransformer)}",
                nameof(selectorType));
        }
        
        SelectorType = selectorType;
        State = state;
    }        
}

```

###### 6.4.3.3 dynamic controller endpoint selector cache

```c#
internal class DynamicControllerEndpointSelectorCache
{
    private readonly ConcurrentDictionary<int, EndpointDataSource> _dataSourceCache = new();
    private readonly ConcurrentDictionary<int, DynamicControllerEndpointSelector> _endpointSelectorCache = new();
            
    public DynamicControllerEndpointSelector GetEndpointSelector(Endpoint endpoint)
    {
        var dataSourceId = endpoint.Metadata
            					 .GetMetadata<ControllerEndpointDataSourceIdMetadata>()!;
        
        return _endpointSelectorCache.GetOrAdd(
            dataSourceId.Id, 
            key => EnsureDataSource(key));
    }
    
    private DynamicControllerEndpointSelector EnsureDataSource(int key)
    {
        if (!_dataSourceCache.TryGetValue(key, out var dataSource))
        {
            throw new InvalidOperationException($"Data source with key '{key}' not registered.");
        }
        
        return new DynamicControllerEndpointSelector(dataSource);
    }
    
    public void AddDataSource(ControllerActionEndpointDataSource dataSource)
    {
        _dataSourceCache.GetOrAdd(dataSource.DataSourceId, dataSource);
    }
    
    // For testing purposes only
    internal void AddDataSource(EndpointDataSource dataSource, int key) =>
        _dataSourceCache.GetOrAdd(key, dataSource);
}

```

###### 6.4.3.4 dynamic controller endpoint selector

```c#
internal class DynamicControllerEndpointSelector : IDisposable
{
    private readonly DataSourceDependentCache<ActionSelectionTable<Endpoint>> _cache;
    private ActionSelectionTable<Endpoint> Table => _cache.EnsureInitialized();
        
    public DynamicControllerEndpointSelector(EndpointDataSource dataSource)
    {
        if (dataSource == null)
        {
            throw new ArgumentNullException(nameof(dataSource));
        }
        
        // 创建 action selection table cache（lazy create）
        _cache = new DataSourceDependentCache<ActionSelectionTable<Endpoint>>(dataSource, Initialize);
    }
    
    // 创建 action selection table 委托
    private static ActionSelectionTable<Endpoint> Initialize(IReadOnlyList<Endpoint> endpoints)
    {
        return ActionSelectionTable<Endpoint>.Create(endpoints);
    }
    
    public IReadOnlyList<Endpoint> SelectEndpoints(RouteValueDictionary values)
    {
        if (values == null)
        {
            throw new ArgumentNullException(nameof(values));
        }
        
        var table = Table;
        var matches = table.Select(values);
        return matches;
    }
            
    public void Dispose()
    {
        _cache.Dispose();
    }
}

```

###### 6.4.3.5 dynamic controller transformer

```c#
public abstract class DynamicRouteValueTransformer
{    
    public object? State { get; set; }
        
    public abstract ValueTask<RouteValueDictionary> TransformAsync(
        HttpContext httpContext, 
        RouteValueDictionary values);        
    
    public virtual ValueTask<IReadOnlyList<Endpoint>> FilterAsync(
        HttpContext httpContext, 
        RouteValueDictionary values, 
        IReadOnlyList<Endpoint> endpoints)
    {
        return new ValueTask<IReadOnlyList<Endpoint>>(endpoints);
    }
}

```



#### 6.5 ext link generator

##### 6.5.1 controller link generator extensions

```c#
public static class ControllerLinkGeneratorExtensions
{    
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetPathByAction(
        this LinkGenerator generator,
        HttpContext httpContext,
        string? action = default,
        string? controller = default,
        object? values = default,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        var address = CreateAddress(httpContext, action, controller, values);
        return generator.GetPathByAddress<RouteValuesAddress>(
            httpContext,
            address,
            address.ExplicitValues,
            address.AmbientValues,
            pathBase,
            fragment,
            options);
    }
       
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetPathByAction(
        this LinkGenerator generator,
        string action,
        string controller,
        object? values = default,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }        
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        var address = CreateAddress(httpContext: null, action, controller, values);
        return generator.GetPathByAddress<RouteValuesAddress>(
            address, 
            address.ExplicitValues, 
            pathBase, 
            fragment, 
            options);
    }
            
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetUriByAction(
        this LinkGenerator generator,
        HttpContext httpContext,
        string? action = default,
        string? controller = default,
        object? values = default,
        string? scheme = default,
        HostString? host = default,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        var address = CreateAddress(httpContext, action, controller, values);
        return generator.GetUriByAddress<RouteValuesAddress>(
            httpContext,
            address,
            address.ExplicitValues,
            address.AmbientValues,
            scheme,
            host,
            pathBase,
            fragment,
            options);
    }
        
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetUriByAction(
        this LinkGenerator generator,
        string action,
        string controller,
        object? values,
        string? scheme,
        HostString host,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }       
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }        
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        var address = CreateAddress(httpContext: null, action, controller, values);
        return generator.GetUriByAddress<RouteValuesAddress>(
            address, 
            address.ExplicitValues, 
            scheme, 
            host, 
            pathBase, 
            fragment, 
            options);
    }

    private static RouteValuesAddress CreateAddress(
        HttpContext? httpContext, 
        string? action, 
        string? controller, 
        object? values)
    {
        var explicitValues = new RouteValueDictionary(values);
        var ambientValues = GetAmbientValues(httpContext);
        
        UrlHelperBase.NormalizeRouteValuesForAction(
            action, 
            controller, 
            explicitValues, 
            ambientValues);
        
        return new RouteValuesAddress()
        {
            AmbientValues = ambientValues,
            ExplicitValues = explicitValues
        };
    }
    
    private static RouteValueDictionary? GetAmbientValues(HttpContext? httpContext)
    {
        return httpContext?.Features?.Get<IRouteValuesFeature>()?.RouteValues;
    }
}

```

##### 6.5.2 page link generator extensions

```c#
public static class PageLinkGeneratorExtensions
{    
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetPathByPage(
        this LinkGenerator generator,
        HttpContext httpContext,
        string? page = default,
        string? handler = default,
        object? values = default,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        var address = CreateAddress(httpContext, page, handler, values);
        return generator.GetPathByAddress<RouteValuesAddress>(
            httpContext,
            address,
            address.ExplicitValues,
            address.AmbientValues,
            pathBase,
            fragment,
            options);
    }

        
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetPathByPage(
        this LinkGenerator generator,
        string page,
        string? handler = default,
        object? values = default,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (page == null)
        {
            throw new ArgumentNullException(nameof(page));
        }
        
        var address = CreateAddress(httpContext: null, page, handler, values);
        return generator.GetPathByAddress(
            address, 
            address.ExplicitValues, 
            pathBase, 
            fragment, 
            options);
    }

    
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetUriByPage(
        this LinkGenerator generator,
        HttpContext httpContext,
        string? page = default,
        string? handler = default,
        object? values = default,
        string? scheme = default,
        HostString? host = default,
        PathString? pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }        
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        var address = CreateAddress(httpContext, page, handler, values);
        return generator.GetUriByAddress<RouteValuesAddress>(
            httpContext,
            address,
            address.ExplicitValues,
            address.AmbientValues,
            scheme,
            host,
            pathBase,
            fragment,
            options);
    }
    
    
    [SuppressMessage(
        "ApiDesign", 
        "RS0026:Do not add multiple public overloads with optional parameters", 
        Justification = "Required to maintain compatibility")]
    public static string? GetUriByPage(
        this LinkGenerator generator,
        string page,
        string? handler,
        object? values,
        string scheme,
        HostString host,
        PathString pathBase = default,
        FragmentString fragment = default,
        LinkOptions? options = default)
    {
        if (generator == null)
        {
            throw new ArgumentNullException(nameof(generator));
        }
        
        if (page == null)
        {
            throw new ArgumentNullException(nameof(page));
        }

        var address = CreateAddress(httpContext: null, page, handler, values);
        return generator.GetUriByAddress<RouteValuesAddress>(
            address, 
            address.ExplicitValues, 
            scheme, 
            host, 
            pathBase, 
            fragment, 
            options);
    }
    
    private static RouteValuesAddress CreateAddress(
        HttpContext? httpContext, 
        string? page, 
        string? handler, 
        object? values)
    {
        var explicitValues = new RouteValueDictionary(values);
        var ambientValues = GetAmbientValues(httpContext);
        
        UrlHelperBase.NormalizeRouteValuesForPage(
            context: null, 
            page, 
            handler, 
            explicitValues, 
            ambientValues);
        
        return new RouteValuesAddress()
        {
            AmbientValues = ambientValues,
            ExplicitValues = explicitValues
        };
    }
    
    private static RouteValueDictionary? GetAmbientValues(HttpContext? httpContext)
    {
        return httpContext?.Features.Get<IRouteValuesFeature>()?.RouteValues;
    }
}

```

##### 6.5.3 url helper base

``` c#
public abstract class UrlHelperBase : IUrlHelper
{
    // Perf: Share the StringBuilder object across multiple calls of GenerateURL for this UrlHelper
    private StringBuilder? _stringBuilder;    
    // Perf: Reuse the RouteValueDictionary across multiple calls of Action for this UrlHelper
    private readonly RouteValueDictionary _routeValueDictionary;
    
    protected RouteValueDictionary AmbientValues { get; }       
    public ActionContext ActionContext { get; }   
    
    public abstract string? Action(UrlActionContext actionContext);       
    public abstract string? RouteUrl(UrlRouteContext routeContext);
    
    protected UrlHelperBase(ActionContext actionContext)
    {
        if (actionContext == null)
        {
            throw new ArgumentNullException(nameof(actionContext));
        }
        
        ActionContext = actionContext;
        AmbientValues = actionContext.RouteData.Values;
        _routeValueDictionary = new RouteValueDictionary();
    }
              
    /// <inheritdoc />
    public virtual bool IsLocalUrl([NotNullWhen(true)] string? url)
    {
        if (string.IsNullOrEmpty(url))
        {
            return false;
        }
        
        // Allows "/" or "/foo" but not "//" or "/\".
        if (url[0] == '/')
        {
            // url is exactly "/"
            if (url.Length == 1)
            {
                return true;
            }
            
            // url doesn't start with "//" or "/\"
            if (url[1] != '/' && url[1] != '\\')
            {
                return !HasControlCharacter(url.AsSpan(1));
            }
            
            return false;
        }
        
        // Allows "~/" or "~/foo" but not "~//" or "~/\".
        if (url[0] == '~' && url.Length > 1 && url[1] == '/')
        {
            // url is exactly "~/"
            if (url.Length == 2)
            {
                return true;
            }
            
            // url doesn't start with "~//" or "~/\"
            if (url[2] != '/' && url[2] != '\\')
            {
                return !HasControlCharacter(url.AsSpan(2));
            }
            
            return false;
        }
        
        return false;
        
        static bool HasControlCharacter(ReadOnlySpan<char> readOnlySpan)
        {
            // URLs may not contain ASCII control characters.
            for (var i = 0; i < readOnlySpan.Length; i++)
            {
                if (char.IsControl(readOnlySpan[i]))
                {
                    return true;
                }
            }
            
            return false;
        }
    }
    
    /// <inheritdoc />
    [return: NotNullIfNotNull("contentPath")]
    public virtual string? Content(string? contentPath)
    {
        if (string.IsNullOrEmpty(contentPath))
        {
            return null;
        }
        else if (contentPath[0] == '~')
        {
            var segment = new PathString(contentPath.Substring(1));
            var applicationPath = ActionContext.HttpContext.Request.PathBase;
            
            var path = applicationPath.Add(segment);
            Debug.Assert(path.HasValue);
            return path.Value;
        }
        
        return contentPath;
    }
    
    /// <inheritdoc />
    public virtual string? Link(string? routeName, object? values)
    {
        return RouteUrl(
            new UrlRouteContext()
            {
                RouteName = routeName,
                Values = values,
                Protocol = ActionContext.HttpContext.Request.Scheme,
                Host = ActionContext.HttpContext.Request.Host.ToUriComponent()
            });
    }
                
    protected RouteValueDictionary GetValuesDictionary(object? values)
    {
        // Perf: RouteValueDictionary can be cast to IDictionary<string, object>, but it is
        // special cased to avoid allocating boxed Enumerator.
        if (values is RouteValueDictionary routeValuesDictionary)
        {
            _routeValueDictionary.Clear();
            foreach (var kvp in routeValuesDictionary)
            {
                _routeValueDictionary.Add(kvp.Key, kvp.Value);
            }
            
            return _routeValueDictionary;
        }
        
        if (values is IDictionary<string, object> dictionaryValues)
        {
            _routeValueDictionary.Clear();
            foreach (var kvp in dictionaryValues)
            {
                _routeValueDictionary.Add(kvp.Key, kvp.Value);
            }
            
            return _routeValueDictionary;
        }
        
        return new RouteValueDictionary(values);
    }
        
    protected string? GenerateUrl(
        string? protocol, 
        string? host, 
        string? virtualPath, 
        string? fragment)
    {
        if (virtualPath == null)
        {
            return null;
        }
        
        // Perf: In most of the common cases, GenerateUrl is called with a null protocol, host and fragment.
        // In such cases, we might not need to build any URL as the url generated is mostly same as the virtual path 
        // available in pathData.
        // For such common cases, this FastGenerateUrl method saves a string allocation per GenerateUrl call.
        if (TryFastGenerateUrl(
	            protocol, 
    	        host, 
        	    virtualPath, 
	            fragment, 
    	        out var url))
        {
            return url;
        }
        
        var builder = GetStringBuilder();
        try
        {
            var pathBase = ActionContext.HttpContext.Request.PathBase;
            
            if (string.IsNullOrEmpty(protocol) && 
                string.IsNullOrEmpty(host))
            {
                AppendPathAndFragment(
                    builder, 
                    pathBase, 
                    virtualPath, 
                    fragment);
                
                // We're returning a partial URL (just path + query + fragment), but we still want it to be rooted.
                if (builder.Length == 0 || builder[0] != '/')
                {
                    builder.Insert(0, '/');
                }
            }
            else
            {
                protocol = string.IsNullOrEmpty(protocol) ? "http" : protocol;
                builder.Append(protocol);
                builder.Append(Uri.SchemeDelimiter);
                
                host = string.IsNullOrEmpty(host) ? ActionContext.HttpContext.Request.Host.Value : host;
                builder.Append(host);
                AppendPathAndFragment(builder, pathBase, virtualPath, fragment);
            }
            
            var path = builder.ToString();
            return path;
        }
        finally
        {
            // Clear the StringBuilder so that it can reused for the next call.
            builder.Clear();
        }
    }
            
    protected string? GenerateUrl(string? protocol, string? host, string? path)
    {
        // This method is similar to GenerateUrl, but it's used for EndpointRouting. It ignores pathbase and fragment
        // because those have already been incorporated.
        if (path == null)
        {
            return null;
        }
        
        // Perf: In most of the common cases, GenerateUrl is called with a null protocol, host and fragment.
        // In such cases, we might not need to build any URL as the url generated is mostly same as the virtual path 
        // available in pathData.
        // For such common cases, this FastGenerateUrl method saves a string allocation per GenerateUrl call.
        if (TryFastGenerateUrl(protocol, host, path, fragment: null, out var url))
        {
            return url;
        }
        
        var builder = GetStringBuilder();
        try
        {
            if (string.IsNullOrEmpty(protocol) && string.IsNullOrEmpty(host))
            {
                AppendPathAndFragment(builder, pathBase: null, path, fragment: null);
                
                // We're returning a partial URL (just path + query + fragment), but we still want it to be rooted.
                if (builder.Length == 0 || builder[0] != '/')
                {
                    builder.Insert(0, '/');
                }
            }
            else
            {
                protocol = string.IsNullOrEmpty(protocol) ? "http" : protocol;
                builder.Append(protocol);                
                builder.Append(Uri.SchemeDelimiter);
                
                host = string.IsNullOrEmpty(host) ? ActionContext.HttpContext.Request.Host.Value : host;
                builder.Append(host);
                AppendPathAndFragment(builder, pathBase: null, path, fragment: null);
            }
            
            return builder.ToString();
        }
        finally
        {
            // Clear the StringBuilder so that it can reused for the next call.
            builder.Clear();
        }
    }
    
    internal static void NormalizeRouteValuesForAction(
            string? action,
            string? controller,
            RouteValueDictionary values,
            RouteValueDictionary? ambientValues)
    {
        object? obj = null;
        if (action == null)
        {
            if (!values.ContainsKey("action") &&
                (ambientValues?.TryGetValue("action", out obj) ?? false))
            {
                values["action"] = obj;
            }
        }
        else
        {
            values["action"] = action;
        }
        
        if (controller == null)
        {
            if (!values.ContainsKey("controller") &&
                (ambientValues?.TryGetValue("controller", out obj) ?? false))
            {
                values["controller"] = obj;
            }
        }
        else
        {
            values["controller"] = controller;
        }
    }
    
    internal static void NormalizeRouteValuesForPage(
        ActionContext? context,
        string? page,
        string? handler,
        RouteValueDictionary values,
        RouteValueDictionary? ambientValues)
    {
        object? value = null;
        if (string.IsNullOrEmpty(page))
        {
            if (!values.ContainsKey("page") &&
                (ambientValues?.TryGetValue("page", out value) ?? false))
            {
                values["page"] = value;
            }
        }
        else
        {
            values["page"] = CalculatePageName(context, ambientValues, page);
        }
        
        if (string.IsNullOrEmpty(handler))
        {
            if (!values.ContainsKey("handler") &&
                (ambientValues?.ContainsKey("handler") ?? false))
            {
                // Clear out form action unless it's explicitly specified in the routeValues.
                values["handler"] = null;
            }
        }
        else
        {
            values["handler"] = handler;
        }
    }
    
    private static object CalculatePageName(
        ActionContext? context, 
        RouteValueDictionary? 
        ambientValues, string pageName)
    {
        Debug.Assert(pageName.Length > 0);
        // Paths not qualified with a leading slash are treated as relative to the current page.
        if (pageName[0] != '/')
        {
            // OK now we should get the best 'normalized' version of the page route value that we can.
            string? currentPagePath;
            if (context != null)
            {
                currentPagePath = NormalizedRouteValue.GetNormalizedRouteValue(context, "page");
            }
            else if (ambientValues != null)
            {
                currentPagePath = Convert.ToString(ambientValues["page"], CultureInfo.InvariantCulture);
            }
            else
            {
                currentPagePath = null;
            }
            
            if (string.IsNullOrEmpty(currentPagePath))
            {
                
                throw new InvalidOperationException(
                    Resources.FormatUrlHelper_RelativePagePathIsNotSupported(
                        pageName,
                        nameof(LinkGenerator),
                        nameof(HttpContext)));
            }
            
            return ViewEnginePath.CombinePath(currentPagePath, pageName);
        }
        
        return pageName;
    }
    
    // for unit testing
    internal static void AppendPathAndFragment(
        StringBuilder builder, 
        PathString pathBase, 
        string virtualPath, 
        string? fragment)
    {
        if (!pathBase.HasValue)
        {
            if (virtualPath.Length == 0)
            {
                builder.Append('/');
            }
            else
            {
                if (!virtualPath.StartsWith('/'))
                {
                    builder.Append('/');
                }
                
                builder.Append(virtualPath);
            }
        }
        else
        {
            if (virtualPath.Length == 0)
            {
                builder.Append(pathBase.Value);
            }
            else
            {
                builder.Append(pathBase.Value);
                
                if (pathBase.Value.EndsWith("/", StringComparison.Ordinal))
                {
                    builder.Length--;
                }
                
                if (!virtualPath.StartsWith("/", StringComparison.Ordinal))
                {
                    builder.Append('/');
                }
                
                builder.Append(virtualPath);
            }
        }
        
        if (!string.IsNullOrEmpty(fragment))
        {
            builder.Append('#').Append(fragment);
        }
    }
    
    private bool TryFastGenerateUrl(
        string? protocol,
        string? host,
        string virtualPath,
        string? fragment,
        [NotNullWhen(true)] out string? url)
    {
        var pathBase = ActionContext.HttpContext.Request.PathBase;
        url = null;
        
        if (string.IsNullOrEmpty(protocol) && 
            string.IsNullOrEmpty(host) && 
            string.IsNullOrEmpty(fragment) && 
            !pathBase.HasValue)
        {
            if (virtualPath.Length == 0)
            {
                url = "/";
                retrn true;
            }
            else if (virtualPath.StartsWith("/", StringComparison.Ordinal))
            {
                url = virtualPath;
                return true;
            }
        }
        
        return false;
    }
    
    private StringBuilder GetStringBuilder()
    {
        if (_stringBuilder == null)
        {
            _stringBuilder = new StringBuilder();
        }
        
        return _stringBuilder;
    }
}

```

###### 6.5.3.1 view engine path

```c#
internal static class ViewEnginePath
{
    public static readonly char[] PathSeparators = new[] { '/', '\\' };
    private const string CurrentDirectoryToken = ".";
    private const string ParentDirectoryToken = "..";
    
    public static string CombinePath(string first, string second)
    {
        Debug.Assert(!string.IsNullOrEmpty(first));
        
        if (second.StartsWith('/'))
        {
            // "second" is already an app-rooted path. Return it as-is.
            return second;
        }
        
        string result;
        
        // Get directory name (including final slash) but do not use Path.GetDirectoryName() to preserve path
        // normalization.
        var index = first.LastIndexOf('/');
        Debug.Assert(index >= 0);
        
        if (index == first.Length - 1)
        {
            // If the first ends in a trailing slash e.g. "/Home/", assume it's a directory.
            result = first + second;
        }
        else
        {
            result = first.Substring(0, index + 1) + second;
        }
        
        return ResolvePath(result);
    }
    
    public static string ResolvePath(string path)
    {
        Debug.Assert(!string.IsNullOrEmpty(path));
        var pathSegment = new StringSegment(path);
        if (path[0] == PathSeparators[0] || path[0] == PathSeparators[1])
        {
            // Leading slashes (e.g. "/Views/Index.cshtml") always generate an empty first token. Ignore these
            // for purposes of resolution.
            pathSegment = pathSegment.Subsegment(1);
        }
        
        var tokenizer = new StringTokenizer(pathSegment, PathSeparators);
        var requiresResolution = false;
        foreach (var segment in tokenizer)
        {
            // Determine if we need to do any path resolution.
            // We need to resolve paths with multiple path separators (e.g "//" or "\\") or, directory traversals e.g. ("../" or "./").
            if (segment.Length == 0 ||
                segment.Equals(ParentDirectoryToken, StringComparison.Ordinal) ||
                segment.Equals(CurrentDirectoryToken, StringComparison.Ordinal))
            {
                requiresResolution = true;
                break;
            }
        }
        
        if (!requiresResolution)
        {
            return path;
        }
        
        var pathSegments = new List<StringSegment>();
        foreach (var segment in tokenizer)
        {
            if (segment.Length == 0)
            {
                // Ignore multiple directory separators
                continue;
            }
            if (segment.Equals(ParentDirectoryToken, StringComparison.Ordinal))
            {
                if (pathSegments.Count == 0)
                {
                    // Don't resolve the path if we ever escape the file system root. We can't reason about it in a
                    // consistent way.
                    return path;
                }
                pathSegments.RemoveAt(pathSegments.Count - 1);
            }
            else if (segment.Equals(CurrentDirectoryToken, StringComparison.Ordinal))
            {
                // We already have the current directory
                continue;
            }
            else
            {
                pathSegments.Add(segment);
            }
        }
        
        var builder = new StringBuilder();
        for (var i = 0; i < pathSegments.Count; i++)
        {
            var segment = pathSegments[i];
            builder.Append('/');
            builder.Append(segment.Buffer, segment.Offset, segment.Length);
        }
        
        return builder.ToString();
    }
}

```

###### 6.5.3.2 normalized route value

```c#
internal static class NormalizedRouteValue
{    
    public static string? GetNormalizedRouteValue(ActionContext context, string key)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }        
        if (key == null)
        {
            throw new ArgumentNullException(nameof(key));
        }        
        if (!context.RouteData.Values.TryGetValue(key, out var routeValue))
        {
            return null;
        }
        
        var actionDescriptor = context.ActionDescriptor;
        string? normalizedValue = null;
        
        if (actionDescriptor.RouteValues
            			   .TryGetValue(key, out var value) &&
            !string.IsNullOrEmpty(value))
        {
            normalizedValue = value;
        }
        
        var stringRouteValue = Convert.ToString(routeValue, CultureInfo.InvariantCulture);
        if (string.Equals(
            	normalizedValue, 
            	stringRouteValue, 
            	StringComparison.OrdinalIgnoreCase))
        {
            return normalizedValue;
        }
        
        return stringRouteValue;
    }
}

```

##### 6.5.4 url helper 实现

###### 6.5.4.1 url helper

```c#
public class UrlHelper : UrlHelperBase
{           
    protected HttpContext HttpContext => ActionContext.HttpContext;
        
    protected IRouter Router
    {
        get
        {
            var routers = ActionContext.RouteData.Routers;
            if (routers.Count == 0)
            {
                throw new InvalidOperationException(
                    "Could not find an IRouter associated with the ActionContext. " + 
                    "If your application is using endpoint routing then you can get a IUrlHelperFactory with "+ 
                    "dependency injection and use it to create a UrlHelper, or use Microsoft.AspNetCore.Routing.LinkGenerator.");
            }
            
            return routers[0];
        }
    }
            
    public UrlHelper(ActionContext actionContext) : base(actionContext)
    {
    }
    
    public override string? Action(UrlActionContext actionContext)
    {
        if (actionContext == null)
        {
            throw new ArgumentNullException(nameof(actionContext));
        }
        
        var valuesDictionary = GetValuesDictionary(actionContext.Values);
        
        NormalizeRouteValuesForAction(
            actionContext.Action, 
            actionContext.Controller, 
            valuesDictionary, AmbientValues);
        
        var virtualPathData = GetVirtualPathData(routeName: null, values: valuesDictionary);
        
        return GenerateUrl(
            actionContext.Protocol, 
            actionContext.Host, 
            virtualPathData, 
            actionContext.Fragment);
    }
        
    public override string? RouteUrl(UrlRouteContext routeContext)
    {
        if (routeContext == null)
        {
            throw new ArgumentNullException(nameof(routeContext));
        }
        
        var valuesDictionary = routeContext.Values as RouteValueDictionary ?? GetValuesDictionary(routeContext.Values);
        var virtualPathData = GetVirtualPathData(routeContext.RouteName, valuesDictionary);
        return GenerateUrl(
            routeContext.Protocol, 
            routeContext.Host, 
            virtualPathData, 
            routeContext.Fragment);
    }
        
    protected virtual VirtualPathData? GetVirtualPathData(string? routeName, RouteValueDictionary values)
    {
        var context = new VirtualPathContext(
            HttpContext, 
            AmbientValues, 
            values, 
            routeName);
        
        return Router.GetVirtualPath(context);
    }
        
    protected virtual string? GenerateUrl(
        string? protocol, 
        string? host, 
        VirtualPathData? pathData, 
        string? fragment)
    {
        return GenerateUrl(
            protocol, 
            host, 
            pathData?.VirtualPath, 
            fragment);
    }
}

```

###### 6.5.4.2 endpoint routing url helper

```c#
internal class EndpointRoutingUrlHelper : UrlHelperBase
{
    private readonly ILogger<EndpointRoutingUrlHelper> _logger;
    private readonly LinkGenerator _linkGenerator;
        
    public EndpointRoutingUrlHelper(
        ActionContext actionContext,
        LinkGenerator linkGenerator,
        ILogger<EndpointRoutingUrlHelper> logger) : base(actionContext)
    {
        if (linkGenerator == null)
        {
            throw new ArgumentNullException(nameof(linkGenerator));
        }        
        if (logger == null)
        {
            throw new ArgumentNullException(nameof(logger));
        }
        
        _linkGenerator = linkGenerator;
        _logger = logger;
    }
    
    /// <inheritdoc />
    public override string? Action(UrlActionContext urlActionContext)
    {
        if (urlActionContext == null)
        {
            throw new ArgumentNullException(nameof(urlActionContext));
        }
        
        var values = GetValuesDictionary(urlActionContext.Values);
        
        if (urlActionContext.Action == null)
        {
            if (!values.ContainsKey("action") &&
                AmbientValues.TryGetValue("action", out var action))
            {
                values["action"] = action;
            }
        }
        else
        {
            values["action"] = urlActionContext.Action;
        }
        
        if (urlActionContext.Controller == null)
        {
            if (!values.ContainsKey("controller") &&
                AmbientValues.TryGetValue("controller", out var controller))
            {
                values["controller"] = controller;
            }
        }
        else
        {
            values["controller"] = urlActionContext.Controller;
        }
                
        var path = _linkGenerator.GetPathByRouteValues(
            ActionContext.HttpContext,
            routeName: null,
            values,
            fragment: urlActionContext.Fragment == null 
            	? FragmentString.Empty 
            	: new FragmentString("#" + urlActionContext.Fragment));
    
        return GenerateUrl(
            urlActionContext.Protocol, 
            urlActionContext.Host, path);
    }
    
    /// <inheritdoc />
    public override string? RouteUrl(UrlRouteContext routeContext)
    {
        if (routeContext == null)
        {
            throw new ArgumentNullException(nameof(routeContext));
        }
        
        var path = _linkGenerator.GetPathByRouteValues(
            ActionContext.HttpContext,
            routeContext.RouteName,
            routeContext.Values,
            fragment: routeContext.Fragment == null 
            	? FragmentString.Empty 
            	: new FragmentString("#" + routeContext.Fragment));
        
        return GenerateUrl(routeContext.Protocol, routeContext.Host, path);
    }
}

```

##### 6.5.5 uri helper factory

```c#
public interface IUrlHelperFactory
{    
    IUrlHelper GetUrlHelper(ActionContext context);
}

public class UrlHelperFactory : IUrlHelperFactory
{
    /// <inheritdoc />
    public IUrlHelper GetUrlHelper(ActionContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        var httpContext = context.HttpContext;
        
        if (httpContext == null)
        {
            throw new ArgumentException(
                Resources.FormatPropertyOfTypeCannotBeNull(
                    nameof(ActionContext.HttpContext),
                    nameof(ActionContext)));
        }
        
        if (httpContext.Items == null)
        {
            throw new ArgumentException(
                Resources.FormatPropertyOfTypeCannotBeNull(
                    nameof(HttpContext.Items),
                    nameof(HttpContext)));
        }
        
        // Perf: Create only one UrlHelper per context
        if (httpContext.Items.TryGetValue(typeof(IUrlHelper), out var value) && value is IUrlHelper urlHelper)
        {
            return urlHelper;
        }
        
        var endpointFeature = httpContext.Features.Get<IEndpointFeature>();
        if (endpointFeature?.Endpoint != null)
        {
            var services = httpContext.RequestServices;
            var linkGenerator = services.GetRequiredService<LinkGenerator>();
            var logger = services.GetRequiredService<ILogger<EndpointRoutingUrlHelper>>();
            
            urlHelper = new EndpointRoutingUrlHelper(
                context,
                linkGenerator,
                logger);
        }
        else
        {
            urlHelper = new UrlHelper(context);
        }
        
        httpContext.Items[typeof(IUrlHelper)] = urlHelper;
        
        return urlHelper;
    }
}

```











#### 4.5 use map

```c#
public static class ControllerEndpointRouteBuilderExtensions
{
    // 确认 mvc 服务已经注册，
    // 如果没有注册，-> 抛出异常
    private static void EnsureControllerServices(IEndpointRouteBuilder endpoints)
    {
        var marker = endpoints.ServiceProvider
            				 .GetService<MvcMarkerService>();
        
        if (marker == null)
        {
            throw new InvalidOperationException(
                Resources.FormatUnableToFindServices(
                    nameof(IServiceCollection),
                    "AddControllers",
                    "ConfigureServices(...)"));
        }
    }
    
    // 获取 controller action endpoint data source
    private static ControllerActionEndpointDataSource GetOrCreateDataSource(
        IEndpointRouteBuilder endpoints)
    {
        // 解析 controller action endpoint data source 服务
        var dataSource = endpoints.DataSources
            					.OfType<ControllerActionEndpointDataSource>()
            					.FirstOrDefault();
        
        // 如果不能解析，
        if (dataSource == null)
        {
            // 解析 ordered endpoint sequence provider cache
            var orderProvider = endpoints.ServiceProvider
                					   .GetRequiredService<OrderedEndpointsSequenceProviderCache>();
            
            // 解析 controller action endpoint data source factory
            var factory = endpoints.ServiceProvider
                				  .GetRequiredService<ControllerActionEndpointDataSourceFactory>();
            
            // 由 ordered endpoint sequence，使用 factory 创建 controller action data source
            dataSource = factory.Create(
                orderProvider.GetOrCreateOrderedEndpointsSequenceProvider(endpoints));
            
            // 将 data source 注入 endpoint route builder 的 data source
            endpoints.DataSources.Add(dataSource);
        }
        
        return dataSource;
    }
}

```

##### 4.5.1 to controller action endpoint convention builder

###### 4.5.1.1 map controllers

```c#
public static class ControllerEndpointRouteBuilderExtensions
{
    public static ControllerActionEndpointConventionBuilder MapControllers(
        this IEndpointRouteBuilder endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        // 确认注册了 controller service 
        EnsureControllerServices(endpoints);
        // 解析 controller action data source 的 default builder
        return GetOrCreateDataSource(endpoints).DefaultBuilder;
    }
}

```

###### 4.5.1.2 map default controller route

```c#
public static class ControllerEndpointRouteBuilderExtensions
{
    public static ControllerActionEndpointConventionBuilder MapDefaultControllerRoute(
        this IEndpointRouteBuilder endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }

        // 确认注册了 controller service 
        EnsureControllerServices(endpoints);
        // 解析 controller action data source
        var dataSource = GetOrCreateDataSource(endpoints);
        // 向 data source 注入 default route - {controller=Home}/{action=Index}/{id?}
        return dataSource.AddRoute(
            "default",
            "{controller=Home}/{action=Index}/{id?}",
            defaults: null,
            constraints: null,
            dataTokens: null);
    }
}

```

###### 4.5.1.3 map controller route

```c#
public static class ControllerEndpointRouteBuilderExtensions
{
    public static ControllerActionEndpointConventionBuilder MapControllerRoute(
        this IEndpointRouteBuilder endpoints,
        string name,
        string pattern,
        object defaults = null,
        object constraints = null,
        object dataTokens = null)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        // 确认已经注册 controller service
        EnsureControllerServices(endpoints);
        // 解析 controller action endpoint data source
        var dataSource = GetOrCreateDataSource(endpoints);
        // 封装 default、constraint、data token，向 data source 注入 传入的 pattern
        return dataSource.AddRoute(
            name,
            pattern,
            new RouteValueDictionary(defaults),
            new RouteValueDictionary(constraints),
            new RouteValueDictionary(dataTokens));
    }
}
```

###### 4.5.1.4 map area controller route

```c#
public static class ControllerEndpointRouteBuilderExtensions
{
    public static ControllerActionEndpointConventionBuilder MapAreaControllerRoute(
        this IEndpointRouteBuilder endpoints,
        string name,
        string areaName,
        string pattern,
        object defaults = null,
        object constraints = null,
        object dataTokens = null)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (string.IsNullOrEmpty(areaName))
        {
            throw new ArgumentException(
                Resources.ArgumentCannotBeNullOrEmpty, 
                nameof(areaName));
        }
        
        // 解析 area 对应的 defaults
        var defaultsDictionary = new RouteValueDictionary(defaults);
        defaultsDictionary["area"] = 
            defaultsDictionary["area"] ?? areaName;
        
        // 解析 area 对应的 constraint
        var constraintsDictionary = new RouteValueDictionary(constraints);
        constraintsDictionary["area"] = 
            constraintsDictionary["area"] ?? new StringRouteConstraint(areaName);
        
        // 调用 map controller route
        return endpoints.MapControllerRoute(
            name, 
            pattern, 
            defaultsDictionary, 
            constraintsDictionary, 
            dataTokens);
    }
}

```

##### 4.5.2 to endpoint conventional builder

###### 4.5.2.1 map fallback to controller

```c#
public static class ControllerEndpointRouteBuilderExtensions
{
    // "MapFallbackToController(IEndpointRouteBuilder, string, string)" is intended to 
    // handle cases where URL path of the request does not contain a file name, and 
    // no other endpoint has matched. 
    // This is convenient for routing requests for dynamic content to a SPA framework, 
    // while also allowing requests for non-existent files to result in an HTTP 404.
    //
    // "MapFallbackToController(IEndpointRouteBuilder, string, string)"/> registers an 
    // endpoint using the pattern {*path:nonfile}. The order of the registered endpoint 
    // will be "int.MaxValue.
    
    public static IEndpointConventionBuilder MapFallbackToController(
        this IEndpointRouteBuilder endpoints,
        string action,
        string controller)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }        
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        EnsureControllerServices(endpoints);

        // Called for side-effect to make sure that the data source is registered.
        var dataSource = GetOrCreateDataSource(endpoints);
        dataSource.CreateInertEndpoints = true;
        RegisterInCache(endpoints.ServiceProvider, dataSource);
        
        // Maps a fallback endpoint with an empty delegate. This is OK because
        // we don't expect the delegate to run.
        var builder = endpoints.MapFallback(context => Task.CompletedTask);
        builder.Add(b =>
                    {
                        // MVC registers a policy that looks for this metadata.
                        b.Metadata.Add(
                            CreateDynamicControllerMetadata(
                                action, 
                                controller, 
                                area: null));
                        b.Metadata.Add(
                            new ControllerEndpointDataSourceIdMetadata(
                                	dataSource.DataSourceId));
                    });
        
        return builder;
    }
    
    public static IEndpointConventionBuilder MapFallbackToController(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        string action,
        string controller)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }        
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }        
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        EnsureControllerServices(endpoints);
        
        // Called for side-effect to make sure that the data source is registered.
        var dataSource = GetOrCreateDataSource(endpoints);
        dataSource.CreateInertEndpoints = true;
        RegisterInCache(endpoints.ServiceProvider, dataSource);
        
        // Maps a fallback endpoint with an empty delegate. This is OK because
        // we don't expect the delegate to run.
        var builder = endpoints.MapFallback(pattern, context => Task.CompletedTask);
        builder.Add(b =>
                    {
                        // MVC registers a policy that looks for this metadata.
                        b.Metadata.Add(
                            CreateDynamicControllerMetadata(
                                action, 
                                controller, 
                                area: null));
                        b.Metadata.Add(
                            new ControllerEndpointDataSourceIdMetadata(
                                	dataSource.DataSourceId));
                    });
        
        return builder;
    }
}
```

###### 4.5.2.2 map fallback to area controller

```c#
public static class ControllerEndpointRouteBuilderExtensions
{
    public static IEndpointConventionBuilder MapFallbackToAreaController(
        this IEndpointRouteBuilder endpoints,
        string action,
        string controller,
        string area)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }        
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        EnsureControllerServices(endpoints);
        
        // Called for side-effect to make sure that the data source is registered.
        var dataSource = GetOrCreateDataSource(endpoints);
        dataSource.CreateInertEndpoints = true;
        RegisterInCache(endpoints.ServiceProvider, dataSource);
        
        // Maps a fallback endpoint with an empty delegate. This is OK because
        // we don't expect the delegate to run.
        var builder = endpoints.MapFallback(context => Task.CompletedTask);
        builder.Add(b =>
                    {
                        // MVC registers a policy that looks for this metadata.
                        b.Metadata.Add(
                            CreateDynamicControllerMetadata(
                                action, 
                                controller, 
                                area));
                        b.Metadata.Add(
                            new ControllerEndpointDataSourceIdMetadata(
                                 	dataSource.DataSourceId));
                    });
        
        return builder;
    }
        
    public static IEndpointConventionBuilder MapFallbackToAreaController(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        string action,
        string controller,
        string area)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }        
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }        
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        EnsureControllerServices(endpoints);
        
        // Called for side-effect to make sure that the data source is registered.
        var dataSource = GetOrCreateDataSource(endpoints);
        dataSource.CreateInertEndpoints = true;
        RegisterInCache(endpoints.ServiceProvider, dataSource);
        
        // Maps a fallback endpoint with an empty delegate. This is OK because
        // we don't expect the delegate to run.
        var builder = endpoints.MapFallback(
            pattern, 
            context => Task.CompletedTask);

        builder.Add(b =>
                    {
                        // MVC registers a policy that looks for this metadata.
                        b.Metadata.Add(
                            CreateDynamicControllerMetadata(
                                action, 
                                controller, 
                                area));
                        b.Metadata.Add(
                            new ControllerEndpointDataSourceIdMetadata(
                                	dataSource.DataSourceId));
                    });
    
        return builder;
    }
                    
    private static DynamicControllerMetadata CreateDynamicControllerMetadata(
        string action, 
        string controller, 
        string area)
    {
        return new DynamicControllerMetadata(
            new RouteValueDictionary()
            {
                { "action", action },
                { "controller", controller },
                { "area", area }
            });
    }                
}

```

##### 4.5.3 map dynamic controller

```c#
public static class ControllerEndpointRouteBuilderExtensions
{
    // This method allows the registration of a "RouteEndpoint" and 
    // "DynamicRouteValueTransformer" that combine to dynamically select a controller 
    // action using custom logic.
    // The instance of "TTransformer" will be retrieved from the dependency injection 
    // container. Register "TTransformer" with the desired service lifetime in 
    // "ConfigureServices".
    
    public static void MapDynamicControllerRoute<TTransformer>(
        this IEndpointRouteBuilder endpoints, 
        string pattern)            
        	where TTransformer : DynamicRouteValueTransformer
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        MapDynamicControllerRoute<TTransformer>(
            endpoints, 
            pattern, 
            state: null);
    }
   
    public static void MapDynamicControllerRoute<TTransformer>(
        this IEndpointRouteBuilder endpoints, 
        string pattern, 
        object state)            
        	where TTransformer : DynamicRouteValueTransformer
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        EnsureControllerServices(endpoints);
        
        // Called for side-effect to make sure that the data source is registered.
        // 解析 controller action endpoint data source
        var controllerDataSource = GetOrCreateDataSource(endpoints);
        // 将 data source 注入 dynamic endpoint selector cache
        RegisterInCache(endpoints.ServiceProvider, controllerDataSource);
        
        // The data source is just used to share the common order with conventionally 
        // routed actions.
        controllerDataSource.AddDynamicControllerEndpoint(
            endpoints, 
            pattern, 
            typeof(TTransformer), 
            state);
    }
        
    public static void MapDynamicControllerRoute<TTransformer>(
        this IEndpointRouteBuilder endpoints, 
        string pattern, 
        object state, 
        int order)            
        	where TTransformer : DynamicRouteValueTransformer
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        EnsureControllerServices(endpoints);
        
        // Called for side-effect to make sure that the data source is registered.
        var controllerDataSource = GetOrCreateDataSource(endpoints);
        RegisterInCache(endpoints.ServiceProvider, controllerDataSource);
        
        // The data source is just used to share the common order with conventionally 
        // routed actions.
        controllerDataSource.AddDynamicControllerEndpoint(
            endpoints, 
            pattern, 
            typeof(TTransformer), 
            state, 
            order);
    }
    
    private static void RegisterInCache(
        IServiceProvider serviceProvider, 
        ControllerActionEndpointDataSource dataSource)
    {
        // 从 service provider 中解析 dynamic controller endpoint selector cache
        var cache = serviceProvider.GetRequiredService<DynamicControllerEndpointSelectorCache>();
        // 向 cache 注入 data source
        cache.AddDataSource(dataSource);
    }
}

```



