## about routing



### 1. about

#### 1.1 router

##### 1.1.1 router 

routing 服务的抽象，封装了 template 或者 pattern，以及对应的钩子（request delegate）；
支持正向路由（route async）和反向路由（get virtual path）方法

*  rout async

  正向路由，即验证 http request 是否匹配 template 或 pattern，实质是通过封装的 template 或者 pattern 来验证（调用 template matcher 或者 pattern matcher ）。如果匹配，执行 router 封装的钩子（委托），如果不匹配，转向其他 router 或者中间件。

  匹配成功后，http request 中的参数将保存到 http context 的 route data 中，用于后续操作，如 mvc 的 model binding 等

* get virtual path

  反向路由，即由 value 反向生成 request path 作为结果，实质是通过封装的 template binder 的 bind value 方法实现

##### 1.1.2 route & router collection

* route ，

  支持组合模式，route 封装具体的 router，是 router 的统一抽象实现

* route handler，

  封装了执行操作的 request delegate，内嵌于 route

* route collection 

  route 中的 template 或者 pattern 使得 route 只能匹配特定的 http request：
  封装了具体 route 集合，通过遍历 route 集合调用对应的 route async 和 get virtual path 方法

* null router

  空实现，可用于 default

##### 1.1.3 route builder

创建 route

因为 route 是组合模式，route 创建 router collection 作为结果，可以向其中注入多个 route

* map route (with template)，通过 route template 注入（创建内嵌的）route，没有指定内嵌的 route handler，使用 default
* map route (with request delegate)，通过 route template 和 request delegate 注入（创建内嵌的）route
* map verb，创建内嵌 route 时注入了 http method constraint

#### 1.2 tree router

tree router 本质上也是 router，支持正向路由（route async）和反向路由（get virtual path）。它通过 tree 存储、查找 route template，从而实现路由功能

##### 1.2.1 url matching tree

执行正向路由（route async）时使用的 tree，它存储路由数据模型 inbound match

* inbound match

  inbound match 是 tree router 使用的抽象，类似 key-value-pair，它封装了路由数据模型 inbound match entry（如模板、constraint等，内嵌的 router 用于执行钩子 等），和对应的 template matcher。

  作为节点数据，它被存储在 url matching tree 上，因为整个 url matching tree 可以存储全部路由数据，类似 route collection 

* url matching node

  url matching tree 节点模型，封装了该 node 的 inbound match 集合、子节点引用集合等，从而存储了全部路由数据和它们的相互关系，从而可以找到 http request 匹配的路由

* tree enumerator

  url matching tree 的遍历器，通过遍历 url matching tree 的 url matching node，调用node 的 matches（inbound match 集合）中的 template matcher 验证 http request。如果验证成功，调用 inbound match 中封装的 router 的钩子

##### 1.2.2 link generation tree

执行反向路由（get virtual path）时使用的 tree，它存储路由数据模型 outbound match

* outbound match

  outbound match 是 link generator tree 使用的抽象，类似 key-value-pair，它封装了路由数据模型 outbound match entry（如模板、constraint等，内嵌的router？），和对应的 template binder。

  作为节点数据，它被存储在 link generation tree 上，因为整个 link generation tree 可以存储全部路由数据

* decision tree node

  link generation tree 继承自 decision tree，decision tree node 是它的节点模型，封装了该 node 的 outbound match 集合 和 decision criterion 集合，接其他 node 的引用集合，从而存储了全部路由数据和他们的相互关系，从而匹配（创建）适合 value 的 path

* get matches 方法

  对标于 (url matching) tree enumerator，get matches 方法可以从 link generation tree 中查找到匹配的 outbound match，进而使用这些 outbound match 的 template binder 创建 virtual path

##### 1.2.3 tree router

router 的派生类型，封装了 url matching tree 和 link generation tree，用于实现路由方法

* route async 方法，

  遍历 url matching tree，遍历 url matching node 的 inbound match 集合，使用 inbound match 封装的 template matcher验证匹配，注入结果（route data）

* get virtual path 方法，

  通过 link generation tree 获取符合注入的 value、ambient value 的 outbound match 集合，遍历 match 集合，调用其封装的 template binder 方法，注入结果

##### 1.2.4 tree router builder

tree router 构造器，用于生成 url matching tree 和 link generation tree

* 注入 inbound match，

  用于注册 route async 方法使用的 inbound match

* 注入 outbound match，

  用于注入 get virtual path 方法使用的 outbound match

* build，

  创建 url matching tree 并注入 url matching tree 集合；没有创建 link generation tree？？

##### 1.2.5 使用 tree router

在`AddRouting()`方法中注册了 tree router 的组件，因为 tree router 实现了 IRouter 接口，在`useRouter()`方法配置到了请求管道。

具体使用在 mvc 中？？

#### 1.3 endpoint routing

##### 1.3.1 endpoint

* 终结点，类似 terminal middleware，最后的 middleware，http request 将在此处理后返回 response 到请求管道，包含：
  * request delegate，执行钩子
  * metadata collection，一些数据

* 通过`endpoint feature`可以在 http context 中解析、设置 endpoint
* endpoint 构建
  * endpoint builder，构建器
  * endpoint conventional builder，包含配置 endpoint builder 的 action 集合的构建器

* endpoint data source 是 endpoint 集合，派生出多种 data source 
  * default endpoint data source，直接存储 data source 集合

  * model endpoint data source，存储 endpoint conventional builder 集合，由 builder 创建 endpoint

  * composite endpoint data source，即存储 data source，又存储 conventional builder

##### 1.3.2 (dfa) matcher

用于验证 http request 是否匹配的服务，对外提供 match 方法，内部使用 dfa 算法

* dfa 相关

  dfa node (tree)、dfa state、jump table

* endpoint selector

  根据 endpoint selector policy 从 candidate 中验证、挑选 endpoint

##### 1.3.3 (dfa) matcher 创建

* dfa matcher builder，注入 endpoint、创建 dfa node (tree root) 并挂载 endpoint
* dfa matcher factory，从 services 中解析 dfa matcher builder 并 build

##### 1.3.3 link generator

用于创建 virtual path（反向路由）



### 2. router routing

#### 2.1 router 抽象

##### 2.1.1 接口

```c#
public interface IRouter
{    
    Task RouteAsync(RouteContext context);        
    VirtualPathData? GetVirtualPath(VirtualPathContext context);
}

public interface INamedRouter : IRouter
{    
    string? Name { get; }
}

```

###### 2.1.1.1 route context

```c#
public class RouteContext
{
    private RouteData _routeData;
    public RouteData RouteData
    {
        get
        {
            return _routeData;
        }
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(RouteData));
            }
            
            _routeData = value;
        }
    }
    
    public HttpContext HttpContext { get; }
    public RequestDelegate? Handler { get; set; }
                    
    public RouteContext(HttpContext httpContext)
    {
        HttpContext = httpContext 
            ?? throw new ArgumentNullException(nameof(httpContext));     
        RouteData = new RouteData();
    }            
}

```

###### 2.1.1.2 route data

```c#
public class RouteData
{
    private RouteValueDictionary? _dataTokens;
    public RouteValueDictionary DataTokens
    {
        get
        {
            if (_dataTokens == null)
            {
                _dataTokens = new RouteValueDictionary();
            }
            
            return _dataTokens;
        }
    }
    
    private List<IRouter>? _routers;
    public IList<IRouter> Routers
    {
        get
        {
            if (_routers == null)
            {
                _routers = new List<IRouter>();
            }
            
            return _routers;
        }
    }
    
    private RouteValueDictionary? _values;
    public RouteValueDictionary Values
    {
        get
        {
            if (_values == null)
            {
                _values = new RouteValueDictionary();
            }
            
            return _values;
        }
    }
                    
    public RouteData()
    {
        // Perf: Avoid allocating collections unless needed.
    }
            
    public RouteData(RouteData other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        // Perf: Avoid allocating collections unless we need to make a copy.
        
        if (other._routers != null)
        {
            _routers = new List<IRouter>(other.Routers);
        }        
        if (other._dataTokens != null)
        {
            _dataTokens = new RouteValueDictionary(other._dataTokens);
        }        
        if (other._values != null)
        {
            _values = new RouteValueDictionary(other._values);
        }
    }

    public RouteData(RouteValueDictionary values)
    {
        if (values == null)
        {
            throw new ArgumentNullException(nameof(values));
        }
        
        _values = values;
    }
        
    public RouteDataSnapshot PushState(
        IRouter? router, 
        RouteValueDictionary? values, 
        RouteValueDictionary? dataTokens)
    {
        /* 克隆 routers 集合 */
        // Perf: this is optimized for small list sizes, in particular to avoid overhead 
        // of a native call in Array.CopyTo inside the List(IEnumerable<T>) constructor.       
        List<IRouter>? routers = null;
        var count = _routers?.Count;
        if (count > 0)
        {
            Debug.Assert(_routers != null);
            
            routers = new List<IRouter>(count.Value);
            for (var i = 0; i < count.Value; i++)
            {
                routers.Add(_routers[i]);
            }
        }
        
        /* 将原有 route data 创建 snapshot */
        var snapshot = new RouteDataSnapshot(
            this,
            _dataTokens?.Count > 0 ? new RouteValueDictionary(_dataTokens) : null, 
            routers,
            _values?.Count > 0 ? new RouteValueDictionary(_values) : null);
        
        // 注入新的 router
        if (router != null)
        {
            Routers.Add(router);
        }
        // 注入新的 values
        if (values != null)
        {
            foreach (var kvp in values)
            {
                if (kvp.Value != null)
                {
                    Values[kvp.Key] = kvp.Value;
                }
            }
        }
        // 注入新的 data token
        if (dataTokens != null)
        {
            foreach (var kvp in dataTokens)
            {
                DataTokens[kvp.Key] = kvp.Value;
            }
        }
        
        return snapshot;
    }
    
    // snap shot 结构体
    public readonly struct RouteDataSnapshot
    {
        private readonly RouteData _routeData;
        private readonly RouteValueDictionary? _dataTokens;
        private readonly IList<IRouter>? _routers;
        private readonly RouteValueDictionary? _values;
                
        public RouteDataSnapshot(
            RouteData routeData,
            RouteValueDictionary? dataTokens,
            IList<IRouter>? routers,
            RouteValueDictionary? values)
        {
            if (routeData == null)
            {
                throw new ArgumentNullException(nameof(routeData));
            }
            
            _routeData = routeData;
            _dataTokens = dataTokens;
            _routers = routers;
            _values = values;
        }
        
        // 恢复，
        // _datatoken、_routes、_values 注入 _routedata
        public void Restore()
        {
            /* data tokens */
            
            if (_routeData._dataTokens == null && 
                _dataTokens == null)
            {
                // Do nothing
            }
            else if (_dataTokens == null)
            {
                _routeData._dataTokens!.Clear();
            }
            else
            {
                _routeData._dataTokens!.Clear();
                
                foreach (var kvp in _dataTokens)
                {
                    _routeData._dataTokens
                        	  .Add(kvp.Key, kvp.Value);
                }
            }
            
            /* routers */
            
            if (_routeData._routers == null 
                && _routers == null)
            {
                // Do nothing
            }
            else if (_routers == null)
            {
                // Perf: this is optimized for small list sizes, in particular to avoid 
                // overhead of a native call in Array.Clear inside the List.Clear() method.
                var routers = _routeData._routers!;
                for (var i = routers.Count - 1; i >= 0 ; i--)
                {
                    routers.RemoveAt(i);
                }
            }
            else
            {
                // Perf: this is optimized for small list sizes, in particular to avoid 
                // overhead of a native call in Array.Clear inside the List.Clear() method.  
                //
                // We want to basically copy the contents of _routers in
                // _routeData._routers - this change does that with the minimal number of 
                // reads/writes and without calling Clear().
                var routers = _routeData._routers!;
                var snapshotRouters = _routers;
                
                // This is made more complicated by the fact that List[int] throws if 
                // i == Count, so we have to do two loops and call Add for those cases.
                var i = 0;
                for (; i < snapshotRouters.Count && 
                     i < routers.Count; i++)
                {
                    routers[i] = snapshotRouters[i];
                }
                
                for (; i < snapshotRouters.Count; i++)
                {
                    routers.Add(snapshotRouters[i]);
                }
                
                // Trim excess - again avoiding RemoveRange because it uses native methods.
                for (i = routers.Count - 1; i >= snapshotRouters.Count; i--)
                {
                    routers.RemoveAt(i);
                }
            }
            
            /* values */
            
            if (_routeData._values == null && 
                _values == null)
            {
                // Do nothing
            }
            else if (_values == null)
            {
                _routeData._values!.Clear();
            }
            else
            {
                _routeData._values!.Clear();
                
                foreach (var kvp in _values)
                {
                    _routeData._values
                        	  .Add(kvp.Key, kvp.Value);
                }
            }
        }
    }
}

```

###### 2.1.1.3 virtual path context

```c#
public class VirtualPathContext
{
    public RouteValueDictionary AmbientValues { get; }        
    public HttpContext HttpContext { get; }        
    public string? RouteName { get; }        
    public RouteValueDictionary Values { get; set; }
       
    public VirtualPathContext(
        HttpContext httpContext,
        RouteValueDictionary ambientValues,
        RouteValueDictionary values)
            : this(httpContext, ambientValues, values, null)
    {
    }
        
    public VirtualPathContext(
        HttpContext httpContext,
        RouteValueDictionary ambientValues,
        RouteValueDictionary values,
        string? routeName)
    {
        HttpContext = httpContext;
        AmbientValues = ambientValues;
        Values = values;
        RouteName = routeName;
    }               
}

```

###### 2.1.1.4 virtual path data

```c#
public class VirtualPathData
{        
    /* data token */
    private RouteValueDictionary _dataTokens;
    public RouteValueDictionary DataTokens
    {
        get
        {
            if (_dataTokens == null)
            {
                _dataTokens = new RouteValueDictionary();
            }
            
            return _dataTokens;
        }
    }
    
    /* virtual path */
    private string _virtualPath;
    public string VirtualPath
    {
        get
        {
            return _virtualPath;
        }
        set
        {
            _virtualPath = NormalizePath(value);
        }
    }    
    
    public IRouter Router { get; set; }
                
    public VirtualPathData(IRouter router, string virtualPath)
        : this(router, virtualPath, dataTokens: null)
    {
    }
        
    public VirtualPathData(
        IRouter router,
        string virtualPath,
        RouteValueDictionary dataTokens)
    {
        if (router == null)
        {
            throw new ArgumentNullException(nameof(router));
        }
        
        Router = router;
        VirtualPath = virtualPath;
        _dataTokens = dataTokens == null 
            			  ? null 
            			  : new RouteValueDictionary(dataTokens);
    }      
    
    // 加上“/”
    private static string NormalizePath(string path)
    {
        if (string.IsNullOrEmpty(path))
        {
            return string.Empty;
        }
        
        if (!path.StartsWith("/", StringComparison.Ordinal))
        {
            return "/" + path;
        }
        
        return path;
    }
}

```

##### 2.1.2 routing data in http context

###### 2.1.2.1 routing feature

```c#
public interface IRoutingFeature
{        
    RouteData? RouteData { get; set; }
}

public class RoutingFeature : IRoutingFeature
{
    /// <inheritdoc />
    public RouteData? RouteData { get; set; }
}

```

###### 2.1.2.2 in http context

```c#
public static class RoutingHttpContextExtensions
{    
    public static RouteData GetRouteData(this HttpContext httpContext)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        var routingFeature = httpContext.Features.Get<IRoutingFeature>();
        return routingFeature?.RouteData ?? new RouteData(httpContext.Request.RouteValues);
    }
            
    public static object? GetRouteValue(this HttpContext httpContext, string key)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        if (key == null)
        {
            throw new ArgumentNullException(nameof(key));
        }
        
        return httpContext.Features.Get<IRouteValuesFeature>()?.RouteValues[key];
    }
}

```

#### 2.2 routers

##### 2.2.1 router base

```c#
public abstract class RouteBase : IRouter, INamedRouter
{
    private readonly object _loggersLock = new object();
    
    // 匹配 request -> template
    private TemplateMatcher? _matcher;
    // 匹配 template -> virtual path
    private TemplateBinder? _binder;
    
    private ILogger? _logger;
    private ILogger? _constraintLogger;
           
    // name
    public virtual string? Name { get; protected set; }
    
    public virtual IDictionary<string, IRouteConstraint> Constraints { get; protected set; } 
    protected virtual IInlineConstraintResolver ConstraintResolver { get; set; }
    
    public virtual RouteValueDictionary DataTokens { get; protected set; }        
    public virtual RouteValueDictionary Defaults { get; protected set; }
           
    public virtual RouteTemplate ParsedTemplate { get; protected set; }
    
    /* 构造函数 */    
    public RouteBase(
        string? template,
        string? name,
        IInlineConstraintResolver constraintResolver,
        RouteValueDictionary? defaults,
        IDictionary<string, object>? constraints,
        RouteValueDictionary? dataTokens)
    {       
        if (constraintResolver == null)
        {
            throw new ArgumentNullException(nameof(constraintResolver));
        }
        
        // 注入 template string，如果是 null，转为 string.empty
        template = template ?? string.Empty;
        
        Name = name;                
        ConstraintResolver = constraintResolver;                
        DataTokens = dataTokens ?? new RouteValueDictionary();
        
        try
        {
            /* 1- 解析 route template，
               	  使用 template parser 从 template string 解析 route template */
            // Data we parse from the template will be used 
            // to fill in the rest of the constraints or defaults. 
            // The parser will throw for invalid routes.
            ParsedTemplate = TemplateParser.Parse(template);
            
            /* 2- 解析 route constraint，
                  使用 inline constraint resolver 从 route template 解析 route constraint */   
            Constraints = GetConstraints(
                			  constraintResolver, 
			                  ParsedTemplate, 
              				  constraints);
            
            /* 3- 获取 parameter 的 default value， 
            	  从 route template 解析 default value */            	  
            Defaults = GetDefaults(ParsedTemplate, defaults);
            
        }
        catch (Exception exception)
        {
            throw new RouteCreationException(
                Resources.FormatTemplateRoute_Exception(name, template), 
                exception);
        }
    }
                 
    /// <inheritdoc />
    public override string ToString()
    {
        return ParsedTemplate.TemplateText!;
    }
    
    [MemberNotNull(nameof(_logger), nameof(_constraintLogger))]
    private void EnsureLoggers(HttpContext context)
    {
        // We check first using the _logger to see 
        // if the loggers have been initialized to avoid taking
        // the lock on the most common case.
        if (_logger == null)
        {
            // We need to lock here to ensure that _constraintLogger 
            // and _logger get initialized atomically.
            lock (_loggersLock)
            {
                if (_logger != null)
                {
                    // Multiple threads might have tried to acquire 
                    // the lock at the same time. 
                    // Technically there is nothing wrong if things 
                    // get reinitialized by a second thread, 
                    // but its easy to prevent by just rechecking and returning here.
                    Debug.Assert(_constraintLogger != null);
                    
                    return;
                }
                
                // 解析 logger factory
                var factory = context.RequestServices
                    				 .GetRequiredService<ILoggerFactory>();
                
                // 创建 constraint logger
                _constraintLogger = 
                    factory.CreateLogger(typeof(RouteConstraintMatcher).FullName!);
                
                // 创建 logger
                _logger = factory.CreateLogger(typeof(RouteBase).FullName!);
            }            
        }
        
        Debug.Assert(_constraintLogger != null);
    }
}

```

###### 2.2.1.1 get constraint

```c#
public abstract class RouteBase : IRouter, INamedRouter
{
    protected static IDictionary<string, IRouteConstraint> GetConstraints(
        IInlineConstraintResolver inlineConstraintResolver,
        RouteTemplate parsedTemplate,
        IDictionary<string, object>? constraints)
    {
        // 创建 route constraint builder
        var constraintBuilder = new RouteConstraintBuilder(
            inlineConstraintResolver, 
            parsedTemplate.TemplateText!);
        
        // 将（传入的） constraints 注入constraint builder
        if (constraints != null)
        {
            foreach (var kvp in constraints)                
            {
                constraintBuilder.AddConstraint(kvp.Key, kvp.Value);
            }
        }
                
        // 遍历（传入的）route template 的 parameter part，
        foreach (var parameter in parsedTemplate.Parameters)
        {
            // 如果 parameter part 是 optional，标记
            if (parameter.IsOptional)
            {
                constraintBuilder.SetOptional(parameter.Name!);
            }
            // 遍历 parameter part 所有 inline constraint， 注入 constraint builder
            foreach (var inlineConstraint in parameter.InlineConstraints)
            {
                constraintBuilder.AddResolvedConstraint(
                    parameter.Name!, 
                    inlineConstraint.Constraint);
            }
        }
        
        // 构建 constraints dictionary
        return constraintBuilder.Build();
    }
}

```

###### 2.2.1.2 get defaults

```c#
public abstract class RouteBase : IRouter, INamedRouter
{
     protected static RouteValueDictionary GetDefaults(
        RouteTemplate parsedTemplate,
        RouteValueDictionary? defaults)
    {
        // 预结果，创建或者克隆（传入的）defaults
        var result = defaults == null 
            		 	? new RouteValueDictionary() 
			            : new RouteValueDictionary(defaults);
        
        // 遍历（传入的）route template 的 parameter part
        foreach (var parameter in parsedTemplate.Parameters)
        {
            // 如果 parameter part 的 default value 不为 null，注入 result
            if (parameter.DefaultValue != null)
            {
#if RVD_TryAdd
    			if (!result.TryAdd(
                    	parameter.Name, 
                    	parameter.DefaultValue))
                {
                    throw new InvalidOperationException(
                        Resources.FormatTemplateRoute
		                          _CannotHaveDefaultValueSpecifiedInlineAndExplicitly(
                                      parameter.Name));
                }
#else
                if (result.ContainsKey(parameter.Name!))
                {
                    throw new InvalidOperationException(
                        Resources.FormatTemplateRoute
                        		 _CannotHaveDefaultValueSpecifiedInlineAndExplicitly(
                                     parameter.Name));
                }
                else
                {
                    result.Add(
                        	   parameter.Name!, 
		                       parameter.DefaultValue);
                }
#endif
            }
        }
                
        return result;
    }                                
}

```

###### 2.2.1.3 接口方法 - route async

```c#
public abstract class RouteBase : IRouter, INamedRouter
{
    public virtual Task RouteAsync(RouteContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        // a- 确认 template matcher 不为 null（创建）
        EnsureMatcher();
        
        // 确认 logger 不为 null       
        EnsureLoggers(context.HttpContext);
                        
        // 从 http context 中解析 request path，
        var requestPath = context.HttpContext.Request.Path;     
        
        // 使用 template matche 验证 request path，不匹配 -> 结束
        if (!_matcher.TryMatch(
            	requestPath, 
            	context.RouteData.Values))
        {
            // If we got back a null value set, that means the URI did not match
            return Task.CompletedTask;
        }
        
        // b- 合并（额外的）data token
        // Perf: Avoid accessing dictionaries if you don't need to write to them, 
        // these dictionaries are all created lazily.
        if (DataTokens.Count > 0)
        {
            MergeValues(
                context.RouteData.DataTokens, 
                DataTokens);
        }
                
        // 使用 constraint matcher 验证，如果不匹配 -> 结束
        if (!RouteConstraintMatcher.Match(
	            Constraints,        
    	        context.RouteData.Values,
        	    context.HttpContext,
            	this,
            	RouteDirection.IncomingRequest,
            	_constraintLogger))
        {
            return Task.CompletedTask;
        }
        
        /* request path（http context 解析得到）匹配 route template 和  route constrain，*/
        
        // 记录日志
        _logger.RequestMatchedRoute(Name!, ParsedTemplate.TemplateText!);        
        // 触发 on route matched 钩子
        return OnRouteMatched(context);
    }
    
    // a- 由 route template（解析得到）创建 template matcher
    [MemberNotNull(nameof(_matcher))]
    private void EnsureMatcher()
    {
        if (_matcher == null)
        {
            _matcher = new TemplateMatcher(ParsedTemplate, Defaults);
        }
    }
    
    // b- 合并传入的 data token
    private static void MergeValues(
        RouteValueDictionary destination,
        RouteValueDictionary values)
    {
        foreach (var kvp in values)
        {
            // This will replace the original value for the specified key.
            // Values from the matched route will take preference over previous
            // data in the route context.
            destination[kvp.Key] = kvp.Value;
        }
    }
    
    // on route matched 钩子
    protected abstract Task OnRouteMatched(RouteContext context);        
}

```

###### 2.2.1.4 接口方法 - get virtual path

```c#
public abstract class RouteBase : IRouter, INamedRouter
{
    public virtual VirtualPathData? GetVirtualPath(VirtualPathContext context)
    {
        // a- 确认 template binder 不为 null（创建）
        EnsureBinder(context.HttpContext);
        
        // 确认 logger 不为 null
        EnsureLoggers(context.HttpContext);
        
        // 使用 template binder 解析 template value result，
        var values = _binder.GetValues(
            					context.AmbientValues, 
					            context.Values);
        // 不能解析，返回 null
        if (values == null)
        {
            // We're missing one of the required values for this route.
            return null;
        }
                        
        // 使用 constraint matcher 验证 template value result 的 combined values，
        // 如果不匹配，返回 null
        if (!RouteConstraintMatcher.Match(
            	Constraints,
	            values.CombinedValues,
    	        context.HttpContext,
        	    this,
            	RouteDirection.UrlGeneration,
            	_constraintLogger))
        {
            return null;
        }
                
        // （通过 constraint 验证），
        // 将 template value result 的 combined values 注入到 virtual path context
        context.Values = values.CombinedValues;   
        
        // b- 使用 on virtual path generated 钩子创建 virtual path data
        var pathData = OnVirtualPathGenerated(context);
        // 如果创建成功，返回结果
        if (pathData != null)
        {
            // If the target generates a value then that can short circuit.
            return pathData;
        }
        
        /* 不能由 on virtual path generated 钩子创建 virtual path data，*/
        
        // 使用 template binder 将 template value result 绑定到 virtual path string
        var virtualPath = _binder.BindValues(values.AcceptedValues);
        // 如果不能绑定，返回 null
        if (virtualPath == null)
        {
            return null;
        }
        // 由 virtual path string 创建 virtual path data        
        pathData = new VirtualPathData(this, virtualPath);
        
        // 注入传入的 data token
        if (DataTokens != null)
        {
            foreach (var dataToken in DataTokens)
            {
                pathData.DataTokens
                    	.Add(dataToken.Key, dataToken.Value);
            }
        }
        
        return pathData;
    }
    
    // a- 使用 template binder factory（从 service provider 中解析），
    //	  由 route template（解析得到）创建 template binder    
    [MemberNotNull(nameof(_binder))]
    private void EnsureBinder(HttpContext context)
    {
        if (_binder == null)
        {
            var binderFactory = context
                .RequestServices
                .GetRequiredService<TemplateBinderFactory>();
            
            _binder = binderFactory.Create(ParsedTemplate, Defaults);
        }
    }
    
    // b- virtual path generated 钩子，由派生类实现
    protected abstract VirtualPathData? 
        OnVirtualPathGenerated(VirtualPathContext context);
}

```

##### 2.2.2 route

* router 的统一表示，封装具体执行操作的 router

```c#
public class Route : RouteBase
{
    private readonly IRouter _target;
    public string? RouteTemplate => ParsedTemplate.TemplateText;
    
    public Route(
        IRouter target,
        string routeTemplate,
        IInlineConstraintResolver inlineConstraintResolver)
        	: this(
                target,
                routeTemplate,
                defaults: null,
                constraints: null,
                dataTokens: null,
                inlineConstraintResolver: inlineConstraintResolver)
    {
    }
        
    public Route(
        IRouter target,
        string routeTemplate,
        RouteValueDictionary? defaults,
        IDictionary<string, object>? constraints,
        RouteValueDictionary? dataTokens,
        IInlineConstraintResolver inlineConstraintResolver)
            : this(
                target, 
                null, 
                routeTemplate, 
                defaults, 
                constraints, 
                dataTokens, 
                inlineConstraintResolver)
    {
    }
       
    public Route(
        IRouter target,
        string? routeName,
        string? routeTemplate,
        RouteValueDictionary? defaults,
        IDictionary<string, object>? constraints,
        RouteValueDictionary? dataTokens,
        IInlineConstraintResolver inlineConstraintResolver)
            : base(
                  routeTemplate,
                  routeName,
                  inlineConstraintResolver,
                  defaults,
                  constraints,
                  dataTokens)
    {
        if (target == null)
        {
            throw new ArgumentNullException(nameof(target));
        }
                
        _target = target;
    }
                
    /// <inheritdoc />
    protected override Task OnRouteMatched(RouteContext context)
    {
        context.RouteData.Routers.Add(_target);
        return _target.RouteAsync(context);
    }
    
    /// <inheritdoc />
    protected override VirtualPathData? OnVirtualPathGenerated(VirtualPathContext context)
    {
        return _target.GetVirtualPath(context);
    }
}

```



##### 2.2.3 route handler

###### 2.2.3.1 扩展接口

```c#
public interface IRouteHandler
{
    RequestDelegate GetRequestHandler(
        HttpContext httpContext, 
        RouteData routeData);
}

```

###### 2.2.3.2 route handler

```c#
public class RouteHandler : IRouteHandler, IRouter
{
    private readonly RequestDelegate _requestDelegate;        
    public RouteHandler(RequestDelegate requestDelegate)
    {
        _requestDelegate = requestDelegate;
    }
    
    /// <inheritdoc />
    public RequestDelegate GetRequestHandler(
        HttpContext httpContext, 
        RouteData routeData)
    {
        return _requestDelegate;
    }
    
    /// <inheritdoc />
    public VirtualPathData? GetVirtualPath(VirtualPathContext context)
    {
        // Nothing to do.
        return null;
    }
    
    /// <inheritdoc />
    public Task RouteAsync(RouteContext context)
    {
        context.Handler = _requestDelegate;
        return Task.CompletedTask;
    }
}

```

##### 2.2.4 router collection

###### 2.2.4.1 接口

```c#
public interface IRouteCollection : IRouter
{    
    void Add(IRouter router);
}

```

###### 2.2.4.2 router collection

```c#
public class RouteCollection : IRouteCollection
{
    private readonly static char[] UrlQueryDelimiters = new char[] { '?', '#' };
    
    private readonly List<IRouter> _routes = new List<IRouter>();    
    private readonly List<IRouter> _unnamedRoutes = new List<IRouter>();
    private readonly Dictionary<string, INamedRouter> _namedRoutes =
        new Dictionary<string, INamedRouter>(StringComparer.OrdinalIgnoreCase);
    
    private RouteOptions? _options;
                           
    public int Count
    {
        get { return _routes.Count; }
    }        
    
    public IRouter this[int index]
    {
        get { return _routes[index]; }
    }                
    
    // 解析 route options
    [MemberNotNull(nameof(_options))]
    private void EnsureOptions(HttpContext context)
    {
        if (_options == null)
        {
            _options = context.RequestServices
                			  .GetRequiredService<IOptions<RouteOptions>>()
                			  .Value;
        }
    }                
}

```

###### 2.2.4.3 接口方法 - route async

```c#
public class RouteCollection : IRouteCollection
{    
    public async virtual Task RouteAsync(RouteContext context)
    {
        // Perf: We want to avoid allocating a new RouteData for each route we 
        // need to process.
        // We can do this by snapshotting the state at the beginning and then restoring 
        // it for each router we execute.
        var snapshot = context.RouteData.PushState(null, values: null, dataTokens: null);
        
        // 遍历 route 集合，
        for (var i = 0; i < Count; i++)
        {
            // 将 route 注入 route context
            var route = this[i];
            context.RouteData
                   .Routers
                   .Add(route);
            
            try
            {
                // 执行 route 的 route async 方法
                await route.RouteAsync(context);                
                // 如果执行结果不为 null，结束
                if (context.Handler != null)
                {
                    break;
                }
            }
            finally
            {
                if (context.Handler == null)
                {
                    snapshot.Restore();
                }
            }
        }
    }
}

```

###### 2.2.4.4 接口方法 - get virtual path

```c#
public class RouteCollection : IRouteCollection
{
    /// <inheritdoc />
    public virtual VirtualPathData? GetVirtualPath(VirtualPathContext context)
    {
        // 解析 route options 
        EnsureOptions(context.HttpContext);
        
        /* 如果 virtual path context 中 route name 不为空  */
        if (!string.IsNullOrEmpty(context.RouteName))
        {
            // 预结果
            VirtualPathData? namedRoutePathData = null;
            
            // 从 named route 集合中找到匹配的 router，
            if (_namedRoutes.TryGetValue(
                				context.RouteName, 
                				out var matchedNamedRoute))
            {
                // 如果能找到，使用 route 解析 virtual path data
                namedRoutePathData = matchedNamedRoute.GetVirtualPath(context);
            }
            
            // a- 从 unamed route 集合中解析 virtual path data
            var pathData = GetVirtualPath(context, _unnamedRoutes);
                        
            // If the named route and one of the unnamed routes also matches, 
            // then we have an ambiguity.
            
            // 如果都能解析到 virtual path data，抛出异常
            if (namedRoutePathData != null && 
                pathData != null)
            {
                var message = Resources.FormatNamedRoutes
                    					_AmbiguousRoutesFound(context.RouteName);
                throw new InvalidOperationException(message);
            }
            
            /* b- 由 named route data 或者 unamed route data 创建 virtual path data */
            return NormalizeVirtualPath(namedRoutePathData ?? pathData);
        }
        /* 否则，即 route name 为空 */
        else
        {
            // a- & b-
            return NormalizeVirtualPath(GetVirtualPath(context, _routes));
        }
    }
        
    // a- 从 route 集合中 get virtual path
    private VirtualPathData? GetVirtualPath(
        VirtualPathContext context, 
        List<IRouter> routes)
    {
        // 遍历 route 集合解析 virtual path data，        
        for (var i = 0; i < routes.Count; i++)
        {
            var route = routes[i];
            
            var pathData = route.GetVirtualPath(context);
            if (pathData != null)
            {
                // 只要找到（第一个），返回结果
                return pathData;
            }
        }
        
        // 找不到，返回 null
        return null;
    }
    
    // b- 标准化 virtual path data
    private VirtualPathData? NormalizeVirtualPath(VirtualPathData? pathData)
    {
        if (pathData == null)
        {
            return pathData;
        }
        
        Debug.Assert(_options != null);
        
        var url = pathData.VirtualPath;
        
        if (!string.IsNullOrEmpty(url) && 
            (_options.LowercaseUrls || _options.AppendTrailingSlash))
        {
            var indexOfSeparator = url.IndexOfAny(UrlQueryDelimiters);
            var urlWithoutQueryString = url;
            var queryString = string.Empty;
            
            if (indexOfSeparator != -1)
            {
                urlWithoutQueryString = url.Substring(0, indexOfSeparator);
                queryString = url.Substring(indexOfSeparator);
            }
            
            if (_options.LowercaseUrls)
            {
                urlWithoutQueryString = urlWithoutQueryString.ToLowerInvariant();
            }
            
            if (_options.LowercaseUrls && 
                _options.LowercaseQueryStrings)
            {
                queryString = queryString.ToLowerInvariant();
            }
            
            if (_options.AppendTrailingSlash && 
                !urlWithoutQueryString.EndsWith("/", StringComparison.Ordinal))
            {
                urlWithoutQueryString += "/";
            }
            
            // queryString will contain the delimiter ? or # as the first character, 
            // so it's safe to append.
            url = urlWithoutQueryString + queryString;
            
            return new VirtualPathData(pathData.Router, url, pathData.DataTokens);
        }
        
        return pathData;
    }        
}

```

###### 2.2.4.5 接口方法 - add

```c#
public class RouteCollection : IRouteCollection
{    
    public void Add(IRouter router)
    {
        if (router == null)
        {
            throw new ArgumentNullException(nameof(router));
        }
        
        // 如果 route 实现了 named router 接口，
        var namedRouter = router as INamedRouter;
        if (namedRouter != null)
        {
            if (!string.IsNullOrEmpty(namedRouter.Name))
            {
                // 注入 named route 集合
                _namedRoutes.Add(namedRouter.Name, namedRouter);
            }
        }
        // 否则，即没有实现 named router 接口，
        else
        {
            // 注入 unamed route 集合
            _unnamedRoutes.Add(router);
        }
        
        // 同时注入 routes 集合（无论是否实现 named router 接口）        
        _routes.Add(router);
    }
}
```

##### 2.2.5 null router

```c#
internal class NullRouter : IRouter
{
    public static readonly NullRouter Instance = new NullRouter();
    
    private NullRouter()
    {
    }
    
    public Task RouteAsync(RouteContext context)
    {
        return Task.CompletedTask;
    }
    
    public VirtualPathData? GetVirtualPath(VirtualPathContext context)
    {
        return null;
    }        
}

```

#### 2.3 router builder

##### 2.3.1 接口

```c#
public interface IRouteBuilder
{    
    IApplicationBuilder ApplicationBuilder { get; }        
    IRouter? DefaultHandler { get; set; }    
    IServiceProvider ServiceProvider { get; }            
    IList<IRouter> Routes { get; }
        
    IRouter Build();
}

```

##### 2.3.2 route builder

```c#
public class RouteBuilder : IRouteBuilder
{
    public IApplicationBuilder ApplicationBuilder { get; }      
    public IRouter? DefaultHandler { get; set; }       
    public IServiceProvider ServiceProvider { get; }       
    public IList<IRouter> Routes { get; }
            
    public RouteBuilder(IApplicationBuilder applicationBuilder)
        : this(
            applicationBuilder, 
            defaultHandler: null)
    {
    }
        
    public RouteBuilder(
        IApplicationBuilder applicationBuilder, 
        IRouter? defaultHandler)
    {
        if (applicationBuilder == null)
        {
            throw new ArgumentNullException(nameof(applicationBuilder));
        }
        
        // 如果 app builder 中没有注入 routing marker service，抛出异常        
        if (applicationBuilder.ApplicationServices
            				  .GetService(typeof(RoutingMarkerService)) == null)
        {
            throw new InvalidOperationException(
                Resources.FormatUnableToFindServices(
                    nameof(IServiceCollection),
                    nameof(RoutingServiceCollectionExtensions.AddRouting),
                    "ConfigureServices(...)"));
        }
        
        ApplicationBuilder = applicationBuilder;
        DefaultHandler = defaultHandler;
        ServiceProvider = applicationBuilder.ApplicationServices;
        
        // 创建 route 集合（默认）
        Routes = new List<IRouter>();
    }
        
    // 返回新的 route collection 实例
    public IRouter Build()
    {
        var routeCollection = new RouteCollection();
        
        foreach (var route in Routes)
        {
            routeCollection.Add(route);
        }
        
        return routeCollection;
    }
}

```

##### 2.3.3 扩展方法 - map route

###### 2.3.3.1 map route (template)

```c#
public static class MapRouteRouteBuilderExtensions
{    
    public static IRouteBuilder MapRoute(
        this IRouteBuilder routeBuilder,
        string? name,
        string? template)
    {
        return MapRoute(
            routeBuilder, 
            name, 
            template, 
            defaults: null);                
    }
        
    public static IRouteBuilder MapRoute(
        this IRouteBuilder routeBuilder,
        string? name,
        string? template,
        object? defaults)
    {
        return MapRoute(
            routeBuilder, 
            name, 
            template, 
            defaults, 
            constraints: null);
    }
            
    public static IRouteBuilder MapRoute(
        this IRouteBuilder routeBuilder,
        string? name,
        string? template,
        object? defaults,
        object? constraints)
    {
        return MapRoute(
            routeBuilder, 
            name, 
            template, 
            defaults, 
            constraints, 
            dataTokens: null);
    }
    
    // 向 route builder 中注入 route
    public static IRouteBuilder MapRoute(
        this IRouteBuilder routeBuilder,
        string? name,
        string? template,
        object? defaults,
        object? constraints,
        object? dataTokens)
    {
        if (routeBuilder.DefaultHandler == null)
        {
            throw new RouteCreationException(
                Resources.FormatDefaultHandler_MustBeSet(nameof(IRouteBuilder)));
        }
        
        routeBuilder.Routes
            		.Add(
            			new Route(
                            routeBuilder.DefaultHandler,
                            name,
                            template,
                            new RouteValueDictionary(defaults),
                            new RouteValueDictionary(constraints)!,
                            new RouteValueDictionary(dataTokens),
                            CreateInlineConstraintResolver(routeBuilder.ServiceProvider)));
        
        return routeBuilder;
    }      
    
    /* create inline constraint resolver */
    
    private static IInlineConstraintResolver CreateInlineConstraintResolver(
        IServiceProvider serviceProvider)
    {
        var inlineConstraintResolver = 
            serviceProvider.GetRequiredService<IInlineConstraintResolver>();
        
        var parameterPolicyFactory = 
            serviceProvider.GetRequiredService<ParameterPolicyFactory>();
        
        // This inline constraint resolver will return a null constraint for 
        // non-IRouteConstraint parameter policies so Route does not error
        return new BackCompatInlineConstraintResolver(
            inlineConstraintResolver, 
            parameterPolicyFactory);
    }
    
    private class BackCompatInlineConstraintResolver : IInlineConstraintResolver
    {
        private readonly IInlineConstraintResolver _inner;
        private readonly ParameterPolicyFactory _parameterPolicyFactory;
        
        public BackCompatInlineConstraintResolver(
            IInlineConstraintResolver inner, 
            ParameterPolicyFactory parameterPolicyFactory)
        {
            _inner = inner;
            _parameterPolicyFactory = parameterPolicyFactory;
        }
        
        public IRouteConstraint? ResolveConstraint(string inlineConstraint)
        {
            // 使用 inner constraint resolver 解析 constraint，            
            var routeConstraint = _inner.ResolveConstraint(inlineConstraint);
            // 如果能解析到，返回 constraint
            if (routeConstraint != null)
            {
                return routeConstraint;
            }
            
            // 否则，即 inner constraint resolver 不能解析，
            // 由 parameter policy factory 创建 constraint，
            var parameterPolicy = _parameterPolicyFactory.Create(null!, inlineConstraint);
            // 如果能创建，返回 constraint
            if (parameterPolicy != null)
            {
                // Logic inside Route will skip adding NullRouteConstraint
                return NullRouteConstraint.Instance;
            }
            
            // 都不能，返回 null
            return null;
        }
    }
}

```

###### 2.3.3.2 map route (request delegate)

```c#
public static class RequestDelegateRouteBuilderExtensions
{    
    public static IRouteBuilder MapRoute(
        this IRouteBuilder builder, 
        string template, 
        RequestDelegate handler)
    {
        var route = new Route(
            new RouteHandler(handler),
            template,
            defaults: null,
            constraints: null,
            dataTokens: null,
            inlineConstraintResolver: GetConstraintResolver(builder));
        
        builder.Routes
	           .Add(route);
        
        return builder;
    }
    
    public static IRouteBuilder MapMiddlewareRoute(
        this IRouteBuilder builder, 
        string template, 
        Action<IApplicationBuilder> action)
    {
        var nested = builder.ApplicationBuilder
            				.New();
        action(nested);
        
        return builder.MapRoute(template, nested.Build());
    }                           
}

```

##### 2.3.4 扩展方法 - map verb

###### 2.3.4.1 map verb (request delegate)

```c#
public static class RequestDelegateRouteBuilderExtensions
{
    private static IInlineConstraintResolver GetConstraintResolver(IRouteBuilder builder)
    {
        return builder.ServiceProvider
            		  .GetRequiredService<IInlineConstraintResolver>();
    }
    
    /* map verb */        
    public static IRouteBuilder MapVerb(
        this IRouteBuilder builder,
        string verb,
        string template,
        RequestDelegate handler)
    {
        var route = new Route(
            new RouteHandler(handler),
            template,
            defaults: null,
            constraints: 
            	new RouteValueDictionary(
                    new 
                    { 
                        httpMethod = new HttpMethodRouteConstraint(verb) 
                    })!,
            dataTokens: null,
            inlineConstraintResolver: GetConstraintResolver(builder));
        
        builder.Routes
               .Add(route);
         
        return builder;
    }
                        
    /* map get */
    public static IRouteBuilder MapGet(
        this IRouteBuilder builder, 
        string template, 
        RequestDelegate handler)
    {
        return builder.MapVerb("GET", template, handler);
    }
                            
    /* map post */
    public static IRouteBuilder MapPost(
        this IRouteBuilder builder, 
        string template, 
        RequestDelegate handler)
    {
        return builder.MapVerb("POST", template, handler);
    }
                        
    /* map put */
    public static IRouteBuilder MapPut(
        this IRouteBuilder builder, 
        string template, 
        RequestDelegate handler)
    {
        return builder.MapVerb("PUT", template, handler);
    }
                   
    /* map delete */
    public static IRouteBuilder MapDelete(
        this IRouteBuilder builder, 
        string template, 
        RequestDelegate handler)
    {
        return builder.MapVerb("DELETE", template, handler);
    }                   
}

```

###### 2.3.4.2 map verb (func)

```c#
public static class RequestDelegateRouteBuilderExtensions
{
    private static IInlineConstraintResolver GetConstraintResolver(IRouteBuilder builder)
    {
        return builder.ServiceProvider
            		  .GetRequiredService<IInlineConstraintResolver>();
    }
    
    /* map verb */
    public static IRouteBuilder MapVerb(
        this IRouteBuilder builder,
        string verb,
        string template,
        Func<HttpRequest, HttpResponse, RouteData, Task> handler)
    {
        RequestDelegate requestDelegate = 
            (httpContext) =>
        		{
            		return handler(
                    		   httpContext.Request, 
                    		   httpContext.Response, 
                    	   	   httpContext.GetRouteData());
        		};
        
        return builder.MapVerb(verb, template, requestDelegate);
    }   
                
    /* map get */   
    public static IRouteBuilder MapGet(
        this IRouteBuilder builder,
        string template,
        Func<HttpRequest, HttpResponse, RouteData, Task> handler)
    {
        return builder.MapVerb("GET", template, handler);
    }
    
    /* map post */    
    public static IRouteBuilder MapPost(
        this IRouteBuilder builder,
        string template,
        Func<HttpRequest, HttpResponse, RouteData, Task> handler)
    {
        return builder.MapVerb("POST", template, handler);
    }
    
    /* map put */    
    public static IRouteBuilder MapPut(
        this IRouteBuilder builder,
        string template,
        Func<HttpRequest, HttpResponse, RouteData, Task> handler)
    {
        return builder.MapVerb("PUT", template, handler);
    }
    
    /* map delete */    
    public static IRouteBuilder MapDelete(
        this IRouteBuilder builder,
        string template,
        Func<HttpRequest, HttpResponse, RouteData, Task> handler)
    {
        return builder.MapVerb("DELETE", template, handler);
    }                                              
}

```

###### 2.3.4.3 map verb (middleware)

```c#
public static class RequestDelegateRouteBuilderExtensions
{
    public static IRouteBuilder MapMiddlewareVerb(
        this IRouteBuilder builder,
        string verb,
        string template,
        Action<IApplicationBuilder> action)
    {
        var nested = builder.ApplicationBuilder
            				.New();
        action(nested);
        return builder.MapVerb(verb, template, nested.Build());
    }                                           
       
    // get
    public static IRouteBuilder MapMiddlewareGet(
        this IRouteBuilder builder, 
        string template, 
        Action<IApplicationBuilder> action)
    {
        return builder.MapMiddlewareVerb("GET", template, action);
    }
        
    // post
    public static IRouteBuilder MapMiddlewarePost(
        this IRouteBuilder builder, 
        string template, 
        Action<IApplicationBuilder> action)
    {
        return builder.MapMiddlewareVerb("POST", template, action);
    }
       
    // put
    public static IRouteBuilder MapMiddlewarePut(
        this IRouteBuilder builder, 
        string template, 
        Action<IApplicationBuilder> action)
    {
        return builder.MapMiddlewareVerb("PUT", template, action);
    }

    // delete
    public static IRouteBuilder MapMiddlewareDelete(
        this IRouteBuilder builder, 
        string template, 
        Action<IApplicationBuilder> action)
    {
        return builder.MapMiddlewareVerb("DELETE", template, action);
    }                                          
}

```

#### 2.4 use router

##### 2.4.1 use router

```c#
public static class RoutingBuilderExtensions
{
    // by router
    public static IApplicationBuilder UseRouter(
        this IApplicationBuilder builder, 
        IRouter router)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }    
        if (router == null)
        {
            throw new ArgumentNullException(nameof(router));
        }
        
        // 如果没有注册 routing marker service，抛出异常
        if (builder.ApplicationServices
            	   .GetService(typeof(RoutingMarkerService)) == null)
        {
            throw new InvalidOperationException(
                Resources.FormatUnableToFindServices(
                    nameof(IServiceCollection),
                    nameof(RoutingServiceCollectionExtensions.AddRouting),
                    "ConfigureServices(...)"));
        }
        
        // 注入 router middleware
        return builder.UseMiddleware<RouterMiddleware>(router);
    }
        
    // by route builder action
    public static IApplicationBuilder UseRouter(
        this IApplicationBuilder builder, 
        Action<IRouteBuilder> action)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }
        
        // 如果没有注册 routing marker service，抛出异常
        if (builder.ApplicationServices
            	   .GetService(typeof(RoutingMarkerService)) == null)
        {
            throw new InvalidOperationException(
                Resources.FormatUnableToFindServices(
                    nameof(IServiceCollection),
                    nameof(RoutingServiceCollectionExtensions.AddRouting),
                    "ConfigureServices(...)"));
        }

        // 创建 route builder 并配置
        var routeBuilder = new RouteBuilder(builder);
        action(routeBuilder);
        
        // 由 route builder 创建 irouter（router collection），
        // 调用 use router（irouter）方法
        return builder.UseRouter(routeBuilder.Build());
    }
}

```

##### 2.4.2 router middleware

```c#
public class RouterMiddleware
{
    private readonly ILogger _logger;
    private readonly RequestDelegate _next;
    private readonly IRouter _router;
            
    public RouterMiddleware(
        RequestDelegate next,
        ILoggerFactory loggerFactory,
        IRouter router)
    {
        _next = next;
        _router = router;        
        _logger = loggerFactory.CreateLogger<RouterMiddleware>();
    }
        
    public async Task Invoke(HttpContext httpContext)
    {
        // 创建 route context，封装当前 http context
        var context = new RouteContext(httpContext);
        // 向 route context 注入 _router
        context.RouteData
               .Routers
               .Add(_router);
        
        // 执行 _router 的 route async 方法
        await _router.RouteAsync(context);
        
        // 如果没有 handler（ route 不匹配），转到 next
        if (context.Handler == null)
        {
            _logger.RequestNotMatched();
            await _next.Invoke(httpContext);
        }
        // 否则，即 route 匹配，
        else
        {
            // 封装 route data -> routing feature，           
            var routingFeature = new RoutingFeature()
            {
                RouteData = context.RouteData
            };
                        
            // Set the RouteValues on the current request, this is to keep the 
            // IRouteValuesFeature inline with the IRoutingFeature
            
            // 将 routing feature（route data）注入 http context，
            httpContext.Request.RouteValues = context.RouteData.Values;
            httpContext.Features.Set<IRoutingFeature>(routingFeature);
            
            // 执行 handler
            await context.Handler(context.HttpContext);
        }
    }
}

```

### 3. tree router

#### 3.1 url matching tree

```c#
public class UrlMatchingTree
{
    public int Order { get; }        
    public UrlMatchingNode Root { get; } = new UrlMatchingNode(length: 0);
    
    public UrlMatchingTree(int order)
    {
        Order = order;
    }            
    
    internal void AddEntry(InboundRouteEntry entry)
    {        
        // example one: 'Customer/Index/{id}'
        //   Root ->
        //       Literals: Customer ->
        //       	 Literals: Index ->
        //           	 Parameters: {id}
        //   Matches: 'Customer/Index/{id}'
        //                                
        // example two: '{Controller}/{Action}/{*parameters}'               
        //   Parameters: {Controller} ->
        //       Parameters: {Action} ->
        // 	 Matches: '{Controller}/{Action}/{*parameters}'
        //
        //   CatchAlls: {*parameters}
        //   Matches: '{Controller}/{Action}/{*parameters}'
                    
        // 定位 tree root
        var current = Root;
        // 由 entry 的 route template、default 创建 template matcher
        var matcher = new TemplateMatcher(entry.RouteTemplate, entry.Defaults);
        
        // 遍历 entry 中 route template 的 segment，定位到适合的子节点（深度）
        for (var i = 0; i < entry.RouteTemplate.Segments.Count; i++)
        {
            var segment = entry.RouteTemplate.Segments[i];
            
            // 如果不是 simple segment，
            if (!segment.IsSimple)
            {
                /* 转到 current node 的 constrained parameters（子节点），
                   如果没有则创建，-> 下一个 segment */
                
                if (current.ConstrainedParameters == null)
                {
                    current.ConstrainedParameters = new UrlMatchingNode(length: i + 1);
                }
                
                current = current.ConstrainedParameters;
                continue;
            }
            
            // （否则）segment 是 simple segment，只有一个 part
            Debug.Assert(segment.Parts.Count == 1);
            var part = segment.Parts[0];
            
            // 如果是 literal part，
            if (part.IsLiteral)
            {
                /* 转到 current node 的 literals（子节点），
                   如果没有则创建，-> 下一个 segment */
                
                if (!current.Literals.TryGetValue(part.Text, out var next))
                {
                    next = new UrlMatchingNode(length: i + 1);
                    current.Literals.Add(part.Text, next);
                }
                
                current = next;
                continue;
            }
            
            // We accept templates that have intermediate optional values, but we ignore
            // those values for route matching. For that reason, we need to add the entry
            // to the list of matches, only if the remaining segments are optional. 
            // For example:
            //   /{controller}/{action=Index}/{id} will be equivalent to 
            //	 {controller}/{action}/{id}
            // for the purposes of route matching.
            
            // 如果是 parameter part，
            // 并且后续 segment 是可选的（即当前 part 是 optional、catch all 或 default，
            // -> 在 current node 注入 outbound match(entry)
            if (part.IsParameter &&
                RemainingSegmentsAreOptional(entry.RouteTemplate.Segments, i))
            {
                current.Matches.Add(
                    new InboundMatch() 
                    { 
                        Entry = entry, 
                        TemplateMatcher = matcher 
                    });
            }
            
            // 如果是 parameter part，
            // 并且 part 包含 inline constraint，
            // 并且 part 不是 catch all
            if (part.IsParameter && 
                part.InlineConstraints.Any() && 
                !part.IsCatchAll)
            {
                /* 转到 current node 的 constrained parameters（子节点），
                   如果没有则创建，-> 下一个 segment */
                if (current.ConstrainedParameters == null)
                {
                    current.ConstrainedParameters = new UrlMatchingNode(length: i + 1);
                }
                
                current = current.ConstrainedParameters;
                continue;
            }
            
            // 如果是 parameter part，并且 part 不是 catch all            
            if (part.IsParameter && 
                !part.IsCatchAll)
            {
                /* 转到 current node 的 parameters（子节点），
                   如果没有则创建，-> 下一个 segment */
                if (current.Parameters == null)
                {
                    current.Parameters = new UrlMatchingNode(length: i + 1);
                }
                
                current = current.Parameters;
                continue;
            }
            
            // 如果是 parameter part，
            // 并且包含 inline constraint，
            // 并且 part 是 catch all
            if (part.IsParameter && 
                part.InlineConstraints.Any() && 
                part.IsCatchAll)
            {
                /* 转到 current node 的 constrained catch all（子节点），
                   如果没有则创建，-> 下一个 segment */
                if (current.ConstrainedCatchAlls == null)
                {
                    current.ConstrainedCatchAlls = new UrlMatchingNode(length: i + 1) 
                    	{ 
                        	IsCatchAll = true 
	                    };
                }
                
                current = current.ConstrainedCatchAlls;
                continue;
            }
            
            // 如果是 parameter part，并且 part 是 catch all
            if (part.IsParameter && part.IsCatchAll)
            {
                if (current.CatchAlls == null)
                {    
                    current.CatchAlls = new UrlMatchingNode(length: i + 1) 
						                    { 
						                        IsCatchAll = true 
						                    };
                }
                
                current = current.CatchAlls;
                continue;
            }
            
            Debug.Fail("We shouldn't get here.");
        }
        
        // add inound match (entry)
        current.Matches.Add(
            new InboundMatch() 
            {
                Entry = entry, 
                TemplateMatcher = matcher 
            });
        
        // sort inbound match (entry)
        current.Matches.Sort((x, y) =>
            {
                var result = x.Entry.Precedence.CompareTo(y.Entry.Precedence);
                return result == 0 
                    ? string.Compare(
                    			x.Entry.RouteTemplate.TemplateText,
                    			y.Entry.RouteTemplate.TemplateText, 
                    			StringComparison.Ordinal) 
                    : result;
            });
    }
    
    // 判断后续 segment 是 optional
    private static bool RemainingSegmentsAreOptional(
        IList<TemplateSegment> segments, 
        int currentParameterIndex)
    {
        for (var i = currentParameterIndex; i < segments.Count; i++)
        {
            // 如果不是 simple segment（complex segment），-> false
            if (!segments[i].IsSimple)
            {
                // /{complex}-{segment}
                return false;
            }
            
            // 由上，是 simple segment，
            // 如果不是 parameter part，-> false
            var part = segments[i].Parts[0];
            if (!part.IsParameter)
            {
                // /literal
                return false;
            }
            
            // 如果 part 是 optional、catch all 或者 default values，
            var isOptionlCatchAllOrHasDefaultValue = part.IsOptional ||
                part.IsCatchAll ||
                part.DefaultValue != null;
            
            if (!isOptionlCatchAllOrHasDefaultValue)
            {
                // /{parameter}
                return false;
            }
        }
        
        return true;
    }
}

```

##### 3.1.1 inbound match

###### 3.1.1.1 inbound match

```c#
[DebuggerDisplay("{DebuggerToString(),nq}")]
public class InboundMatch
{    
    public InboundRouteEntry Entry { get; set; }        
    public TemplateMatcher TemplateMatcher { get; set; }
    
    private string DebuggerToString()
    {
        return TemplateMatcher?.Template?.TemplateText;
    }
}

```

###### 3.1.1.2 inbound match entry

```c#
public class InboundRouteEntry
{    
    public string RouteName { get; set; }      
    public int Order { get; set; }      
    public IRouter Handler { get; set; }                 
    public decimal Precedence { get; set; }        
           
    public RouteTemplate RouteTemplate { get; set; }
    public IDictionary<string, IRouteConstraint> Constraints { get; set; }   
    public RouteValueDictionary Defaults { get; set; }     
}

```

##### 3.1.2 url matching node

```c#
[DebuggerDisplay("{DebuggerToString(),nq}")]
public class UrlMatchingNode
{
    public int Depth { get; }
    public List<InboundMatch> Matches { get; }        
    public Dictionary<string, UrlMatchingNode> Literals { get; }    
    public bool IsCatchAll { get; set; }
    
    /* 子节点 */
    public UrlMatchingNode ConstrainedParameters { get; set; }        
    public UrlMatchingNode Parameters { get; set; }        
    public UrlMatchingNode ConstrainedCatchAlls { get; set; }        
    public UrlMatchingNode CatchAlls { get; set; }
    
    public UrlMatchingNode(int length)
    {
        Depth = length;
        
        Matches = new List<InboundMatch>();
        Literals = new Dictionary<string, UrlMatchingNode>(
            StringComparer.OrdinalIgnoreCase);
    }
    
    private string DebuggerToString()
    {
        return 
            $"Length: {Depth}, 
             "Matches: {string.Join(
            				" | ", 
        					"Matches?.Select(m => 
                                $"({m.TemplateMatcher
                                    ".Template
                                    ".TemplateText})"))}";
	}
}

```

##### 3.1.3 tree enumerator

```c#
internal struct TreeEnumerator : IEnumerator<UrlMatchingNode>
{
    private readonly Stack<UrlMatchingNode> _stack;
    private readonly PathTokenizer _tokenizer;
    
    public UrlMatchingNode Current { get; private set; }
    object IEnumerator.Current => Current;
    
    public TreeEnumerator(
        UrlMatchingNode root, 
        PathTokenizer tokenizer)
    {
        _stack = new Stack<UrlMatchingNode>();
        _tokenizer = tokenizer;
        Current = null;
        
        _stack.Push(root);
    }
                            
    public bool MoveNext()
    {
        if (_stack == null)
        {
            return false;
        }
        
        while (_stack.Count > 0)
        {
            var next = _stack.Pop();
            
            // In case of wild card segment, the request path segment length can be greater
            // Example:
            // Template:    a/{*path}
            // Request Url: a/b/c/d
            if (next.IsCatchAll && next.Matches.Count > 0)
            {
                Current = next;
                return true;
            }
            // Next template has the same length as the url we are trying to match
            // The only possible matching segments are either our current matches or
            // any catch-all segment after this segment in which the catch all is empty.
            else if (next.Depth == _tokenizer.Count)
            {
                if (next.Matches.Count > 0)
                {
                    Current = next;
                    return true;
                }
                else
                {
                    // We can stop looking as any other child node from this node will be
                    // either a literal, a constrained parameter or a parameter.
                    // (Catch alls and constrained catch alls will show up as candidate 
                    // matches).
                    continue;
                }
            }
            
            if (next.CatchAlls != null)
            {
                _stack.Push(next.CatchAlls);
            }
            
            if (next.ConstrainedCatchAlls != null)
            {
                _stack.Push(next.ConstrainedCatchAlls);
            }
            
            if (next.Parameters != null)
            {
                _stack.Push(next.Parameters);
            }
            
            if (next.ConstrainedParameters != null)
            {
                _stack.Push(next.ConstrainedParameters);
            }
            
            if (next.Literals.Count > 0)
            {
                Debug.Assert(next.Depth < _tokenizer.Count);
                if (next.Literals.TryGetValue(_tokenizer[next.Depth].Value, out var node))
                {
                    _stack.Push(node);
                }
            }
        }
        
        return false;
    }
    
    public void Reset()
    {
        _stack.Clear();
        Current = null;
    }
    
    public void Dispose()
    {
    }
}

```

#### 3.2 decision tree

##### 3.2.1 decision tree node

```c#
internal class DecisionTreeNode<TItem>
{
    // matched item 集合（result）
    public IList<TItem> Matches { get; set; }    
    // criterion 集合
    public IList<DecisionCriterion<TItem>> Criteria { get; set; }
}

```

###### 3.2.1.1 decision criterion

```c#
internal class DecisionCriterion<TItem>
{
    public string Key { get; set; }    
    // 其他 decision node（branch）集合（类似导航属性）
    public Dictionary<object, DecisionTreeNode<TItem>> Branches { get; set; }
}

```

##### 3.2.2 decision tree builder

```c#
internal static class DecisionTreeBuilder<TItem>
{
    public static DecisionTreeNode<TItem> GenerateTree(
        IReadOnlyList<TItem> items, 
        IClassifier<TItem> classifier)
    {
        // 将传入的 TItems(objects) 集合转换为 item descirptor 集合
        var itemCount = items.Count;
        var itemDescriptors = new List<ItemDescriptor<TItem>>(itemCount);
        for (var i = 0; i < itemCount; i++)
        {
            var item = items[i];
            itemDescriptors.Add(
                new ItemDescriptor<TItem>()
                {
                    Criteria = classifier.GetCriteria(item),
                    Index = i,
                    Item = item,
                });
        }
        
        // 创建 比较器
        var comparer = new DecisionCriterionValueEqualityComparer(classifier.ValueComparer);
                
        return GenerateNode(
            new TreeBuilderContext(),
            comparer,
            itemDescriptors);
    }
    
    private static DecisionTreeNode<TItem> GenerateNode(
        TreeBuilderContext context,
        DecisionCriterionValueEqualityComparer comparer,
        List<ItemDescriptor<TItem>> items)
    {
        // 创建 criterion 字典（默认值 empty）
        var criteria = new Dictionary<string, Criterion>(StringComparer.OrdinalIgnoreCase);    
        // 创建 item 集合，预结果
        var matches = new List<TItem>();
        
        // For each item in the working set, we want to map it to it's possible 
        // criteria-branch pairings, then reduce that tree to the minimal set.
        
        // 遍历 item descriptor 并注入
        foreach (var item in items)
        {
            var unsatisfiedCriteria = 0;
            
            // 遍历 item 的 criteria
            foreach (var kvp in item.Criteria)
            {
                // context.CurrentCriteria is the logical 'stack' of criteria that we've 
                // already processed on this branch of the tree.
                
                // 如果 current(node) 的 criteria 包含 (item) decision criterion (key)，
                // -> 下一个 (item) criterion
                if (context.CurrentCriteria.Contains(kvp.Key))
                {
                    continue;
                }
                
                /* 当前 node 的 criteria 不包含 (item) decision criterion(key)。。。 */
                
                // 标记
                unsatisfiedCriteria++;
                
                // 将 (item) decision criterioin 封装为 criterion，
                // 注入 criteria 集合
                if (!criteria.TryGetValue(kvp.Key, out var criterion))
                {
                    criterion = new Criterion(comparer);
                    criteria.Add(kvp.Key, criterion);
                }
                
                if (!criterion.TryGetValue(kvp.Value, out var branch))
                {
                    branch = new List<ItemDescriptor<TItem>>();
                    criterion.Add(kvp.Value, branch);
                }
                
                branch.Add(item);
            }
            
            // If all of the criteria on item are satisfied by the 'stack' then this 
            // item is a match.
            if (unsatisfiedCriteria == 0)
            {
                matches.Add(item.Item);
            }
        }
        
        // Iterate criteria in order of branchiness to determine which one to explore next. 
        // If a criterion has no 'new' matches under it then we can just eliminate that 
        // part of the tree.
        var reducedCriteria = new List<DecisionCriterion<TItem>>();
        foreach (var criterion in criteria.OrderByDescending(c => c.Value.Count))
        {
            var reducedBranches = 
                new Dictionary<object, DecisionTreeNode<TItem>>(comparer.InnerComparer);
            
            foreach (var branch in criterion.Value)
            {
                bool hasReducedItems = false;
                
                foreach (var item in branch.Value)
                {
                    if (context.MatchedItems.Add(item))
                    {
                        hasReducedItems = true;
                    }
                }
                
                if (hasReducedItems)
                {
                    var childContext = new TreeBuilderContext(context);
                    childContext.CurrentCriteria.Add(criterion.Key);
                    
                    var newBranch = GenerateNode(childContext, comparer, branch.Value);
                    reducedBranches.Add(branch.Key.Value, newBranch);
                }
            }
            
            if (reducedBranches.Count > 0)
            {
                var newCriterion = new DecisionCriterion<TItem>()
                {
                    Key = criterion.Key,
                    Branches = reducedBranches,
                };
                
                reducedCriteria.Add(newCriterion);
            }
        }
        
        return new DecisionTreeNode<TItem>()
        {
            Criteria = reducedCriteria,
            Matches = matches,
        };
    }        
}

```

###### 3.2.2.1 item descriptor

```c#
internal class ItemDescriptor<TItem>
{
    public int Index { get; set; }    
    public TItem Item { get; set; }
    // criterion 字典
    public IDictionary<string, DecisionCriterionValue> Criteria { get; set; }       
}

internal readonly struct DecisionCriterionValue
{
    private readonly object _value;
    public object Value
    {
        get { return _value; }
    }
    
    public DecisionCriterionValue(object value)
    {
        _value = value;
    }        
}

```

###### 3.2.2.2 classifier

```c#
internal interface IClassifier<TItem>
{
    IDictionary<string, DecisionCriterionValue> GetCriteria(TItem item);    
    IEqualityComparer<object> ValueComparer { get; }
}

```

###### 3.2.2.3 decision criterion value equality comparer

```c#
internal class DecisionCriterionValueEqualityComparer : 
	IEqualityComparer<DecisionCriterionValue>
{
    public IEqualityComparer<object> InnerComparer { get; private set; }
    
    public DecisionCriterionValueEqualityComparer(
        IEqualityComparer<object> innerComparer)
    {
        InnerComparer = innerComparer;
    }
            
    public bool Equals(
        DecisionCriterionValue x, 
        DecisionCriterionValue y)
    {
        return InnerComparer.Equals(x.Value, y.Value);
    }
    
    public int GetHashCode(DecisionCriterionValue obj)
    {
        return InnerComparer.GetHashCode(obj.Value);
    }
}

```

###### 3.2.2.4 criterion

```c#
internal static class DecisionTreeBuilder<TItem>
{
    private class Criterion : 
    	Dictionary<DecisionCriterionValue, List<ItemDescriptor<TItem>>>
    {
        public Criterion(DecisionCriterionValueEqualityComparer comparer)
            : base(comparer)
        {
        }
    }
}

```

###### 3.2.2.5 tree builder context

```c#
internal static class DecisionTreeBuilder<TItem>
{
    private class TreeBuilderContext
    {
        public HashSet<string> CurrentCriteria { get; private set; }        
        public HashSet<ItemDescriptor<TItem>> MatchedItems { get; private set; }
        
        public TreeBuilderContext()
        {
            CurrentCriteria = 
                new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            
            MatchedItems = new HashSet<ItemDescriptor<TItem>>();
        }
        
        public TreeBuilderContext(TreeBuilderContext other)
        {
            CurrentCriteria = 
                new HashSet<string>(
                	other.CurrentCriteria, 
                	StringComparer.OrdinalIgnoreCase);
            
            MatchedItems = new HashSet<ItemDescriptor<TItem>>();
        }                
    }    
}

```

#### 3.3 link generation decision tree

```c#
[DebuggerDisplay("{DebuggerDisplayString,nq}")]
internal class LinkGenerationDecisionTree
{
    // Fallback value for cases where the ambient values weren't provided.    
    // This is safe because we don't mutate the route values in here.
    private static readonly RouteValueDictionary 
        EmptyAmbientValues = new RouteValueDictionary();
    
    // decision tree 根节点，for attribute routing
    private readonly DecisionTreeNode<OutboundMatch> _root;
    // outbound match 集合，for conventional routing
    private readonly List<OutboundMatch> _conventionalEntries;
    
    public LinkGenerationDecisionTree(IReadOnlyList<OutboundMatch> entries)
    {
        // 创建 attribute entry 集合（默认值 empty）
        var attributedEntries = new List<OutboundMatch>();
        // 创建 conventional entry 集合（默认值 empty）
        _conventionalEntries = new List<OutboundMatch>();
        
        // Anything with a RoutePattern.RequiredValueAny as a RequiredValue is a 
        // conventional route. This is because RequiredValueAny acts as a wildcard, 
        // whereas an attribute route entry is denormalized to contain an exact 
        // set of required values.
        //
        // We will only see conventional routes show up here for endpoint routing.
        
        // 遍历传入的 outbound match，
        for (var i = 0; i < entries.Count; i++)
        {
            var isAttributeRoute = true;
            
            // 遍历 outbound match 的 entry 的 required value
            var entry = entries[i];                        
            foreach (var kvp in entry.Entry.RequiredLinkValues)
            {
                // 如果包含通配符（required value any），-> 不是 attribute route
                if (RoutePattern.IsRequiredValueAny(kvp.Value))
                {
                    isAttributeRoute = false;
                    break;
                }
            }
            
            // 如果是 attribute route，注入 attribute entry 集合
            if (isAttributeRoute)
            {
                attributedEntries.Add(entry);
            }
            // 否则，即是 conventional route，注入 conventional entry 集合
            else
            {
                _conventionalEntries.Add(entry);
            }
        }
        
        // 由 attribute entry 构建 decision tree
        _root = DecisionTreeBuilder<OutboundMatch>.GenerateTree(
            attributedEntries,
            new OutboundMatchClassifier());
    }
    
    private class OutboundMatchClassifier : IClassifier<OutboundMatch>
    {
        public IEqualityComparer<object> ValueComparer => 
            RouteValueEqualityComparer.Default;
        
        public IDictionary<string, DecisionCriterionValue> GetCriteria(OutboundMatch item)
        {
            var results = 
                new Dictionary<string, DecisionCriterionValue>(
                	StringComparer.OrdinalIgnoreCase);
            
            foreach (var kvp in item.Entry.RequiredLinkValues)
            {
                results.Add(
                    kvp.Key, 
                    new DecisionCriterionValue(kvp.Value ?? string.Empty));
            }
            
            return results;
        }
    }
    
    
    
    
    private class OutboundMatchResultComparer : IComparer<OutboundMatchResult>
    {
        public static readonly OutboundMatchResultComparer 
            Instance = new OutboundMatchResultComparer();
        
        public int Compare(OutboundMatchResult x, OutboundMatchResult y)
        {
            // For this comparison lower is better.
            if (x.Match.Entry.Order != y.Match.Entry.Order)
            {
                return x.Match.Entry.Order.CompareTo(y.Match.Entry.Order);
            }
            
            if (x.Match.Entry.Precedence != y.Match.Entry.Precedence)
            {
                // Reversed because higher is better
                return y.Match.Entry.Precedence.CompareTo(x.Match.Entry.Precedence);
            }
            
            if (x.IsFallbackMatch != y.IsFallbackMatch)
            {
                // A fallback match is worse than a non-fallback
                return x.IsFallbackMatch.CompareTo(y.IsFallbackMatch);
            }
            
            return string.Compare(
                x.Match.Entry.RouteTemplate.TemplateText,
                y.Match.Entry.RouteTemplate.TemplateText,
                StringComparison.Ordinal);
        }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    // Example output:
    //
    // => action: Buy => controller: Store => version: V1(Matches: Store/Buy/V1)
    // => action: Buy => controller: Store => version: V2(Matches: Store/Buy/V2)
    // => action: Buy => controller: Store => area: Admin(Matches: Admin/Store/Buy)        
    // => action: Buy => controller: Products(Matches: Products/Buy)
    // => action: Cart => controller: Store(Matches: Store/Cart)
    internal string DebuggerDisplayString
    {
        get
        {
            var sb = new StringBuilder();
            var branchStack = new Stack<string>();
            branchStack.Push(string.Empty);
            FlattenTree(branchStack, sb, _root);
            return sb.ToString();
        }
    }
    
    private void FlattenTree(
        Stack<string> branchStack, 
        StringBuilder sb, 
        DecisionTreeNode<OutboundMatch> node)
    {
        // leaf node
        if (node.Criteria.Count == 0)
        {
            var matchesSb = new StringBuilder();
            foreach (var branch in branchStack)
            {
                matchesSb.Insert(0, branch);
            }
            sb.Append(matchesSb.ToString());
            sb.Append(" (Matches: ");
            sb.AppendJoin(
                ", ", 
                node.Matches
                	.Select(m => m.Entry.RouteTemplate.TemplateText));
            sb.AppendLine(")");
        }
        
        foreach (var criterion in node.Criteria)
        {
            foreach (var branch in criterion.Branches)
            {
                branchStack.Push($" => {criterion.Key}: {branch.Key}");
                FlattenTree(branchStack, sb, branch.Value);
                branchStack.Pop();
            }
        }
    }
}

```

##### 3.3.1 get matches

```c#
internal class LinkGenerationDecisionTree
{
    public IList<OutboundMatchResult> GetMatches(
        RouteValueDictionary values, 
        RouteValueDictionary ambientValues)
    {
        // Perf: Avoid allocation for List if there aren't any Matches or Criteria
        if (_root.Matches.Count > 0 || 
            _root.Criteria.Count > 0 || 
            _conventionalEntries.Count > 0)
        {
            // 预结果
            var results = new List<OutboundMatchResult>();
            
            Walk(
                results, 
                values, 
                ambientValues ?? EmptyAmbientValues, 
                _root, 
                isFallbackPath: false);
            
            ProcessConventionalEntries(
                results, 
                values, 
                ambientValues ?? EmptyAmbientValues);
            
            results.Sort(OutboundMatchResultComparer.Instance);
            
            return results;
        }
        
        return null;
    }    
       
    // We need to recursively walk the decision tree based on the provided route data
    // (context.Values + context.AmbientValues) to find all entries that match. This process is
    // virtually identical to action selection.
    //
    // Each entry has a collection of 'required link values' that must be satisfied. These are
    // key-value pairs that make up the decision tree.
    //
    // A 'require link value' is considered satisfied IF:
    //  1. The value in context.Values matches the required value OR
    //  2. There is no value in context.Values and the value in context.AmbientValues 
    //     matches OR
    //  3. The required value is 'null' and there is no value in context.Values.
    //
    // Ex:
    //  entry requires { area = null, controller = Store, action = Buy }
    //  context.Values = { controller = Store, action = Buy }
    //  context.AmbientValues = { area = Help, controller = AboutStore, 
    //                           action = HowToBuyThings }
    //
    //  In this case the entry is a match. The 'controller' and 'action' are both supplied 
    //  by context.Values, and the 'area' is satisfied because there's NOT a value in 
    //  context.Values. It's OK to ignore ambient values in link generation.
    //
    //  If another entry existed like { area = Help, controller = Store, action = Buy }, 
    //  this would also match.
    //
    // The decision tree uses a tree data structure to execute these rules across all 
    // candidates at once.
    
    private void Walk(
        List<OutboundMatchResult> results,
        RouteValueDictionary values,
        RouteValueDictionary ambientValues,
        DecisionTreeNode<OutboundMatch> node,
        bool isFallbackPath)
    {
        // Any entries in node.Matches have had all their required values satisfied, 
        // so add them to the results.
        
        // 将当前 node 的 matches 封装为 outbound match result，注入 result
        var matches = node.Matches;       
        var matchesCount = matches.Count;
        for (var i = 0; i < matchesCount; i++)
        {
            results.Add(new OutboundMatchResult(matches[i], isFallbackPath));
        }
        
        // 遍历 decision tree node <outbound match> 的 criteria，        
        var criteria = node.Criteria;        
        var criteriaCount = criteria.Count;
        for (var i = 0; i < criteriaCount; i++)
        {
            var criterion = criteria[i];
            var key = criterion.Key;
            
            // 如果能够从传入的 values 按照 key 解析 value，
            // 认为匹配，
            // -> 从 criterion 的 branches 中按照 value 解析 branch，
            //    由 branch 递归（将 node 下的 matches 注入 result）
            if (values.TryGetValue(key, out var value))
            {
                if (criterion.Branches.TryGetValue(value ?? string.Empty, out var branch))
                {
                    Walk(results, values, ambientValues, branch, isFallbackPath);
                }
            }
            // 否则，即不能从传入的 values 中按照 key 解析 value，
            // 即 values 没有提供 node 所定义的 (parameter)
            else
            {
                // If a value wasn't explicitly supplied, match BOTH the ambient value 
                // and the empty value if an ambient value was supplied. 
                // The path explored with the empty value is considered the fallback path.
                DecisionTreeNode<OutboundMatch> branch;
                
                // 如果能从传入的 ambient values 解析 value，且不为 string.empty，
                // 认为匹配，
                // -> 从 criterion 的 branches 中按照 ambient values 解析 branch，
                //    由 branch 递归（将 node 下的 matches 注入 result）
                if (ambientValues.TryGetValue(key, out value) &&
                    !criterion.Branches.Comparer.Equals(value, string.Empty))
                {
                    if (criterion.Branches.TryGetValue(value, out branch))
                    {
                        Walk(results, values, ambientValues, branch, isFallbackPath);
                    }
                }
                
                // 从 criterion 的 branches 中按照 string.empty 解析 branch，
                // 由 branch 递归（将 node 下的 matches 注入 result
                if (criterion.Branches.TryGetValue(string.Empty, out branch))
                {
                    Walk(results, values, ambientValues, branch, isFallbackPath: true);
                }
            }
        }
    }
    
    private void ProcessConventionalEntries(
        List<OutboundMatchResult> results,
        RouteValueDictionary values,
        RouteValueDictionary ambientvalues)
    {
        for (var i = 0; i < _conventionalEntries.Count; i++)
        {
            results.Add(
                new OutboundMatchResult(
                    _conventionalEntries[i], 
                    isFallbackMatch: false));
        }
    }
}
    
```

##### 3.3.2 outbound match

```c#
public class OutboundMatch
{     
    public OutboundRouteEntry Entry { get; set; }         
    public TemplateBinder TemplateBinder { get; set; }    
}

```

###### 3.3.2.1 outbound match entry

```c#
public class OutboundRouteEntry
{
    public string RouteName { get; set; }
    public int Order { get; set; }
    public IRouter Handler { get; set; }
    public decimal Precedence { get; set; }
    
    public object Data { get; set; }
    
    public RouteTemplate RouteTemplate { get; set; }
    public IDictionary<string, IRouteConstraint> Constraints { get; set; }        
    public RouteValueDictionary Defaults { get; set; }
    
    public RouteValueDictionary RequiredLinkValues { get; set; }                               
}

```

###### 3.3.2.2 outbound match result

```c#
internal readonly struct OutboundMatchResult
{
    public OutboundMatch Match { get; }    
    public bool IsFallbackMatch { get; }
    
    public OutboundMatchResult(
        OutboundMatch match, 
        bool isFallbackMatch)
    {
        Match = match;
        IsFallbackMatch = isFallbackMatch;
    }        
}

```

#### 3.4 tree router

```c#
public class TreeRouter : IRouter
{    
    // Key used by routing and action selection to match an attribute
    // route entry to a group of action descriptors.    
    public static readonly string RouteGroupKey = "!__route_group";
    
    private readonly UrlMatchingTree[] _trees;
    internal IEnumerable<UrlMatchingTree> MatchingTrees => _trees;    
    private readonly LinkGenerationDecisionTree _linkGenerationTree;   
    
    private readonly IDictionary<string, OutboundMatch> _namedEntries;
            
    private readonly ILogger _logger;
    private readonly ILogger _constraintLogger;
    
    public int Version { get; }    
           
    internal TreeRouter(
        UrlMatchingTree[] trees,
        IEnumerable<OutboundRouteEntry> linkGenerationEntries,
        UrlEncoder urlEncoder,
        ObjectPool<UriBuildingContext> objectPool,
        ILogger routeLogger,
        ILogger constraintLogger,
        int version)
    {
        if (trees == null)
        {
            throw new ArgumentNullException(nameof(trees));
        }        
        if (linkGenerationEntries == null)
        {
            throw new ArgumentNullException(nameof(linkGenerationEntries));
        }        
        if (urlEncoder == null)
        {
            throw new ArgumentNullException(nameof(urlEncoder));
        }        
        if (objectPool == null)
        {
            throw new ArgumentNullException(nameof(objectPool));
        }        
        if (routeLogger == null)
        {
            throw new ArgumentNullException(nameof(routeLogger));
        }        
        if (constraintLogger == null)
        {
            throw new ArgumentNullException(nameof(constraintLogger));
        }
        
        // 注入 url matching tree 集合
        _trees = trees;
        
        _logger = routeLogger;
        _constraintLogger = constraintLogger;
        
        /* 注入 named outbound matches，创建 link decision tree */                
        _namedEntries = 
            new Dictionary<string, OutboundMatch>(StringComparer.OrdinalIgnoreCase);		
        var outboundMatches = 
            new List<OutboundMatch>();
        
        // 遍历 传入 outbound route entry 集合，注入 outbound matches
        foreach (var entry in linkGenerationEntries)
        {
            /* 封装 outbound route entry 为 outbound match */
            var binder = new TemplateBinder(
                urlEncoder, 
                objectPool, 
                entry.RouteTemplate, 
                entry.Defaults);
            
            var outboundMatch = 
                new OutboundMatch() 
            	{
                	Entry = entry, 
                	TemplateBinder = binder 
            	};
            
            /* 注入 outbound matches */
            outboundMatches.Add(outboundMatch);
                        
            /* 忽略没有 route name 的 entry*/
            // Skip unnamed entries
            if (entry.RouteName == null)
            {
                continue;
            }
            
            // We only need to keep one OutboundMatch per route template
            // so in case two entries have the same name and the same template we only keep
            // the first entry.
            
            /* 如果 outbound route entry 重名，抛出异常，
               否则 注入 named entries */
            if (_namedEntries.TryGetValue(
                	entry.RouteName, 
                	out var namedMatch) &&
                !string.Equals(
                    namedMatch.Entry.RouteTemplate.TemplateText,
                    entry.RouteTemplate.TemplateText,
                    StringComparison.OrdinalIgnoreCase))
            {
                throw new ArgumentException(
                    Resources.FormatAttributeRoute
                    		 _DifferentLinkGenerationEntries
                    		 _SameName(entry.RouteName),
                    nameof(linkGenerationEntries));
            }
            else if (namedMatch == null)
            {
                _namedEntries.Add(entry.RouteName, outboundMatch);
            }
        }
                
        // The decision tree will take care of ordering for these entries.
        
        /* 由上，由outbound matches 创建 link generation tree */
        _linkGenerationTree = new LinkGenerationDecisionTree(outboundMatches.ToArray());
        
        Version = version;
    }                                                                                          
}

```

##### 3.4.1 接口方法 - route async

```c#
public class TreeRouter : IRouter
{    
    public async Task RouteAsync(RouteContext context)
    {
        // 遍历 url matching tree 集合，
        foreach (var tree in _trees)
        {
            /* 为 url matching tree 创建 tree enumerator */
            var tokenizer = new PathTokenizer(context.HttpContext.Request.Path);
            var root = tree.Root;            
            var treeEnumerator = new TreeEnumerator(root, tokenizer);
            
            // Create a snapshot before processing the route. 
            // We'll restore this snapshot before running each to restore the state. 
            // This is likely an "empty" snapshot, which doesn't allocate.
            
            // 创建 route data 的 snapshot
            var snapshot = context.RouteData
                				  .PushState(
                					   router: null, 
                					   values: null, 
                					   dataTokens: null);
            
            // 遍历 url matching node，
            while (treeEnumerator.MoveNext())
            {
                var node = treeEnumerator.Current;
                
                // 遍历 node 中的 matches
                foreach (var item in node.Matches)
                {                    
                    var entry = item.Entry;
                    var matcher = item.TemplateMatcher;
                    
                    try
                    {
                        // 如果 request 不能通过 matcher 匹配，下一个 inbound match
                        if (!matcher.TryMatch(
                            	context.HttpContext.Request.Path, 
                            	context.RouteData.Values))
                        {
                            continue;
                        }
                        
                        // 如果 (request) 不能通过 route constraint matcher 匹配，
                        // 下一个 inbound match
                        if (!RouteConstraintMatcher.Match(
	                            entry.Constraints,
    	                        context.RouteData.Values,
        	                    context.HttpContext,
            	                this,
                	            RouteDirection.IncomingRequest,
                    	        _constraintLogger))
                        {
                            continue;
                        }
                        
                        /* inbound match 匹配 request */
                        
                        // 日志
                        _logger.RequestMatchedRoute(
                            entry.RouteName, 
                            entry.RouteTemplate.TemplateText);
                        
                        // 向 route data 注入该 inbound route entry 的 handler(irouter)
                        context.RouteData.Routers.Add(entry.Handler);
                        // 执行 irouter
                        await entry.Handler.RouteAsync(context);
                        if (context.Handler != null)
                        {
                            return;
                        }
                    }
                    finally
                    {                        
                        if (context.Handler == null)
                        {
                            // Restore the original values to prevent polluting the route data.
                            snapshot.Restore();
                        }
                    }
                }
            }
        }
    }
}

```

##### 3.4.2 接口方法 - get virtual path

```c#
public class TreeRouter : IRouter
{       
    public VirtualPathData GetVirtualPath(VirtualPathContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        // If it's a named route we will try to generate a link directly and
        // if we can't, we will not try to generate it using an unnamed route.
        
        // 如果 route name 不为 null，调用 get virtual path for named route
        if (context.RouteName != null)
        {
            return GetVirtualPathForNamedRoute(context);
        }
        
        // The decision tree will give us back all entries that match the provided 
        // route data in the correct order. 
        // We just need to iterate them and use the first one that can generate a link.
        
        /* route name 不为 null，使用 outbound match 创建 virtual path */
        
        // 解析 outbound match
        var matches = _linkGenerationTree.GetMatches(
            context.Values, 
            context.AmbientValues);
        
        if (matches == null)
        {
            return null;
        }
        
        // 遍历 outbound match，调用 generate virtual path 方法
        for (var i = 0; i < matches.Count; i++)
        {
            var path = GenerateVirtualPath(
                context, 
                matches[i].Match.Entry, 
                matches[i].Match.TemplateBinder);
            
            if (path != null)
            {
                return path;
            }
        }
        
        return null;
    }
    
    // get virtual path for named route
    private VirtualPathData GetVirtualPathForNamedRoute(VirtualPathContext context)
    {
        if (_namedEntries.TryGetValue(
	            context.RouteName, 
    	        out var match))
        {
            // 调用 generate virtual path 方法
            var path = GenerateVirtualPath(
                context, 
                match.Entry, 
                match.TemplateBinder);
            if (path != null)
            {
                return path;
            }
        }
        return null;
    }
    
    // 创建 virtual path
    private VirtualPathData GenerateVirtualPath(
        VirtualPathContext context,
        OutboundRouteEntry entry,
        TemplateBinder binder)
    {
        // In attribute the context includes the values that are used to select this 
        // entry - typically these will be the standard 'action', 'controller' and 
        // maybe 'area' tokens. 
        // However, we don't want to pass these to the link generation code, or else 
        // they will end up as query parameters.
        //
        // So, we need to exclude from here any values that are 'required link values', 
        // but aren't parameters in the template.
        //
        // Ex:
        //      template: api/Products/{action}
        //      required values: { id = "5", action = "Buy", Controller = "CoolProducts" }
        //
        //      result: { id = "5", action = "Buy" }
        
        /* 将 outbound route entry 的 required link value（用于属性注入）
           注入 input values */
        var inputValues = new RouteValueDictionary();
        foreach (var kvp in context.Values)
        {
            if (entry.RequiredLinkValues.ContainsKey(kvp.Key))
            {
                var parameter = entry.RouteTemplate.GetParameter(kvp.Key);
                
                if (parameter == null)
                {
                    continue;
                }
            }
            
            inputValues.Add(kvp.Key, kvp.Value);
        }
        
        // 使用 template binder 合并 values
        var bindingResult = binder.GetValues(context.AmbientValues, inputValues);
        if (bindingResult == null)
        {
            // A required parameter in the template didn't get a value.
            return null;
        }
        
        // constraint matcher 验证 constraint
        var matched = RouteConstraintMatcher.Match(
            entry.Constraints,
            bindingResult.CombinedValues,
            context.HttpContext,
            this,
            RouteDirection.UrlGeneration,
            _constraintLogger);
        
        if (!matched)
        {
            // A constraint rejected this link.
            return null;
        }
        
        // 获取 outbound route entry 中 iroute 的virtual path，
        // 如果不为 null，直接返回结果
        var pathData = entry.Handler.GetVirtualPath(context);
        if (pathData != null)
        {
            // If path is non-null then the target router short-circuited, we don't expect this
            // in typical MVC scenarios.
            return pathData;
        }
        
        // 否则，即 irouter 无法创建 path data，
        // 由 template binder 创建 virtual path data 并返回
        var path = binder.BindValues(bindingResult.AcceptedValues);
        if (path == null)
        {
            return null;
        }        
        return new VirtualPathData(this, path);
    }
}

```

#### 3.5 tree router builder

```c#
public class TreeRouteBuilder
{
    private readonly ILogger _logger;
    private readonly ILogger _constraintLogger;
    private readonly UrlEncoder _urlEncoder;
    private readonly ObjectPool<UriBuildingContext> _objectPool;
    private readonly IInlineConstraintResolver _constraintResolver;
    
    // inbound route entry 集合
    public IList<InboundRouteEntry> InboundEntries { get; } = new List<InboundRouteEntry>();  
    // outbound route entry 集合
    public IList<OutboundRouteEntry> OutboundEntries { get; } = new List<OutboundRouteEntry>();
    
    internal TreeRouteBuilder(
        ILoggerFactory loggerFactory,
        ObjectPool<UriBuildingContext> objectPool,
        IInlineConstraintResolver constraintResolver)
    {
        if (loggerFactory == null)
        {
            throw new ArgumentNullException(nameof(loggerFactory));
        }        
        if (objectPool == null)
        {
            throw new ArgumentNullException(nameof(objectPool));
        }        
        if (constraintResolver == null)
        {
            throw new ArgumentNullException(nameof(constraintResolver));
        }
        
        _urlEncoder = UrlEncoder.Default;
        _objectPool = objectPool;
        _constraintResolver = constraintResolver;
        
        _logger = loggerFactory.CreateLogger<TreeRouter>();
        _constraintLogger = 
            loggerFactory.CreateLogger(typeof(RouteConstraintMatcher).FullName);
    }
                                                     
    public void Clear()
    {
        InboundEntries.Clear();
        OutboundEntries.Clear();
    }
}

```

##### 3.5.1 map inbound

* 注入正向路由

```c#
public class TreeRouteBuilder
{
    public InboundRouteEntry MapInbound(
        IRouter handler,
        RouteTemplate routeTemplate,
        string routeName,
        int order)
    {
        if (handler == null)
        {
            throw new ArgumentNullException(nameof(handler));
        }        
        if (routeTemplate == null)
        {
            throw new ArgumentNullException(nameof(routeTemplate));
        }
        
        var entry = new InboundRouteEntry()
        {
            Handler = handler,
            Order = order,
            Precedence = RoutePrecedence.ComputeInbound(routeTemplate),
            RouteName = routeName,
            RouteTemplate = routeTemplate,
        };
        
        var constraintBuilder = new RouteConstraintBuilder(
            _constraintResolver, 
            routeTemplate.TemplateText);
        
        foreach (var parameter in routeTemplate.Parameters)
        {
            if (parameter.InlineConstraints != null)
            {
                if (parameter.IsOptional)
                {
                    constraintBuilder.SetOptional(parameter.Name);
                }
                
                foreach (var constraint in parameter.InlineConstraints)
                {
                    constraintBuilder.AddResolvedConstraint(
                        parameter.Name, 
                        constraint.Constraint);
                }
            }
        }
        entry.Constraints = constraintBuilder.Build();
        
        entry.Defaults = new RouteValueDictionary();
        foreach (var parameter in entry.RouteTemplate.Parameters)
        {
            if (parameter.DefaultValue != null)
            {
                entry.Defaults.Add(parameter.Name, parameter.DefaultValue);
            }           
        }
        InboundEntries.Add(entry);
        return entry;
    }
}

```

##### 3.5.2 map outbound

* 注入反向路由

```c#
public class TreeRouteBuilder
{
    public OutboundRouteEntry MapOutbound(
        IRouter handler,
        RouteTemplate routeTemplate,
        RouteValueDictionary requiredLinkValues,
        string routeName,
        int order)
    {
        if (handler == null)
        {
            throw new ArgumentNullException(nameof(handler));
        }        
        if (routeTemplate == null)
        {
            throw new ArgumentNullException(nameof(routeTemplate));
        }        
        if (requiredLinkValues == null)
        {                
            throw new ArgumentNullException(nameof(requiredLinkValues));
            
        }
        
        var entry = new OutboundRouteEntry()            
        {
            Handler = handler,
            Order = order,
            Precedence = RoutePrecedence.ComputeOutbound(routeTemplate),
            RequiredLinkValues = requiredLinkValues,
            RouteName = routeName,
            RouteTemplate = routeTemplate,
        };
        
        var constraintBuilder = new RouteConstraintBuilder(
            _constraintResolver, 
            routeTemplate.TemplateText);
        
        foreach (var parameter in routeTemplate.Parameters)
        {
            if (parameter.InlineConstraints != null)
            {
                if (parameter.IsOptional)
                {
                    constraintBuilder.SetOptional(parameter.Name);
                }
                
                foreach (var constraint in parameter.InlineConstraints)
                {
                    constraintBuilder.AddResolvedConstraint(
                        parameter.Name, 
                        constraint.Constraint);
                }
            }
        }
        
        entry.Constraints = constraintBuilder.Build();

        entry.Defaults = new RouteValueDictionary();
        foreach (var parameter in entry.RouteTemplate.Parameters)
        {
            if (parameter.DefaultValue != null)
            {
                entry.Defaults
                     .Add(
                    	  parameter.Name, 
                    	  parameter.DefaultValue);
            }
        }
        
        OutboundEntries.Add(entry);
        return entry;
    }
}

```

##### 3.5.3 build

```c#
public class TreeRouteBuilder
{
    public TreeRouter Build()
    {
        return Build(version: 0);
    }
           
    public TreeRouter Build(int version)
    {
        // Tree route builder builds a tree for each of the different route orders defined 
        // by the user. When a route needs to be matched, the matching algorithm in tree 
        // router just iterates over the trees in ascending order when it tries to match 
        // the route.
        var trees = new Dictionary<int, UrlMatchingTree>();
        
        foreach (var entry in InboundEntries)
        {
            if (!trees.TryGetValue(entry.Order, out var tree))
            {                    
                tree = new UrlMatchingTree(entry.Order);
                trees.Add(entry.Order, tree);
            }
            
            tree.AddEntry(entry);
        }
                
        return new TreeRouter(
            trees.Values.OrderBy(tree => tree.Order).ToArray(),
            OutboundEntries,
            _urlEncoder,
            _objectPool,
            _logger,
            _constraintLogger,
            version);
    }
}

```

#### 3.6 use tree router

** see mvc **



### 4. endpoint routing

#### 4.1 endpoint

##### 4.1.1 endpoint

```c#
public class Endpoint
{
    // name
    public string? DisplayName { get; }        
    // metadata 集合
    public EndpointMetadataCollection Metadata { get; }        
    // 处理（请求）的 request delegate
    public RequestDelegate? RequestDelegate { get; }
    
    public Endpoint(
        RequestDelegate? requestDelegate,
        EndpointMetadataCollection? metadata,
        string? displayName)
    {
        // All are allowed to be null
        RequestDelegate = requestDelegate;
        Metadata = metadata ?? EndpointMetadataCollection.Empty;
        DisplayName = displayName;
    }
                    
    public override string? ToString() => 
        DisplayName ?? base.ToString();
}

```

###### 4.1.1.1 endpoint metadata collection

```c#
public sealed class EndpointMetadataCollection : IReadOnlyList<object>
{    
    // 静态 empty 实例
    public static readonly EndpointMetadataCollection 
        Empty = new EndpointMetadataCollection(Array.Empty<object>());
    
    // metadata 容器
    private readonly object[] _items;    
    // metadata 缓存容器
    private readonly ConcurrentDictionary<Type, object[]> _cache;
    
    public object this[int index] => _items[index];        
    public int Count => _items.Length;
    
    public EndpointMetadataCollection(IEnumerable<object> items)
    {
        if (items == null)
        {
            throw new ArgumentNullException(nameof(items));
        }
        
        _items = items.ToArray();
        _cache = new ConcurrentDictionary<Type, object[]>();
    }
           
    public EndpointMetadataCollection(params object[] items)
        : this((IEnumerable<object>)items)
    {
    }
                
    /* get metadata */   
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? GetMetadata<T>() where T : class
    {
        if (_cache.TryGetValue(typeof(T), out var obj))
        {
            var result = (T[])obj;
            var length = result.Length;
            return length > 0 ? result[length - 1] : default;
        }
        
        return GetMetadataSlow<T>();
    }
    
    private T? GetMetadataSlow<T>() where T : class
    {
        var result = GetOrderedMetadataSlow<T>();
        var length = result.Length;
        return length > 0 ? result[length - 1] : default;
    }
    
    /* get ordered  metadata */
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public IReadOnlyList<T> GetOrderedMetadata<T>() where T : class
    {
        if (_cache.TryGetValue(typeof(T), out var result))
        {
            return (T[])result;
        }
        
        return GetOrderedMetadataSlow<T>();
    }        
    
    private T[] GetOrderedMetadataSlow<T>() where T : class
    {
        
        List<T>? matches = null;
        
        var items = _items;
        for (var i = 0; i < items.Length; i++)
        {
            if (items[i] is T item)
            {
                matches ??= new List<T>();
                matches.Add(item);
            }
        }
        
        var results = matches == null ? Array.Empty<T>() : matches.ToArray();
        _cache.TryAdd(typeof(T), results);
        return results;
    }
    
    /* get enumerator */
    
    public Enumerator GetEnumerator() => new Enumerator(this);
    
    IEnumerator<object> IEnumerable<object>.GetEnumerator() => 
        GetEnumerator();    
    
    IEnumerator IEnumerable.GetEnumerator() => 
        GetEnumerator();
    
    // enumerator 结构体    
    public struct Enumerator : IEnumerator<object?>
    {
        // Intentionally not readonly to prevent defensive struct copies
        private object[] _items;
        private int _index;
        public object? Current { get; private set; }
        
        internal Enumerator(EndpointMetadataCollection collection)
        {
            _items = collection._items;
            _index = 0;
            Current = null;
        }                                                       
            
        public bool MoveNext()
        {
            if (_index < _items.Length)
            {
                Current = _items[_index++];
                return true;
            }
            
            Current = null;
            return false;
        }
                
        public void Reset()
        {
            _index = 0;
            Current = null;
        }
        
        public void Dispose()
        {
        }
    }
}

```

###### 4.1.1.2 variety of metadata



##### 4.1.2 endpoint feature

```c#
public interface IEndpointFeature
{    
    Endpoint? Endpoint { get; set; }
}

public static class EndpointHttpContextExtensions
{
    private class EndpointFeature : IEndpointFeature
    {
        public Endpoint? Endpoint { get; set; }
    }
}

```

###### 4.1.2.1 endpoint feature in http context

```c#
public static class EndpointHttpContextExtensions
{
    // get endpoint
    public static Endpoint? GetEndpoint(this HttpContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        return context.Features.Get<IEndpointFeature>()?.Endpoint;
    }
    
    // set endpoint
    public static void SetEndpoint(
        this HttpContext context, 
        Endpoint? endpoint)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        var feature = context.Features
            				 .Get<IEndpointFeature>();
        
        if (endpoint != null)
        {
            if (feature == null)
            {
                feature = new EndpointFeature();
                context.Features.Set(feature);
            }
            
            feature.Endpoint = endpoint;
        }
        else
        {
            if (feature == null)
            {
                // No endpoint to set and no feature on context. Do othing
                return;
            }
            
            feature.Endpoint = null;
        }
    }            
}

```

##### 4.1.3 endpoint builder

```c#
public abstract class EndpointBuilder
{                
    public string? DisplayName { get; set; }        
    public IList<object> Metadata { get; } = new List<object>();
    public RequestDelegate? RequestDelegate { get; set; }
    
    public abstract Endpoint Build();
}

```

#### 4.2 endpoint conventional builder

##### 4.2.1 接口

```c#
public interface IEndpointConventionBuilder
{    
    // 注入配置 endpint builder 的 action
    void Add(Action<EndpointBuilder> convention);
}

```

###### 4.2.1.1 扩展方法 - metadata props

```c#
public static class RoutingEndpointConventionBuilderExtensions
{    
    // required host
    public static TBuilder RequireHost<TBuilder>(
        this TBuilder builder, 
        params string[] hosts) 
        	where TBuilder : IEndpointConventionBuilder
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (hosts == null)
        {
            throw new ArgumentNullException(nameof(hosts));
        }
        
        builder.Add(endpointBuilder =>
                    {
                        endpointBuilder.Metadata.Add(new HostAttribute(hosts));
                    });
        return builder;
    }
        
    // display name (by string)
    public static TBuilder WithDisplayName<TBuilder>(
        this TBuilder builder, 
        string displayName) 
        	where TBuilder : IEndpointConventionBuilder 
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }
        
        builder.Add(b =>
                    {
                        b.DisplayName = displayName;
                    });
        
        return builder;
    }
    
    // display name (by func)   
    public static TBuilder WithDisplayName<TBuilder>(
        this TBuilder builder,
        Func<EndpointBuilder, string> func) 
        	where TBuilder : IEndpointConventionBuilder
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (func == null)
        {
            throw new ArgumentNullException(nameof(func));
        }
        
        builder.Add(b =>
                    {
                        b.DisplayName = func(b);
                    });
        
        return builder;
    }
    
    // with maetadata
    public static TBuilder WithMetadata<TBuilder>(
        this TBuilder builder, 
        params object[] items) 
        	where TBuilder : IEndpointConventionBuilder
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (items == null)
        {
            throw new ArgumentNullException(nameof(items));
        }
        
        builder.Add(b =>
                    {
                        foreach (var item in items)
                        {
                            b.Metadata.Add(item);
                        }
                    });
        
        return builder;
    }
}

```

##### 4.2.2 default endpoint convention builder

```c#
internal class DefaultEndpointConventionBuilder : IEndpointConventionBuilder
{
    // 配置 endpoint builder 的 action 集合
    private readonly List<Action<EndpointBuilder>> _conventions;
    // endpoint builder
    internal EndpointBuilder EndpointBuilder { get; }
    
    public DefaultEndpointConventionBuilder(EndpointBuilder endpointBuilder)
    {
        EndpointBuilder = endpointBuilder;
        _conventions = new List<Action<EndpointBuilder>>();
    }
    
    public void Add(Action<EndpointBuilder> convention)
    {
        _conventions.Add(convention);
    }
    
    public Endpoint Build()
    {
        foreach (var convention in _conventions)
        {
            convention(EndpointBuilder);
        }
        
        return EndpointBuilder.Build();
    }
}

```

##### 4.2.3 map action endpoint convention builder

```c#
public sealed class MapActionEndpointConventionBuilder : IEndpointConventionBuilder
{
    // 配置 endpoint conventional builder 的 action 集合
    private readonly List<IEndpointConventionBuilder> _endpointConventionBuilders;
    
    internal MapActionEndpointConventionBuilder(
        IEndpointConventionBuilder endpointConventionBuilder)
    {
        _endpointConventionBuilders = new List<IEndpointConventionBuilder>() 
        { 
            endpointConventionBuilder 
        };
    }
    
    internal MapActionEndpointConventionBuilder(
        List<IEndpointConventionBuilder> endpointConventionBuilders)
    {
        _endpointConventionBuilders = endpointConventionBuilders;
    }
        
    public void Add(Action<EndpointBuilder> convention)
    {
        foreach (var endpointConventionBuilder in _endpointConventionBuilders)
        {
            endpointConventionBuilder.Add(convention);
        }
    }
}

```

#### 4.3 endpoint data source

##### 4.3.1 抽象基类

```c#
public abstract class EndpointDataSource
{
    public abstract IReadOnlyList<Endpoint> Endpoints { get; }
    public abstract IChangeToken GetChangeToken();            
}

```

##### 4.3.2 default  endpoint data source

* 空实现，没有实现 get change token 方法

```c#
public sealed class DefaultEndpointDataSource : EndpointDataSource
{
    private readonly IReadOnlyList<Endpoint> _endpoints;
    public override IReadOnlyList<Endpoint> Endpoints => _endpoints;
    
    public DefaultEndpointDataSource(params Endpoint[] endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        _endpoints = (Endpoint[])endpoints.Clone();
    }
        
    public DefaultEndpointDataSource(IEnumerable<Endpoint> endpoints)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }
        
        _endpoints = new List<Endpoint>(endpoints);
    }
        
    public override IChangeToken GetChangeToken() => 
        NullChangeToken.Singleton;            
}

```

##### 4.3.3 model endpoint data source

* 包含配置 endpoint builder 的 action 集合，
* 由 endpoint builder 创建 endpoint，从而实现了 endpoint 属性
* 没有实现 get change token 方法

```c#
internal class ModelEndpointDataSource : EndpointDataSource
{
    private List<DefaultEndpointConventionBuilder> _endpointConventionBuilders;
    
    internal IEnumerable<EndpointBuilder> EndpointBuilders => 
        _endpointConventionBuilders.Select(b => b.EndpointBuilder);
    
    public override IReadOnlyList<Endpoint> Endpoints => 
        _endpointConventionBuilders.Select(e => e.Build()).ToArray();
    
    
    public ModelEndpointDataSource()
    {
        _endpointConventionBuilders = new List<DefaultEndpointConventionBuilder>();
    }
    
    public IEndpointConventionBuilder AddEndpointBuilder(EndpointBuilder endpointBuilder)
    {
        var builder = new DefaultEndpointConventionBuilder(endpointBuilder);
        _endpointConventionBuilders.Add(builder);
        
        return builder;
    }
    
    public override IChangeToken GetChangeToken()
    {
        return NullChangeToken.Singleton;
    }        
}

```

##### 4.3.4 composite endpoint data source

```c#
[DebuggerDisplay("{DebuggerDisplayString,nq}")]
public sealed class CompositeEndpointDataSource : EndpointDataSource
{
    private readonly object _lock;
    
    private readonly ICollection<EndpointDataSource> _dataSources = default!;
    public IEnumerable<EndpointDataSource> DataSources => _dataSources;
    
    private IReadOnlyList<Endpoint> _endpoints = default!;
    public override IReadOnlyList<Endpoint> Endpoints
    {
        get
        {
            EnsureInitialized();
            return _endpoints;
        }
    }
        
    private IChangeToken _consumerChangeToken;
    private CancellationTokenSource _cts;
    
    private CompositeEndpointDataSource()
    {
        CreateChangeToken();
        _lock = new object();
    }
    
    internal CompositeEndpointDataSource(
        ObservableCollection<EndpointDataSource> dataSources) : this()
    {
        _dataSources = dataSources;
        dataSources.CollectionChanged += OnDataSourcesChanged;                
    }
    
    private void OnDataSourcesChanged(
        object? sender, 
        NotifyCollectionChangedEventArgs e)
    {
        lock (_lock)
        {
            // Only trigger changes if composite data source has already initialized endpoints
            if (_endpoints != null)
            {
                HandleChange();
            }
        }        
    }
        
    public CompositeEndpointDataSource(
        IEnumerable<EndpointDataSource> endpointDataSources) : this()
    {
        _dataSources = new List<EndpointDataSource>();        
        foreach (var dataSource in endpointDataSources)
        {
            _dataSources.Add(dataSource);
        }
    }
                           
    public override IChangeToken GetChangeToken()
    {
        EnsureInitialized();
        return _consumerChangeToken;
    }
               
    // Defer initialization to avoid doing lots of reflection on startup.
    private void EnsureInitialized()
    {
        if (_endpoints == null)
        {
            Initialize();
        }
    }
    
    // Note: we can't use DataSourceDependentCache here because we also need to 
    // handle a list of change tokens, which is a complication most of our code 
    // doesn't have.
    private void Initialize()
    {
        lock (_lock)
        {
            if (_endpoints == null)
            {
                _endpoints = _dataSources.SelectMany(d => d.Endpoints).ToArray();
                
                foreach (var dataSource in _dataSources)
                {
                    ChangeToken.OnChange(
                        dataSource.GetChangeToken,
                        HandleChange);
                }
            }
        }
    }
    
    private void HandleChange()
    {
        lock (_lock)
        {
            // Refresh the endpoints from datasource so that callbacks can get the 
            // latest endpoints
            _endpoints = _dataSources.SelectMany(d => d.Endpoints).ToArray();
            
            // Prevent consumers from re-registering callback to inflight events as that can
            // cause a stackoverflow
            // Example:
            // 1. B registers A
            // 2. A fires event causing B's callback to get called
            // 3. B executes some code in its callback, but needs to re-register callback
            //    in the same callback
            var oldTokenSource = _cts;
            var oldToken = _consumerChangeToken;
            
            CreateChangeToken();
            
            // Raise consumer callbacks. Any new callback registration would happen on 
            // the new token created in earlier step.
            oldTokenSource.Cancel();
        }
    }
    
    [MemberNotNull(nameof(_cts), nameof(_consumerChangeToken))]
    private void CreateChangeToken()
    {
        _cts = new CancellationTokenSource();
        _consumerChangeToken = new CancellationChangeToken(_cts.Token);
    }
    
    private string DebuggerDisplayString
    {
        get
        {
            // Try using private variable '_endpoints' to avoid initialization
            if (_endpoints == null)
            {
                return "No endpoints";
            }
            
            var sb = new StringBuilder();
            foreach (var endpoint in _endpoints)
            {
                if (endpoint is RouteEndpoint routeEndpoint)
                {
                    var template = routeEndpoint.RoutePattern.RawText;                    
                    template = string.IsNullOrEmpty(template) 
                        ? "\"\"" 
                        : template;
                    
                    sb.Append(template);
                    sb.Append(", Defaults: new { ");
                    sb.AppendJoin(
                        ", ", 
                        FormatValues(routeEndpoint.RoutePattern.Defaults));
                    sb.Append(" }");
                    
                    var routeNameMetadata = routeEndpoint.Metadata
                        								 .GetMetadata<IRouteNameMetadata>();
                    sb.Append(", Route Name: ");
                    sb.Append(routeNameMetadata?.RouteName);
                    
                    var routeValues = routeEndpoint.RoutePattern.RequiredValues;
                    if (routeValues.Count > 0)
                    {
                        sb.Append(", Required Values: new { ");
                        sb.AppendJoin(", ", FormatValues(routeValues));
                        sb.Append(" }");
                    }
                    sb.Append(", Order: ");
                    sb.Append(routeEndpoint.Order);
                    
                    var httpMethodMetadata = routeEndpoint.Metadata
                        								  .GetMetadata<IHttpMethodMetadata>();
                    if (httpMethodMetadata != null)
                    {
                        sb.Append(", Http Methods: ");
                        sb.AppendJoin(", ", httpMethodMetadata.HttpMethods);
                    }
                    sb.Append(", Display Name: ");
                    sb.Append(routeEndpoint.DisplayName);
                    sb.AppendLine();
                }
                else
                {
                    sb.Append("Non-RouteEndpoint. DisplayName:");
                    sb.AppendLine(endpoint.DisplayName);
                }
            }
            return sb.ToString();
            
            IEnumerable<string> FormatValues(
                IEnumerable<KeyValuePair<string, object?>> values)
            {
                return values.Select(
                    kvp =>
                    {
                        var value = "null";
                        if (kvp.Value != null)
                        {
                            value = "\"" + kvp.Value.ToString() + "\"";
                        }
                        return kvp.Key + " = " + value;
                    });
            }
        }
    }
}

```

#### 4.4 route endpoint

##### 4.4.1 route endpoint

```c#
public sealed class RouteEndpoint : Endpoint
{          
    public RoutePattern RoutePattern { get; }
    public int Order { get; }  
    
    public RouteEndpoint(
        RequestDelegate requestDelegate,
        RoutePattern routePattern,
        int order,
        EndpointMetadataCollection? metadata,
        string? displayName)            
        	: base(requestDelegate, metadata, displayName)
    {
        if (requestDelegate == null)
        {
            throw new ArgumentNullException(nameof(requestDelegate));
        }        
        if (routePattern == null)
        {
            throw new ArgumentNullException(nameof(routePattern));
        }
        
        RoutePattern = routePattern;
        Order = order;
    }            
}

```

##### 4.4.2 route endpoint builder

```c#
public sealed class RouteEndpointBuilder : EndpointBuilder
{    
    public RoutePattern RoutePattern { get; set; }        
    public int Order { get; set; }
        
    public RouteEndpointBuilder(
        RequestDelegate requestDelegate,
        RoutePattern routePattern,
        int order)
    {
        RequestDelegate = requestDelegate;
        RoutePattern = routePattern;
        Order = order;
    }
    
    /// <inheritdoc />
    public override Endpoint Build()
    {
        if (RequestDelegate is null)
        {
            throw new InvalidOperationException(
                $"{nameof(RequestDelegate)} must be specified to construct a 
                "{nameof(RouteEndpoint)}.");
        }
        
        var routeEndpoint = new RouteEndpoint(
            RequestDelegate,
            RoutePattern,
            Order,
            new EndpointMetadataCollection(Metadata),
            DisplayName);
        
        return routeEndpoint;
    }
}

```

#### 4.5 endpoint route builder

* 封装 application builder 和 endpoint data source 

##### 4.5.1 接口 

```c#
public interface IEndpointRouteBuilder
{       
    IServiceProvider ServiceProvider { get; }        
    ICollection<EndpointDataSource> DataSources { get; }
    
    IApplicationBuilder CreateApplicationBuilder();        
}

```

##### 4.5.2 default endpoint route builder

```c#
internal class DefaultEndpointRouteBuilder : IEndpointRouteBuilder
{
    public IApplicationBuilder ApplicationBuilder { get; }
    public ICollection<EndpointDataSource> DataSources { get; }
    public IServiceProvider ServiceProvider => ApplicationBuilder.ApplicationServices;
    
    public DefaultEndpointRouteBuilder(IApplicationBuilder applicationBuilder)
    {
        ApplicationBuilder = applicationBuilder 
            ?? throw new ArgumentNullException(nameof(applicationBuilder));
        DataSources = new List<EndpointDataSource>();
    }
        
    public IApplicationBuilder CreateApplicationBuilder() => ApplicationBuilder.New(); 
}

```

##### 4.5.3 扩展方法 - to convention endpoint builder

###### 4.5.3.1 map

```c#
public static class EndpointRouteBuilderExtensions
{   
    // map with pattern string & requrest delegate
    public static IEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return Map(
            endpoints, 
            RoutePatternFactory.Parse(pattern), 
            requestDelegate);
    }
        
    // map with pattern & request delegate
    public static IEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        RoutePattern pattern,
        RequestDelegate requestDelegate)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }        
        if (requestDelegate == null)
        {
            throw new ArgumentNullException(nameof(requestDelegate));
        }
        
        const int defaultOrder = 0;
        
        var builder = new RouteEndpointBuilder(
            requestDelegate,
            pattern,
            defaultOrder)
        {
            DisplayName = pattern.RawText ?? pattern.DebuggerToString(),
        };
        
        // Add delegate attributes as metadata
        var attributes = requestDelegate.Method.GetCustomAttributes();
        
        // This can be null if the delegate is a dynamic method or compiled from 
        // an expression tree
        if (attributes != null)
        {
            foreach (var attribute in attributes)
            {
                builder.Metadata.Add(attribute);                            
            }
        }
        
        // 解析 endpoint 的 model endpoint data source，
        // 如果没有则创建
        var dataSource = endpoints.DataSources
            					  .OfType<ModelEndpointDataSource>()
            					  .FirstOrDefault();
        if (dataSource == null)
        {
            dataSource = new ModelEndpointDataSource();
            endpoints.DataSources.Add(dataSource);
        }
        
        // 将 builder 注入 model endpoint data source
        return dataSource.AddEndpointBuilder(builder);
    }
}

```

###### 4.5.3.2 map method

```c#
public static class EndpointRouteBuilderExtensions
{    
    public static IEndpointConventionBuilder MapMethods(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        IEnumerable<string> httpMethods,
        RequestDelegate requestDelegate)
    {
        if (httpMethods == null)
        {
            throw new ArgumentNullException(nameof(httpMethods));
        }
        
        // map pattern
        var builder = endpoints.Map(RoutePatternFactory.Parse(pattern), requestDelegate);
        // 配置 display name
        builder.WithDisplayName($"{pattern} HTTP: {string.Join(", ", httpMethods)}");
        // 配置 http method metadata
        builder.WithMetadata(new HttpMethodMetadata(httpMethods));
        
        return builder;
    }
    
    /* map get */
    private static readonly string[] GetVerb = new[] { "GET" };        
    public static IEndpointConventionBuilder MapGet(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(
            endpoints, 
            pattern, 
            GetVerb, 
            requestDelegate);
    }
    
    /* map post */
    private static readonly string[] PostVerb = new[] { "POST" };
    public static IEndpointConventionBuilder MapPost(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(
            endpoints, 
            pattern, 
            PostVerb, 
            requestDelegate);
    }
    
    /* map put */
    private static readonly string[] PutVerb = new[] { "PUT" };
    public static IEndpointConventionBuilder MapPut(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(
            endpoints, 
            pattern, 
            PutVerb, 
            requestDelegate);
    }
    
    /* map delete */
    private static readonly string[] DeleteVerb = new[] { "DELETE" };     
    public static IEndpointConventionBuilder MapDelete(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(
            endpoints, 
            pattern, 
            DeleteVerb, 
            requestDelegate);
    }
}

```

###### 4.5.3.3 map fallback

```c#
public static class FallbackEndpointRouteBuilderExtensions
{    
    public static readonly string DefaultPattern = "{*path:nonfile}";
        
    // "MapFallback" is intended to handle cases where URL path of the request 
    // does not contain a file name, and no other endpoint has matched. 
    // This is convenient for routing requests for dynamic content to a SPA framework, 
    // while also allowing requests for non-existent files to result in an HTTP 404.
    //
    // "MapFallback" registers an endpoint using the pattern "{*path:nonfile}". 
    // The order of the registered endpoint will be "int.MaxValue".    
    public static IEndpointConventionBuilder MapFallback(
        this IEndpointRouteBuilder endpoints, 
        RequestDelegate requestDelegate)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (requestDelegate == null)
        {
            throw new ArgumentNullException(nameof(requestDelegate));
        }
        
        return endpoints.MapFallback("{*path:nonfile}", requestDelegate);
    }

        
    // "MapFallback" is intended to handle cases where no other endpoint has matched. 
    // This is convenient for routing requests to a SPA framework.
    // The order of the registered endpoint will be "int.MaxValue".
    //
    // This overload will use the provided "pattern" verbatim. 
    // Use the ":nonfile" route contraint to exclude requests for static files.    
    public static IEndpointConventionBuilder MapFallback(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }        
        if (requestDelegate == null)
        {
            throw new ArgumentNullException(nameof(requestDelegate));
        }
        
        // map pattern
        var conventionBuilder = endpoints.Map(pattern, requestDelegate);
        // 配置 display name、order
        conventionBuilder.WithDisplayName("Fallback " + pattern);
        conventionBuilder.Add(b => ((RouteEndpointBuilder)b).Order = int.MaxValue);
        
        return conventionBuilder;
    }
}

```

##### 4.5.4 扩展方法 - to map action endpoint convention builder

###### 4.5.4.1 map

```c#
public static class MapActionEndpointRouteBuilderExtensions
{
     public static MapActionEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate action)
    {
        return Map(endpoints, RoutePatternFactory.Parse(pattern), action);
    }
    
    
    public static MapActionEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        RoutePattern pattern,
        Delegate action)
    {
        if (endpoints is null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (pattern is null)
        {
            throw new ArgumentNullException(nameof(pattern));
        }        
        if (action is null)
        {
            throw new ArgumentNullException(nameof(action));
        }
        
        const int defaultOrder = 0;
        
        var builder = new RouteEndpointBuilder(
            MapActionExpressionTreeBuilder.BuildRequestDelegate(action),
            pattern,
            defaultOrder)
        {
            DisplayName = pattern.RawText ?? pattern.DebuggerToString(),
        };
        
        // Add delegate attributes as metadata
        var attributes = action.Method.GetCustomAttributes();
        
        // This can be null if the delegate is a dynamic method or compiled from
        // an expression tree
        if (attributes is not null)
        {
            foreach (var attribute in attributes)
            {
                builder.Metadata.Add(attribute);
            }
        }
        
        var dataSource = endpoints.DataSources
            					  .OfType<ModelEndpointDataSource>()
            					  .FirstOrDefault();
        if (dataSource is null)
        {
            dataSource = new ModelEndpointDataSource();
            endpoints.DataSources.Add(dataSource);
        }
        
        return new MapActionEndpointConventionBuilder(
            dataSource.AddEndpointBuilder(builder));
    }                                   
}

```

###### 4.5.3.3 map method

```c#
public static class MapActionEndpointRouteBuilderExtensions
{
    public static MapActionEndpointConventionBuilder MapMethods(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        IEnumerable<string> httpMethods,
        Delegate action)
    {
        if (httpMethods is null)
        {
            throw new ArgumentNullException(nameof(httpMethods));
        }
        
        // map pattern
        var builder = endpoints.Map(RoutePatternFactory.Parse(pattern), action);
        // 配置 display name
        builder.WithDisplayName($"{pattern} HTTP: {string.Join(", ", httpMethods)}");
        // 配置 http method metadata
        builder.WithMetadata(new HttpMethodMetadata(httpMethods));
        
        return builder;
    }
            
    /* map get */
    private static readonly string[] GetVerb = new[] { "GET" };
    public static MapActionEndpointConventionBuilder MapGet(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate action)
    {
        return MapMethods(endpoints, pattern, GetVerb, action);
    }
    
    /* map post */
    private static readonly string[] PostVerb = new[] { "POST" };
    public static MapActionEndpointConventionBuilder MapPost(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate action)
    {
        return MapMethods(endpoints, pattern, PostVerb, action);
    }
    
    /* map put */
    private static readonly string[] PutVerb = new[] { "PUT" };
    public static MapActionEndpointConventionBuilder MapPut(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate action)
    {
        return MapMethods(endpoints, pattern, PutVerb, action);
    }
        
    /* map delete */
    private static readonly string[] DeleteVerb = new[] { "DELETE" };                           
    public static MapActionEndpointConventionBuilder MapDelete(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate action)
    {
        return MapMethods(endpoints, pattern, DeleteVerb, action);
    }    
}

```

#### 4.6 dfa

##### 4.6.1 dfa node

```c#
[DebuggerDisplay("{DebuggerToString(),nq}")]
internal class DfaNode
{
    // The depth of the node. The depth indicates the number of segments
    // that must be processed to arrive at this node.
    //
    // This value is not computed for Policy nodes and will be set to -1.
    public int PathDepth { get; set; } = -1;
    
    // Just for diagnostics and debugging
    public string Label { get; set; }
    
    public List<Endpoint> Matches { get; private set; }    
    public Dictionary<string, DfaNode> Literals { get; private set; }    
    public DfaNode Parameters { get; set; }    
    public DfaNode CatchAll { get; set; }
    
    public INodeBuilderPolicy NodeBuilder { get; set; }    
    public Dictionary<object, DfaNode> PolicyEdges { get; private set; }
    
    public void AddPolicyEdge(object state, DfaNode node)
    {
        if (PolicyEdges == null)
        {
            PolicyEdges = new Dictionary<object, DfaNode>();
        }
        
        PolicyEdges.Add(state, node);
    }
    
    public void AddLiteral(string literal, DfaNode node)
    {
        if (Literals == null)
        {
            Literals = new Dictionary<string, DfaNode>(StringComparer.OrdinalIgnoreCase);
        }
        
        Literals.Add(literal, node);
    }
    
    public void AddMatch(Endpoint endpoint)
    {
        if (Matches == null)
        {
            Matches = new List<Endpoint>();
        }
        
        Matches.Add(endpoint);
    }
    
    public void AddMatches(IEnumerable<Endpoint> endpoints)
    {
        if (Matches == null)
        {
            Matches = new List<Endpoint>(endpoints);
        }
        else
        {
            Matches.AddRange(endpoints);
        }
    }
    
    public void Visit(Action<DfaNode> visitor)
    {
        // 如果包含 literal，visit literals
        if (Literals != null)
        {
            foreach (var kvp in Literals)
            {
                kvp.Value.Visit(visitor);
            }
        }
        
        // Break cycles
        // 如果包含 parameter， visit parameter
        if (Parameters != null && !ReferenceEquals(this, Parameters))
        {
            Parameters.Visit(visitor);
        }
        
        // Break cycles
        // 如果包含 catch all，visit catch all        
        if (CatchAll != null && !ReferenceEquals(this, CatchAll))
        {
            CatchAll.Visit(visitor);
        }
        
        // 如果包含 policy edge，visit policy edge
        if (PolicyEdges != null)
        {
            foreach (var kvp in PolicyEdges)
            {
                kvp.Value.Visit(visitor);
            }
        }
        
        visitor(this);
    }
    
    private string DebuggerToString()
    {
        var builder = new StringBuilder();
        
        builder.Append(Label);
        builder.Append(" d:");
        builder.Append(PathDepth);
        builder.Append(" m:");
        builder.Append(Matches?.Count ?? 0);
        builder.Append(" c: ");
        
        if (Literals != null)
        {
            builder.AppendJoin(
                ", ", 
                Literals.Select(kvp => 
                                	$"{kvp.Key}->({FormatNode(kvp.Value)})"));
        }
        
        return builder.ToString();
        
        // DfaNodes can be self-referential, don't traverse cycles.
        string FormatNode(DfaNode other)
        {
            return ReferenceEquals(this, other) 
                ? "this" 
                : other.DebuggerToString();
        }
    }    
}

```

###### 4.6.1.1 node builder policy

```c#
public interface INodeBuilderPolicy
{    
    bool AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints);       
    
    IReadOnlyList<PolicyNodeEdge> GetEdges(IReadOnlyList<Endpoint> endpoints);        
    PolicyJumpTable BuildJumpTable(
        int exitDestination, 
        IReadOnlyList<PolicyJumpTableEdge> edges);
}

```

###### 4.6.1.2 policy node edge

```c#
public readonly struct PolicyNodeEdge
{
    public IReadOnlyList<Endpoint> Endpoints { get; }        
    public object State { get; }
    
    public PolicyNodeEdge(object state, IReadOnlyList<Endpoint> endpoints)
    {
        State = state ?? throw new System.ArgumentNullException(nameof(state));
        Endpoints = endpoints ?? throw new System.ArgumentNullException(nameof(endpoints));
    }               
}

```

###### 4.6.1.3 policy jump table edge

```c#
public readonly struct PolicyJumpTableEdge
{
    public object State { get; }        
    public int Destination { get; }
    public PolicyJumpTableEdge(
        object state, 
        int destination)
    {
        State = state ?? throw new System.ArgumentNullException(nameof(state));
        Destination = destination;
    }            
}

```

##### 4.6.2 jump table

```c#
[DebuggerDisplay("{DebuggerToString(),nq}")]
internal abstract class JumpTable
{
    public abstract int GetDestination(
        string path, 
        PathSegment segment);
    
    public virtual string DebuggerToString()
    {
        return GetType().Name;
    }
}

```

###### 4.6.2.1  single entry jump table

```c#
internal class SingleEntryJumpTable : JumpTable
{
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    private readonly string _text;
    private readonly int _destination;
    
    public SingleEntryJumpTable(
        int defaultDestination,            
        int exitDestination,
        string text,
        int destination)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
        _text = text;
        _destination = destination;
    }
    
    public override int GetDestination(string path, PathSegment segment)
    {
        if (segment.Length == 0)
        {
            return _exitDestination;
        }
        
        if (segment.Length == _text.Length &&
            string.Compare(
                path,
                segment.Start,
                _text,
                0,
                segment.Length,
                StringComparison.OrdinalIgnoreCase) == 0)
        {
            return _destination;
        }
        
        return _defaultDestination;
    }
    
    public override string DebuggerToString()
    {
        return $"{{ {_text}: {_destination}, 
            "$+: {_defaultDestination}, $0: {_exitDestination} }}";
    }
}

```

###### 4.6.2.2 single entry ascii jump table

```c#
internal class SingleEntryAsciiJumpTable : JumpTable
{
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    private readonly string _text;
    private readonly int _destination;
    
    public SingleEntryAsciiJumpTable(
        int defaultDestination,
        int exitDestination,
        string text,
        int destination)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
        _text = text;
        _destination = destination;
    }
    
    public unsafe override int GetDestination(
        string path, 
        PathSegment segment)
    {
        var length = segment.Length;
        if (length == 0)
        {
            return _exitDestination;
        }
        
        var text = _text;
        if (length != text.Length)
        {
            return _defaultDestination;
        }
        
        var a = path.AsSpan(segment.Start, length);
        var b = text.AsSpan();
        
        return Ascii.AsciiIgnoreCaseEquals(a, b, length) 
            ? _destination 
            : _defaultDestination;
    }
    
    public override string DebuggerToString()
    {
        return $"{{ {_text}: {_destination}, 
            "$+: {_defaultDestination}, $0: {_exitDestination} }}";
    }
}

```

###### 4.6.2.3 dictionary jump table

```c#
internal class DictionaryJumpTable : JumpTable
{
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    private readonly Dictionary<string, int> _dictionary;
    
    public DictionaryJumpTable(
        int defaultDestination,
        int exitDestination,
        (string text, int destination)[] entries)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
        
        _dictionary = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        for (var i = 0; i < entries.Length; i++)
        {
            _dictionary.Add(entries[i].text, entries[i].destination);
        }
    }
    
    public override int GetDestination(string path, PathSegment segment)
    {
        if (segment.Length == 0)
        {
            return _exitDestination;
        }
        
        var text = path.Substring(segment.Start, segment.Length);
        if (_dictionary.TryGetValue(text, out var destination))
        {
            return destination;
        }
        
        return _defaultDestination;
    }
    
    public override string DebuggerToString()
    {
        var builder = new StringBuilder();
        builder.Append("{ ");
        
        builder.AppendJoin(
            ", ", 
            _dictionary.Select(kvp => $"{kvp.Key}: {kvp.Value}"));
        
        builder.Append("$+: ");
        builder.Append(_defaultDestination);
        builder.Append(", ");
        
        builder.Append("$0: ");
        builder.Append(_defaultDestination);
        
        builder.Append(" }");
        
        
        return builder.ToString();
    }
}

```

###### 4.6.2.4 linear search jump table

```c#
internal class LinearSearchJumpTable : JumpTable
{
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    private readonly (string text, int destination)[] _entries;
    
    public LinearSearchJumpTable(
        int defaultDestination,
        int exitDestination,
        (string text, int destination)[] entries)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
        _entries = entries;
    }
    
    public override int GetDestination(string path, PathSegment segment)
    {
        if (segment.Length == 0)
        {
            return _exitDestination;
        }
        
        var entries = _entries;
        for (var i = 0; i < entries.Length; i++)
        {
            var text = entries[i].text;
            if (segment.Length == text.Length &&
                string.Compare(
                    path,
                    segment.Start,
                    text,
                    0,
                    segment.Length,
                    StringComparison.OrdinalIgnoreCase) == 0)
            {
                return entries[i].destination;
            }
        }
        
        return _defaultDestination;
    }
    
    public override string DebuggerToString()
    {
        var builder = new StringBuilder();
        builder.Append("{ ");
        
        builder.AppendJoin(", ", _entries.Select(e => $"{e.text}: {e.destination}"));
        
        builder.Append("$+: ");
        builder.Append(_defaultDestination);
        builder.Append(", ");
        
        builder.Append("$0: ");
        builder.Append(_defaultDestination);
        
        builder.Append(" }");
        
        return builder.ToString();
    }
}

```

###### 4.6.2.5 il emit trie jump table

```c#
internal class ILEmitTrieJumpTable : JumpTable
{
    private const int NotAscii = int.MinValue;
    
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    private readonly (string text, int destination)[] _entries;
    
    private readonly bool? _vectorize;
    private readonly JumpTable _fallback;
    
    // Used to protect the initialization of the compiled delegate
    private object _lock;
    private bool _initializing;
    private Task _task;
    
    // Will be replaced at runtime by the generated code.
    //
    // Internal for testing
    internal Func<string, PathSegment, int> _getDestination;
    
    public ILEmitTrieJumpTable(
        int defaultDestination,
        int exitDestination,
        (string text, int destination)[] entries,
        bool? vectorize,
        JumpTable fallback)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
        _entries = entries;
        _vectorize = vectorize;
        _fallback = fallback;
        
        _getDestination = FallbackGetDestination;
    }
    
    public override int GetDestination(string path, PathSegment segment)
    {
        return _getDestination(path, segment);
    }
    
    // Used when we haven't yet initialized the IL trie. We defer compilation of the IL 
    // for startup performance.
    private int FallbackGetDestination(string path, PathSegment segment)
    {
        if (path.Length == 0)
        {
            return _exitDestination;
        }
        
        // We only hit this code path if the IL delegate is still initializing.
        LazyInitializer.EnsureInitialized(
            ref _task, 
            ref _initializing, 
            ref _lock, 
            InitializeILDelegateAsync);
        
        return _fallback.GetDestination(path, segment);
    }
    
    // Internal for testing
    internal async Task InitializeILDelegateAsync()
    {
        // Offload the creation of the IL delegate to the thread pool.
        await Task.Run(() =>
                       {
                           InitializeILDelegate();
                       });
    }
    
    // Internal for testing
    internal void InitializeILDelegate()
    {
        var generated = ILEmitTrieFactory.Create(
            _defaultDestination, 
            _exitDestination, 
            _entries, 
            _vectorize);
        
        _getDestination = (string path, PathSegment segment) =>
        {
            if (segment.Length == 0)
            {
                return _exitDestination;
            }
            
            var result = generated(path, segment.Start, segment.Length);
            if (result == ILEmitTrieFactory.NotAscii)
            {
                result = _fallback.GetDestination(path, segment);
            }
            
            return result;
        };
    }
}

```

###### 4.6.2.6 zero entry jump table

```c#
internal class ZeroEntryJumpTable : JumpTable
{
    private readonly int _defaultDestination;
    private readonly int _exitDestination;
    
    public ZeroEntryJumpTable(int defaultDestination, int exitDestination)
    {
        _defaultDestination = defaultDestination;
        _exitDestination = exitDestination;
    }
    
    public override int GetDestination(string path, PathSegment segment)
    {
        return segment.Length == 0 ? _exitDestination : _defaultDestination;
    }
    
    public override string DebuggerToString()
    {
        return $"{{ $+: {_defaultDestination}, $0: {_exitDestination} }}";
    }
}

```

##### 4.6.3 jump table builder

```c#
internal static class JumpTableBuilder
{
    public static readonly int InvalidDestination = -1;
    
    public static JumpTable Build(
        int defaultDestination, 
        int exitDestination, 
        (string text, int destination)[] pathEntries)
    {
        if (defaultDestination == InvalidDestination)
        {
            var message = 
                $"{nameof(defaultDestination)} is not set. Please report this as a bug.";
            
            throw new InvalidOperationException(message);
        }
        
        if (exitDestination == InvalidDestination)
        {
            var message = 
                $"{nameof(exitDestination)} is not set. Please report this as a bug.";
            
            throw new InvalidOperationException(message);
        }
        
        // The JumpTable implementation is chosen based on the number of entries.
        //
        // Basically the concerns that we're juggling here are that different implementations
        // make sense depending on the characteristics of the entries.
        //
        // On netcoreapp we support IL generation of optimized tries that is much faster
        // than anything we can do with string.Compare or dictionaries. However the IL emit
        // strategy requires us to produce a fallback jump table - see comments on the class.
        //
        // We have an optimized fast path for zero entries since we don't have to
        // do any string comparisons.
        if (pathEntries == null || pathEntries.Length == 0)
        {
            return new ZeroEntryJumpTable(defaultDestination, exitDestination);
        }
        
        // The IL Emit jump table is not faster for a single entry - but we have an 
        // optimized version when all text is ASCII
        if (pathEntries.Length == 1 && Ascii.IsAscii(pathEntries[0].text))
        {
            var entry = pathEntries[0];
            return new SingleEntryAsciiJumpTable(
                defaultDestination, 
                exitDestination, 
                entry.text, 
                entry.destination);
        }
        
        // We have a fallback that works for non-ASCII
        if (pathEntries.Length == 1)
        {
            var entry = pathEntries[0];
            return new SingleEntryJumpTable(
                defaultDestination, 
                exitDestination, 
                entry.text, 
                entry.destination);
        }
        
        // We choose a hard upper bound of 100 as the limit for when we switch to a dictionary
        // over a trie. The reason is that while the dictionary has a bigger constant factor,
        // it is O(1) vs a trie which is O(M * log(N)). Our perf testing shows that the trie
        // is better for ~90 entries based on all of Azure's route table. Anything above 
        // 100 edges we'd consider to be a very very large node, and so while we don't think 
        // anyone will have a node this large in practice, we want to make sure the 
        // performance is reasonable for any size.
        //
        // Additionally if we're on 32bit, the scalability is worse, so switch to the 
        // dictionary at 50 entries.
        var threshold = IntPtr.Size == 8 ? 100 : 50;
        if (pathEntries.Length >= threshold)
        {
            return new DictionaryJumpTable(
                defaultDestination, 
                exitDestination, 
                pathEntries);
        }
        
        // If we have more than a single string, the IL emit strategy is the fastest - but 
        // we need to decide what do for the fallback case.
        JumpTable fallback;
        
        // Based on our testing a linear search is still faster than a dictionary at ten 
        // entries.
        if (pathEntries.Length <= 10)
        {
            fallback = new LinearSearchJumpTable(
                defaultDestination, 
                exitDestination, 
                pathEntries);
        }
        else
        {
            fallback = new DictionaryJumpTable(
                defaultDestination, 
                exitDestination, 
                pathEntries);
        }
        
        // Use the ILEmitTrieJumpTable if the IL is going to be compiled (not interpreted)
        if (RuntimeFeature.IsDynamicCodeCompiled)
        {
            return new ILEmitTrieJumpTable(
                defaultDestination, 
                exitDestination, 
                pathEntries, 
                vectorize: null, 
                fallback);
        }
        
        return fallback;
    }
}

```

##### 4.6.4 dfa state

```c#
[DebuggerDisplay("{DebuggerToString(),nq}")]
internal readonly struct DfaState
{
    public readonly Candidate[] Candidates;
    public readonly IEndpointSelectorPolicy[] Policies;
    public readonly JumpTable PathTransitions;
    public readonly PolicyJumpTable PolicyTransitions;
    
    public DfaState(        
        Candidate[] candidates,
        IEndpointSelectorPolicy[] policies,
        JumpTable pathTransitions,
        PolicyJumpTable policyTransitions)
    {
        Candidates = candidates;
        Policies = policies;
        PathTransitions = pathTransitions;
        PolicyTransitions = policyTransitions;
    }
    
    public string DebuggerToString()
    {
        return
            $"matches: {Candidates?.Length ?? 0}, " +
            $"path: ({PathTransitions?.DebuggerToString()}), " +
            $"policy: ({PolicyTransitions?.DebuggerToString()})";
    }
}

```

###### 4.6.4.1 candidate

```c#
internal readonly struct Candidate
{
    public readonly Endpoint Endpoint;        
    public readonly CandidateFlags Flags;
    public readonly int Score;

    // for defaults
    public readonly KeyValuePair<string, object>[] Slots;    
    // List of parameters to capture.     
    public readonly (string parameterName, int segmentIndex, int slotIndex)[] Captures;    
    // Catchall parameter to capture (limit one per template).
    public readonly (string parameterName, int segmentIndex, int slotIndex) CatchAll;    
    // Complex segments 
    public readonly (RoutePatternPathSegment pathSegment, int segmentIndex)[] ComplexSegments;
    // constraints
    public readonly KeyValuePair<string, IRouteConstraint>[] Constraints;
       
    public Candidate(Endpoint endpoint)
    {
        Endpoint = endpoint;
        
        Slots = Array.Empty<KeyValuePair<string, object>>();
        Captures = Array.Empty<(string parameterName, int segmentIndex, int slotIndex)>();
        CatchAll = default;
        ComplexSegments = Array.Empty<(
            RoutePatternPathSegment pathSegment, int segmentIndex)>();
        Constraints = Array.Empty<KeyValuePair<string, IRouteConstraint>>();
        Score = 0;        
        Flags = CandidateFlags.None;
    }
    
    public Candidate(
        Endpoint endpoint,
        int score,
        KeyValuePair<string, object>[] slots,
        (string parameterName, int segmentIndex, int slotIndex)[] captures,
        in (string parameterName, int segmentIndex, int slotIndex) catchAll,
        (RoutePatternPathSegment pathSegment, int segmentIndex)[] complexSegments,
        KeyValuePair<string, IRouteConstraint>[] constraints)
    {
        Endpoint = endpoint;
        Score = score;
        
        Slots = slots;
        Captures = captures;
        CatchAll = catchAll;
        ComplexSegments = complexSegments;
        Constraints = constraints;
        
        Flags = CandidateFlags.None;
        
        /* 设置 flags */
        for (var i = 0; i < slots.Length; i++)
        {
            if (slots[i].Key != null)
            {
                Flags |= CandidateFlags.HasDefaults;
            }
        }        
        if (captures.Length > 0)
        {
            Flags |= CandidateFlags.HasCaptures;
        }        
        if (catchAll.parameterName != null)
        {
            Flags |= CandidateFlags.HasCatchAll;
        }        
        if (complexSegments.Length > 0)
        {
            Flags |= CandidateFlags.HasComplexSegments;
        }        
        if (constraints.Length > 0)
        {
            Flags |= CandidateFlags.HasConstraints;
        }
    }  
    
    [Flags]
    public enum CandidateFlags
    {
        None = 0,
        HasDefaults = 1,
        HasCaptures = 2,
        HasCatchAll = 4,
        HasSlots = HasDefaults | HasCaptures | HasCatchAll,
        HasComplexSegments = 8,
        HasConstraints = 16,
    }
}

```

###### 4.6.4.2 endpoint selector policy

```c#
public interface IEndpointSelectorPolicy
{    
    bool AppliesToEndpoints(IReadOnlyList<Endpoint> endpoints);        
    Task ApplyAsync(HttpContext httpContext, CandidateSet candidates);
}

```

##### 4.6.5 policy jump table

```c#
public abstract class PolicyJumpTable
{    
    public abstract int GetDestination(HttpContext httpContext);
    
    internal virtual string DebuggerToString()
    {
        return GetType().Name;
    }
}

```

###### 4.6.5.1 http method single entry policy jump table

```c#
internal sealed class HttpMethodSingleEntryPolicyJumpTable : PolicyJumpTable
{
    private readonly int _exitDestination;
    private readonly string _method;
    private readonly int _destination;
    private readonly int _corsPreflightExitDestination;
    private readonly int _corsPreflightDestination;
    
    private readonly bool _supportsCorsPreflight;
    
    public HttpMethodSingleEntryPolicyJumpTable(
        int exitDestination,
        string method,
        int destination,
        bool supportsCorsPreflight,
        int corsPreflightExitDestination,
        int corsPreflightDestination)
    {
        _exitDestination = exitDestination;
        _method = method;
        _destination = destination;
        _supportsCorsPreflight = supportsCorsPreflight;
        _corsPreflightExitDestination = corsPreflightExitDestination;
        _corsPreflightDestination = corsPreflightDestination;
    }
    
    public override int GetDestination(HttpContext httpContext)
    {
        var httpMethod = httpContext.Request.Method;
        if (_supportsCorsPreflight && 
            HttpMethodMatcherPolicy.IsCorsPreflightRequest(
                httpContext, 
                httpMethod, 
                out var accessControlRequestMethod))
        {
            return HttpMethods.Equals(accessControlRequestMethod, _method) 
                ? _corsPreflightDestination 
                : _corsPreflightExitDestination;
        }
        
        return HttpMethods.Equals(httpMethod, _method) 
            ? _destination 
            : _exitDestination;
    }
}

```

###### 4.6.5.2 http method dictionary entry policy jump table

```c#
internal sealed class HttpMethodDictionaryPolicyJumpTable : PolicyJumpTable
{
    private readonly int _exitDestination;
    private readonly Dictionary<string, int>? _destinations;
    private readonly int _corsPreflightExitDestination;
    private readonly Dictionary<string, int>? _corsPreflightDestinations;
    
    private readonly bool _supportsCorsPreflight;
    
    public HttpMethodDictionaryPolicyJumpTable(
        int exitDestination,
        Dictionary<string, int>? destinations,
        int corsPreflightExitDestination,
        Dictionary<string, int>? corsPreflightDestinations)
    {
        _exitDestination = exitDestination;
        _destinations = destinations;
        _corsPreflightExitDestination = corsPreflightExitDestination;
        _corsPreflightDestinations = corsPreflightDestinations;
        
        _supportsCorsPreflight = _corsPreflightDestinations != null && 
            					 _corsPreflightDestinations.Count > 0;
    }
    
    public override int GetDestination(HttpContext httpContext)
    {
        int destination;
        
        var httpMethod = httpContext.Request.Method;
        if (_supportsCorsPreflight && 
            HttpMethodMatcherPolicy.IsCorsPreflightRequest(
                httpContext, 
                httpMethod, 
                out var accessControlRequestMethod))
        {
            return _corsPreflightDestinations
                	   !.TryGetValue(accessControlRequestMethod, out destination)
                		   ? destination
                		   : _corsPreflightExitDestination;
        }
        
        return _destinations != null &&
                _destinations.TryGetValue(httpMethod, out destination) 
            		? destination 
            		: _exitDestination;
    }
}

```



#### 4.7 endpoint selector

##### 4.7.1 接口

```c#
public abstract class EndpointSelector
{    
    public abstract Task SelectAsync(HttpContext httpContext, CandidateSet candidates);
}

```

###### 4.7.1.1 candidate set

```c#
public sealed class CandidateSet
{
    internal CandidateState[] Candidates;
    public int Count => Candidates.Length;        
    public ref CandidateState this[int index]
    {
        // Note that this is a ref-return because of performance.
        // We don't want to copy these fat structs if it can be avoided.        
        // PERF: Force inlining
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            // Friendliness for inlining
            if ((uint)index >= Count)
            {
                ThrowIndexArgumentOutOfRangeException();
            }
            
            return ref Candidates[index];
        }
    }
    
    /* 构造函数 */
    
    public CandidateSet(
        Endpoint[] endpoints, 
        RouteValueDictionary[] values, 
        int[] scores)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (values == null)
        {
            throw new ArgumentNullException(nameof(values));
        }        
        if (scores == null)
        {
            throw new ArgumentNullException(nameof(scores));
        }
        
        if (endpoints.Length != values.Length || 
            endpoints.Length != scores.Length)
        {
            throw new ArgumentException(
                $"The provided {nameof(endpoints)}, {nameof(values)}, and 
                "{nameof(scores)} must have the same length.");
        }
        
        Candidates = new CandidateState[endpoints.Length];
        for (var i = 0; i < endpoints.Length; i++)
        {
            Candidates[i] = new CandidateState(
                endpoints[i], 
                values[i], 
                scores[i]);
        }
    }
    
    // Used in tests.
    internal CandidateSet(Candidate[] candidates)
    {
        Candidates = new CandidateState[candidates.Length];
        for (var i = 0; i < candidates.Length; i++)
        {
            Candidates[i] = new CandidateState(
                candidates[i].Endpoint, 
                candidates[i].Score);
        }
    }
    
    internal CandidateSet(CandidateState[] candidates)
    {
        Candidates = candidates;
    }
    
    /* 方法 */    
            
    public bool IsValidCandidate(int index)
    {
        // Friendliness for inlining
        if ((uint)index >= Count)
        {
            ThrowIndexArgumentOutOfRangeException();
        }
        
        return IsValidCandidate(ref Candidates[index]);
    }
    
    internal static bool IsValidCandidate(ref CandidateState candidate)
    {
        return candidate.Score >= 0;
    }
        
    public void SetValidity(int index, bool value)
    {
        // Friendliness for inlining
        if ((uint)index >= Count)
        {
            ThrowIndexArgumentOutOfRangeException();
        }
        
        ref var original = ref Candidates[index];
        SetValidity(ref original, value);
    }
    
    internal static void SetValidity(
        ref CandidateState candidate, 
        bool value)
    {
        var originalScore = candidate.Score;
        
        var score = originalScore >= 0 ^ value 
            ? ~originalScore 
            : originalScore;
        
        candidate = new CandidateState(
            candidate.Endpoint, 
            candidate.Values, 
            score);
    }
        
    public void ReplaceEndpoint(
        int index, 
        Endpoint? endpoint, 
        RouteValueDictionary? values)
    {
        // Friendliness for inlining
        if ((uint)index >= Count)
        {
            ThrowIndexArgumentOutOfRangeException();
        }
        
        // CandidateState allows a null-valued endpoint. 
        // However a validate candidate should never have a null endpoint
        // We'll make lives easier for matcher policies by declaring it as non-null.
        Candidates[index] = new CandidateState(
            endpoint!, 
            values, 
            Candidates[index].Score);
        
        if (endpoint == null)
        {
            SetValidity(index, false);
        }
    }
        
    public void ExpandEndpoint(
        int index, 
        IReadOnlyList<Endpoint> endpoints, IComparer<Endpoint> comparer)
    {
        // Friendliness for inlining
        if ((uint)index >= Count)
        {
            ThrowIndexArgumentOutOfRangeException();
        }        
        if (endpoints == null)
        {
            ThrowArgumentNullException(nameof(endpoints));
        }        
        if (comparer == null)
        {
            ThrowArgumentNullException(nameof(comparer));
        }
        
        // First we need to verify that the score of what we're replacing is unique.
        ValidateUniqueScore(index);
        
        switch (endpoints.Count)
        {
            case 0:
                ReplaceEndpoint(index, null, null);
                break;
                
            case 1:
                ReplaceEndpoint(index, endpoints[0], Candidates[index].Values);
                break;
                
            default:
                
                var score = GetOriginalScore(index);
                var values = Candidates[index].Values;
                
                // Adding candidates requires expanding the array and computing 
                // new score values for the new candidates.
                var original = Candidates;
                var candidates = new CandidateState[original.Length - 1 + endpoints.Count];
                Candidates = candidates;
                
                // Since the new endpoints have an unknown ordering relationship to 
                // each other, we need to:
                // - order them
                // - assign scores
                // - offset everything that comes after
                //
                // If the inputs look like:
                //
                // score 0: A1
                // score 0: A2
                // score 1: B
                // score 2: C <-- being expanded
                // score 3: D
                //
                // Then the result should look like:
                //
                // score 0: A1
                // score 0: A2
                // score 1: B
                // score 2: `C1
                // score 3: `C2
                // score 4: D
                
                // Candidates before index can be copied unchanged.
                for (var i = 0; i < index; i++)
                {
                    candidates[i] = original[i];
                }
                
                var buffer = endpoints.ToArray();
                Array.Sort<Endpoint>(buffer, comparer);
                
                // Add the first new endpoint with the current score
                candidates[index] = new CandidateState(buffer[0], values, score);
                
                var scoreOffset = 0;
                for (var i = 1; i < buffer.Length; i++)
                {
                    var cmp = comparer.Compare(buffer[i - 1], buffer[i]);
                    
                    // This should not be possible. This would mean that sorting is wrong.
                    Debug.Assert(cmp <= 0);
                    if (cmp == 0)
                    {
                        // Score is unchanged.
                    }
                    else if (cmp < 0)
                    {
                        // Endpoint is lower priority, higher score.
                        scoreOffset++;
                    }
                    
                    Candidates[i + index] = new CandidateState(
                        buffer[i], 
                        values, 
                        score + scoreOffset);
                }
                
                for (var i = index + 1; i < original.Length; i++)
                {
                    Candidates[i + endpoints.Count - 1] = new CandidateState(
                        original[i].Endpoint, 
                        original[i].Values, 
                        original[i].Score + scoreOffset);
                }
                
                break;
                
        }
    }
    
    // Returns the *positive* score value. 
    // Score is used to track valid/invalid which can cause it to be negative.
    //
    // This is the original score and used to determine if there are ambiguities.
    private int GetOriginalScore(int index)
    {
        var score = Candidates[index].Score;
        return score >= 0 ? score : ~score;
    }
    
    private void ValidateUniqueScore(int index)
    {
        var score = GetOriginalScore(index);
        
        var count = 0;
        var candidates = Candidates;
        for (var i = 0; i < candidates.Length; i++)
        {
            if (GetOriginalScore(i) == score)
            {
                count++;
            }
        }
        
        Debug.Assert(count > 0);
        if (count > 1)
        {
            // Uh-oh. We don't allow duplicates with ExpandEndpoint because that 
            // will do unpredictable things.
            var duplicates = new List<Endpoint>();
            for (var i = 0; i < candidates.Length; i++)
            {
                if (GetOriginalScore(i) == score)
                {
                    duplicates.Add(candidates[i].Endpoint!);
                }
            }
            
            var message =
                    $"Using {nameof(ExpandEndpoint)} requires that the replaced 
                	"endpoint have a unique priority. " +
                    $"The following endpoints were found with the same priority:" + 
                	Environment.NewLine +
                    string.Join(
                		Environment.NewLine, 
                		duplicates.Select(e => e.DisplayName));
            
            throw new InvalidOperationException(message);
        }
    }
    
    [DoesNotReturn]
    private static void ThrowIndexArgumentOutOfRangeException()
    {
        throw new ArgumentOutOfRangeException("index");
    }
    
    [DoesNotReturn]
    private static void ThrowArgumentNullException(string parameter)
    {
        throw new ArgumentNullException(parameter);
    }
}

```

###### 4.7.1.2 candidate state

```c#
public struct CandidateState
{
    public Endpoint Endpoint { get; }    
    public int Score { get; }        
    public RouteValueDictionary? Values { get; internal set; }
    
    internal CandidateState(
        Endpoint endpoint, 
        int score)
    {
        Endpoint = endpoint;
        Score = score;
        Values = null;
    }
    
    internal CandidateState(
        Endpoint endpoint, 
        RouteValueDictionary? values, 
        int score)
    {
        Endpoint = endpoint;
        Values = values;
        Score = score;
    }                    
}

```

##### 4.7.2 default endpoint selector

```c#
internal sealed class DefaultEndpointSelector : EndpointSelector
{
    public override Task SelectAsync(
        HttpContext httpContext,
        CandidateSet candidateSet)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }        
        if (candidateSet == null)
        {
            throw new ArgumentNullException(nameof(candidateSet));
        }
        
        Select(httpContext, candidateSet.Candidates);
        return Task.CompletedTask;
    }
    
    internal static void Select(
        HttpContext httpContext, 
        CandidateState[] candidateState)
    {
        // Fast path: We can specialize for trivial numbers of candidates 
        // since there can be no ambiguities
        switch (candidateState.Length)
        {
            case 0:
                {
                    /* 没有 candidate */
                    // Do nothing
                    break;
                }                
            case 1:
                {
                    /* 只有1个 candidate，*/
                    // 验证 validate，如果 valid，注入 http context
                    ref var state = ref candidateState[0];
                    if (CandidateSet.IsValidCandidate(ref state))
                    {
                        httpContext.SetEndpoint(state.Endpoint);
                        httpContext.Request.RouteValues = state.Values!;
                    }
                    
                    break;
                }                
            default:
                {
                    /* 多个 candidate */
                    // Slow path: 
                    //   There's more than one candidate (to say nothing of validity) 
                    //   so we have to process for ambiguities.
                    ProcessFinalCandidates(httpContext, candidateState);
                    break;
                }
        }
    }   
        
    private static void ProcessFinalCandidates(
        HttpContext httpContext,
        CandidateState[] candidateState)
    {
        // 初始化，置 null
        Endpoint? endpoint = null;
        RouteValueDictionary? values = null;
        int? foundScore = null;
        
        // 遍历 candidate state 集合，
        // 按 score 查找 endpoint（score 较小的）       
        for (var i = 0; i < candidateState.Length; i++)
        {
            ref var state = ref candidateState[i];
            
            if (!CandidateSet.IsValidCandidate(ref state))
            {
                continue;
            }
            
            if (foundScore == null)
            {
                // This is the first match we've seen - speculatively assign it.
                endpoint = state.Endpoint;
                values = state.Values;
                foundScore = state.Score;
            }
            else if (foundScore < state.Score)
            {
                // This candidate is lower priority than the one we've seen
                // so far, we can stop.
                //
                // Don't worry about the 'null < state.Score' case, it returns false.
                break;
            }
            else if (foundScore == state.Score)
            {
                // This is the second match we've found of the same score, so there
                // must be an ambiguity.
                //
                // Don't worry about the 'null == state.Score' case, it returns false.
                
                ReportAmbiguity(candidateState);
                
                // Unreachable, ReportAmbiguity always throws.
                throw new NotSupportedException();
            }
        }
        
        // 向 http context 注入 endpoint 和 route value dictionary
        if (endpoint != null)
        {
            httpContext.SetEndpoint(endpoint);
            httpContext.Request.RouteValues = values!;
        }
    }
    
    private static void ReportAmbiguity(CandidateState[] candidateState)
    {
        // If we get here it's the result of an ambiguity - we're OK with this
        // being a littler slower and more allocatey.
        var matches = new List<Endpoint>();
        for (var i = 0; i < candidateState.Length; i++)
        {
            ref var state = ref candidateState[i];
            if (CandidateSet.IsValidCandidate(ref state))
            {
                matches.Add(state.Endpoint);
            }
        }
        
        var message = Resources.FormatAmbiguousEndpoints(
            Environment.NewLine,
            string.Join(
                Environment.NewLine, 
                matches.Select(e => e.DisplayName)));
        
        throw new AmbiguousMatchException(message);
    }
}

```



#### 4.8 matcher

##### 4.8.1 抽象基类

```c#
internal abstract class Matcher
{        
    public abstract Task MatchAsync(HttpContext httpContext);
}

```

##### 4.8.2 dfa matcher

```c#
internal sealed class DfaMatcher : Matcher
{
    private readonly ILogger _logger;
    private readonly EndpointSelector _selector;
    private readonly DfaState[] _states;
    
    private readonly int _maxSegmentCount;    
    private readonly bool _isDefaultEndpointSelector;
    
    public DfaMatcher(
        ILogger<DfaMatcher> logger, 
        EndpointSelector selector,
        DfaState[] states, 
        int maxSegmentCount)
    {
        // 注入服务，        
        _logger = logger;
        _selector = selector;
        _states = states;
        _maxSegmentCount = maxSegmentCount;
        
        _isDefaultEndpointSelector = selector is DefaultEndpointSelector;
    }     
       
    internal static class EventIds
    {
        public static readonly EventId CandidatesNotFound = 
            new EventId(1000, "CandidatesNotFound");
        public static readonly EventId CandidatesFound = 
            new EventId(1001, "CandidatesFound");        
        public static readonly EventId CandidateRejectedByComplexSegment = 
            new EventId(1002, "CandidateRejectedByComplexSegment");
        public static readonly EventId CandidateRejectedByConstraint = 
            new EventId(1003, "CandidateRejectedByConstraint");        
        public static readonly EventId CandidateNotValid = 
            new EventId(1004, "CandiateNotValid");
        public static readonly EventId CandidateValid = 
            new EventId(1005, "CandiateValid");
    }
    
    #nullable disable
    private static class Logger
    {
        private static readonly Action<ILogger, string, Exception> 
            _candidatesNotFound = LoggerMessage.Define<string>(
            	LogLevel.Debug,
            	EventIds.CandidatesNotFound,
	            "No candidates found for the request path '{Path}'");
        
        private static readonly Action<ILogger, int, string, Exception> 
            _candidatesFound = LoggerMessage.Define<int, string>(
            	LogLevel.Debug,
	            EventIds.CandidatesFound,
    	        "{CandidateCount} candidate(s) found for the request path '{Path}'");
        
        private static readonly Action<ILogger, string, string, string, string, Exception> 
            _candidateRejectedByComplexSegment = 
            	LoggerMessage.Define<string, string, string, string>(
            		LogLevel.Debug,
		            EventIds.CandidateRejectedByComplexSegment,
		            "Endpoint '{Endpoint}' with route pattern '{RoutePattern}' was rejected by complex segment '{Segment}' for the request path '{Path}'");
        
        private static readonly 
            Action<ILogger, string, string, string, string, object, string, Exception> 
            	_candidateRejectedByConstraint = 
            		LoggerMessage.Define<string, string, string, string, object, string>(
			            LogLevel.Debug,
            			EventIds.CandidateRejectedByConstraint,
			            "Endpoint '{Endpoint}' with route pattern '{RoutePattern}' was rejected by constraint '{ConstraintName}':'{Constraint}' with value '{RouteValue}' for the request path '{Path}'");
        
        private static readonly Action<ILogger, string, string, string, Exception> 
            _candidateNotValid = LoggerMessage.Define<string, string, string>(
            	LogLevel.Debug,
	            EventIds.CandidateNotValid,
    	        "Endpoint '{Endpoint}' with route pattern '{RoutePattern}' is not valid for the request path '{Path}'");
        
        private static readonly Action<ILogger, string, string, string, Exception> 
            _candidateValid = LoggerMessage.Define<string, string, string>(
            	LogLevel.Debug,
            	EventIds.CandidateValid,
	            "Endpoint '{Endpoint}' with route pattern '{RoutePattern}' is valid for the request path '{Path}'");
        
        public static void CandidatesNotFound(
            ILogger logger, 
            string path)
        {
            _candidatesNotFound(logger, path, null);
        }
        
        public static void CandidatesFound(
            ILogger logger, 
            string path, 
            Candidate[] candidates)
        {
            _candidatesFound(logger, candidates.Length, path, null);
        }
        
        public static void CandidateRejectedByComplexSegment(
            ILogger logger, 
            string path, 
            Endpoint endpoint, 
            RoutePatternPathSegment segment)
        {
            // This should return a real pattern 
            // since we're processing complex segments.... but just in case.
            if (logger.IsEnabled(LogLevel.Debug))
            {
                var routePattern = GetRoutePattern(endpoint);
                _candidateRejectedByComplexSegment(
                    logger, 
                    endpoint.DisplayName, 
                    routePattern, 
                    segment.DebuggerToString(), 
                    path, 
                    null);
            }
        }
        
        public static void CandidateRejectedByConstraint(
            ILogger logger, 
            string path, 
            Endpoint endpoint, 
            string constraintName, 
            IRouteConstraint constraint, 
            object value)
        {
            // This should return a real pattern 
            // since we're processing constraints.... but just in case.
            if (logger.IsEnabled(LogLevel.Debug))
            {
                var routePattern = GetRoutePattern(endpoint);
                _candidateRejectedByConstraint(
                    logger, 
                    endpoint.DisplayName, 
                    routePattern, 
                    constraintName, 
                    constraint.ToString(), 
                    value, 
                    path, 
                    null);
            }
        }
        
        public static void CandidateNotValid(
            ILogger logger, 
            string path, 
            Endpoint endpoint)
        {
            // This can be the fallback value because it really might not be a route endpoint
            if (logger.IsEnabled(LogLevel.Debug))
            {
                var routePattern = GetRoutePattern(endpoint);
                _candidateNotValid(
                    logger, 
                    endpoint.DisplayName, 
                    routePattern, 
                    path, 
                    null);
            }
        }
        
        public static void CandidateValid(
            ILogger logger, 
            string path, 
            Endpoint endpoint)
        {
            // This can be the fallback value because it really might not be a route endpoint
            if (logger.IsEnabled(LogLevel.Debug))
            {
                var routePattern = GetRoutePattern(endpoint);
                _candidateValid(
                    logger, 
                    endpoint.DisplayName, 
                    routePattern, 
                    path, 
                    null);
            }
        }
        
        private static string GetRoutePattern(Endpoint endpoint)
        {
            return (endpoint as RouteEndpoint)
                ?.RoutePattern
                ?.RawText 
                ?? "(none)";
        }
    }
}

```

###### 4.8.2.1 match

```c#
internal sealed class DfaMatcher : Matcher
{
    public sealed override Task MatchAsync(HttpContext httpContext)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
                
        var log = _logger.IsEnabled(LogLevel.Debug);                
        var path = httpContext.Request.Path.Value!;
        
        /* 获取 candicate 和 policy 集合  */
        
        // 从 http request path 解析 segment
        Span<PathSegment> buffer = stackalloc PathSegment[_maxSegmentCount];
        var count = FastPathTokenizer.Tokenize(path, buffer);
        var segments = buffer.Slice(0, count);
                
        // 从 http context、http request path 和 segment 解析 candidate set
        var (candidates, policies) = FindCandidateSet(httpContext, path, segments);
        
        var candidateCount = candidates.Length;
        if (candidateCount == 0)
        {
            if (log)
            {
                Logger.CandidatesNotFound(_logger, path);
            }
            
            return Task.CompletedTask;
        }
        
        if (log)
        {
            Logger.CandidatesFound(_logger, path, candidates);
        }
        
        var policyCount = policies.Length;
        
        /* 如果只有1个 candidate，且没有 policy，且使用 default selector，
           -> 将 candidate.endpoint 注入 http context */                
        if (candidateCount == 1 && 
            policyCount == 0 && 
            _isDefaultEndpointSelector)
        {
            ref readonly var candidate = ref candidates[0];
            
            // Just strict path matching (no route values)
            if (candidate.Flags == Candidate.CandidateFlags.None)
            {
                httpContext.SetEndpoint(candidate.Endpoint);
                
                // We're done
                return Task.CompletedTask;
            }
        }
                        
        // At this point we have a candidate set, defined as a list of endpoints in
        // priority order.
        //
        // We don't yet know that any candidate can be considered a match, because
        // we haven't processed things like route constraints and complex segments.
        //
        // Now we'll iterate each endpoint to capture route values, process constraints,
        // and process complex segments.
        
        // `candidates` has all of our internal state that we use to process the
        // set of endpoints before we call the EndpointSelector.
        //
        // `candidateSet` is the mutable state that we pass to the EndpointSelector.
        
        /* 由上，由多个 candidate，封装 candidate 到 candidate state 集合，
           使用 endpoint selector 匹配适合的 candidate (endpoint)，
           -> 将 candidate.endpoint 注入 http context */
        
        
        // 封装 candidate 到 candidate state 集合
        var candidateState = new CandidateState[candidateCount];
        
        // 遍历 candidate (candidate state)，
        // 根据 candidate flag 处理 candidate (candidate state)...
        for (var i = 0; i < candidateCount; i++)
        {            
            ref readonly var candidate = ref candidates[i];
            ref var state = ref candidateState[i];
            state = new CandidateState(candidate.Endpoint, candidate.Score);
            
            var flags = candidate.Flags;
            
            // First process all of the parameters and defaults.
            
            // 如果 candidate 包含 slot（required value）
            if ((flags & Candidate.CandidateFlags.HasSlots) != 0)
            {
                // The Slots array has the default values of the route values in it.
                //
                // We want to create a new array for the route values based on Slots
                // as a prototype.
                var prototype = candidate.Slots;
                var slots = new KeyValuePair<string, object?>[prototype.Length];
                
                if ((flags & 
                     Candidate.CandidateFlags.HasDefaults) != 0)
                {
                    Array.Copy(prototype, 0, slots, 0, prototype.Length);
                }
                
                if ((flags & 
                     Candidate.CandidateFlags.HasCaptures) != 0)
                {
                    ProcessCaptures(slots, candidate.Captures, path, segments);
                }
                
                if ((flags & 
                     Candidate.CandidateFlags.HasCatchAll) != 0)
                {
                    ProcessCatchAll(slots, candidate.CatchAll, path, segments);
                }
                
                // 将处理后的 slot 注回到 candidate state 中
                state.Values = RouteValueDictionary.FromArray(slots);
            }
            
            // Now that we have the route values, we need to process complex segments.
            // Complex segments go through an old API that requires a fully-materialized
            // route value dictionary.
            
            
            var isMatch = true;
            
            // 如果 candidate 包含 complex segment
            if ((flags & 
                 Candidate.CandidateFlags.HasComplexSegments) != 0)
            {
                state.Values ??= new RouteValueDictionary();
                if (!ProcessComplexSegments(
                    	candidate.Endpoint, 
                    	candidate.ComplexSegments, 
                    	path, 
                    	segments, 
                    	state.Values))
                {
                    CandidateSet.SetValidity(ref state, false);
                    isMatch = false;
                }
            }
            // 如果 candidate 包含 constraint
            if ((flags & 
                 Candidate.CandidateFlags.HasConstraints) != 0)
            {
                state.Values ??= new RouteValueDictionary();
                if (!ProcessConstraints(
                    	candidate.Endpoint, 
                    	candidate.Constraints, 
                    	httpContext, 
                    	state.Values))
                {
                    CandidateSet.SetValidity(ref state, false);
                    isMatch = false;
                }
            }
            
            if (log)
            {
                if (isMatch)
                {
                    Logger.CandidateValid(_logger, path, candidate.Endpoint);
                }
                else
                {
                    Logger.CandidateNotValid(_logger, path, candidate.Endpoint);
                }
            }
        }
        
        // 如果 policy = 0，且 使用 default endpoint selector，
        // -> 使用 default endpoint selector 的 select 方法（注入 endpoint）
        if (policyCount == 0 && 
            _isDefaultEndpointSelector)
        {
            // Fast path that avoids allocating the candidate set.
            //
            // We can use this when there are no policies and we're using the default selector.
            DefaultEndpointSelector.Select(httpContext, candidateState);
            return Task.CompletedTask;
        }
        // 否则，policy=0，（不是 default endpoint selector），
        // -> 使用 endpoint selector 的 select 方法（注入 endpoint）
        else if (policyCount == 0)
        {
            // Fast path that avoids a state machine.
            //
            // We can use this when there are no policies and a non-default selector.
            return _selector.SelectAsync(
                httpContext, 
                new CandidateSet(candidateState));
        }
               
        // 由上，policy != 0 并且 selector 不是 default，       
        return SelectEndpointWithPoliciesAsync(
            httpContext, 
            policies, 
            new CandidateSet(candidateState));
    }    
}

```

###### 4.8.2.2 find cadidates

```c#
internal sealed class DfaMatcher : Matcher
{
    internal (Candidate[] candidates, 
              IEndpointSelectorPolicy[] policies) FindCandidateSet(
        HttpContext httpContext,
        string path,
        ReadOnlySpan<PathSegment> segments)
    {
        // dfa states
        var states = _states;        
        // destination
        var destination = 0;
        
        // 遍历 http request path 的 segment，
        for (var i = 0; i < segments.Length; i++)
        {
            // jump (follow candidate state 的 path transition)
            destination = states[destination].PathTransitions
                							 .GetDestination(path, segments[i]);
        }
        
        // jump (follow candidate state 的 policy transition)
        var policyTransitions = states[destination].PolicyTransitions;
        while (policyTransitions != null)
        {
            destination = policyTransitions.GetDestination(httpContext);
            policyTransitions = states[destination].PolicyTransitions;
        }
        
        return (states[destination].Candidates, 
                states[destination].Policies);
    }
}

```

###### 4.8.2.3 process candidates (by flags)

```c#
internal sealed class DfaMatcher : Matcher
{
    private void ProcessCaptures(
        KeyValuePair<string, object?>[] slots,
        (string parameterName, int segmentIndex, int slotIndex)[] captures,
        string path,
        ReadOnlySpan<PathSegment> segments)
    {
        // 遍历  capture，
        for (var i = 0; i < captures.Length; i++)
        {
            // 解析 parameter name、segment index、slot index
            (var parameterName, var segmentIndex, var slotIndex) = captures[i];
            
            if ((uint)segmentIndex < (uint)segments.Length)
            {
                // 解析 segment
                var segment = segments[segmentIndex];
                // parameter name 不为 null，且 segment 不为空
                if (parameterName != null && segment.Length > 0)
                {
                    // 向 slot 注入 (parameter name, sub path)
                    slots[slotIndex] = new KeyValuePair<string, object?>(
                        parameterName,
                        path.Substring(segment.Start, segment.Length));
                }
            }
        }
    }
        
    private void ProcessCatchAll(
        KeyValuePair<string, object?>[] slots,
        in (string parameterName, int segmentIndex, int slotIndex) catchAll,
        string path,
        ReadOnlySpan<PathSegment> segments)
    {
        // Read segmentIndex to local both to skip double read from stack value
        // and to use the same in-bounds validated variable to access the array.
        var segmentIndex = catchAll.segmentIndex;
        if ((uint)segmentIndex < (uint)segments.Length)
        {
            var segment = segments[segmentIndex];
            slots[catchAll.slotIndex] = new KeyValuePair<string, object?>(
                catchAll.parameterName,
                path.Substring(segment.Start));
        }
    }
	
    private bool ProcessComplexSegments(
        Endpoint endpoint,
        (RoutePatternPathSegment pathSegment, int segmentIndex)[] complexSegments,
        string path,
        ReadOnlySpan<PathSegment> segments,
        RouteValueDictionary values)
    {
        for (var i = 0; i < complexSegments.Length; i++)
        {
            (var complexSegment, var segmentIndex) = complexSegments[i];
            var segment = segments[segmentIndex];
            var text = path.AsSpan(segment.Start, segment.Length);
            if (!RoutePatternMatcher
                .MatchComplexSegment(complexSegment, text, values))
            {
                Logger.CandidateRejectedByComplexSegment(
                    _logger, 
                    path, 
                    endpoint, 
                    complexSegment);
                return false;
            }
        }
        
        return true;
    }

    private bool ProcessConstraints(
        Endpoint endpoint,
        KeyValuePair<string, IRouteConstraint>[] constraints,
        HttpContext httpContext,
        RouteValueDictionary values)
    {
        for (var i = 0; i < constraints.Length; i++)
        {
            var constraint = constraints[i];
            if (!constraint.Value.Match(
                	httpContext, 
                	NullRouter.Instance, 
                	constraint.Key, 
                	values, 
                	RouteDirection.IncomingRequest))
            {
                Logger.CandidateRejectedByConstraint(
                    _logger, 
                    httpContext.Request.Path, 
                    endpoint, 
                    constraint.Key, 
                    constraint.Value, 
                    values[constraint.Key]);
                return false;
            }
        }
        
        return true;
    }    
}

```

###### 4.8.2.4 select endpoint with policy

```c#
internal sealed class DfaMatcher : Matcher
{
    private async Task SelectEndpointWithPoliciesAsync(
        HttpContext httpContext,
        IEndpointSelectorPolicy[] policies,
        CandidateSet candidateSet)
    {
        for (var i = 0; i < policies.Length; i++)
        {
            var policy = policies[i];
            await policy.ApplyAsync(httpContext, candidateSet);
            if (httpContext.GetEndpoint() != null)
            {
                // This is a short circuit, the selector chose an endpoint.
                return;
            }
        }
        
        await _selector.SelectAsync(httpContext, candidateSet);
    }            
}

```

##### 4.8.3 data source dependent matcher

```c#
internal sealed class DataSourceDependentMatcher : Matcher
{
    private readonly Func<MatcherBuilder> _matcherBuilderFactory;
    private readonly DataSourceDependentCache<Matcher> _cache;
    
    public DataSourceDependentMatcher(
        EndpointDataSource dataSource,
        Lifetime lifetime,
        Func<MatcherBuilder> matcherBuilderFactory)
    {
        _matcherBuilderFactory = matcherBuilderFactory;
        
        _cache = new DataSourceDependentCache<Matcher>(dataSource, CreateMatcher);
        _cache.EnsureInitialized();
        
        // This will Dispose the cache when the lifetime is disposed, this allows
        // the service provider to manage the lifetime of the cache.
        lifetime.Cache = _cache;
    }
    
    // Used in tests
    internal Matcher CurrentMatcher => _cache.Value!;
    
    public override Task MatchAsync(HttpContext httpContext)
    {
        return CurrentMatcher.MatchAsync(httpContext);
    }
    
    private Matcher CreateMatcher(IReadOnlyList<Endpoint> endpoints)
    {
        var builder = _matcherBuilderFactory();
        for (var i = 0; i < endpoints.Count; i++)
        {
            // By design we only look at RouteEndpoint here. It's possible to
            // register other endpoint types, which are non-routable, and it's
            // ok that we won't route to them.
            if (endpoints[i] is RouteEndpoint endpoint && 
                endpoint.Metadata
                		.GetMetadata<ISuppressMatchingMetadata>()
                		?.SuppressMatching != true)
            {
                builder.AddEndpoint(endpoint);
            }
        }
        
        return builder.Build();
    }
    
    // Used to tie the lifetime of a DataSourceDependentCache to the service provider
    public sealed class Lifetime : IDisposable
    {
        private readonly object _lock = new object();
        private DataSourceDependentCache<Matcher>? _cache;
        private bool _disposed;
        
        public DataSourceDependentCache<Matcher>? Cache
        {
            get => _cache;
            set
            {
                lock (_lock)
                {
                    if (_disposed)
                    {
                        value?.Dispose();
                    }
                    
                    _cache = value;
                }
            }
        }
        
        public void Dispose()
        {
            lock (_lock)
            {
                _cache?.Dispose();
                _cache = null;
                
                _disposed = true;
            }
        }
    }
}

```

###### 4.8.3.1 data source dependent cache?

```c#

```

###### 4.8.3.2 suppress matching metadata?

```c#

```



#### 4.9 matcher builder

##### 4.9.1 抽象基类

* 通过注入 route endpoint 创建 matcher

```c#
internal abstract class MatcherBuilder
{
    public abstract void AddEndpoint(RouteEndpoint endpoint);    
    public abstract Matcher Build();
}

```

##### 4.9.2 dfa matcher builder

```c#
internal class DfaMatcherBuilder : MatcherBuilder
{
    // endpoint 集合
    private readonly List<RouteEndpoint> _endpoints = new List<RouteEndpoint>();
    
    private readonly ILoggerFactory _loggerFactory;
    private readonly ParameterPolicyFactory _parameterPolicyFactory;
    private readonly EndpointSelector _selector;
    private readonly IEndpointSelectorPolicy[] _endpointSelectorPolicies;
    private readonly INodeBuilderPolicy[] _nodeBuilders;
    private readonly EndpointComparer _comparer;
    internal EndpointComparer Comparer => _comparer;  
    
    // These collections are reused when building candidates
    private readonly 
        Dictionary<string, int> _assignments;
    private readonly 
        List<KeyValuePair<string, object>> _slots;
    private readonly 
        List<(string parameterName, int segmentIndex, int slotIndex)> _captures;
    private readonly 
        List<(RoutePatternPathSegment pathSegment, int segmentIndex)> _complexSegments;
    private readonly 
        List<KeyValuePair<string, IRouteConstraint>> _constraints;
    
    private int _stateIndex;
        
    internal bool UseCorrectCatchAllBehavior { get; set; }
    
    public DfaMatcherBuilder(
        ILoggerFactory loggerFactory,
        ParameterPolicyFactory parameterPolicyFactory,
        EndpointSelector selector,
        IEnumerable<MatcherPolicy> policies)
    {        
        _loggerFactory = loggerFactory;
        
        // 注入 parameter policy factory
        _parameterPolicyFactory = parameterPolicyFactory;
        // 注入 endpoint selector
        _selector = selector;
        
        if (AppContext.TryGetSwitch(
            	"Microsoft.AspNetCore.Routing.UseCorrectCatchAllBehavior", 
            	out var enabled))
        {
            UseCorrectCatchAllBehavior = enabled;
        }
        else
        {
            UseCorrectCatchAllBehavior = true; // default to correct behavior
        }
        
        // 从注入的 policies 中抽取，
        // node builder policy，endpoint comparer policy 和 endpointselector policy
        var (nodeBuilderPolicies, 
             endpointComparerPolicies, 
             endpointSelectorPolicies) = ExtractPolicies(policies.OrderBy(p => p.Order));
        
        _endpointSelectorPolicies = endpointSelectorPolicies;
        _nodeBuilders = nodeBuilderPolicies;
        
        // 创建 candidate 组件（empty）        
        _comparer = new EndpointComparer(endpointComparerPolicies);        
        _assignments = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        _slots = new List<KeyValuePair<string, object>>();
        _captures = new List<(string parameterName, int segmentIndex, int slotIndex)>();
        _complexSegments = new List<(RoutePatternPathSegment pathSegment, int segmentIndex)>();
        _constraints = new List<KeyValuePair<string, IRouteConstraint>>();
    }    
    
    private static (INodeBuilderPolicy[] nodeBuilderPolicies, 
                    IEndpointComparerPolicy[] endpointComparerPolicies, 
                    IEndpointSelectorPolicy[] endpointSelectorPolicies) 
        ExtractPolicies(IEnumerable<MatcherPolicy> policies)
    {
        var nodeBuilderPolicies = new List<INodeBuilderPolicy>();
        var endpointComparerPolicies = new List<IEndpointComparerPolicy>();
        var endpointSelectorPolicies = new List<IEndpointSelectorPolicy>();
        
        foreach (var policy in policies)
        {
            if (policy is INodeBuilderPolicy nodeBuilderPolicy)
            {
                nodeBuilderPolicies.Add(nodeBuilderPolicy);
            }
            
            if (policy is IEndpointComparerPolicy endpointComparerPolicy)
            {
                endpointComparerPolicies.Add(endpointComparerPolicy);
            }
            
            if (policy is IEndpointSelectorPolicy endpointSelectorPolicy)
            {
                endpointSelectorPolicies.Add(endpointSelectorPolicy);
            }
        }
        
        return (nodeBuilderPolicies.ToArray(), 
                endpointComparerPolicies.ToArray(), 
                endpointSelectorPolicies.ToArray());
    }
}

```

###### 4.9.2.1 add endpoint

```c#
internal class DfaMatcherBuilder : MatcherBuilder
{
    public override void AddEndpoint(RouteEndpoint endpoint)
    {
        _endpoints.Add(endpoint);
    }
}

```

###### 4.9.2.2 build

```c#
internal class DfaMatcherBuilder : MatcherBuilder
{
    public override Matcher Build()
    {
#if DEBUG
    	var includeLabel = true;
#else
	    var includeLabel = false;
#endif
    	/* a - 构建 dfa tree */
    	var root = BuildDfaTree(includeLabel);
        
        // State count is the number of nodes plus an exit state
        var stateCount = 1;
        var maxSegmentCount = 0;
        root.Visit((node) =>
        	{
                stateCount++;
                maxSegmentCount = Math.Max(maxSegmentCount, node.PathDepth);
            });
        _stateIndex = 0;
        
        // The max segment count is the maximum path-node-depth +1. We need
        // the +1 to capture any additional content after the 'last' segment.
        maxSegmentCount++;
        
        /* b - 创建 dfa state 数组 */
        var states = new DfaState[stateCount];
        var exitDestination = stateCount - 1;
        AddNode(root, states, exitDestination);
        
        // The root state only has a jump table.
        /* c - 注入 exit destination state */
        states[exitDestination] = new DfaState(
            Array.Empty<Candidate>(),
            Array.Empty<IEndpointSelectorPolicy>(),
            JumpTableBuilder.Build(exitDestination, exitDestination, null),
            null);
        
        /* 创建 dfa matcher */
        return new DfaMatcher(
            _loggerFactory.CreateLogger<DfaMatcher>(), 
            _selector, 
            states, 
            maxSegmentCount);
    }  
    
    private int AddNode(
        DfaNode node,
        DfaState[] states,
        int exitDestination)
    {
        node.Matches?.Sort(_comparer);
        
        var currentStateIndex = _stateIndex;
        
        var currentDefaultDestination = exitDestination;
        var currentExitDestination = exitDestination;
        (string text, int destination)[] pathEntries = null;
        PolicyJumpTableEdge[] policyEntries = null;
        
        if (node.Literals != null)
        {
            pathEntries = new (string text, int destination)[node.Literals.Count];
            
            var index = 0;
            foreach (var kvp in node.Literals)
            {
                var transition = Transition(kvp.Value);
                pathEntries[index++] = (kvp.Key, transition);
            }
        }
        
        if (node.Parameters != null &&
            node.CatchAll != null &&
            ReferenceEquals(node.Parameters, node.CatchAll))
        {
            // This node has a single transition to but it should accept zero-width segments
            // this can happen when a node only has catchall parameters.
            currentExitDestination 
                = currentDefaultDestination 
                = Transition(node.Parameters);
        }
        else if (node.Parameters != null && 
                 node.CatchAll != null)
        {
            // This node has a separate transition for zero-width segments
            // this can happen when a node has both parameters and catchall parameters.
            currentDefaultDestination = Transition(node.Parameters);
            currentExitDestination = Transition(node.CatchAll);
        }
        else if (node.Parameters != null)
        {
            // This node has paramters but no catchall.
            currentDefaultDestination = Transition(node.Parameters);
        }
        else if (node.CatchAll != null)
        {
            // This node has a catchall but no parameters
            currentExitDestination 
                = currentDefaultDestination 
                = Transition(node.CatchAll);
        }
        
        if (node.PolicyEdges != null && 
            node.PolicyEdges.Count > 0)
        {
            policyEntries = new PolicyJumpTableEdge[node.PolicyEdges.Count];
            
            var index = 0;
            foreach (var kvp in node.PolicyEdges)
            {
                policyEntries[index++] = new PolicyJumpTableEdge(
                    kvp.Key, 
                    Transition(kvp.Value));
            }
        }
        
        var candidates = CreateCandidates(node.Matches);
        
        // Perf: most of the time there aren't any endpoint selector policies, create
        // this lazily.
        List<IEndpointSelectorPolicy> endpointSelectorPolicies = null;
        if (node.Matches?.Count > 0)
        {
            for (var i = 0; i < _endpointSelectorPolicies.Length; i++)
            {
                var endpointSelectorPolicy = _endpointSelectorPolicies[i];
                if (endpointSelectorPolicy.AppliesToEndpoints(node.Matches))
                {
                    if (endpointSelectorPolicies == null)
                    {
                        endpointSelectorPolicies = new List<IEndpointSelectorPolicy>();
                    }
                    
                    endpointSelectorPolicies.Add(endpointSelectorPolicy);
                }
            }
        }
        
        states[currentStateIndex] = new DfaState(
            candidates,
            endpointSelectorPolicies
            	?.ToArray() ?? Array.Empty<IEndpointSelectorPolicy>(),
            JumpTableBuilder.Build(
                currentDefaultDestination, 
                currentExitDestination, 
                pathEntries),
            // Use the final exit destination when building the policy state.
            // We don't want to use either of the current destinations 
            // because they refer routing states,
            // and a policy state should never transition back to a routing state.
            BuildPolicy(exitDestination, node.NodeBuilder, policyEntries));
        
        return currentStateIndex;
        
        int Transition(DfaNode next)
        {
            // Break cycles
            if (ReferenceEquals(node, next))
            {
                return _stateIndex;
            }
            else
            {
                _stateIndex++;
                return AddNode(next, states, exitDestination);
            }
        }
    }
    
    internal Candidate[] CreateCandidates(IReadOnlyList<Endpoint> endpoints)
    {
        if (endpoints == null || endpoints.Count == 0)
        {
            return Array.Empty<Candidate>();
        }
        
        var candiates = new Candidate[endpoints.Count];
        
        var score = 0;
        var examplar = endpoints[0];
        candiates[0] = CreateCandidate(examplar, score);
        
        for (var i = 1; i < endpoints.Count; i++)
        {
            var endpoint = endpoints[i];
            if (!_comparer.Equals(examplar, endpoint))
            {
                // This endpoint doesn't have the same priority.
                examplar = endpoint;
                score++;
            }
            
            candiates[i] = CreateCandidate(endpoint, score);
        }
        
        return candiates;
    }

    internal Candidate CreateCandidate(Endpoint endpoint, int score)
    {
        (string parameterName, 
         int segmentIndex, 
         int slotIndex) catchAll = default;
        
        if (endpoint is RouteEndpoint routeEndpoint)
        {
            _assignments.Clear();
            _slots.Clear();
            _captures.Clear();
            _complexSegments.Clear();
            _constraints.Clear();
            
            foreach (var kvp in routeEndpoint.RoutePattern.Defaults)
            {
                _assignments.Add(kvp.Key, _assignments.Count);
                _slots.Add(kvp);
            }
            
            for (var i = 0; i < routeEndpoint.RoutePattern.PathSegments.Count; i++)
            {
                var segment = routeEndpoint.RoutePattern.PathSegments[i];
                if (!segment.IsSimple)
                {
                    continue;
                }
                
                var parameterPart = segment.Parts[0] as RoutePatternParameterPart;
                if (parameterPart == null)
                {
                    continue;
                }
                
                if (!_assignments.TryGetValue(
                    	parameterPart.Name, 
                    	out var slotIndex))
                {
                    slotIndex = _assignments.Count;
                    _assignments.Add(parameterPart.Name, slotIndex);
                    
                    // A parameter can have a required value, default value/catch all, 
                    // or be a normal parameter
                    // Add the required value or default value as the slot's initial value
                    if (TryGetRequiredValue(
                        	routeEndpoint.RoutePattern, 
                        	parameterPart, 
                        	out var requiredValue))
                    {
                        _slots.Add(
                            new KeyValuePair<string, object>(
                                parameterPart.Name, 
                                requiredValue));
                    }
                    else
                    {
                        var hasDefaultValue = 
                            parameterPart.Default != null || 
                            parameterPart.IsCatchAll;
                        
                        _slots.Add(hasDefaultValue 
                                       ? new KeyValuePair<string, object>(
                                           parameterPart.Name, 
                                           parameterPart.Default) 
                                   	   : default);
                    }
                }
                
                if (TryGetRequiredValue(
                    	routeEndpoint.RoutePattern, 
                    	parameterPart, 
                    	out _))
                {
                    // Don't capture a parameter if it has a required value
                    // There is no need because a parameter 
                    // with a required value is matched as a literal
                }
                else if (parameterPart.IsCatchAll)
                {
                    catchAll = (parameterPart.Name, i, slotIndex);
                }
                else
                {
                    _captures.Add((parameterPart.Name, i, slotIndex));
                }
            }
            
            for (var i = 0; i < routeEndpoint.RoutePattern.PathSegments.Count; i++)
            {
                var segment = routeEndpoint.RoutePattern.PathSegments[i];
                if (segment.IsSimple)
                {
                    continue;
                }
                
                _complexSegments.Add((segment, i));
            }
            
            foreach (var kvp in routeEndpoint.RoutePattern.ParameterPolicies)
            {
                // may be null, that's ok
                var parameter = 
                    routeEndpoint
                    	.RoutePattern
                    	.GetParameter(kvp.Key); 
                var parameterPolicyReferences = kvp.Value;
                for (var i = 0; i < parameterPolicyReferences.Count; i++)
                {
                    var reference = parameterPolicyReferences[i];
                    var parameterPolicy =
                        _parameterPolicyFactory
                        	.Create(parameter, reference);
                    if (parameterPolicy is IRouteConstraint routeConstraint)
                    {
                        _constraints.Add(
                            new KeyValuePair<string, IRouteConstraint>(
                                kvp.Key, 
                                routeConstraint));
                    }
                }
            }
            
            return new Candidate(
                endpoint,
                score,
                _slots.ToArray(),
                _captures.ToArray(),
                catchAll,
                _complexSegments.ToArray(),
                _constraints.ToArray());
        }
        else
        {
            return new Candidate(
                endpoint,
                score,
                Array.Empty<KeyValuePair<string, object>>(),
                Array.Empty<(string parameterName, int segmentIndex, int slotIndex)>(),
                catchAll,
                Array.Empty<(RoutePatternPathSegment pathSegment, int segmentIndex)>(),
                Array.Empty<KeyValuePair<string, IRouteConstraint>>());
        }
    }
    
    private static PolicyJumpTable BuildPolicy(
        int exitDestination, 
        INodeBuilderPolicy nodeBuilder, 
        PolicyJumpTableEdge[] policyEntries)
    {
        if (policyEntries == null)
        {
            return null;
        }
        
        return nodeBuilder.BuildJumpTable(exitDestination, policyEntries);
    }
}

```

###### 4.9.2.3 build dfa tree

```c#
internal class DfaMatcherBuilder : MatcherBuilder
{
    public DfaNode BuildDfaTree(bool includeLabel = false)
    {
        if (!UseCorrectCatchAllBehavior)
        {
            // In 3.0 we did a global sort of the endpoints up front. 
            // This was a bug, because we actually want
            // do do the sort at each level of the tree based on precedence.
            //
            // _useLegacy30Behavior enables opt-out via an AppContext switch.
            _endpoints.Sort(_comparer);
        }
        
        // Since we're doing a BFS we will process each 'level' of the tree in stages
        // this list will hold the set of items we need to process at the current
        // stage.
        var work = new List<(RouteEndpoint endpoint, 
                             int precedenceDigit, 
                             List<DfaNode> parents)>(_endpoints.Count);
        
        List<(RouteEndpoint endpoint, 
              int precedenceDigit, 
              List<DfaNode> parents)> previousWork = null;
        
        var root = new DfaNode() 
        { 
            PathDepth = 0, 
            Label = includeLabel ? "/" : null 
        };
        
        // To prepare for this we need to compute the max depth, as well as
        // a seed list of items to process (entry, root).
        var maxDepth = 0;
        for (var i = 0; i < _endpoints.Count; i++)
        {
            var endpoint = _endpoints[i];
            var precedenceDigit = 
                GetPrecedenceDigitAtDepth(endpoint, depth: 0);
            
            work.Add(
                (endpoint, 
                 precedenceDigit, 
                 new List<DfaNode>() { root, }));
            
            maxDepth = Math.Max(
                maxDepth, 
                endpoint.RoutePattern.PathSegments.Count);
        }
        
        var workCount = work.Count;
        
        // Sort work at each level by *PRECEDENCE OF THE CURRENT SEGMENT*.
        //
        // We build the tree by doing a BFS over the list of entries. This is important
        // because a 'parameter' node can also traverse the same paths that literal nodes
        // traverse. This means that we need to order the entries first, or else we will
        // miss possible edges in the DFA.
        //
        // We'll sort the matches again later using the *real* comparer once building the
        // precedence part of the DFA is over.
        var precedenceDigitComparer = Comparer<(RouteEndpoint endpoint, 
                                                int precedenceDigit, 
                                                List<DfaNode> parents)>
            									.Create((x, y) =>
                                                     {
                                                         return x.precedenceDigit      			  															 .CompareTo(y.precedenceDigit);
                                                     });
        
        // Now we process the entries a level at a time.
        for (var depth = 0; depth <= maxDepth; depth++)
        {
            // As we process items, collect the next set of items.
            List<(RouteEndpoint endpoint, 
                  int precedenceDigit, 
                  List<DfaNode> parents)> nextWork;
            
            var nextWorkCount = 0;
            if (previousWork == null)
            {
                nextWork = 
                    new List<(RouteEndpoint endpoint, 
                              int precedenceDigit, 
                              List<DfaNode> parents)>();
            }
            else
            {
                // Reuse previous collection for the next collection
                // Don't clear the list so nested lists can be reused
                nextWork = previousWork;
            }
            
            if (UseCorrectCatchAllBehavior)
            {
                // The fix for the 3.0 sorting behavior bug.
                
                // See comments on precedenceDigitComparer
                work.Sort(
                    0, 
                    workCount, 
                    precedenceDigitComparer);
            }
            
            for (var i = 0; i < workCount; i++)
            {
                var (endpoint, _, parents) = work[i];
                
                if (!HasAdditionalRequiredSegments(endpoint, depth))
                {
                    for (var j = 0; j < parents.Count; j++)
                    {
                        var parent = parents[j];
                        parent.AddMatch(endpoint);
                    }
                }
                
                // Find the parents of this edge at the current depth
                List<DfaNode> nextParents;
                if (nextWorkCount < nextWork.Count)
                {
                    nextParents = nextWork[nextWorkCount].parents;
                    nextParents.Clear();
                    
                    var nextPrecedenceDigit = GetPrecedenceDigitAtDepth(endpoint, depth + 1);
                    nextWork[nextWorkCount] = (endpoint, nextPrecedenceDigit, nextParents);
                }
                else
                {
                    nextParents = new List<DfaNode>();
                    
                    // Add to the next set of work now so the list will be reused
                    // even if there are no parents
                    var nextPrecedenceDigit = GetPrecedenceDigitAtDepth(endpoint, depth + 1);
                    nextWork.Add((endpoint, nextPrecedenceDigit, nextParents));
                }
                
                var segment = GetCurrentSegment(endpoint, depth);
                if (segment == null)
                {
                    continue;
                }
                
                for (var j = 0; j < parents.Count; j++)
                {
                    var parent = parents[j];
                    var part = segment.Parts[0];
                    var parameterPart = part as RoutePatternParameterPart;
                    if (segment.IsSimple && 
                        part is RoutePatternLiteralPart literalPart)
                    {
                        AddLiteralNode(
                            includeLabel, 
                            nextParents, 
                            parent, 
                            literalPart.Content);
                    }
                    else if (segment.IsSimple && 
                             parameterPart != null && 
                             parameterPart.IsCatchAll)
                    {
                        // A catch all should traverse all literal nodes 
                        // as well as parameter nodes we don't need 
                        // to create the parameter node here because of ordering
                        // all catchalls will be processed after all parameters.
                        if (parent.Literals != null)
                        {
                            nextParents.AddRange(parent.Literals.Values);
                        }
                        if (parent.Parameters != null)
                        {
                            nextParents.Add(parent.Parameters);
                        }
                        
                        // We also create a 'catchall' here. We don't do further traversals
                        // on the catchall node because only catchalls can end up here. The
                        // catchall node allows us to capture an unlimited amount of segments
                        // and also to match a zero-length segment, which a parameter node
                        // doesn't allow.
                        if (parent.CatchAll == null)
                        {
                            parent.CatchAll = new DfaNode()
                            {
                                PathDepth = parent.PathDepth + 1,
                                Label = includeLabel ? parent.Label + "{*...}/" : null,
                            };
                            
                            // The catchall node just loops.
                            parent.CatchAll.Parameters = parent.CatchAll;
                            parent.CatchAll.CatchAll = parent.CatchAll;
                        }
                        
                        parent.CatchAll.AddMatch(endpoint);
                    }
                    else if (segment.IsSimple && 
                             parameterPart != null && 
                             TryGetRequiredValue(
                                 endpoint.RoutePattern, 
                                 parameterPart, 
                                 out var requiredValue))
                    {
                        // If the parameter has a matching required value, 
                        // replace the parameter with the required value as a literal. 
                        // This should use the parameter's transformer (if present) e.g. 
                        // Template: Home/{action}, 
                        // Required values: { action = "Index" }, Result: Home/Index
                        
                        if (endpoint
                            	.RoutePattern
                            	.ParameterPolicies
                            	.TryGetValue(
                                    parameterPart.Name, 
                                    out var parameterPolicyReferences))
                        {
                            for (var k = 0; k < parameterPolicyReferences.Count; k++)
                            {
                                var reference = parameterPolicyReferences[k];
                                var parameterPolicy = _parameterPolicyFactory.Create(
                                    parameterPart, 
                                    reference);
                                if (parameterPolicy is 
                                    IOutboundParameterTransformer parameterTransformer)
                                {
                                    requiredValue = parameterTransformer
                                        .TransformOutbound(requiredValue);
                                    break;
                                }
                            }
                        }
                        
                        var literalValue = requiredValue
                            ?.ToString() 
                            ?? throw new InvalidOperationException(
                            	$"Required value for literal '{parameterPart.Name}' 
                            	"must evaluate to a non-null string.");
                        
                        AddLiteralNode(
                            includeLabel, 
                            nextParents, 
                            parent, 
                            literalValue);
                    }
                    else if (segment.IsSimple && 
                             parameterPart != null)
                    {
                        if (parent.Parameters == null)
                        {
                            parent.Parameters = new DfaNode()
                            {
                                PathDepth = parent.PathDepth + 1,
                                Label = includeLabel ? parent.Label + "{...}/" : null,
                            };
                        }
                        
                        // A parameter should traverse all literal nodes 
                        // as well as the parameter node
                        if (parent.Literals != null)
                        {
                            nextParents.AddRange(parent.Literals.Values);
                        }
                        nextParents.Add(parent.Parameters);
                    }
                    else
                    {
                        // Complex segment - we treat these are parameters here and do the
                        // expensive processing later. We don't want to spend time processing
                        // complex segments unless they are the best match, and treating them
                        // like parameters in the DFA allows us to do just that.
                        if (parent.Parameters == null)
                        {
                            parent.Parameters = new DfaNode()
                            {
                                PathDepth = parent.PathDepth + 1,
                                Label = includeLabel ? parent.Label + "{...}/" : null,
                            };
                        }
                        
                        if (parent.Literals != null)
                        {
                            nextParents.AddRange(parent.Literals.Values);
                        }
                        nextParents.Add(parent.Parameters);
                    }
                }
                
                if (nextParents.Count > 0)
                {
                    nextWorkCount++;
                }
            }
            
            // Prepare the process the next stage.
            previousWork = work;
            work = nextWork;
            workCount = nextWorkCount;
        }
        
        // Build the trees of policy nodes (like HTTP methods). Post-order traversal
        // means that we won't have infinite recursion.
        root.Visit(ApplyPolicies);
        
        return root;
    }       
    
    private static int GetPrecedenceDigitAtDepth(
        RouteEndpoint endpoint, 
        int depth)
    {
        var segment = GetCurrentSegment(endpoint, depth);
        if (segment is null)
        {
            // Treat "no segment" as high priority. 
            // it won't effect the algorithm, but we need to define a sort-order.
            return 0;
        }
        
        return RoutePrecedence.ComputeInboundPrecedenceDigit(
            endpoint.RoutePattern, 
            segment);
    }
    
    private static bool HasAdditionalRequiredSegments(
        RouteEndpoint endpoint, 
        int depth)
    {
        for (var i = depth; i < endpoint.RoutePattern
             							.PathSegments
             							.Count; i++)
        {
            var segment = endpoint.RoutePattern
                				  .PathSegments[i];
            if (!segment.IsSimple)
            {
                // Complex segments always require more processing
                return true;
            }
            
            var parameterPart = segment.Parts[0] as RoutePatternParameterPart;
            if (parameterPart == null)
            {
                // It's a literal
                return true;
            }
            
            if (!parameterPart.IsOptional &&
                !parameterPart.IsCatchAll &&
                parameterPart.Default == null)
            {
                return true;
            }
        }
        
        return false;
    }
    
    private static RoutePatternPathSegment GetCurrentSegment(
        RouteEndpoint endpoint, 
        int depth)
    {
        if (depth < endpoint.RoutePattern
            				.PathSegments
            				.Count)
        {
            return endpoint.RoutePattern
                		   .PathSegments[depth];
        }
        
        if (endpoint.RoutePattern.PathSegments.Count == 0)
        {
            return null;
        }
        
        var lastSegment = endpoint.RoutePattern
            					  .PathSegments[endpoint.RoutePattern
                                                		.PathSegments.Count - 1];
        
        if (lastSegment.IsSimple && 
            lastSegment.Parts[0] is RoutePatternParameterPart parameterPart && 
            parameterPart.IsCatchAll)
        {
            return lastSegment;
        }
        
        return null;
    }
    
    private static void AddLiteralNode(
        bool includeLabel, 
        List<DfaNode> nextParents, 
        DfaNode parent, 
        string literal)
    {
        DfaNode next = null;
        if (parent.Literals == null ||
            !parent.Literals.TryGetValue(literal, out next))
        {
            next = new DfaNode()
            {
                PathDepth = parent.PathDepth + 1,
                Label = includeLabel ? parent.Label + literal + "/" : null,
            };
            parent.AddLiteral(literal, next);
        }
        
        nextParents.Add(next);
    }
    
    private static bool TryGetRequiredValue(
        RoutePattern routePattern, 
        RoutePatternParameterPart parameterPart, 
        out object value)
    {
        if (!routePattern
            	.RequiredValues
            	.TryGetValue(parameterPart.Name, out value))
        {
            return false;
        }
        
        return !RouteValueEqualityComparer
            .Default
            .Equals(value, string.Empty);
    }
    
    private void ApplyPolicies(DfaNode node)
    {
        if (node.Matches == null || node.Matches.Count == 0)
        {
            return;
        }
        
        // We're done with the precedence based work. Sort the endpoints
        // before applying policies for simplicity in policy-related code.
        node.Matches.Sort(_comparer);
        
        // Start with the current node as the root.
        var work = new List<DfaNode>() { node, };
        List<DfaNode> previousWork = null;
        for (var i = 0; i < _nodeBuilders.Length; i++)
        {
            var nodeBuilder = _nodeBuilders[i];
            
            // Build a list of each
            List<DfaNode> nextWork;
            if (previousWork == null)
            {
                nextWork = new List<DfaNode>();
            }
            else
            {
                // Reuse previous collection for the next collection
                previousWork.Clear();
                nextWork = previousWork;
            }
            
            for (var j = 0; j < work.Count; j++)
            {
                var parent = work[j];
                if (!nodeBuilder
                    	.AppliesToEndpoints(
                            parent.Matches 
                            	?? (IReadOnlyList<Endpoint>)Array.Empty<Endpoint>()))
                {
                    // This node-builder doesn't care about this node, so add it to the list
                    // to be processed by the next node-builder.
                    nextWork.Add(parent);
                    continue;
                }
                
                // This node-builder does apply to this node, 
                // so we need to create new nodes for each edge,
                // and then attach them to the parent.
                var edges = nodeBuilder.GetEdges(
                    parent.Matches 
                    	?? (IReadOnlyList<Endpoint>)Array.Empty<Endpoint>());
                for (var k = 0; k < edges.Count; k++)
                {
                    var edge = edges[k];
                    
                    var next = new DfaNode()
                    {
                        // If parent label is null then labels are not being included
                        Label = (parent.Label != null) 
                            ? parent.Label + " " + edge.State.ToString() 
                            : null,
                    };
                    
                    if (edge.Endpoints.Count > 0)
                    {
                        next.AddMatches(edge.Endpoints);
                    }
                    nextWork.Add(next);
                    
                    parent.AddPolicyEdge(edge.State, next);
                }
                
                // Associate the node-builder so we can build a jump table later.
                parent.NodeBuilder = nodeBuilder;
                
                // The parent no longer has matches, it's not considered a terminal node.
                parent.Matches?.Clear();
            }
            
            previousWork = work;
            work = nextWork;
        }
    }                        
}

```

#### 4.10 dfa matcher factory

##### 4.10.1 matcher factory

* 通过 endpoint data source 创建 matcher

```c#
internal abstract class MatcherFactory
{
    public abstract Matcher CreateMatcher(EndpointDataSource dataSource);
}

```

##### 4.10.2 dfa matcher factory

```c#
internal class DfaMatcherFactory : MatcherFactory
{
    private readonly IServiceProvider _services;
    
    // Using the service provider here so we can avoid coupling to the dependencies
    // of DfaMatcherBuilder.
    public DfaMatcherFactory(IServiceProvider services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        _services = services;
    }
    
    public override Matcher CreateMatcher(EndpointDataSource dataSource)
    {
        if (dataSource == null)
        {
            throw new ArgumentNullException(nameof(dataSource));
        }
        
        // Creates a tracking entry in DI to stop listening for change events
        // when the services are disposed.
        var lifetime = _services.GetRequiredService<DataSourceDependentMatcher.Lifetime>();
        
        return new DataSourceDependentMatcher(
            dataSource, 
            lifetime, 
            () =>
            	{
                    return _services.GetRequiredService<DfaMatcherBuilder>();
                });
    }
}

```

#### 4.11 link generator

* 创建 virtual path（反向路由）

  

#### 4.6 use (endpoint) routing

##### 4.6.1 use routing

```c#
public static class EndpointRoutingApplicationBuilderExtensions
{
    private const string EndpointRouteBuilder = "__EndpointRouteBuilder";
    
    public static IApplicationBuilder UseRouting(
        this IApplicationBuilder builder)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }
        
        // 确认 routing service 已经注册
        VerifyRoutingServicesAreRegistered(builder);
        
        // 创建 default endpoint route builder
        var endpointRouteBuilder = new DefaultEndpointRouteBuilder(builder);
        // 将 default endpoint route builder 注入 IApplicationBuilder
        builder.Properties[EndpointRouteBuilder] = endpointRouteBuilder;
        
        // 注入 endpoint routing middleware
        return builder.UseMiddleware<EndpointRoutingMiddleware>(endpointRouteBuilder);
    }
}

```

###### 4.6.1.1 routing middleware

* 使用 matcher 择匹配的 endpoint 注入 http context

```c#
internal sealed class EndpointRoutingMiddleware
{
    private const string 
        DiagnosticsEndpointMatchedKey = "Microsoft.AspNetCore.Routing.EndpointMatched";
    
    private readonly MatcherFactory _matcherFactory;
    private readonly ILogger _logger;
    private readonly EndpointDataSource _endpointDataSource;
    private readonly DiagnosticListener _diagnosticListener;
    private readonly RequestDelegate _next;
    
    private Task<Matcher>? _initializationTask;
    
    public EndpointRoutingMiddleware(
        MatcherFactory matcherFactory,
        ILogger<EndpointRoutingMiddleware> logger,
        IEndpointRouteBuilder endpointRouteBuilder,
        DiagnosticListener diagnosticListener,
        RequestDelegate next)
    {
        if (endpointRouteBuilder == null)
        {
            throw new ArgumentNullException(nameof(endpointRouteBuilder));
        }
        
        // 注入服务
        _matcherFactory = matcherFactory 
            ?? throw new ArgumentNullException(nameof(matcherFactory));
        _logger = logger 
            ?? throw new ArgumentNullException(nameof(logger));
        _diagnosticListener = diagnosticListener 
            ?? throw new ArgumentNullException(nameof(diagnosticListener));
        _next = next 
            ?? throw new ArgumentNullException(nameof(next));    
        
        // 创建 endpoint data source（默认值，empty）
        _endpointDataSource = new CompositeEndpointDataSource(
            endpointRouteBuilder.DataSources);
    }
    
    public Task Invoke(HttpContext httpContext)
    {
        /* 如果 http context 中已经注入了 endpoint，返回 */
        // There's already an endpoint, skip matching completely
        var endpoint = httpContext.GetEndpoint();
        if (endpoint != null)
        {
            Log.MatchSkipped(_logger, endpoint);
            return _next(httpContext);
        }
        
        /* 找到适合的 endpoint */           
        
        // There's an inherent race condition between
        // waiting for init and accessing the matcher
        // this is OK because once `_matcher` is initialized, it will not be set to null again.
        var matcherTask = InitializeAsync();
        if (!matcherTask.IsCompletedSuccessfully)
        {
            // matcher task 赢得异步执行
            return AwaitMatcher(this, httpContext, matcherTask);
        }
        
        var matchTask = matcherTask.Result.MatchAsync(httpContext);
        if (!matchTask.IsCompletedSuccessfully)
        {
            // match task 赢得异步执行
            return AwaitMatch(this, httpContext, matchTask);
        }
        
        return SetRoutingAndContinue(httpContext);
        
        // Awaited fallbacks for when the Tasks do not synchronously complete
        static async Task AwaitMatcher(
            EndpointRoutingMiddleware middleware, 
            HttpContext httpContext, 
            Task<Matcher> matcherTask)
        {
            var matcher = await matcherTask;
            await matcher.MatchAsync(httpContext);
            await middleware.SetRoutingAndContinue(httpContext);
        }
        
        static async Task AwaitMatch(
            EndpointRoutingMiddleware middleware, 
            HttpContext httpContext, 
            Task matchTask)
        {
            await matchTask;
            await middleware.SetRoutingAndContinue(httpContext);
        }        
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Task SetRoutingAndContinue(HttpContext httpContext)
    {
        // If there was no mutation of the endpoint then log failure
        var endpoint = httpContext.GetEndpoint();
        if (endpoint == null)
        {
            Log.MatchFailure(_logger);
        }
        else
        {
            // Raise an event if the route matched
            if (_diagnosticListener.IsEnabled() && 
                _diagnosticListener.IsEnabled(DiagnosticsEndpointMatchedKey))
            {
                // We're just going to send the HttpContext 
                // since it has all of the relevant information
                _diagnosticListener.Write(DiagnosticsEndpointMatchedKey, httpContext);
            }
            
            Log.MatchSuccess(_logger, endpoint);
        }
        
        return _next(httpContext);
    }
    
    /* 从 matcher factory 解析 matcher */
    
    // Initialization is async to avoid blocking threads while reflection and things
    // of that nature take place.
    //
    // We've seen cases where startup is very slow if we  allow multiple threads to race
    // while initializing the set of endpoints/routes. Doing CPU intensive work is a
    // blocking operation if you have a low core count and enough work to do.
    private Task<Matcher> InitializeAsync()
    {
        var initializationTask = _initializationTask;
        if (initializationTask != null)
        {
            return initializationTask;
        }
        
        return InitializeCoreAsync();
    }
    
    private Task<Matcher> InitializeCoreAsync()
    {
        var initialization = 
            new TaskCompletionSource<Matcher>(
	            TaskCreationOptions.RunContinuationsAsynchronously);
        var initializationTask = 
            Interlocked.CompareExchange(
            	ref _initializationTask, 
            initialization.Task, null);
        
        if (initializationTask != null)
        {
            // This thread lost the race, join the existing task.
            return initializationTask;
        }
        
        // This thread won the race, do the initialization.
        try
        {
            var matcher = _matcherFactory.CreateMatcher(_endpointDataSource);
            
            // Now replace the initialization task with one created 
            // with the default execution context.
            // This is important because capturing the execution context 
            // will leak memory in ASP.NET Core.
            using (ExecutionContext.SuppressFlow())
            {
                _initializationTask = Task.FromResult(matcher);
            }
            
            // Complete the task, 
            // this will unblock any requests that came in while initializing.
            initialization.SetResult(matcher);
            return initialization.Task;
        }
        catch (Exception ex)
        {
            // Allow initialization to occur again. Since DataSources can change, it's possible
            // for the developer to correct the data causing the failure.
            _initializationTask = null;
            
            // Complete the task, 
            // this will throw for any requests that came in while initializing.
            initialization.SetException(ex);
            return initialization.Task;
        }
    }
    
#nullable disable
    private static class Log
    {
        private static readonly Action<ILogger, string, Exception> 
            _matchSuccess = LoggerMessage.Define<string>(
            	LogLevel.Debug,
	            new EventId(1, "MatchSuccess"),
    	        "Request matched endpoint '{EndpointName}'");
        
        private static readonly Action<ILogger, Exception> 
            _matchFailure = LoggerMessage.Define(
	            LogLevel.Debug,
    	        new EventId(2, "MatchFailure"),
        	    "Request did not match any endpoints");
        
        private static readonly Action<ILogger, string, Exception> 
            _matchingSkipped = LoggerMessage.Define<string>(
            	LogLevel.Debug,
	            new EventId(3, "MatchingSkipped"),
    	        "Endpoint '{EndpointName}' already set, skipping route matching.");
        
        public static void MatchSuccess(ILogger logger, Endpoint endpoint)
        {
            _matchSuccess(logger, endpoint.DisplayName, null);
        }
        
        public static void MatchFailure(ILogger logger)
        {
            _matchFailure(logger, null);
        }
        
        public static void MatchSkipped(ILogger logger, Endpoint endpoint)
        {
            _matchingSkipped(logger, endpoint.DisplayName, null);
        }
    }
}

```

##### 4.6.2 use endpoint

```c#
public static class EndpointRoutingApplicationBuilderExtensions
{
    private const string EndpointRouteBuilder = "__EndpointRouteBuilder";
    
    public static IApplicationBuilder UseEndpoints(
        this IApplicationBuilder builder, 
        Action<IEndpointRouteBuilder> configure)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (configure == null)
        {
            throw new ArgumentNullException(nameof(configure));
        
        }
        
        // 确认 routing service 已经注册
        VerifyRoutingServicesAreRegistered(builder);
        
        /* 确认已经调用了 use routing，
           此时可以使用注入的 use routing 方法创建的 endpoint route builder，
           从而保证是 endpoint route builder 是 global，
           此处（use endpoint 方法）注入的 endpoint 可以在 use routing 发现并匹配 request */
        VerifyEndpointRoutingMiddlewareIsRegistered(builder, out var endpointRouteBuilder);
        
        // 配置 endpoint route builder，即注入 endpoint
        configure(endpointRouteBuilder);
                
        // Yes, this mutates an IOptions. 
        // We're registering data sources in a global collection which
        // can be used for discovery of endpoints or URL generation.
        //
        // Each middleware gets its own collection of data sources, 
        // and all of those data sources also get added to a global collection.
        
        /* 将 endpoint route builder 的 endpoint data source 注入 route options */
        
        // 解析 route options
        var routeOptions = builder.ApplicationServices
            					  .GetRequiredService<IOptions<RouteOptions>>();
        // 遍历 endpoint route builder 的 data source，
        // 注入 route options 的 value
        foreach (var dataSource in endpointRouteBuilder.DataSources)
        {
            routeOptions.Value.EndpointDataSources.Add(dataSource);
        }
        
        // 注入 endpoint middleware 
        return builder.UseMiddleware<EndpointMiddleware>();
    }
}

```

###### 4.6.2.1 endpoint middleware

```c#
internal sealed class EndpointMiddleware
{
    internal const string 
        AuthorizationMiddlewareInvokedKey = 
        	"__AuthorizationMiddlewareWithEndpointInvoked";
    internal const string 
        CorsMiddlewareInvokedKey = 
        	"__CorsMiddlewareWithEndpointInvoked";
    
    private readonly ILogger _logger;
    private readonly RequestDelegate _next;
    private readonly RouteOptions _routeOptions;
    
    public EndpointMiddleware(
        ILogger<EndpointMiddleware> logger,
        RequestDelegate next,
        IOptions<RouteOptions> routeOptions)
    {
        _logger = logger 
            ?? throw new ArgumentNullException(nameof(logger));
        _next = next 
            ?? throw new ArgumentNullException(nameof(next));
        _routeOptions = routeOptions?.Value 
            ?? throw new ArgumentNullException(nameof(routeOptions));
    }
    
    public Task Invoke(HttpContext httpContext)
    {
        var endpoint = httpContext.GetEndpoint();
        if (endpoint?.RequestDelegate != null)
        {
            // 如果 route options 标记了 suppres check for unhandle security
            if (!_routeOptions.SuppressCheckForUnhandledSecurityMetadata)
            {
                // 如果 endpoint 包含 IAuthordata，
                // 但是 httpContext 的 items 没有注入对应的 key --
                //   “__AuthorizationMiddlewareWithEndpointInvoked”，抛出异常                
                if (endpoint.Metadata
	                    	.GetMetadata<IAuthorizeData>() != null &&
                    !httpContext.Items
		                    	.ContainsKey(AuthorizationMiddlewareInvokedKey))
                {
                    ThrowMissingAuthMiddlewareException(endpoint);
                }
                
                // 如果 endpoint 包含 ICorsMetadata，
                // 但是 http context 的 items 没有注入对应的 key --
                //   “__CorsMiddlewareWithEndpointInvoked”，抛出异常                
                if (endpoint.Metadata
                    		.GetMetadata<ICorsMetadata>() != null &&
                    !httpContext.Items
	                    	.ContainsKey(CorsMiddlewareInvokedKey))
                {
                    ThrowMissingCorsMiddlewareException(endpoint);
                }
            }
            
            Log.ExecutingEndpoint(_logger, endpoint);
            
            try
            {
                // 获取 endpoint 中的的 request delegate 并执行
                var requestTask = endpoint.RequestDelegate(httpContext);
                if (!requestTask.IsCompletedSuccessfully)
                {
                    return AwaitRequestTask(endpoint, requestTask, _logger);
                }
            }
            catch (Exception exception)
            {
                Log.ExecutedEndpoint(_logger, endpoint);
                return Task.FromException(exception);
            }
            
            Log.ExecutedEndpoint(_logger, endpoint);
            return Task.CompletedTask;
        }
        
        return _next(httpContext);
        
        // 异步执行等待
        static async Task AwaitRequestTask(
            Endpoint endpoint, 
            Task requestTask, 
            ILogger logger)
        {
            try
            {
                await requestTask;
            }
            finally
            {
                Log.ExecutedEndpoint(logger, endpoint);
            }
        }
    }
    
    private static void ThrowMissingAuthMiddlewareException(Endpoint endpoint)
    {
        throw new InvalidOperationException(
            $"Endpoint {endpoint.DisplayName} contains authorization metadata, " +                         "but a middleware was not found that supports authorization." +                                 Environment.NewLine +
            "Configure your application startup by adding app.UseAuthorization() inside the all to Configure(..) in the application startup code. The call to app.UseAuthorization() must appear between app.UseRouting() and app.UseEndpoints(...).");
    }
    
    private static void ThrowMissingCorsMiddlewareException(Endpoint endpoint)
    {
        throw new InvalidOperationException(
            $"Endpoint {endpoint.DisplayName} contains CORS metadata, " +                                   "but a middleware was not found that supports CORS." +                                         Environment.NewLine +
            "Configure your application startup by adding app.UseCors() inside the call to Configure(..) in the application startup code. The call to app.UseCors() must appear between app.UseRouting() and app.UseEndpoints(...).");
    }
    
#nullable disable
    private static class Log
    {
        private static readonly Action<ILogger, string, Exception> 
            _executingEndpoint = LoggerMessage.Define<string>(
            	LogLevel.Information,
            	new EventId(0, "ExecutingEndpoint"),
            	"Executing endpoint '{EndpointName}'");
        
        private static readonly Action<ILogger, string, Exception> 
            _executedEndpoint = LoggerMessage.Define<string>(
            	LogLevel.Information,
            	new EventId(1, "ExecutedEndpoint"),
            	"Executed endpoint '{EndpointName}'");
        
        public static void ExecutingEndpoint(ILogger logger, Endpoint endpoint)
        {
            _executingEndpoint(logger, endpoint.DisplayName, null);
        }
        
        public static void ExecutedEndpoint(ILogger logger, Endpoint endpoint)
        {
            _executedEndpoint(logger, endpoint.DisplayName, null);
        }
    }
}

```



### 5. services

#### 5.1 add routing

```c#
public static class RoutingServiceCollectionExtensions
{
    // add routing
    public static IServiceCollection AddRouting(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        // 注入 inline constraint resolver
        services.TryAddTransient<
            IInlineConstraintResolver, 
        	DefaultInlineConstraintResolver>();
        
        // 注入 uri building context (object pool)
        services.TryAddTransient<
            ObjectPoolProvider, 
        	DefaultObjectPoolProvider>();
        services.TryAddSingleton<ObjectPool<UriBuildingContext>>(s =>
        	{
                var provider = s.GetRequiredService<ObjectPoolProvider>();
                return provider.Create<UriBuildingContext>(
                    new UriBuilderContextPooledObjectPolicy());
            });

        // The TreeRouteBuilder is a builder for creating routes, 
        // it should stay transient because it's stateful.
        
        // 注入 tree router builder
        services.TryAdd(ServiceDescriptor.Transient<TreeRouteBuilder>(s =>
        	{
                var loggerFactory = s.GetRequiredService<ILoggerFactory>();
                var objectPool = s.GetRequiredService<ObjectPool<UriBuildingContext>>();
                var constraintResolver = s.GetRequiredService<IInlineConstraintResolver>();
                return new TreeRouteBuilder(loggerFactory, objectPool, constraintResolver);
            }));

        // 注入 routing marker service
        services.TryAddSingleton(typeof(RoutingMarkerService));
        
        // Setup global collection of endpoint data sources
        
        // 注入 route options，包含 endpoint data source 集合
        var dataSources = new ObservableCollection<EndpointDataSource>();
        services.TryAddEnumerable(
            ServiceDescriptor
            	.Transient<IConfigureOptions<RouteOptions>, ConfigureRouteOptions>(
                    serviceProvider => new ConfigureRouteOptions(dataSources)));
        
        // Allow global access to the list of endpoints.
        services.TryAddSingleton<EndpointDataSource>(s =>
        	{
                // Call internal ctor and pass global collection
                return new CompositeEndpointDataSource(dataSources);
            });
        
        //
        // Default matcher implementation
        //
        services.TryAddSingleton<ParameterPolicyFactory, DefaultParameterPolicyFactory>();
        services.TryAddSingleton<MatcherFactory, DfaMatcherFactory>();
        services.TryAddTransient<DfaMatcherBuilder>();
        services.TryAddSingleton<DfaGraphWriter>();
        services.TryAddTransient<DataSourceDependentMatcher.Lifetime>();
        services.TryAddSingleton<EndpointMetadataComparer>(services =>
        	{
                // This has no public constructor. 
                return new EndpointMetadataComparer(services);
            });
        //
        // Link generation related services
        //
        services.TryAddSingleton<LinkGenerator, DefaultLinkGenerator>();
        services.TryAddSingleton<
            IEndpointAddressScheme<string>, EndpointNameAddressScheme>();
        services.TryAddSingleton<
            IEndpointAddressScheme<RouteValuesAddress>, RouteValuesAddressScheme>();
        services.TryAddSingleton<LinkParser, DefaultLinkParser>();
        
        //
        // Endpoint Selection
        //
        services.TryAddSingleton<EndpointSelector, DefaultEndpointSelector>();
        services.TryAddEnumerable(
            ServiceDescriptor.Singleton<MatcherPolicy, HttpMethodMatcherPolicy>());
        services.TryAddEnumerable(
            ServiceDescriptor.Singleton<MatcherPolicy, HostMatcherPolicy>());
        
        // 注入 template binder
        services.TryAddSingleton<TemplateBinderFactory, DefaultTemplateBinderFactory>();
        // 注入 route pattern transformer
        services.TryAddSingleton<RoutePatternTransformer, DefaultRoutePatternTransformer>();
        return services;
    }
    
    // add routing by action    
    public static IServiceCollection AddRouting(
        this IServiceCollection services,
        Action<RouteOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        services.Configure(configureOptions);
        services.AddRouting();
        
        return services;
    }
}

```

##### 5.1.1 route options

```c#
public class RouteOptions
{    
    /* endpoint data source */
    
    private ICollection<EndpointDataSource> _endpointDataSources = default!;            
    internal ICollection<EndpointDataSource> EndpointDataSources
    {
        get
        {
            // IOptions<RouteOptions> 在 routing service 中注册
            Debug.Assert(
                _endpointDataSources != null, 
                "Endpoint data sources should have been set in DI.");
            return _endpointDataSources;
        }
        
        set => _endpointDataSources = value;
    }
    
    /* constraint */
    
    private IDictionary<string, Type> _constraintTypeMap = GetDefaultConstraintMap();  
    private static IDictionary<string, Type> GetDefaultConstraintMap()
    {
        var defaults = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
        
        // Type-specific constraints
        AddConstraint<IntRouteConstraint>(defaults, "int");
        AddConstraint<BoolRouteConstraint>(defaults, "bool");
        AddConstraint<DateTimeRouteConstraint>(defaults, "datetime");
        AddConstraint<DecimalRouteConstraint>(defaults, "decimal");
        AddConstraint<DoubleRouteConstraint>(defaults, "double");
        AddConstraint<FloatRouteConstraint>(defaults, "float");
        AddConstraint<GuidRouteConstraint>(defaults, "guid");
        AddConstraint<LongRouteConstraint>(defaults, "long");
        
        // Length constraints
        AddConstraint<MinLengthRouteConstraint>(defaults, "minlength");
        AddConstraint<MaxLengthRouteConstraint>(defaults, "maxlength");
        AddConstraint<LengthRouteConstraint>(defaults, "length");
        
        // Min/Max value constraints
        AddConstraint<MinRouteConstraint>(defaults, "min");
        AddConstraint<MaxRouteConstraint>(defaults, "max");
        AddConstraint<RangeRouteConstraint>(defaults, "range");
        
        // Regex-based constraints
        AddConstraint<AlphaRouteConstraint>(defaults, "alpha");
        AddConstraint<RegexInlineRouteConstraint>(defaults, "regex");
        
        AddConstraint<RequiredRouteConstraint>(defaults, "required");
        
        // Files
        AddConstraint<FileNameRouteConstraint>(defaults, "file");
        AddConstraint<NonFileNameRouteConstraint>(defaults, "nonfile");
        
        return defaults;
    }        
    // This API could be exposed on RouteOptions
    private static void AddConstraint<
        [DynamicallyAccessedMembers(
            DynamicallyAccessedMemberTypes.PublicConstructors)]TConstraint>(
        Dictionary<string, Type> constraintMap, 
        string text) 
        	where TConstraint : IRouteConstraint
    {
        constraintMap[text] = typeof(TConstraint);
    }
    // constraint map
    public IDictionary<string, Type> ConstraintMap
    {
        get
        {
            return _constraintTypeMap;
        }
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(ConstraintMap));
            }
            
            _constraintTypeMap = value;
        }
    }
    
    /* for link generator */
    
    public bool LowercaseUrls { get; set; }            
    public bool LowercaseQueryStrings { get; set; }           
    public bool AppendTrailingSlash { get; set; }       
    public bool SuppressCheckForUnhandledSecurityMetadata { get; set; }        
}

```

##### 5.1.2 configure route options

```c#
internal class ConfigureRouteOptions : IConfigureOptions<RouteOptions>
{
    private readonly ICollection<EndpointDataSource> _dataSources;
    
    public ConfigureRouteOptions(ICollection<EndpointDataSource> dataSources)
    {
        if (dataSources == null)
        {
            throw new ArgumentNullException(nameof(dataSources));
        }
        
        _dataSources = dataSources;
    }
    
    public void Configure(RouteOptions options)
    {
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        options.EndpointDataSources = _dataSources;
    }
}

```

##### 5.1.3 routing marker service

```c#

```

