### 1. http basic info

#### 1.1 version



#### 1.2 http version policy

```c#
public enum HttpVersionPolicy
{        
    // Note that this option does not allow use of prenegotiated clear text connection, e.g. H2C.   
    RequestVersionOrLower,
          
    // Note that this option allows to use prenegotiated clear text connection for the requested version but not for anything higher.   
    RequestVersionOrHigher,
               
    // Note that this option allows to use prenegotiated clear text connection for the requested version.   
    RequestVersionExact
}

```

#### 1.3 http method

```c#
public partial class HttpMethod : IEquatable<HttpMethod>
{   
    // "get"
    private static readonly HttpMethod s_getMethod = 
        new HttpMethod("GET", http3StaticTableIndex: H3StaticTable.MethodGet);
    
    public static HttpMethod Get
    {
        get { return s_getMethod; }
    }    
    
    // "put"
    private static readonly HttpMethod s_putMethod = 
        new HttpMethod("PUT", http3StaticTableIndex: H3StaticTable.MethodPut);
    
    public static HttpMethod Put
    {
        get { return s_putMethod; }
    }    
    
    // "post"
    private static readonly HttpMethod s_postMethod = 
        new HttpMethod("POST", http3StaticTableIndex: H3StaticTable.MethodPost);
    
    public static HttpMethod Post
    {
        get { return s_postMethod; }
    }    
    
    // "delete"
    private static readonly HttpMethod s_deleteMethod = 
        new HttpMethod("DELETE", http3StaticTableIndex: H3StaticTable.MethodDelete);
    
    public static HttpMethod Delete
    {
        get { return s_deleteMethod; }
    }    
    
    // "head"
    private static readonly HttpMethod s_headMethod = 
        new HttpMethod("HEAD", http3StaticTableIndex: H3StaticTable.MethodHead);
    
    public static HttpMethod Head
    {
        get { return s_headMethod; }
    }
    
    // "options"
    private static readonly HttpMethod s_optionsMethod = 
        new HttpMethod("OPTIONS", http3StaticTableIndex: H3StaticTable.MethodOptions);
    
    public static HttpMethod Options
    {
        get { return s_optionsMethod; }
    }
    
    // "trace"
    private static readonly HttpMethod s_traceMethod = 
        new HttpMethod("TRACE", -1);
    
    public static HttpMethod Trace
    {
        get { return s_traceMethod; }
    }
    
    // "patch"
    private static readonly HttpMethod s_patchMethod = 
        new HttpMethod("PATCH", -1);
    
    public static HttpMethod Patch
    {
        get { return s_patchMethod; }
    }
    
    // "connect"
    private static readonly HttpMethod s_connectMethod = 
        new HttpMethod("CONNECT", http3StaticTableIndex: H3StaticTable.MethodConnect);
    
    internal static HttpMethod Connect
    {
        get { return s_connectMethod; }
    }
    
    
    
    private readonly string _method;
    public string Method
    {
        get { return _method; }
    }
    
    private int _hashcode;
    private readonly int? _http3Index;    
    
    // ctor                                                      
    public HttpMethod(string method)
    {
        if (string.IsNullOrEmpty(method))
        {
            throw new ArgumentException(SR.net_http_argument_empty_string, nameof(method));
        }
        if (HttpRuleParser.GetTokenLength(method, 0) != method.Length)
        {
            throw new FormatException(SR.net_http_httpmethod_format_error);
        }
        
        _method = method;
    }
    
    private HttpMethod(string method, int http3StaticTableIndex)
    {
        _method = method;
        _http3Index = http3StaticTableIndex;
    }
    
#region IEquatable<HttpMethod> Members
    public bool Equals([NotNullWhen(true)] HttpMethod? other)
    {
        if (other is null)
        {
            return false;
        }
        
        if (object.ReferenceEquals(_method, other._method))
        {
            // Strings are static, so there is a good chance that two equal methods use the same reference
            // (unless they differ in case).
            return true;
        }
        
        return string.Equals(_method, other._method, StringComparison.OrdinalIgnoreCase);
    }    
#endregion

    public override bool Equals([NotNullWhen(true)] object? obj)
    {
        return Equals(obj as HttpMethod);
    }
        
    public override int GetHashCode()
    {
        if (_hashcode == 0)
        {
            _hashcode = StringComparer.OrdinalIgnoreCase.GetHashCode(_method);
        }
        
        return _hashcode;
    }
    
    public override string ToString()
    {
        return _method;
    }
    
    public static bool operator ==(HttpMethod? left, HttpMethod? right)
    {
        return left is null || right is null 
            ? ReferenceEquals(left, right) 
            : left.Equals(right);
    }
    
    public static bool operator !=(HttpMethod? left, HttpMethod? right)
    {
        return !(left == right);
    }
    
        
    // Returns a singleton method instance with a capitalized method name for the supplied method if it's known; 
    // otherwise, returns the original.       
    internal static HttpMethod Normalize(HttpMethod method)
    {
        Debug.Assert(method != null);
        Debug.Assert(!string.IsNullOrEmpty(method._method));
        
        // _http3Index is only set for the singleton instances, so if it's not null,
        // we can avoid the lookup.  Otherwise, look up the method instance and return the
        // normalized instance if it's found.
        
        if (method._http3Index is null && method._method.Length >= 3) // 3 == smallest known method
        {
            HttpMethod? match = (method._method[0] | 0x20) switch
            	{
                    'c' => s_connectMethod,
                    'd' => s_deleteMethod,
                    'g' => s_getMethod,
                    'h' => s_headMethod,
                    'o' => s_optionsMethod,
                    'p' => method._method.Length switch
                    	{
                            3 => s_putMethod,
                            4 => s_postMethod,
                            _ => s_patchMethod,
                    	},
                    't' => s_traceMethod,
                    _ => null,
            	};
            
            if (match is not null && 
                string.Equals(method._method, match._method, StringComparison.OrdinalIgnoreCase))
            {
                return match;
            }
        }
        
        return method;
    }
    
    internal bool MustHaveRequestBody
    {
        get
        {
            // Normalize before calling this
            Debug.Assert(ReferenceEquals(this, Normalize(this)));
            
            return !ReferenceEquals(this, HttpMethod.Get) && 
                   !ReferenceEquals(this, HttpMethod.Head) && 
                   !ReferenceEquals(this, HttpMethod.Connect) &&
                   !ReferenceEquals(this, HttpMethod.Options) && 
                   !ReferenceEquals(this, HttpMethod.Delete);
        }
    }
}

public partial class HttpMethod
{
    private byte[]? _http3EncodedBytes;
    
    internal byte[] Http3EncodedBytes
    {
        get
        {
            byte[]? http3EncodedBytes = Volatile.Read(ref _http3EncodedBytes);
            if (http3EncodedBytes is null)
            {
                Volatile.Write(
                    ref _http3EncodedBytes, 
                    http3EncodedBytes = _http3Index is int index && 
                    index >= 0 
                    	? QPackEncoder.EncodeStaticIndexedHeaderFieldToArray(index) 
                    	: QPackEncoder.EncodeLiteralHeaderFieldWithStaticNameReferenceToArray(H3StaticTable.MethodGet, _method));
            }
            
            return http3EncodedBytes;
        }
    }
}

```

#### 1.4 http headers



##### 1.4.1 http request headers

```c#

```

##### 1.4.2 http response headers

```c#

```



#### 1.5 http content

```c#
public abstract class HttpContent : IDisposable
{        
    internal static readonly Encoding DefaultStringEncoding = Encoding.UTF8;
    internal const int MaxBufferSize = int.MaxValue;
    
    // content headers
    private HttpContentHeaders? _headers;
    public HttpContentHeaders Headers
	{
    	get
        {
            if (_headers == null)
            {
                _headers = new HttpContentHeaders(this);
            }
            return _headers;
        }
	}
    
    // buffer stream
    private MemoryStream? _bufferedContent;
    private bool IsBuffered
    {
        get { return _bufferedContent != null; }
    }
    
    // buffer content (stream or task<stream>)
    private object? _contentReadStream; 
    internal bool TryGetBuffer(out ArraySegment<byte> buffer)
    {
        if (_bufferedContent != null)
        {
            return _bufferedContent.TryGetBuffer(out buffer);
        }
        
        buffer = default;
        return false;
    }
        
    private bool _canCalculateLength;    
    private bool _disposed;    
    internal virtual bool AllowDuplex => true;
    
    protected HttpContent()
    {
        // Log to get an ID for the current content. This ID is used when the content gets associated to a message.
        if (NetEventSource.Log.IsEnabled()) NetEventSource.Info(this);        
        // We start with the assumption that we can calculate the content length.
        _canCalculateLength = true;
    }                                                                                                                            
   
#region IDisposable Members
    protected virtual void Dispose(bool disposing)
    {
        if (disposing && !_disposed)
        {
            _disposed = true;
            
            if (_contentReadStream != null)
            {
                Stream? s = _contentReadStream as Stream 
                    ?? (_contentReadStream is Task<Stream> t && 
                        t.Status == TaskStatus.RanToCompletion ? t.Result : null);
                
                s?.Dispose();
                _contentReadStream = null;
            }

            if (IsBuffered)
            {
                _bufferedContent!.Dispose();
            }
        }
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }    
#endregion
        
#region Helpers

    private void CheckDisposed()
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(this.GetType().ToString());
        }
    }
    
    private void CheckTaskNotNull(Task task)
    {
        if (task == null)
        {
            var e = new InvalidOperationException(SR.net_http_content_no_task_returned);
            if (NetEventSource.Log.IsEnabled()) NetEventSource.Error(this, e);
            throw e;
        }
    }
            
    private static Exception GetStreamCopyException(Exception originalException)
    {
        // HttpContent derived types should throw HttpRequestExceptions if there is an error. However, since the stream
        // provided by CopyToAsync() can also throw, we wrap such exceptions in HttpRequestException. This way custom content
        // types don't have to worry about it. The goal is that users of HttpContent don't have to catch multiple
        // exceptions (depending on the underlying transport), but just HttpRequestExceptions
        // Custom stream should throw either IOException or HttpRequestException.
        // We don't want to wrap other exceptions thrown by Stream (e.g. InvalidOperationException), since we
        // don't want to hide such "usage error" exceptions in HttpRequestException.
        // ObjectDisposedException is also wrapped, since aborting HWR after a request is complete will result in
        // the response stream being closed.
        return StreamCopyExceptionNeedsWrapping(originalException) 
            ? WrapStreamCopyException(originalException) 
            : originalException;
    }
        
    internal static Exception WrapStreamCopyException(Exception e)
    {
        Debug.Assert(StreamCopyExceptionNeedsWrapping(e));
        return new HttpRequestException(
            SR.net_http_content_stream_copy_error, 
            e);
    }
    
    internal static bool StreamCopyExceptionNeedsWrapping(Exception e) => 
        e is IOException || e is ObjectDisposedException;
    
    
    private static int GetPreambleLength(ArraySegment<byte> buffer, Encoding encoding)
    {
        byte[]? data = buffer.Array;
        int offset = buffer.Offset;
        int dataLength = buffer.Count;
        
        Debug.Assert(data != null);
        Debug.Assert(encoding != null);
        
        switch (encoding.CodePage)
        {
            case UTF8CodePage:
                return (dataLength >= UTF8PreambleLength && 
                        data[offset + 0] == UTF8PreambleByte0 && 
                        data[offset + 1] == UTF8PreambleByte1 && 
                        data[offset + 2] == UTF8PreambleByte2) ? UTF8PreambleLength : 0;
                
            case UTF32CodePage:
                return (dataLength >= UTF32PreambleLength && 
                        data[offset + 0] == UTF32PreambleByte0 && 
                        data[offset + 1] == UTF32PreambleByte1 && 
                        data[offset + 2] == UTF32PreambleByte2 && 
                        data[offset + 3] == UTF32PreambleByte3) ? UTF32PreambleLength : 0;
            
            case UnicodeCodePage:
                return (dataLength >= UnicodePreambleLength && 
                        data[offset + 0] == UnicodePreambleByte0 && 
                        data[offset + 1] == UnicodePreambleByte1) ? UnicodePreambleLength : 0;
                
            case BigEndianUnicodeCodePage:
                return (dataLength >= BigEndianUnicodePreambleLength && 
                        data[offset + 0] == BigEndianUnicodePreambleByte0 && 
                        data[offset + 1] == BigEndianUnicodePreambleByte1) ? BigEndianUnicodePreambleLength : 0;
                
            default:
                byte[] preamble = encoding.GetPreamble();
                return BufferHasPrefix(buffer, preamble) ? preamble.Length : 0;
        }
    }
    
    private static bool TryDetectEncoding(
        ArraySegment<byte> buffer, 
        [NotNullWhen(true)] out Encoding? encoding, 
        out int preambleLength)
    {
        byte[]? data = buffer.Array;
        int offset = buffer.Offset;
        int dataLength = buffer.Count;
        
        Debug.Assert(data != null);
        
        if (dataLength >= 2)
        {
            int first2Bytes = data[offset + 0] << 8 | data[offset + 1];
            
            switch (first2Bytes)
            {
                case UTF8PreambleFirst2Bytes:
                    if (dataLength >= UTF8PreambleLength && 
                        data[offset + 2] == UTF8PreambleByte2)
                    {
                        encoding = Encoding.UTF8;
                        preambleLength = UTF8PreambleLength;
                        return true;
                    }
                    break;
                    
                case UTF32OrUnicodePreambleFirst2Bytes:
                    // UTF32 not supported on Phone
                    if (dataLength >= UTF32PreambleLength && 
                        data[offset + 2] == UTF32PreambleByte2 && 
                        data[offset + 3] == UTF32PreambleByte3)
                    {
                        encoding = Encoding.UTF32;
                        preambleLength = UTF32PreambleLength;
                    }
                    else
                    {
                        encoding = Encoding.Unicode;
                        preambleLength = UnicodePreambleLength;
                    }
                    return true;
                    
                case BigEndianUnicodePreambleFirst2Bytes:
                    encoding = Encoding.BigEndianUnicode;
                    preambleLength = BigEndianUnicodePreambleLength;
                    return true;
            }
        }
        
        encoding = null;
        preambleLength = 0;
        return false;
    }
    
    private static bool BufferHasPrefix(ArraySegment<byte> buffer, byte[] prefix)
    {
        byte[]? byteArray = buffer.Array;
        if (prefix == null || byteArray == null || prefix.Length > buffer.Count || prefix.Length == 0)
            return false;
        
        for (int i = 0, j = buffer.Offset; i < prefix.Length; i++, j++)
        {
            if (prefix[i] != byteArray[j])
                return false;
        }
        
        return true;
    }
    
#endregion Helpers
        
    private static async Task<TResult> WaitAndReturnAsync<TState, TResult>(Task waitTask, TState state, Func<TState, TResult> returnFunc)
    {
        await waitTask.ConfigureAwait(false);
        return returnFunc(state);
    }
    
    private static Exception CreateOverCapacityException(int maxBufferSize)
    {
        return new HttpRequestException(SR.Format(SR.net_http_content_buffersize_exceeded, maxBufferSize));
    }                    
}

```

##### - encoding

```c#
public abstract class HttpContent : IDisposable
{
    private const int UTF8CodePage = 65001;
    private const int UTF8PreambleLength = 3;
    private const byte UTF8PreambleByte0 = 0xEF;
    private const byte UTF8PreambleByte1 = 0xBB;
    private const byte UTF8PreambleByte2 = 0xBF;
    private const int UTF8PreambleFirst2Bytes = 0xEFBB;
    
    private const int UTF32CodePage = 12000;
    private const int UTF32PreambleLength = 4;
    private const byte UTF32PreambleByte0 = 0xFF;
    private const byte UTF32PreambleByte1 = 0xFE;
    private const byte UTF32PreambleByte2 = 0x00;
    private const byte UTF32PreambleByte3 = 0x00;
    private const int UTF32OrUnicodePreambleFirst2Bytes = 0xFFFE;
    
    private const int UnicodeCodePage = 1200;
    private const int UnicodePreambleLength = 2;
    private const byte UnicodePreambleByte0 = 0xFF;
    private const byte UnicodePreambleByte1 = 0xFE;
    
    private const int BigEndianUnicodeCodePage = 1201;
    private const int BigEndianUnicodePreambleLength = 2;
    private const byte BigEndianUnicodePreambleByte0 = 0xFE;
    private const byte BigEndianUnicodePreambleByte1 = 0xFF;
    private const int BigEndianUnicodePreambleFirst2Bytes = 0xFEFF;
    
#if DEBUG
    static HttpContent()
	{
    	// Ensure the encoding constants used in this class match the actual data from the Encoding class
    	AssertEncodingConstants(
            Encoding.UTF8, 
            UTF8CodePage, 
            UTF8PreambleLength, 
            UTF8PreambleFirst2Bytes,
            UTF8PreambleByte0,
            UTF8PreambleByte1,
            UTF8PreambleByte2);
    
    	// UTF32 not supported on Phone
    	AssertEncodingConstants(
            Encoding.UTF32, 
            UTF32CodePage, 
            UTF32PreambleLength, 
            UTF32OrUnicodePreambleFirst2Bytes,            
            UTF32PreambleByte0,
            UTF32PreambleByte1,
            UTF32PreambleByte2,
            UTF32PreambleByte3);
    
    	AssertEncodingConstants(
            Encoding.Unicode, 
            UnicodeCodePage, 
            UnicodePreambleLength, 
            UTF32OrUnicodePreambleFirst2Bytes,
            UnicodePreambleByte0,
            UnicodePreambleByte1);

    	AssertEncodingConstants(
            Encoding.BigEndianUnicode, 
            BigEndianUnicodeCodePage,
            BigEndianUnicodePreambleLength,
            BigEndianUnicodePreambleFirst2Bytes,
            BigEndianUnicodePreambleByte0,
            BigEndianUnicodePreambleByte1);
	}
    
    private static void AssertEncodingConstants(
        Encoding encoding, 
        int codePage, 
        int preambleLength, 
        int first2Bytes, 
        params byte[] preamble)
    {
        Debug.Assert(encoding != null);
        Debug.Assert(preamble != null);
        
        Debug.Assert(
            codePage == encoding.CodePage,
            "Encoding code page mismatch for encoding: " + encoding.EncodingName,
            "Expected (constant): {0}, Actual (Encoding.CodePage): {1}", 
            codePage, encoding.CodePage);
        
        byte[] actualPreamble = encoding.GetPreamble();
        
        Debug.Assert(
            preambleLength == actualPreamble.Length,
            "Encoding preamble length mismatch for encoding: " + encoding.EncodingName,
            "Expected (constant): {0}, Actual (Encoding.GetPreamble().Length): {1}", 
            preambleLength, actualPreamble.Length);
        
        Debug.Assert(actualPreamble.Length >= 2);
        int actualFirst2Bytes = actualPreamble[0] << 8 | actualPreamble[1];
        
        Debug.Assert(
            first2Bytes == actualFirst2Bytes,
            "Encoding preamble first 2 bytes mismatch for encoding: " + encoding.EncodingName,
            "Expected (constant): {0}, Actual: {1}", first2Bytes, actualFirst2Bytes);
        
        Debug.Assert(
            preamble.Length == actualPreamble.Length,
            "Encoding preamble mismatch for encoding: " + encoding.EncodingName,
            "Expected (constant): {0}, Actual (Encoding.GetPreamble()): {1}",
            BitConverter.ToString(preamble),
            BitConverter.ToString(actualPreamble));
        
        for (int i = 0; i < preamble.Length; i++)
        {
            Debug.Assert(
                preamble[i] == actualPreamble[i],
                "Encoding preamble mismatch for encoding: " + encoding.EncodingName,
                "Expected (constant): {0}, Actual (Encoding.GetPreamble()): {1}",
                BitConverter.ToString(preamble),
                BitConverter.ToString(actualPreamble));
        }
    }
#endif      
}

```

##### - limit array pool write stream

```c#
public abstract class HttpContent : IDisposable
{
    internal sealed class LimitArrayPoolWriteStream : Stream
    {
        private const int MaxByteArrayLength = 0x7FFFFFC7;
        private const int InitialLength = 256;
        
        private readonly int _maxBufferSize;
        private byte[] _buffer;
        private int _length;
        
        public LimitArrayPoolWriteStream(int maxBufferSize) : this(maxBufferSize, InitialLength) { }
        
        public LimitArrayPoolWriteStream(int maxBufferSize, long capacity)
        {
            if (capacity < InitialLength)
            {
                capacity = InitialLength;
            }
            else if (capacity > maxBufferSize)
            {
                throw CreateOverCapacityException(maxBufferSize);
            }
            
            _maxBufferSize = maxBufferSize;
            _buffer = ArrayPool<byte>.Shared.Rent((int)capacity);
        }
        
        protected override void Dispose(bool disposing)
        {
            Debug.Assert(_buffer != null);
            
            ArrayPool<byte>.Shared.Return(_buffer);
            _buffer = null!;
            
            base.Dispose(disposing);
        }
        
        public ArraySegment<byte> GetBuffer() => new ArraySegment<byte>(_buffer, 0, _length);
        
        public byte[] ToArray()
        {
            var arr = new byte[_length];
            Buffer.BlockCopy(_buffer, 0, arr, 0, _length);
            return arr;
        }
        
        private void EnsureCapacity(int value)
        {
            if ((uint)value > (uint)_maxBufferSize) // value cast handles overflow to negative as well
            {
                throw CreateOverCapacityException(_maxBufferSize);
            }
            else if (value > _buffer.Length)
            {
                Grow(value);
            }
        }
        
        private void Grow(int value)
        {
            Debug.Assert(value > _buffer.Length);
            
            // Extract the current buffer to be replaced.
            byte[] currentBuffer = _buffer;
            _buffer = null!;
            
            // Determine the capacity to request for the new buffer.  It should be
            // at least twice as long as the current one, if not more if the requested
            // value is more than that.  If the new value would put it longer than the max
            // allowed byte array, than shrink to that (and if the required length is actually
            // longer than that, we'll let the runtime throw).
            uint twiceLength = 2 * (uint)currentBuffer.Length;
            int newCapacity = twiceLength > MaxByteArrayLength 
                ? (value > MaxByteArrayLength ? value : MaxByteArrayLength) 
                : Math.Max(value, (int)twiceLength);
            
            // Get a new buffer, copy the current one to it, return the current one, and
            // set the new buffer as current.
            byte[] newBuffer = ArrayPool<byte>.Shared.Rent(newCapacity);
            Buffer.BlockCopy(currentBuffer, 0, newBuffer, 0, _length);
            ArrayPool<byte>.Shared.Return(currentBuffer);
            _buffer = newBuffer;
        }
        
        public override void Write(byte[] buffer, int offset, int count)
        {
            Debug.Assert(buffer != null);
            Debug.Assert(offset >= 0);
            Debug.Assert(count >= 0);
            
            EnsureCapacity(_length + count);
            Buffer.BlockCopy(buffer, offset, _buffer, _length, count);
            _length += count;
        }
        
        public override void Write(ReadOnlySpan<byte> buffer)
        {
            EnsureCapacity(_length + buffer.Length);
            buffer.CopyTo(new Span<byte>(_buffer, _length, buffer.Length));
            _length += buffer.Length;
        }
        
        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            Write(buffer, offset, count);
            return Task.CompletedTask;
        }
        
        public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
        {
            Write(buffer.Span);
            return default;
        }
        
        public override IAsyncResult BeginWrite(
            byte[] buffer, int offset, int count, AsyncCallback? asyncCallback, object? asyncState) =>
            TaskToApm.Begin(WriteAsync(buffer, offset, count, CancellationToken.None), asyncCallback, asyncState);
        
        public override void EndWrite(IAsyncResult asyncResult) =>
            TaskToApm.End(asyncResult);
        
        public override void WriteByte(byte value)
        {
            int newLength = _length + 1;
            EnsureCapacity(newLength);
            _buffer[_length] = value;
            _length = newLength;
        }
        
        public override void Flush() { }
        public override Task FlushAsync(CancellationToken cancellationToken) => Task.CompletedTask;
        
        public override long Length => _length;
        public override bool CanWrite => true;
        public override bool CanRead => false;
        public override bool CanSeek => false;
        
        public override long Position { get { throw new NotSupportedException(); } set { throw new NotSupportedException(); } }
        public override int Read(byte[] buffer, int offset, int count) { throw new NotSupportedException(); }
        public override long Seek(long offset, SeekOrigin origin) { throw new NotSupportedException(); }
        public override void SetLength(long value) { throw new NotSupportedException(); }
    }
}

```

##### 1.5.1 load into buffer

###### 1.5.1.1 load into

```c#
public abstract class HttpContent : IDisposable
{
    internal void LoadIntoBuffer(long maxBufferSize, CancellationToken cancellationToken)
    {
        CheckDisposed();
        
        // 创建 temp buffer
        if (!CreateTemporaryBuffer(
            	maxBufferSize, 
            	out MemoryStream? tempBuffer, 
            	out Exception? error))
        {
            // 已经创建，-> 返回
            return;
        }
        
        // 不能创建 buffer，-> 抛出异常
        if (tempBuffer == null)
        {
            throw error!;
        }
        
        // Register for cancellation and tear down the underlying stream in case of cancellation/timeout.
        // We're only comfortable disposing of the HttpContent instance like this because LoadIntoBuffer is internal and
        // we're only using it on content instances we get back from a handler's Send call that haven't been given out to the user yet.
        // If we were to ever make LoadIntoBuffer public, we'd need to rethink this.
        CancellationTokenRegistration cancellationRegistration = 
            cancellationToken.Register(static s => ((HttpContent)s!).Dispose(), this);
        
        try
        {
            // 将 temp buffer 序列化
            SerializeToStream(tempBuffer, null, cancellationToken);
            // Rewind after writing data.
            tempBuffer.Seek(0, SeekOrigin.Begin); 
            // 注入到 buffer content
            _bufferedContent = tempBuffer;
        }
        catch (Exception e)
        {
            if (NetEventSource.Log.IsEnabled()) NetEventSource.Error(this, e);
            
            if (CancellationHelper.ShouldWrapInOperationCanceledException(e, cancellationToken))
            {
                throw CancellationHelper.CreateOperationCanceledException(e, cancellationToken);
            }
            
            if (StreamCopyExceptionNeedsWrapping(e))
            {
                throw GetStreamCopyException(e);
            }
            
            throw;
        }
        finally
        {
            // Clean up the cancellation registration.
            cancellationRegistration.Dispose();
        }
    }
}

```

###### 1.5.1.2 load into async

```c#
public abstract class HttpContent : IDisposable
{   
    public Task LoadIntoBufferAsync() => LoadIntoBufferAsync(MaxBufferSize);
       
    public Task LoadIntoBufferAsync(long maxBufferSize) =>
        LoadIntoBufferAsync(maxBufferSize, CancellationToken.None);
    
    internal Task LoadIntoBufferAsync(CancellationToken cancellationToken) =>
        LoadIntoBufferAsync(MaxBufferSize, cancellationToken);
    
    internal Task LoadIntoBufferAsync(long maxBufferSize, CancellationToken cancellationToken)
    {
        CheckDisposed();
        
        // 创建 temp buffer
        if (!CreateTemporaryBuffer(
            	maxBufferSize, 
            	out MemoryStream? tempBuffer, 
            	out Exception? error))
        {           
            // 已经创建，-> 返回
            return Task.CompletedTask;
        }
        
        // 如果不能创建，-> 抛出异常
        if (tempBuffer == null)
        {            
            return Task.FromException(error!);
        }
        
        try
        {
            // 序列化 temp buffer task
            Task task = SerializeToStreamAsync(tempBuffer, null, cancellationToken);
            CheckTaskNotNull(task);
            // load buffer core
            return LoadIntoBufferAsyncCore(task, tempBuffer);
        }
        catch (Exception e) when (StreamCopyExceptionNeedsWrapping(e))
        {
            return Task.FromException(GetStreamCopyException(e));
        }
        // other synchronous exceptions from SerializeToStreamAsync/CheckTaskNotNull will propagate
    }
    
    private async Task LoadIntoBufferAsyncCore(Task serializeToStreamTask, MemoryStream tempBuffer)
    {
        try
        {
            // 执行 序列化 temp buffer
            await serializeToStreamTask.ConfigureAwait(false);
        }
        catch (Exception e)
        {
            // Cleanup partially filled stream.
            tempBuffer.Dispose(); 
            Exception we = GetStreamCopyException(e);
            if (we != e) throw we;
            throw;
        }
        
        try
        {
            // Rewind after writing data.
            tempBuffer.Seek(0, SeekOrigin.Begin); 
            // 注入到 buffer content
            _bufferedContent = tempBuffer;
        }
        catch (Exception e)
        {
            if (NetEventSource.Log.IsEnabled()) NetEventSource.Error(this, e);
            throw;
        }
    }
}

```

###### 1.5.1.3 create temp buffer (stream)

```c#
public abstract class HttpContent : IDisposable
{
    //
    private bool CreateTemporaryBuffer(
        long maxBufferSize, 
        out MemoryStream? tempBuffer, 
        out Exception? error)
    {
        if (maxBufferSize > HttpContent.MaxBufferSize)
        {
            // This should only be hit when called directly; 
            // HttpClient/HttpClientHandler will not exceed this limit.
            throw new ArgumentOutOfRangeException(
                nameof(maxBufferSize), 
                maxBufferSize,
                SR.Format(
                    System.Globalization.CultureInfo.InvariantCulture,
                    SR.net_http_content_buffersize_limit, 
                    HttpContent.MaxBufferSize));
        }
        
        if (IsBuffered)
        {
            // If we already buffered the content, just return false.
            tempBuffer = default;
            error = default;
            return false;
        }
        
        tempBuffer = CreateMemoryStream(maxBufferSize, out error);
        return true;
    }
    
    //
    private MemoryStream? CreateMemoryStream(long maxBufferSize, out Exception? error)
    {
        error = null;
        
        // If we have a Content-Length allocate the right amount of buffer up-front. 
        // Also check whether the content length exceeds the max. buffer size.
        long? contentLength = Headers.ContentLength;
        
        if (contentLength != null)
        {
            Debug.Assert(contentLength >= 0);
            
            if (contentLength > maxBufferSize)
            {
                error = new HttpRequestException(
                    SR.Format(
                        System.Globalization.CultureInfo.InvariantCulture, 
                        SR.net_http_content_buffersize_exceeded,
                        maxBufferSize));
                return null;
            }
            
            // We can safely cast contentLength to (int) since we just checked that it is <= maxBufferSize.
            return new LimitMemoryStream((int)maxBufferSize, (int)contentLength);
        }
        
        // We couldn't determine the length of the buffer. Create a memory stream with an empty buffer.
        return new LimitMemoryStream((int)maxBufferSize, 0);
    }
    
    ///
    internal sealed class LimitMemoryStream : MemoryStream
    {
        private readonly int _maxSize;
        
        public LimitMemoryStream(int maxSize, int capacity) : base(capacity)
        {
            Debug.Assert(capacity <= maxSize);
            _maxSize = maxSize;
        }
        
        public byte[] GetSizedBuffer()
        {
            ArraySegment<byte> buffer;
            return 
                TryGetBuffer(out buffer) && 
                buffer.Offset == 0 && buffer.Count == buffer.Array!.Length 
                	? buffer.Array 
                	: ToArray();
        }

        public override void WriteByte(byte value)
        {
            CheckSize(1);
            base.WriteByte(value);
        }
        
        public override void Write(
            byte[] buffer, 
            int offset, 
            int count)
        {
            CheckSize(count);
            base.Write(buffer, offset, count);
        }
                       
        public override Task WriteAsync(
            byte[] buffer, 
            int offset, 
            int count, 
            CancellationToken cancellationToken)
        {
            CheckSize(count);
            return base.WriteAsync(buffer, offset, count, cancellationToken);
        }
        
        public override ValueTask WriteAsync(
            ReadOnlyMemory<byte> buffer,
            CancellationToken cancellationToken)
        {
            CheckSize(buffer.Length);
            return base.WriteAsync(buffer, cancellationToken);
        }
        
        public override IAsyncResult BeginWrite(
            byte[] buffer, 
            int offset, 
            int count, 
            AsyncCallback? callback, 
            object? state)
        {
            CheckSize(count);
            return base.BeginWrite(buffer, offset, count, callback, state);
        }
        
        public override void EndWrite(IAsyncResult asyncResult)
        {
            base.EndWrite(asyncResult);
        }
        
        public override Task CopyToAsync(
            Stream destination, 
            int bufferSize, 
            CancellationToken cancellationToken)
        {
            ArraySegment<byte> buffer;
            if (TryGetBuffer(out buffer))
            {
                ValidateCopyToArguments(destination, bufferSize);
                
                long pos = Position;
                long length = Length;
                Position = length;
                
                long bytesToWrite = length - pos;
                return destination.WriteAsync(buffer.Array!, (int)(buffer.Offset + pos), (int)bytesToWrite, cancellationToken);
            }
            
            return base.CopyToAsync(destination, bufferSize, cancellationToken);
        }
        
        private void CheckSize(int countToAdd)
        {
            if (_maxSize - Length < countToAdd)
            {
                throw CreateOverCapacityException(_maxSize);
            }
        }
    }
}

```

###### 1.5.1.4 serialize to stream

```c#
public abstract class HttpContent : IDisposable
{
    //
    protected virtual void SerializeToStream(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken)
    {
        throw new NotSupportedException(
            SR.Format(
                SR.net_http_missing_sync_implementation, 
                GetType(), 
                nameof(HttpContent), 
                nameof(SerializeToStream)));
    }
    
    // 
    protected virtual Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken) =>
        	SerializeToStreamAsync(stream, context);
    
    protected abstract Task SerializeToStreamAsync(Stream stream, TransportContext? context);
}

```





##### 1.5.2 read

###### 1.5.2.1 as string

```c#
public abstract class HttpContent : IDisposable
{
    //
    public Task<string> ReadAsStringAsync() => ReadAsStringAsync(CancellationToken.None);
    
    // 
    public Task<string> ReadAsStringAsync(CancellationToken cancellationToken)
    {
        CheckDisposed();
        return WaitAndReturnAsync(
            // load into buffer
            LoadIntoBufferAsync(cancellationToken), 
            this, 
            // read buffer content => string
            static s => s.ReadBufferedContentAsString());
    }
    
    // read buffer content (stream) => string
    private string ReadBufferedContentAsString()
    {
        Debug.Assert(IsBuffered);
        
        // 如果 buffer content 为空，-> 返回 ""
        if (_bufferedContent!.Length == 0)
        {
            return string.Empty;
        }
        
        // convert buffer => array segment
        ArraySegment<byte> buffer;
        if (!TryGetBuffer(out buffer))
        {
            buffer = new ArraySegment<byte>(_bufferedContent.ToArray());
        }
                
        return ReadBufferAsString(buffer, Headers);
    }
    
    // read buffer array => string
    internal static string ReadBufferAsString(ArraySegment<byte> buffer, HttpContentHeaders headers)
    {
        // We don't validate the Content-Encoding header: If the content was encoded, it's the caller's
        // responsibility to make sure to only call ReadAsString() on already decoded content. E.g. if the
        // Content-Encoding is 'gzip' the user should set HttpClientHandler.AutomaticDecompression to get a
        // decoded response stream.
        
        Encoding? encoding = null;
        int bomLength = -1;        
        
        // 从 http content header 解析 charset 
        string? charset = headers.ContentType?.CharSet;
        
        // 如果 charset 不为 null，
        if (charset != null)
        {
            try
            {
                // 解析 encoding
                if (charset.Length > 2 &&
                    charset[0] == '\"' &&
                    charset[charset.Length - 1] == '\"')
                {
                    encoding = Encoding.GetEncoding(charset.Substring(1, charset.Length - 2));
                }
                else
                {
                    encoding = Encoding.GetEncoding(charset);
                }
                
                // 解析 bom
                // Byte-order-mark (BOM) characters may be present even if a charset was specified.
                bomLength = GetPreambleLength(buffer, encoding);
            }
            catch (ArgumentException e)
            {
                throw new InvalidOperationException(
                    SR.net_http_content_invalid_charset, 
                    e);
            }
        }
        
        // 如果 encoding 为 null，即 (above) 没有解析到 encoding
        if (encoding == null)
        {
            // 从 buffer 中按照 bom length 解析 encoding，            
            if (!TryDetectEncoding(buffer, out encoding, out bomLength))
            {
                // 使用 default encoding (utf8)
                encoding = DefaultStringEncoding;                                
                bomLength = 0;
            }
        }
        
        // Drop the BOM when decoding the data.
        return encoding.GetString(
            buffer.Array!, 
            buffer.Offset + bomLength, 
            buffer.Count - bomLength);
    }    
}

```

###### 1.5.2.2 as byte array

```c#
public abstract class HttpContent : IDisposable
{
    //
    public Task<byte[]> ReadAsByteArrayAsync() => ReadAsByteArrayAsync(CancellationToken.None);
    
    //
    public Task<byte[]> ReadAsByteArrayAsync(CancellationToken cancellationToken)
    {
        CheckDisposed();
        return WaitAndReturnAsync(
            // load into buffer
            LoadIntoBufferAsync(cancellationToken), 
            this, 
            // read buffer content => byte array
            static s => s.ReadBufferedContentAsByteArray());
    }
    
    // read buffer content (stream) => byte array
    internal byte[] ReadBufferedContentAsByteArray()
    {
        Debug.Assert(_bufferedContent != null);        
        return _bufferedContent.ToArray();
    }
}

```

###### 1.5.2.3 as stream

###### - try read stream

```c#
public abstract class HttpContent : IDisposable
{
    internal Stream? TryReadAsStream()
    {
        CheckDisposed();
               
        // 如果 buffer content stream 为 null
        if (_contentReadStream == null) 
        {
            // 解析 buffer content => memory stream，
            // 如果不能解析，-> 创建 content read stream
            Stream? s = TryGetBuffer(out ArraySegment<byte> buffer) 
                ? new MemoryStream(buffer.Array!, buffer.Offset, buffer.Count, writable: false) 
                : TryCreateContentReadStream();
            
            _contentReadStream = s;
            return s;
        }
        // （否则，即 buffer content stream 不为 null），
        // 如果 buffer content stream 是 stream，-> 返回 stream
        else if (_contentReadStream is Stream s) // have a Stream
        {
            return s;
        }
        // （否则，即 buffer content stream 不为 null，但不是 stream，即 buffer 是 task of stream）
        else 
        {
            Debug.Assert(
                _contentReadStream is Task<Stream>, 
                $"Expected a Task<Stream>, got ${_contentReadStream}");
            
            // 解析 stream 并返回
            Task<Stream> t = (Task<Stream>)_contentReadStream;
            return t.Status == TaskStatus.RanToCompletion ? t.Result : null;
        }
    }
}

```

###### - read stream

```c#
public abstract class HttpContent : IDisposable
{
    //
    public Stream ReadAsStream() => ReadAsStream(CancellationToken.None);
    
    //
    public Stream ReadAsStream(CancellationToken cancellationToken)
    {
        CheckDisposed();
                
        if (_contentReadStream == null) 
        {
            Stream s = TryGetBuffer(out ArraySegment<byte> buffer) 
                ? new MemoryStream(buffer.Array!, buffer.Offset, buffer.Count, writable: false) 
                : CreateContentReadStream(cancellationToken);
            
            _contentReadStream = s;
            return s;
        }
        else if (_contentReadStream is Stream stream) 
        {
            return stream;
        }
        else 
        {            
            throw new HttpRequestException(SR.net_http_content_read_as_stream_has_task);
        }
    }        
}

```

###### - read stream async

```c#
public abstract class HttpContent : IDisposable
{    
    //
    public Task<Stream> ReadAsStreamAsync() => ReadAsStreamAsync(CancellationToken.None);
    
    //
    public Task<Stream> ReadAsStreamAsync(CancellationToken cancellationToken)
    {
        CheckDisposed();
                
        if (_contentReadStream == null) 
        {
            Task<Stream> t = TryGetBuffer(out ArraySegment<byte> buffer) 
                ? Task.FromResult<Stream>(new MemoryStream(buffer.Array!, buffer.Offset, buffer.Count, writable: false)) 
                : CreateContentReadStreamAsync(cancellationToken);
            
            _contentReadStream = t;
            return t;
        }
        else if (_contentReadStream is Task<Stream> t) 
        {
            return t;
        }
        else
        {
            Debug.Assert(
                _contentReadStream is Stream, 
                $"Expected a Stream, got ${_contentReadStream}");
            
            Task<Stream> ts = Task.FromResult((Stream)_contentReadStream);
            _contentReadStream = ts;
            return ts;
        }
    }
}

```



###### 1.5.2.5 create content read stream

```c#
public abstract class HttpContent : IDisposable
{    
    protected virtual Stream CreateContentReadStream(CancellationToken cancellationToken)
    {
        LoadIntoBuffer(MaxBufferSize, cancellationToken);
        return _bufferedContent!;
    }
    
    protected virtual Task<Stream> CreateContentReadStreamAsync()
    {
        // By default just buffer the content to a memory stream. Derived classes can override this behavior
        // if there is a better way to retrieve the content as stream (e.g. byte array/string use a more efficient
        // way, like wrapping a read-only MemoryStream around the bytes/string)
        return WaitAndReturnAsync(LoadIntoBufferAsync(), this, s => (Stream)s._bufferedContent!);
    }
    
    protected virtual Task<Stream> CreateContentReadStreamAsync(CancellationToken cancellationToken)
    {
        // Drops the CT for compatibility reasons, see https://github.com/dotnet/runtime/issues/916#issuecomment-562083237
        return CreateContentReadStreamAsync();
    }
    
    // As an optimization for internal consumers of HttpContent (e.g. HttpClient.GetStreamAsync), and for
    // HttpContent-derived implementations that override CreateContentReadStreamAsync in a way that always
    // or frequently returns synchronously-completed tasks, we can avoid the task allocation by enabling
    // callers to try to get the Stream first synchronously.
    internal virtual Stream? TryCreateContentReadStream() => null;
}

```

##### 1.5.3 copy

###### 1.5.3.1 copy to

```c#
public abstract class HttpContent : IDisposable
{    
    public void CopyTo(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken)
    {
        CheckDisposed();
        
        if (stream == null)
        {
            throw new ArgumentNullException(nameof(stream));
        }
        
        try
        {
            if (TryGetBuffer(out ArraySegment<byte> buffer))
            {
                stream.Write(buffer.Array!, buffer.Offset, buffer.Count);
            }
            else
            {
                SerializeToStream(stream, context, cancellationToken);
            }
        }
        catch (Exception e) when (StreamCopyExceptionNeedsWrapping(e))
        {
            throw GetStreamCopyException(e);
        }
    }        
}

```

###### 1.5.3.2 copy to async

```c#
public abstract class HttpContent : IDisposable
{    
    //
    public Task CopyToAsync(Stream stream) => CopyToAsync(stream, CancellationToken.None);
    
    //
    public Task CopyToAsync(
        Stream stream, 
        CancellationToken cancellationToken) =>        
        CopyToAsync(stream, null, cancellationToken);

    //
    public Task CopyToAsync(
        Stream stream, 
        TransportContext? context) =>
        CopyToAsync(stream, context, CancellationToken.None);
    
    //
    public Task CopyToAsync(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken)
    {
        CheckDisposed();
        if (stream == null)
        {
            throw new ArgumentNullException(nameof(stream));
        }
        
        try
        {
            return WaitAsync(InternalCopyToAsync(stream, context, cancellationToken));
        }
        catch (Exception e) when (StreamCopyExceptionNeedsWrapping(e))
        {
            return Task.FromException(GetStreamCopyException(e));
        }
                
        static async Task WaitAsync(ValueTask copyTask)
        {
            try
            {
                await copyTask.ConfigureAwait(false);
            }
            catch (Exception e) when (StreamCopyExceptionNeedsWrapping(e))
            {
                throw WrapStreamCopyException(e);
            }
        }
    }
    
    // 
    internal ValueTask InternalCopyToAsync(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken)
    {
        // 解析 buffer byte[]
        if (TryGetBuffer(out ArraySegment<byte> buffer))
        {
            return stream.WriteAsync(buffer, cancellationToken);
        }
        
        // 序列化
        Task task = SerializeToStreamAsync(stream, context, cancellationToken);
        CheckTaskNotNull(task);
        return new ValueTask(task);
    }
}

```

##### 1.5.4 computer length

```c#
public abstract class HttpContent : IDisposable
{        
    internal long? GetComputedOrBufferLength()
    {
        CheckDisposed();
        
        if (IsBuffered)
        {
            return _bufferedContent!.Length;
        }
        
        // If we already tried to calculate the length, but the derived class returned 'false', then don't try
        // again; just return null.
        if (_canCalculateLength)
        {
            long length = 0;
            if (TryComputeLength(out length))
            {
                return length;
            }
            
            // Set flag to make sure next time we don't try to compute the length, since we know that we're unable
            // to do so.
            _canCalculateLength = false;
        }
        return null;
    }
    
    protected internal abstract bool TryComputeLength(out long length);
}

```

#### 1.6 variety of http content

##### 1.6.1 empty content

```c#
internal sealed class EmptyContent : HttpContent
{
    internal override bool AllowDuplex => false;
    
    //
    protected override void SerializeToStream(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken)
    { 
    }
    
    protected override Task SerializeToStreamAsync(
        Stream stream, TransportContext? 
        context) =>
        	Task.CompletedTask;
    
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken) =>
        	cancellationToken.IsCancellationRequested 
        		? Task.FromCanceled(cancellationToken) 
        		: SerializeToStreamAsync(stream, context);
    
    //
    protected override Stream CreateContentReadStream(CancellationToken cancellationToken) =>
        EmptyReadStream.Instance;
    
    protected override Task<Stream> CreateContentReadStreamAsync() =>
        Task.FromResult<Stream>(EmptyReadStream.Instance);
    
    protected override Task<Stream> CreateContentReadStreamAsync(CancellationToken cancellationToken) =>
        cancellationToken.IsCancellationRequested 
        	? Task.FromCanceled<Stream>(cancellationToken) 
        	: CreateContentReadStreamAsync();
    
    //
    internal override Stream? TryCreateContentReadStream() => EmptyReadStream.Instance;
    
    //
    protected internal override bool TryComputeLength(out long length)
    {
        length = 0;
        return true;
    }                                            
}

```

##### 1.6.2 read only memory content

```c#
public sealed class ReadOnlyMemoryContent : HttpContent
{
    private readonly ReadOnlyMemory<byte> _content;    
    internal override bool AllowDuplex => false;
    
    public ReadOnlyMemoryContent(ReadOnlyMemory<byte> content) => _content = content;
    
    //
    protected override void SerializeToStream(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken)
    {
        stream.Write(_content.Span);
    }
    
    //
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context) =>
        	stream.WriteAsync(_content).AsTask();
    
    protected override Task SerializeToStreamAsync(
        Stream stream,
        TransportContext? context, 
        CancellationToken cancellationToken) =>
        	stream.WriteAsync(_content, cancellationToken).AsTask();
    
    //
    protected internal override bool TryComputeLength(out long length)
    {
        length = _content.Length;
        return true;
    }
    
    //
    protected override Stream CreateContentReadStream(CancellationToken cancellationToken) =>
        new ReadOnlyMemoryStream(_content);
    
    protected override Task<Stream> CreateContentReadStreamAsync() =>
        Task.FromResult<Stream>(new ReadOnlyMemoryStream(_content));
    
    // 
    internal override Stream TryCreateContentReadStream() =>
        new ReadOnlyMemoryStream(_content);        
}

```

##### 1.6.3 byte array content

```c#
public class ByteArrayContent : HttpContent
{
    private readonly byte[] _content;
    private readonly int _offset;
    private readonly int _count;
    
    internal override bool AllowDuplex => false;
    
    public ByteArrayContent(byte[] content)
    {
        if (content == null)
        {
            throw new ArgumentNullException(nameof(content));
        }
        
        _content = content;
        _count = content.Length;
    }
    
    public ByteArrayContent(byte[] content, int offset, int count)
    {
        if (content == null)
        {
            throw new ArgumentNullException(nameof(content));
        }
        if ((offset < 0) || (offset > content.Length))
        {
            throw new ArgumentOutOfRangeException(nameof(offset));
        }
        if ((count < 0) || (count > (content.Length - offset)))
        {
            throw new ArgumentOutOfRangeException(nameof(count));
        }
        
        _content = content;
        _offset = offset;
        _count = count;
    }
    
    //
    protected override void SerializeToStream(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken) =>
        	stream.Write(_content, _offset, _count);
    
    //
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context) =>
        	SerializeToStreamAsyncCore(stream, default);
    
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken) =>
        // Only skip the original protected virtual SerializeToStreamAsync if this
        // isn't a derived type that may have overridden the behavior.
        	GetType() == typeof(ByteArrayContent) 
        		? SerializeToStreamAsyncCore(stream, cancellationToken) 
        		: base.SerializeToStreamAsync(stream, context, cancellationToken);
    
    private protected Task SerializeToStreamAsyncCore(
        Stream stream, 
        CancellationToken cancellationToken) =>
        	stream.WriteAsync(_content, _offset, _count, cancellationToken);
    
    //
    protected internal override bool TryComputeLength(out long length)
    {
        length = _count;
        return true;
    }
    
    //
    protected override Stream CreateContentReadStream(CancellationToken cancellationToken) =>
        CreateMemoryStreamForByteArray();
    
    protected override Task<Stream> CreateContentReadStreamAsync() =>
        Task.FromResult<Stream>(CreateMemoryStreamForByteArray());
    
    //
    internal override Stream? TryCreateContentReadStream() =>
        GetType() == typeof(ByteArrayContent) 
        	? CreateMemoryStreamForByteArray() 
        	// type check ensures we use possible derived type's CreateContentReadStreamAsync override
        	: null;
    
    internal MemoryStream CreateMemoryStreamForByteArray() => new MemoryStream(_content, _offset, _count, writable: false);        
}

```

###### 1.6.3.1 string content

```c#
public class StringContent : ByteArrayContent
{
    private const string DefaultMediaType = "text/plain";
    
    public StringContent(string content) : this(content, null, null)
    {
    }
    
    public StringContent(string content, Encoding? encoding) : 
    	this(content, encoding, null)
    {
    }
        
    public StringContent(string content, Encoding? encoding, string? mediaType) : 
    	base(GetContentByteArray(content, encoding))
    {
        // Initialize the 'Content-Type' header with information provided by parameters.
        MediaTypeHeaderValue headerValue = 
            new MediaTypeHeaderValue((mediaType == null) ? DefaultMediaType : mediaType);
            
        headerValue.CharSet = (encoding == null) 
            ? HttpContent.DefaultStringEncoding.WebName 
            : encoding.WebName;
        
        Headers.ContentType = headerValue;
    }
    
    // A StringContent is essentially a ByteArrayContent. We serialize the string into a byte-array in the
    // constructor using encoding information provided by the caller (if any). When this content is sent, the
    // Content-Length can be retrieved easily (length of the array).
    private static byte[] GetContentByteArray(string content, Encoding? encoding)
    {
        // In this case we treat 'null' strings different from string.Empty in order to be consistent with our
        // other *Content constructors: 'null' throws, empty values are allowed.
        if (content == null)
        {
            throw new ArgumentNullException(nameof(content));
        }
        
        if (encoding == null)
        {
            encoding = HttpContent.DefaultStringEncoding;
        }
        
        return encoding.GetBytes(content);
    }
    
    // 
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken) =>        
        	GetType() == typeof(StringContent) 
        		? SerializeToStreamAsyncCore(stream, cancellationToken) 
        		: base.SerializeToStreamAsync(stream, context, cancellationToken);
    
    // 
    internal override Stream? TryCreateContentReadStream() =>
        GetType() == typeof(StringContent) 
        	? CreateMemoryStreamForByteArray() 
	        // type check ensures we use possible derived type's CreateContentReadStreamAsync override
        	: null;
}

```

###### 1.6.3.2 form url encoded content

```c#
public class FormUrlEncodedContent : ByteArrayContent
{
    public FormUrlEncodedContent(IEnumerable<KeyValuePair<string?, string?>> nameValueCollection) :
    	base(GetContentByteArray(nameValueCollection))
    {
        Headers.ContentType = new MediaTypeHeaderValue("application/x-www-form-urlencoded");
    }
    
    private static byte[] GetContentByteArray(IEnumerable<KeyValuePair<string?, string?>> nameValueCollection)
    {
        if (nameValueCollection == null)
        {
            throw new ArgumentNullException(nameof(nameValueCollection));
        }
        
        // Encode and concatenate data
        StringBuilder builder = new StringBuilder();
        foreach (KeyValuePair<string?, string?> pair in nameValueCollection)
        {
            if (builder.Length > 0)
            {
                builder.Append('&');
            }
            
            builder.Append(Encode(pair.Key));
            builder.Append('=');
            builder.Append(Encode(pair.Value));
        }
        
        return HttpRuleParser.DefaultHttpEncoding.GetBytes(builder.ToString());
    }
    
    private static string Encode(string? data)
    {
        if (string.IsNullOrEmpty(data))
        {
            return string.Empty;
        }
        // Escape spaces as '+'.
        return Uri.EscapeDataString(data).Replace("%20", "+");
    }
    
    //
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken) =>
            // Only skip the original protected virtual SerializeToStreamAsync if this
            // isn't a derived type that may have overridden the behavior.
            GetType() == typeof(FormUrlEncodedContent) 
        		? SerializeToStreamAsyncCore(stream, cancellationToken) 
        		: base.SerializeToStreamAsync(stream, context, cancellationToken);
    
    //
    internal override Stream? TryCreateContentReadStream() =>
        GetType() == typeof(FormUrlEncodedContent) 
        ? CreateMemoryStreamForByteArray() 
        // type check ensures we use possible derived type's CreateContentReadStreamAsync override
        : null;
}

```



##### 1.6.4 stream content

```c#
public class StreamContent : HttpContent
{
    private Stream _content;
    private int _bufferSize;
    private bool _contentConsumed;
    private long _start;
    
    internal override bool AllowDuplex => false;
    
    public StreamContent(Stream content)
    {
        if (content == null)
        {
            throw new ArgumentNullException(nameof(content));
        }
        
        // Indicate that we should use default buffer size by setting size to 0.
        InitializeContent(content, 0);
    }
    
    public StreamContent(Stream content, int bufferSize)
    {
        if (content == null)
        {
            throw new ArgumentNullException(nameof(content));
        }
        if (bufferSize <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(bufferSize));
        }
        
        InitializeContent(content, bufferSize);
    }
    
    [MemberNotNull(nameof(_content))]
    private void InitializeContent(Stream content, int bufferSize)
    {
        _content = content;
        _bufferSize = bufferSize;
        if (content.CanSeek)
        {
            _start = content.Position;
        }
        if (NetEventSource.Log.IsEnabled()) NetEventSource.Associate(this, content);
    }
    
    //
    protected override void SerializeToStream(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken)
    {
        Debug.Assert(stream != null);
        PrepareContent();
        // If the stream can't be re-read, make sure that it gets disposed once it is consumed.
        StreamToStreamCopy.Copy(_content, stream, _bufferSize, !_content.CanSeek);
    }
    
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context) =>
        	SerializeToStreamAsyncCore(stream, default);
    
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken) =>        
        	GetType() == typeof(StreamContent) 
        		? SerializeToStreamAsyncCore(stream, cancellationToken) 
        		: base.SerializeToStreamAsync(stream, context, cancellationToken);
        
    private Task SerializeToStreamAsyncCore(Stream stream, CancellationToken cancellationToken)
    {
        Debug.Assert(stream != null);
        PrepareContent();
        return StreamToStreamCopy.CopyAsync(
            _content,
            stream,
            _bufferSize,
            !_content.CanSeek, // If the stream can't be re-read, make sure that it gets disposed once it is consumed.
            cancellationToken);
    }
    
    private void PrepareContent()
    {
        if (_contentConsumed)
        {
            // If the content needs to be written to a target stream a 2nd time, then the stream must support
            // seeking (e.g. a FileStream), otherwise the stream can't be copied a second time to a target
            // stream (e.g. a NetworkStream).
            if (_content.CanSeek)
            {
                _content.Position = _start;
            }
            else
            {
                throw new InvalidOperationException(SR.net_http_content_stream_already_read);
            }
        }
        
        _contentConsumed = true;
    }
    
    //
    protected internal override bool TryComputeLength(out long length)
    {
        if (_content.CanSeek)
        {
            length = _content.Length - _start;
            return true;
        }
        else
        {
            length = 0;
            return false;
        }
    }
    
    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            _content.Dispose();
        }
        base.Dispose(disposing);
    }
    
    //
    protected override Stream CreateContentReadStream(CancellationToken cancellationToken) =>
        new ReadOnlyStream(_content);
        
    protected override Task<Stream> CreateContentReadStreamAsync()
    {
        // Wrap the stream with a read-only stream to prevent someone from writing to the stream.
        return Task.FromResult<Stream>(new ReadOnlyStream(_content));
    }
    
    //
    internal override Stream? TryCreateContentReadStream() =>
        GetType() == typeof(StreamContent) 
        ? new ReadOnlyStream(_content) 
        // type check ensures we use possible derived type's CreateContentReadStreamAsync override
        : null;
                   
    private sealed class ReadOnlyStream : DelegatingStream
    {
        public override bool CanWrite
        {
            get { return false; }
        }
        
        public override int WriteTimeout
        {
            get { throw new NotSupportedException(SR.net_http_content_readonly_stream); }
            set { throw new NotSupportedException(SR.net_http_content_readonly_stream); }
        }
        
        public ReadOnlyStream(Stream innerStream) : base(innerStream)
        {
        }
        
        public override void Flush()
        {
            throw new NotSupportedException(SR.net_http_content_readonly_stream);
        }
        
        public override Task FlushAsync(CancellationToken cancellationToken)
        {
            throw new NotSupportedException(SR.net_http_content_readonly_stream);
        }
        
        public override void SetLength(long value)
        {
            throw new NotSupportedException(SR.net_http_content_readonly_stream);
        }
        
        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException(SR.net_http_content_readonly_stream);
        }
        
        public override void Write(ReadOnlySpan<byte> buffer)
        {
            throw new NotSupportedException(SR.net_http_content_readonly_stream);
        }
        
        public override void WriteByte(byte value)
        {
            throw new NotSupportedException(SR.net_http_content_readonly_stream);
        }
        
        public override Task WriteAsync(byte[] buffer, int offset, int count, Threading.CancellationToken cancellationToken)
        {
            throw new NotSupportedException(SR.net_http_content_readonly_stream);
        }
        
        public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
        {
            throw new NotSupportedException(SR.net_http_content_readonly_stream);
        }
    }
}

```

##### 1.6.5 multipart content

```c#
public class MultipartContent : HttpContent, IEnumerable<HttpContent>
{    
    private const string CrLf = "\r\n";    
    private const int CrLfLength = 2;
    private const int DashDashLength = 2;
    private const int ColonSpaceLength = 2;
    private const int CommaSpaceLength = 2;
    
    private readonly List<HttpContent> _nestedContent;
    private readonly string _boundary;
       
    public HeaderEncodingSelector<HttpContent>? HeaderEncodingSelector { get; set; }
    
    public MultipartContent() : this("mixed", GetDefaultBoundary())
    { 
    }
    
    public MultipartContent(string subtype) : this(subtype, GetDefaultBoundary())
    { 
    }
    
    public MultipartContent(string subtype, string boundary)
    {
        if (string.IsNullOrWhiteSpace(subtype))
        {
            throw new ArgumentException(SR.net_http_argument_empty_string, nameof(subtype));
        }
        
        ValidateBoundary(boundary);        
        _boundary = boundary;
        
        string quotedBoundary = boundary;
        if (!quotedBoundary.StartsWith('\"'))
        {
            quotedBoundary = "\"" + quotedBoundary + "\"";
        }
        
        MediaTypeHeaderValue contentType = new MediaTypeHeaderValue("multipart/" + subtype);
        contentType.Parameters.Add(new NameValueHeaderValue(nameof(boundary), quotedBoundary));
        Headers.ContentType = contentType;
        
        _nestedContent = new List<HttpContent>();
    }
    
    private static void ValidateBoundary(string boundary)
    {
        // NameValueHeaderValue is too restrictive for boundary.
        // Instead validate it ourselves and then quote it.
        if (string.IsNullOrWhiteSpace(boundary))
        {
            throw new ArgumentException(SR.net_http_argument_empty_string, nameof(boundary));
        }
        
        // RFC 2046 Section 5.1.1
        // boundary := 0*69<bchars> bcharsnospace
        // bchars := bcharsnospace / " "
        // bcharsnospace := DIGIT / ALPHA / "'" / "(" / ")" / "+" / "_" / "," / "-" / "." / "/" / ":" / "=" / "?"
        if (boundary.Length > 70)
        {
            throw new ArgumentOutOfRangeException(
                nameof(boundary), 
                boundary,
                SR.Format(
                    System.Globalization.CultureInfo.InvariantCulture, 
                    R.net_http_content_field_too_long, 70));
        }
        // Cannot end with space.
        if (boundary.EndsWith(' '))
        {
            throw new ArgumentException(
                SR.Format(
                    System.Globalization.CultureInfo.InvariantCulture, 
                    SR.net_http_headers_invalid_value, 
                    boundary), 
                nameof(boundary));
        }
        
        const string AllowedMarks = @"'()+_,-./:=? ";
        
        foreach (char ch in boundary)
        {
            if (('0' <= ch && ch <= '9') || // Digit.
                ('a' <= ch && ch <= 'z') || // alpha.
                ('A' <= ch && ch <= 'Z') || // ALPHA.
                (AllowedMarks.Contains(ch))) // Marks.
            {
                // Valid.
            }
            else
            {
                throw new ArgumentException(
                    SR.Format(
                        System.Globalization.CultureInfo.InvariantCulture, 
                        SR.net_http_headers_invalid_value, 
                        boundary), 
                    nameof(boundary));
            }
        }
    }
    
    private static string GetDefaultBoundary()
    {
        return Guid.NewGuid().ToString();
    }
    
    public virtual void Add(HttpContent content)
    {
        if (content == null)
        {
            throw new ArgumentNullException(nameof(content));
        }
        
        _nestedContent.Add(content);
    }
    
    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            foreach (HttpContent content in _nestedContent)
            {
                content.Dispose();
            }
            _nestedContent.Clear();
        }
        base.Dispose(disposing);
    }
                          
    public IEnumerator<HttpContent> GetEnumerator()
    {
        return _nestedContent.GetEnumerator();
    }
           
    Collections.IEnumerator Collections.IEnumerable.GetEnumerator()
    {
        return _nestedContent.GetEnumerator();
    }
    
    
    
    
    
    
        // for-each content
        //   write "--" + boundary
        //   for-each content header
        //     write header: header-value
        //   write content.CopyTo[Async]
        // write "--" + boundary + "--"
        // Can't be canceled directly by the user.  If the overall request is canceled
        // then the stream will be closed an exception thrown.
        
        private sealed class ContentReadStream : Stream
        {
            private readonly Stream[] _streams;
            private readonly long _length;

            private int _next;
            private Stream? _current;
            private long _position;

            internal ContentReadStream(Stream[] streams)
            {
                Debug.Assert(streams != null);
                _streams = streams;
                foreach (Stream stream in streams)
                {
                    _length += stream.Length;
                }
            }

            protected override void Dispose(bool disposing)
            {
                if (disposing)
                {
                    foreach (Stream s in _streams)
                    {
                        s.Dispose();
                    }
                }
            }

            public override async ValueTask DisposeAsync()
            {
                foreach (Stream s in _streams)
                {
                    await s.DisposeAsync().ConfigureAwait(false);
                }
            }

            public override bool CanRead => true;
            public override bool CanSeek => true;
            public override bool CanWrite => false;

            public override int Read(byte[] buffer, int offset, int count)
            {
                ValidateBufferArguments(buffer, offset, count);
                if (count == 0)
                {
                    return 0;
                }

                while (true)
                {
                    if (_current != null)
                    {
                        int bytesRead = _current.Read(buffer, offset, count);
                        if (bytesRead != 0)
                        {
                            _position += bytesRead;
                            return bytesRead;
                        }

                        _current = null;
                    }

                    if (_next >= _streams.Length)
                    {
                        return 0;
                    }

                    _current = _streams[_next++];
                }
            }

            public override int Read(Span<byte> buffer)
            {
                if (buffer.Length == 0)
                {
                    return 0;
                }

                while (true)
                {
                    if (_current != null)
                    {
                        int bytesRead = _current.Read(buffer);
                        if (bytesRead != 0)
                        {
                            _position += bytesRead;
                            return bytesRead;
                        }

                        _current = null;
                    }

                    if (_next >= _streams.Length)
                    {
                        return 0;
                    }

                    _current = _streams[_next++];
                }
            }

            public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
            {
                ValidateBufferArguments(buffer, offset, count);
                return ReadAsyncPrivate(new Memory<byte>(buffer, offset, count), cancellationToken).AsTask();
            }

            public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default) =>
                ReadAsyncPrivate(buffer, cancellationToken);

            public override IAsyncResult BeginRead(byte[] array, int offset, int count, AsyncCallback? asyncCallback, object? asyncState) =>
                TaskToApm.Begin(ReadAsync(array, offset, count, CancellationToken.None), asyncCallback, asyncState);

            public override int EndRead(IAsyncResult asyncResult) =>
                TaskToApm.End<int>(asyncResult);

            public async ValueTask<int> ReadAsyncPrivate(Memory<byte> buffer, CancellationToken cancellationToken)
            {
                if (buffer.Length == 0)
                {
                    return 0;
                }

                while (true)
                {
                    if (_current != null)
                    {
                        int bytesRead = await _current.ReadAsync(buffer, cancellationToken).ConfigureAwait(false);
                        if (bytesRead != 0)
                        {
                            _position += bytesRead;
                            return bytesRead;
                        }

                        _current = null;
                    }

                    if (_next >= _streams.Length)
                    {
                        return 0;
                    }

                    _current = _streams[_next++];
                }
            }

            public override long Position
            {
                get { return _position; }
                set
                {
                    if (value < 0)
                    {
                        throw new ArgumentOutOfRangeException(nameof(value));
                    }

                    long previousStreamsLength = 0;
                    for (int i = 0; i < _streams.Length; i++)
                    {
                        Stream curStream = _streams[i];
                        long curLength = curStream.Length;

                        if (value < previousStreamsLength + curLength)
                        {
                            _current = curStream;
                            i++;
                            _next = i;

                            curStream.Position = value - previousStreamsLength;
                            for (; i < _streams.Length; i++)
                            {
                                _streams[i].Position = 0;
                            }

                            _position = value;
                            return;
                        }

                        previousStreamsLength += curLength;
                    }

                    _current = null;
                    _next = _streams.Length;
                    _position = value;
                }
            }

            public override long Seek(long offset, SeekOrigin origin)
            {
                switch (origin)
                {
                    case SeekOrigin.Begin:
                        Position = offset;
                        break;

                    case SeekOrigin.Current:
                        Position += offset;
                        break;

                    case SeekOrigin.End:
                        Position = _length + offset;
                        break;

                    default:
                        throw new ArgumentOutOfRangeException(nameof(origin));
                }

                return Position;
            }

            public override long Length => _length;

            public override void Flush() { }
            public override void SetLength(long value) { throw new NotSupportedException(); }
            public override void Write(byte[] buffer, int offset, int count) { throw new NotSupportedException(); }
            public override void Write(ReadOnlySpan<byte> buffer) { throw new NotSupportedException(); }
            public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken) { throw new NotSupportedException(); }
            public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default) { throw new NotSupportedException(); }
        }


        private static void WriteToStream(Stream stream, string content) =>
            WriteToStream(stream, content, HttpRuleParser.DefaultHttpEncoding);

        private static void WriteToStream(Stream stream, string content, Encoding encoding)
        {
            const int StackallocThreshold = 1024;

            int maxLength = encoding.GetMaxByteCount(content.Length);

            byte[]? rentedBuffer = null;
            Span<byte> buffer = maxLength <= StackallocThreshold
                ? stackalloc byte[StackallocThreshold]
                : (rentedBuffer = ArrayPool<byte>.Shared.Rent(maxLength));

            try
            {
                int written = encoding.GetBytes(content, buffer);
                stream.Write(buffer.Slice(0, written));
            }
            finally
            {
                if (rentedBuffer != null)
                {
                    ArrayPool<byte>.Shared.Return(rentedBuffer);
                }
            }
        }

        #endregion Serialization
    }
```

##### - selector

```c#
public delegate Encoding? HeaderEncodingSelector<TContext>(string headerName, TContext context);

```

##### - override base method

```c#
public class MultipartContent : HttpContent, IEnumerable<HttpContent>
{    
    internal override bool AllowDuplex => false;
    
    // for-each content, write "--" + boundary
    // for-each content header, 
    // 	- write header: header-value, 
    // 	- write content.CopyTo[Async]
    // 	- write "--" + boundary + "--"
    // Can't be canceled directly by the user.  
    // If the overall request is canceled then the stream will be closed an exception thrown.
    
    //
    protected override void SerializeToStream(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken)
    {
        Debug.Assert(stream != null);
        try
        {
            // Write start boundary.
            WriteToStream(stream, "--" + _boundary + CrLf);
            
            // Write each nested content.
            for (int contentIndex = 0; contentIndex < _nestedContent.Count; contentIndex++)
            {
                // Write divider, headers, and content.
                HttpContent content = _nestedContent[contentIndex];
                SerializeHeadersToStream(stream, content, writeDivider: contentIndex != 0);
                content.CopyTo(stream, context, cancellationToken);
            }
            
            // Write footer boundary.
            WriteToStream(stream, CrLf + "--" + _boundary + "--" + CrLf);
        }
        catch (Exception ex)
        {
            if (NetEventSource.Log.IsEnabled()) NetEventSource.Error(this, ex);
            throw;
        }
    }
        
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context) =>
        	SerializeToStreamAsyncCore(stream, context, default);
    
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken) =>           
            GetType() == typeof(MultipartContent) 
        		? SerializeToStreamAsyncCore(stream, context, cancellationToken) 
        		: base.SerializeToStreamAsync(stream, context, cancellationToken);
    
    private protected async Task SerializeToStreamAsyncCore(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken)
    {
        Debug.Assert(stream != null);
        try
        {
            // Write start boundary.
            await EncodeStringToStreamAsync(stream, "--" + _boundary + CrLf, cancellationToken)
                .ConfigureAwait(false);
            
            // Write each nested content.
            var output = new MemoryStream();
            for (int contentIndex = 0; contentIndex < _nestedContent.Count; contentIndex++)
            {
                // Write divider, headers, and content.
                HttpContent content = _nestedContent[contentIndex];
                
                output.SetLength(0);
                SerializeHeadersToStream(output, content, writeDivider: contentIndex != 0);
                output.Position = 0;
                await output.CopyToAsync(stream, cancellationToken).ConfigureAwait(false);                
                await content.CopyToAsync(stream, context, cancellationToken).ConfigureAwait(false);
            }
            
            // Write footer boundary.
            await EncodeStringToStreamAsync(stream, CrLf + "--" + _boundary + "--" + CrLf, cancellationToken)
                .ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            if (NetEventSource.Log.IsEnabled()) NetEventSource.Error(this, ex);
            throw;
        }
    }
    
    //
    protected override Stream CreateContentReadStream(CancellationToken cancellationToken)
    {
        ValueTask<Stream> task = CreateContentReadStreamAsyncCore(async: false, cancellationToken);
        Debug.Assert(task.IsCompleted);
        return task.GetAwaiter().GetResult();
    }
    
    protected override Task<Stream> CreateContentReadStreamAsync() =>
        CreateContentReadStreamAsyncCore(async: true, CancellationToken.None).AsTask();
    
    protected override Task<Stream> CreateContentReadStreamAsync(CancellationToken cancellationToken) =>        
        GetType() == typeof(MultipartContent) 
        	? CreateContentReadStreamAsyncCore(async: true, cancellationToken).AsTask() 
        	: base.CreateContentReadStreamAsync(cancellationToken);

    private async ValueTask<Stream> CreateContentReadStreamAsyncCore(bool async, CancellationToken cancellationToken)
    {
        try
        {
            var streams = new Stream[2 + (_nestedContent.Count * 2)];
            int streamIndex = 0;
            
            // Start boundary.
            streams[streamIndex++] = EncodeStringToNewStream("--" + _boundary + CrLf);
            
            // Each nested content.
            for (int contentIndex = 0; contentIndex < _nestedContent.Count; contentIndex++)
            {
                cancellationToken.ThrowIfCancellationRequested();
                
                HttpContent nestedContent = _nestedContent[contentIndex];
                streams[streamIndex++] = EncodeHeadersToNewStream(
                    nestedContent, 
                    writeDivider: contentIndex != 0);
                
                Stream readStream;
                if (async)
                {                        
                    readStream = nestedContent.TryReadAsStream() 
                        ?? await nestedContent.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
                }
                else
                {
                    readStream = nestedContent.ReadAsStream(cancellationToken);
                }
                // Cannot be null, at least an empty stream is necessary.
                readStream ??= new MemoryStream();
                
                if (!readStream.CanSeek)
                {
                    // Seekability impacts whether HttpClientHandlers are able to rewind. To maintain compat
                    // and to allow such use cases when a nested stream isn't seekable (which should be rare),
                    // we fall back to the base behavior. We don't dispose of the streams already obtained
                    // as we don't necessarily own them yet.                                        
                    // Do not pass a cancellationToken to base.CreateContentReadStreamAsync() as it would trigger an infinite 
                    // loop => StackOverflow
                    return async 
                        ? await base.CreateContentReadStreamAsync().ConfigureAwait(false) 
                        : base.CreateContentReadStream(cancellationToken);
                }
                
                streams[streamIndex++] = readStream;
            }
            
            // Footer boundary.
            streams[streamIndex] = EncodeStringToNewStream(CrLf + "--" + _boundary + "--" + CrLf);
            
            return new ContentReadStream(streams);
        }
        catch (Exception ex)
        {
            if (NetEventSource.Log.IsEnabled()) NetEventSource.Error(this, ex);
            throw;
        }
    }
    
    private void SerializeHeadersToStream(Stream stream, HttpContent content, bool writeDivider)
    {
        // Add divider.
        if (writeDivider) // Write divider for all but the first content.
        {
            WriteToStream(stream, CrLf + "--"); // const strings
            WriteToStream(stream, _boundary);
            WriteToStream(stream, CrLf);
        }
        
        // Add headers.
        foreach (KeyValuePair<string, IEnumerable<string>> headerPair in content.Headers)
        {
            Encoding headerValueEncoding = HeaderEncodingSelector?.Invoke(headerPair.Key, content) 
                ?? HttpRuleParser.DefaultHttpEncoding;
            
            WriteToStream(stream, headerPair.Key);
            WriteToStream(stream, ": ");
            string delim = string.Empty;
            foreach (string value in headerPair.Value)
            {
                WriteToStream(stream, delim);
                WriteToStream(stream, value, headerValueEncoding);
                delim = ", ";
            }
            WriteToStream(stream, CrLf);
        }
        
        // Extra CRLF to end headers (even if there are no headers).
        WriteToStream(stream, CrLf);
    }
    
    private static ValueTask EncodeStringToStreamAsync(
        Stream stream, 
        string input, 
        CancellationToken cancellationToken)
    {
        byte[] buffer = HttpRuleParser.DefaultHttpEncoding.GetBytes(input);
        return stream.WriteAsync(new ReadOnlyMemory<byte>(buffer), cancellationToken);
    }
    
    private static Stream EncodeStringToNewStream(string input)
    {
        return new MemoryStream(HttpRuleParser.DefaultHttpEncoding.GetBytes(input), writable: false);
    }
    
    private Stream EncodeHeadersToNewStream(HttpContent content, bool writeDivider)
    {
        var stream = new MemoryStream();
        SerializeHeadersToStream(stream, content, writeDivider);
        stream.Position = 0;
        return stream;
    }
    
    //
    protected internal override bool TryComputeLength(out long length)
    {
        // Start Boundary.
        long currentLength = DashDashLength + _boundary.Length + CrLfLength;
        
        if (_nestedContent.Count > 1)
        {
            // Internal boundaries
            currentLength += (_nestedContent.Count - 1) * (CrLfLength + DashDashLength + _boundary.Length + CrLfLength);
        }
        
        foreach (HttpContent content in _nestedContent)
        {
            // Headers.
            foreach (KeyValuePair<string, IEnumerable<string>> headerPair in content.Headers)
            {
                currentLength += headerPair.Key.Length + ColonSpaceLength;
                
                Encoding headerValueEncoding = HeaderEncodingSelector?.Invoke(headerPair.Key, content) 
                    ?? HttpRuleParser.DefaultHttpEncoding;
                
                int valueCount = 0;
                foreach (string value in headerPair.Value)
                {
                    currentLength += headerValueEncoding.GetByteCount(value);
                    valueCount++;
                }
                
                if (valueCount > 1)
                {
                    currentLength += (valueCount - 1) * CommaSpaceLength;
                }
                
                currentLength += CrLfLength;
            }
            
            currentLength += CrLfLength;
            
            // Content.
            if (!content.TryComputeLength(out long tempContentLength))
            {
                length = 0;
                return false;
            }
            currentLength += tempContentLength;
        }
        
        // Terminating boundary.
        currentLength += CrLfLength + DashDashLength + _boundary.Length + DashDashLength + CrLfLength;
        
        length = currentLength;
        return true;
    }        
}

```

###### 1.6.5.1 multipart form data content

```c#
public class MultipartFormDataContent : MultipartContent
{
    private const string formData = "form-data";
    
    public MultipartFormDataContent()            : base(formData)
    {
    }
    
    public MultipartFormDataContent(string boundary)            : base(formData, boundary)
    {
    }
    
    public override void Add(HttpContent content)
    {
        if (content == null)
        {
            throw new ArgumentNullException(nameof(content));
        }
        
        if (content.Headers.ContentDisposition == null)
        {
            content.Headers.ContentDisposition = new ContentDispositionHeaderValue(formData);
        }
        
        base.Add(content);
    }
    
    public void Add(HttpContent content, string name)
    {
        if (content == null)
        {
            throw new ArgumentNullException(nameof(content));
        }
        if (string.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException(SR.net_http_argument_empty_string, nameof(name));
        }
        
        AddInternal(content, name, null);
    }
    
    public void Add(HttpContent content, string name, string fileName)
    {
        if (content == null)
        {
            throw new ArgumentNullException(nameof(content));
        }
        if (string.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException(SR.net_http_argument_empty_string, nameof(name));
        }
        if (string.IsNullOrWhiteSpace(fileName))
        {
            throw new ArgumentException(SR.net_http_argument_empty_string, nameof(fileName));
        }
        
        AddInternal(content, name, fileName);
    }
    
    private void AddInternal(HttpContent content, string name, string? fileName)
    {
        if (content.Headers.ContentDisposition == null)
        {
            ContentDispositionHeaderValue header = new ContentDispositionHeaderValue(formData);
            header.Name = name;
            header.FileName = fileName;
            header.FileNameStar = fileName;
            
            content.Headers.ContentDisposition = header;
        }
        base.Add(content);
    }
    
    // 
    protected override Task SerializeToStreamAsync(
        Stream stream, 
        TransportContext? context, 
        CancellationToken cancellationToken) =>           
            GetType() == typeof(MultipartFormDataContent) ? SerializeToStreamAsyncCore(stream, context, cancellationToken) 
        	: base.SerializeToStreamAsync(stream, context, cancellationToken);
}

```



###### 1.1.6 status code

status code

status desription



##### 1.1.7 http utilities

```c#
internal static partial class HttpUtilities
    {
        internal static Version DefaultRequestVersion => HttpVersion.Version11;

        internal static Version DefaultResponseVersion => HttpVersion.Version11;

        internal static HttpVersionPolicy DefaultVersionPolicy => HttpVersionPolicy.RequestVersionOrLower;

        internal static bool IsHttpUri(Uri uri)
        {
            Debug.Assert(uri != null);
            return IsSupportedScheme(uri.Scheme);
        }

        internal static bool IsSupportedScheme(string scheme) =>
            IsSupportedNonSecureScheme(scheme) ||
            IsSupportedSecureScheme(scheme);

        internal static bool IsSupportedSecureScheme(string scheme) =>
            string.Equals(scheme, "https", StringComparison.OrdinalIgnoreCase) || IsSecureWebSocketScheme(scheme);

        internal static bool IsNonSecureWebSocketScheme(string scheme) =>
            string.Equals(scheme, "ws", StringComparison.OrdinalIgnoreCase);

        internal static bool IsSecureWebSocketScheme(string scheme) =>
            string.Equals(scheme, "wss", StringComparison.OrdinalIgnoreCase);

        internal static bool IsSupportedProxyScheme(string scheme) =>
            string.Equals(scheme, "http", StringComparison.OrdinalIgnoreCase) || IsSocksScheme(scheme);

        internal static bool IsSocksScheme(string scheme) =>
            string.Equals(scheme, "socks5", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(scheme, "socks4a", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(scheme, "socks4", StringComparison.OrdinalIgnoreCase);

        // Always specify TaskScheduler.Default to prevent us from using a user defined TaskScheduler.Current.
        //
        // Since we're not doing any CPU and/or I/O intensive operations, continue on the same thread.
        // This results in better performance since the continuation task doesn't get scheduled by the
        // scheduler and there are no context switches required.
        internal static Task ContinueWithStandard<T>(this Task<T> task, object state, Action<Task<T>, object?> continuation)
        {
            return task.ContinueWith(continuation, state, CancellationToken.None,
                TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
        }
    }

internal static partial class HttpUtilities
    {
        internal static bool IsSupportedNonSecureScheme(string scheme) =>
            string.Equals(scheme, "http", StringComparison.OrdinalIgnoreCase)
            || IsNonSecureWebSocketScheme(scheme);

        internal static string InvalidUriMessage => SR.net_http_client_http_baseaddress_required;
    }
```

### 2. http message

#### 2.1 http request message

```c#
 public class HttpRequestMessage : IDisposable
 {
     private const int MessageNotYetSent = 0;
     private const int MessageAlreadySent = 1;
     
     // send status
     private int _sendStatus = MessageNotYetSent;
     
     internal bool MarkAsSent()
     {
         return Interlocked.Exchange(ref _sendStatus, MessageAlreadySent) == MessageNotYetSent;
     }
     
     internal bool WasSentByHttpClient() => _sendStatus == MessageAlreadySent;
     
     // uri
     private Uri? _requestUri;  
     public Uri? RequestUri
     {
         get { return _requestUri; }
         set
         {
             if ((value != null) && 
                 (value.IsAbsoluteUri) && 
                 (!HttpUtilities.IsHttpUri(value)))
             {
                 throw new ArgumentException(HttpUtilities.InvalidUriMessage, nameof(value));
             }
             
             CheckDisposed();             
             // It's OK to set 'null'. 
             // HttpClient will add the 'BaseAddress'. If there is no 'BaseAddress' sending this message will throw.
             _requestUri = value;
         }
     }
     
     // version
     private Version _version;
     public Version Version
     {
         get { return _version; }
         set
         {
             if (value == null)
             {
                 throw new ArgumentNullException(nameof(value));
             }
             
             CheckDisposed();             
             _version = value;
         }
     }
     
     // version policy
     private HttpVersionPolicy _versionPolicy;
     public HttpVersionPolicy VersionPolicy
     {
         get { return _versionPolicy; }
         set
         {
             CheckDisposed();             
             _versionPolicy = value;
         }
     }
     
     // method
     private HttpMethod _method;
     public HttpMethod Method
     {
         get { return _method; }
         set
         {
             if (value == null)
             {
                 throw new ArgumentNullException(nameof(value));
             }
             
             CheckDisposed();             
             _method = value;
         }
     }
     
     // reqeust headers
     private HttpRequestHeaders? _headers;   
     public HttpRequestHeaders Headers
     {
         get
         {
             if (_headers == null)
             {
                 _headers = new HttpRequestHeaders();
             }
             return _headers;
         }
     }
     
     internal bool HasHeaders => _headers != null;
     
     // content
     private HttpContent? _content;     
     public HttpContent? Content
     {
         get { return _content; }
         set
         {
             CheckDisposed();
             
             if (NetEventSource.Log.IsEnabled())
             {
                 if (value == null)
                 {
                     NetEventSource.ContentNull(this);
                 }
                 else
                 {
                     NetEventSource.Associate(this, value);
                 }
             }             
             // It's OK to set a 'null' content, even if the method is POST/PUT.
             _content = value;
         }
     }
     
     // check disposed
     private void CheckDisposed()
     {
         if (_disposed)
         {
             throw new ObjectDisposedException(this.GetType().ToString());
         }
     }
          
     // request options
     private HttpRequestOptions? _options;
     public HttpRequestOptions Options => _options ??= new HttpRequestOptions();
     
     private bool _disposed;
     
     
     // ctor                      
     public HttpRequestMessage() : this(HttpMethod.Get, (Uri?)null)
     {
     }
     
     public HttpRequestMessage(HttpMethod method, Uri? requestUri)
     {
         InitializeValues(method, requestUri);
     }
     
     public HttpRequestMessage(HttpMethod method, string? requestUri)
     {
         // It's OK to have a 'null' request Uri. 
         // If HttpClient is used, the 'BaseAddress' will be added.
         // If there is no 'BaseAddress', sending this request message will throw.
         // Note that we also allow the string to be empty: null and empty are considered equivalent.
         if (string.IsNullOrEmpty(requestUri))
         {
             InitializeValues(method, null);
         }
         else
         {
             InitializeValues(method, new Uri(requestUri, UriKind.RelativeOrAbsolute));
         }
     }          
     
     [MemberNotNull(nameof(_method))]
     [MemberNotNull(nameof(_version))]
     private void InitializeValues(HttpMethod method, Uri? requestUri)
     {
         if (method is null)
         {
             throw new ArgumentNullException(nameof(method));
         }
         
         if ((requestUri != null) && 
             (requestUri.IsAbsoluteUri) && 
             (!HttpUtilities.IsHttpUri(requestUri)))
         {
             throw new ArgumentException(HttpUtilities.InvalidUriMessage, nameof(requestUri));
         }
         
         _method = method;
         _requestUri = requestUri;
         _version = HttpUtilities.DefaultRequestVersion;
         _versionPolicy = HttpUtilities.DefaultVersionPolicy;
     }          
     
     public override string ToString()
     {
         StringBuilder sb = new StringBuilder();
         
         sb.Append("Method: ");
         sb.Append(_method);
         
         sb.Append(", RequestUri: '");
         sb.Append(_requestUri == null ? "<null>" : _requestUri.ToString());
         
         sb.Append("', Version: ");
         sb.Append(_version);
         
         sb.Append(", Content: ");
         sb.Append(_content == null ? "<null>" : _content.GetType().ToString());
         
         sb.AppendLine(", Headers:");
         HeaderUtilities.DumpHeaders(sb, _headers, _content?.Headers);
         
         return sb.ToString();
     }
                 
     protected virtual void Dispose(bool disposing)
     {
         // The reason for this type to implement IDisposable is that it contains instances of types that implement
         // IDisposable (content).
         if (disposing && !_disposed)
         {
             _disposed = true;
             if (_content != null)
             {
                 _content.Dispose();
             }
         }
     }
     
     public void Dispose()
     {
         Dispose(true);
         GC.SuppressFinalize(this);
     }               
 }

```

#### 2.2 http response message

```c#
public class HttpResponseMessage : IDisposable
{
    private const HttpStatusCode defaultStatusCode = HttpStatusCode.OK;
    
    // version
    private Version _version;
    public Version Version
    {
        get { return _version; }
        set
        {
#if !PHONE
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }
#endif
            CheckDisposed();            
            _version = value;
        }
    }    
    
    internal void SetVersionWithoutValidation(Version value) => _version = value;                        
    
    // status code
    private HttpStatusCode _statusCode;
    public HttpStatusCode StatusCode
    {
        get { return _statusCode; }
        set
        {
            if (((int)value < 0) || ((int)value > 999))
            {
                throw new ArgumentOutOfRangeException(nameof(value));
            }
            
            CheckDisposed();            
            _statusCode = value;
        }
    }    
    
    internal void SetStatusCodeWithoutValidation(HttpStatusCode value) => _statusCode = value;            
    
    public bool IsSuccessStatusCode
    {
        get { return ((int)_statusCode >= 200) && ((int)_statusCode <= 299); }
    }
    
    // reason phrase
    private string? _reasonPhrase;
    public string? ReasonPhrase
    {
        get
        {
            if (_reasonPhrase != null)
            {
                return _reasonPhrase;
            }
            // Provide a default if one was not set.
            return HttpStatusDescription.Get(StatusCode);
        }
        set
        {
            if ((value != null) && ContainsNewLineCharacter(value))
            {
                throw new FormatException(SR.net_http_reasonphrase_format_error);
            }
            
            CheckDisposed();      
            // It's OK to have a 'null' reason phrase.
            _reasonPhrase = value; 
        }
    }
    
    internal void SetReasonPhraseWithoutValidation(string value) => _reasonPhrase = value;
    
    // headers
    private HttpResponseHeaders? _headers;
    public HttpResponseHeaders Headers => _headers ??= new HttpResponseHeaders();
    
    // trailing headers
    private HttpResponseHeaders? _trailingHeaders;         
    public HttpResponseHeaders TrailingHeaders => _trailingHeaders ??= new HttpResponseHeaders(containsTrailingHeaders: true);
    
    // In the common/desired case where response.TrailingHeaders isn't accessed until after the whole payload has been
    // received, "_trailingHeaders" will still be null, and we can simply store the supplied instance into
    // "_trailingHeaders" and assume ownership of the instance.  
    // In the uncommon case where it was accessed, we add all of the headers to the existing instance.    
    internal void StoreReceivedTrailingHeaders(HttpResponseHeaders headers)
    {
        Debug.Assert(headers.ContainsTrailingHeaders);
        
        if (_trailingHeaders is null)
        {
            _trailingHeaders = headers;
        }
        else
        {
            _trailingHeaders.AddHeaders(headers);
        }
    }
    
    // request message
    private HttpRequestMessage? _requestMessage;
    public HttpRequestMessage? RequestMessage
    {
        get { return _requestMessage; }
        set
        {
            CheckDisposed();
            if (value is not null && NetEventSource.Log.IsEnabled())
            {
                 NetEventSource.Associate(this, value);
            }            
            _requestMessage = value;
        }
    }
        
    // content
    private HttpContent? _content;
    [AllowNull]
    public HttpContent Content
    {
        get { return _content ??= new EmptyContent(); }
        set
        {
            CheckDisposed();            
            if (NetEventSource.Log.IsEnabled())
            {
                if (value == null)
                {
                    NetEventSource.ContentNull(this);
                }
                else
                {
                    NetEventSource.Associate(this, value);
                }
            }            
            _content = value;
        }
    }
    
    // check disposed
    private void CheckDisposed()
	{
    	if (_disposed)
        {
            throw new ObjectDisposedException(this.GetType().ToString());
        }
	}
    
    private bool _disposed;
    
    // ctor               
    public HttpResponseMessage() : this(defaultStatusCode)
    {
    }
    
    public HttpResponseMessage(HttpStatusCode statusCode)
    {
        if (((int)statusCode < 0) || ((int)statusCode > 999))
        {
            throw new ArgumentOutOfRangeException(nameof(statusCode));
        }
        
        _statusCode = statusCode;
        _version = HttpUtilities.DefaultResponseVersion;
    }
    
    public HttpResponseMessage EnsureSuccessStatusCode()
    {
        if (!IsSuccessStatusCode)
        {
            throw new HttpRequestException(
                SR.Format(
                    System.Globalization.CultureInfo.InvariantCulture,
                    SR.net_http_message_not_success_statuscode,
                    (int)_statusCode,
                    ReasonPhrase),
                inner: null,
                _statusCode);
        }
        
        return this;
    }
    
    public override string ToString()
    {
        StringBuilder sb = new StringBuilder();
        
        sb.Append("StatusCode: ");
        sb.Append((int)_statusCode);
        
        sb.Append(", ReasonPhrase: '");
        sb.Append(ReasonPhrase ?? "<null>");
        
        sb.Append("', Version: ");
        sb.Append(_version);
        
        sb.Append(", Content: ");
        sb.Append(_content == null ? "<null>" : _content.GetType().ToString());
        
        sb.AppendLine(", Headers:");
        HeaderUtilities.DumpHeaders(sb, _headers, _content?.Headers);
        
        if (_trailingHeaders != null)
        {
            sb.AppendLine(", Trailing Headers:");
            HeaderUtilities.DumpHeaders(sb, _trailingHeaders);
        }
        
        return sb.ToString();
    }
    
    private bool ContainsNewLineCharacter(string value)
    {
        foreach (char character in value)
        {
            if ((character == HttpRuleParser.CR) || (character == HttpRuleParser.LF))
            {
                return true;
            }
        }
        return false;
    }
    
   
    protected virtual void Dispose(bool disposing)
    {
        // The reason for this type to implement IDisposable is that it contains instances of types that implement
        // IDisposable (content).
        if (disposing && !_disposed)
        {
            _disposed = true;
            if (_content != null)
            {
                _content.Dispose();
            }
        }
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }              
}

```

### 3. http message handler

```c#
public abstract class HttpMessageHandler : IDisposable
{
    protected HttpMessageHandler()
    {
        if (NetEventSource.Log.IsEnabled()) NetEventSource.Info(this);
    }
    
    // We cannot add abstract member to a public class in order to not to break already established contract of this class.
    // So we add virtual method, override it everywhere internally and provide proper implementation.
    // Unfortunately we cannot force everyone to implement so in such case we throw NSE.
    protected internal virtual HttpResponseMessage Send(
        HttpRequestMessage request, 
        CancellationToken cancellationToken)
    {
        throw new NotSupportedException(
            SR.Format(
                SR.net_http_missing_sync_implementation, 
                GetType(), nameof(HttpMessageHandler), 
                nameof(Send)));
    }
    
    protected internal abstract Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request, 
        CancellationToken cancellationToken);
     
    protected virtual void Dispose(bool disposing)
    {
        // Nothing to do in base class.
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}

```

#### 3.1 delegating handler

```c#
public abstract class DelegatingHandler : HttpMessageHandler
{
    private HttpMessageHandler? _innerHandler;
    private volatile bool _operationStarted;
    private volatile bool _disposed;
    
    [DisallowNull]
    public HttpMessageHandler? InnerHandler
    {
        get
        {
            return _innerHandler;
        }
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }
            CheckDisposedOrStarted();
            
            if (NetEventSource.Log.IsEnabled()) NetEventSource.Associate(this, value);
            _innerHandler = value;
        }
    }
    
    protected DelegatingHandler()
    {
    }
    
    protected DelegatingHandler(HttpMessageHandler innerHandler)
    {
        InnerHandler = innerHandler;
    }
    
    protected internal override HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        if (request == null)
        {
            throw new ArgumentNullException(nameof(request), SR.net_http_handler_norequest);
        }
        SetOperationStarted();
        return _innerHandler!.Send(request, cancellationToken);
    }
    
    protected internal override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        if (request == null)
        {
            throw new ArgumentNullException(nameof(request), SR.net_http_handler_norequest);
        }
        SetOperationStarted();
        return _innerHandler!.SendAsync(request, cancellationToken);
    }
    
    protected override void Dispose(bool disposing)
    {
        if (disposing && !_disposed)
        {
            _disposed = true;
            if (_innerHandler != null)
            {
                _innerHandler.Dispose();
            }
        }
        
        base.Dispose(disposing);
    }
    
    private void CheckDisposed()
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(GetType().ToString());
        }
    }
    
    private void CheckDisposedOrStarted()
    {
        CheckDisposed();
        if (_operationStarted)
        {
            throw new InvalidOperationException(SR.net_http_operation_started);
        }
    }
    
    private void SetOperationStarted()
    {
        CheckDisposed();
        if (_innerHandler == null)
        {
            throw new InvalidOperationException(SR.net_http_handler_not_assigned);
        }
        // This method flags the handler instances as "active". I.e. we executed at least one request (or are
        // in the process of doing so). This information is used to lock-down all property setters. Once a
        // Send/SendAsync operation started, no property can be changed.
        if (!_operationStarted)
        {
            _operationStarted = true;
        }
    }
}

```

##### 3.1.1 dig handler

```c#
internal sealed class DiagnosticsHandler : DelegatingHandler
{
    /// <summary>
    /// DiagnosticHandler constructor
    /// </summary>
    /// <param name="innerHandler">Inner handler: Windows or Unix implementation of HttpMessageHandler.
    
    /// Note that DiagnosticHandler is the latest in the pipeline </param>
    public DiagnosticsHandler(HttpMessageHandler innerHandler) : base(innerHandler)
    {
    }
    
    internal static bool IsEnabled()
    {
        // check if there is a parent Activity (and propagation is not suppressed)
        // or if someone listens to HttpHandlerDiagnosticListener
        return IsGloballyEnabled() && (Activity.Current != null || Settings.s_diagnosticListener.IsEnabled());
    }
    
    internal static bool IsGloballyEnabled()
    {
        return Settings.s_activityPropagationEnabled;
    }
    
    // SendAsyncCore returns already completed ValueTask for when async: false is passed.
    // Internally, it calls the synchronous Send method of the base class.
    protected internal override HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken) =>
        SendAsyncCore(request, async: false, cancellationToken).AsTask().GetAwaiter().GetResult();
    
    protected internal override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) =>
        SendAsyncCore(request, async: true, cancellationToken).AsTask();
    
    private async ValueTask<HttpResponseMessage> SendAsyncCore(HttpRequestMessage request, bool async,
                                                               CancellationToken cancellationToken)
    {
        // HttpClientHandler is responsible to call static DiagnosticsHandler.IsEnabled() before forwarding request here.
        // It will check if propagation is on (because parent Activity exists or there is a listener) or off (forcibly disabled)
        // This code won't be called unless consumer unsubscribes from DiagnosticListener right after the check.
        // So some requests happening right after subscription starts might not be instrumented. Similarly,
        // when consumer unsubscribes, extra requests might be instrumented
        
        if (request == null)
        {
            throw new ArgumentNullException(nameof(request), SR.net_http_handler_norequest);
        }
        
        Activity? activity = null;
        DiagnosticListener diagnosticListener = Settings.s_diagnosticListener;
        
        // if there is no listener, but propagation is enabled (with previous IsEnabled() check)
        // do not write any events just start/stop Activity and propagate Ids
        if (!diagnosticListener.IsEnabled())
        {
            activity = new Activity(DiagnosticsHandlerLoggingStrings.ActivityName);
            activity.Start();
            InjectHeaders(activity, request);
            
            try
            {
                return async ?
                    await base.SendAsync(request, cancellationToken).ConfigureAwait(false) :
                base.Send(request, cancellationToken);
            }
            finally
            {
                activity.Stop();
            }
        }
        
        Guid loggingRequestId = Guid.Empty;
        
        // There is a listener. Check if listener wants to be notified about HttpClient Activities
        if (diagnosticListener.IsEnabled(DiagnosticsHandlerLoggingStrings.ActivityName, request))
        {
            activity = new Activity(DiagnosticsHandlerLoggingStrings.ActivityName);
            
            // Only send start event to users who subscribed for it, but start activity anyway
            if (diagnosticListener.IsEnabled(DiagnosticsHandlerLoggingStrings.ActivityStartName))
            {
                StartActivity(diagnosticListener, activity, new ActivityStartData(request));
            }
            else
            {
                activity.Start();
            }
        }
        // try to write System.Net.Http.Request event (deprecated)
        if (diagnosticListener.IsEnabled(DiagnosticsHandlerLoggingStrings.RequestWriteNameDeprecated))
        {
            long timestamp = Stopwatch.GetTimestamp();
            loggingRequestId = Guid.NewGuid();
            Write(diagnosticListener, DiagnosticsHandlerLoggingStrings.RequestWriteNameDeprecated,
                  new RequestData(request, loggingRequestId, timestamp));
        }
        
        // If we are on at all, we propagate current activity information
        Activity? currentActivity = Activity.Current;
        if (currentActivity != null)
        {
            InjectHeaders(currentActivity, request);
        }
        
        HttpResponseMessage? response = null;
        TaskStatus taskStatus = TaskStatus.RanToCompletion;
        try
        {
            response = async ?
                await base.SendAsync(request, cancellationToken).ConfigureAwait(false) :
            base.Send(request, cancellationToken);
            return response;
        }
        catch (OperationCanceledException)
        {
            taskStatus = TaskStatus.Canceled;
            
            // we'll report task status in HttpRequestOut.Stop
            throw;
        }
        catch (Exception ex)
        {
            taskStatus = TaskStatus.Faulted;
            
            if (diagnosticListener.IsEnabled(DiagnosticsHandlerLoggingStrings.ExceptionEventName))
            {
                // If request was initially instrumented, Activity.Current has all necessary context for logging
                // Request is passed to provide some context if instrumentation was disabled and to avoid
                // extensive Activity.Tags usage to tunnel request properties
                Write(diagnosticListener, DiagnosticsHandlerLoggingStrings.ExceptionEventName, new ExceptionData(ex, request));
            }
            throw;
        }
        finally
        {
            // always stop activity if it was started
            if (activity != null)
            {
                StopActivity(diagnosticListener, activity, new ActivityStopData(
                    response,
                    // If request is failed or cancelled, there is no response, therefore no information about request;
                    // pass the request in the payload, so consumers can have it in Stop for failed/canceled requests
                    // and not retain all requests in Start
                    request,
                    taskStatus));
            }
            // Try to write System.Net.Http.Response event (deprecated)
            if (diagnosticListener.IsEnabled(DiagnosticsHandlerLoggingStrings.ResponseWriteNameDeprecated))
            {
                long timestamp = Stopwatch.GetTimestamp();
                Write(diagnosticListener, DiagnosticsHandlerLoggingStrings.ResponseWriteNameDeprecated,
                      new ResponseData(
                          response,
                          loggingRequestId,
                          timestamp,
                            taskStatus));
                }
            }
        }

        #region private

        private sealed class ActivityStartData
        {
            // matches the properties selected in https://github.com/dotnet/diagnostics/blob/ffd0254da3bcc47847b1183fa5453c0877020abd/src/Microsoft.Diagnostics.Monitoring.EventPipe/Configuration/HttpRequestSourceConfiguration.cs#L36-L40
            [DynamicDependency(nameof(HttpRequestMessage.RequestUri), typeof(HttpRequestMessage))]
            [DynamicDependency(nameof(HttpRequestMessage.Method), typeof(HttpRequestMessage))]
            [DynamicDependency(nameof(HttpRequestMessage.RequestUri), typeof(HttpRequestMessage))]
            [DynamicDependency(nameof(Uri.Host), typeof(Uri))]
            [DynamicDependency(nameof(Uri.Port), typeof(Uri))]
            internal ActivityStartData(HttpRequestMessage request)
            {
                Request = request;
            }

            public HttpRequestMessage Request { get; }

            public override string ToString() => $"{{ {nameof(Request)} = {Request} }}";
        }

        private sealed class ActivityStopData
        {
            internal ActivityStopData(HttpResponseMessage? response, HttpRequestMessage request, TaskStatus requestTaskStatus)
            {
                Response = response;
                Request = request;
                RequestTaskStatus = requestTaskStatus;
            }

            public HttpResponseMessage? Response { get; }
            public HttpRequestMessage Request { get; }
            public TaskStatus RequestTaskStatus { get; }

            public override string ToString() => $"{{ {nameof(Response)} = {Response}, {nameof(Request)} = {Request}, {nameof(RequestTaskStatus)} = {RequestTaskStatus} }}";
        }

        private sealed class ExceptionData
        {
            // preserve the same properties as ActivityStartData above + common Exception properties
            [DynamicDependency(nameof(HttpRequestMessage.RequestUri), typeof(HttpRequestMessage))]
            [DynamicDependency(nameof(HttpRequestMessage.Method), typeof(HttpRequestMessage))]
            [DynamicDependency(nameof(HttpRequestMessage.RequestUri), typeof(HttpRequestMessage))]
            [DynamicDependency(nameof(Uri.Host), typeof(Uri))]
            [DynamicDependency(nameof(Uri.Port), typeof(Uri))]
            [DynamicDependency(nameof(System.Exception.Message), typeof(Exception))]
            [DynamicDependency(nameof(System.Exception.StackTrace), typeof(Exception))]
            internal ExceptionData(Exception exception, HttpRequestMessage request)
            {
                Exception = exception;
                Request = request;
            }

            public Exception Exception { get; }
            public HttpRequestMessage Request { get; }

            public override string ToString() => $"{{ {nameof(Exception)} = {Exception}, {nameof(Request)} = {Request} }}";
        }

        private sealed class RequestData
        {
            // preserve the same properties as ActivityStartData above
            [DynamicDependency(nameof(HttpRequestMessage.RequestUri), typeof(HttpRequestMessage))]
            [DynamicDependency(nameof(HttpRequestMessage.Method), typeof(HttpRequestMessage))]
            [DynamicDependency(nameof(HttpRequestMessage.RequestUri), typeof(HttpRequestMessage))]
            [DynamicDependency(nameof(Uri.Host), typeof(Uri))]
            [DynamicDependency(nameof(Uri.Port), typeof(Uri))]
            internal RequestData(HttpRequestMessage request, Guid loggingRequestId, long timestamp)
            {
                Request = request;
                LoggingRequestId = loggingRequestId;
                Timestamp = timestamp;
            }

            public HttpRequestMessage Request { get; }
            public Guid LoggingRequestId { get; }
            public long Timestamp { get; }

            public override string ToString() => $"{{ {nameof(Request)} = {Request}, {nameof(LoggingRequestId)} = {LoggingRequestId}, {nameof(Timestamp)} = {Timestamp} }}";
        }

        private sealed class ResponseData
        {
            [DynamicDependency(nameof(HttpResponseMessage.StatusCode), typeof(HttpResponseMessage))]
            internal ResponseData(HttpResponseMessage? response, Guid loggingRequestId, long timestamp, TaskStatus requestTaskStatus)
            {
                Response = response;
                LoggingRequestId = loggingRequestId;
                Timestamp = timestamp;
                RequestTaskStatus = requestTaskStatus;
            }

            public HttpResponseMessage? Response { get; }
            public Guid LoggingRequestId { get; }
            public long Timestamp { get; }
            public TaskStatus RequestTaskStatus { get; }

            public override string ToString() => $"{{ {nameof(Response)} = {Response}, {nameof(LoggingRequestId)} = {LoggingRequestId}, {nameof(Timestamp)} = {Timestamp}, {nameof(RequestTaskStatus)} = {RequestTaskStatus} }}";
        }

        private static class Settings
        {
            private const string EnableActivityPropagationEnvironmentVariableSettingName = "DOTNET_SYSTEM_NET_HTTP_ENABLEACTIVITYPROPAGATION";
            private const string EnableActivityPropagationAppCtxSettingName = "System.Net.Http.EnableActivityPropagation";

            public static readonly bool s_activityPropagationEnabled = GetEnableActivityPropagationValue();

            private static bool GetEnableActivityPropagationValue()
            {
                // First check for the AppContext switch, giving it priority over the environment variable.
                if (AppContext.TryGetSwitch(EnableActivityPropagationAppCtxSettingName, out bool enableActivityPropagation))
                {
                    return enableActivityPropagation;
                }

                // AppContext switch wasn't used. Check the environment variable to determine which handler should be used.
                string? envVar = Environment.GetEnvironmentVariable(EnableActivityPropagationEnvironmentVariableSettingName);
                if (envVar != null && (envVar.Equals("false", StringComparison.OrdinalIgnoreCase) || envVar.Equals("0")))
                {
                    // Suppress Activity propagation.
                    return false;
                }

                // Defaults to enabling Activity propagation.
                return true;
            }

            public static readonly DiagnosticListener s_diagnosticListener =
                new DiagnosticListener(DiagnosticsHandlerLoggingStrings.DiagnosticListenerName);
        }

        private static void InjectHeaders(Activity currentActivity, HttpRequestMessage request)
        {
            if (currentActivity.IdFormat == ActivityIdFormat.W3C)
            {
                if (!request.Headers.Contains(DiagnosticsHandlerLoggingStrings.TraceParentHeaderName))
                {
                    request.Headers.TryAddWithoutValidation(DiagnosticsHandlerLoggingStrings.TraceParentHeaderName, currentActivity.Id);
                    if (currentActivity.TraceStateString != null)
                    {
                        request.Headers.TryAddWithoutValidation(DiagnosticsHandlerLoggingStrings.TraceStateHeaderName, currentActivity.TraceStateString);
                    }
                }
            }
            else
            {
                if (!request.Headers.Contains(DiagnosticsHandlerLoggingStrings.RequestIdHeaderName))
                {
                    request.Headers.TryAddWithoutValidation(DiagnosticsHandlerLoggingStrings.RequestIdHeaderName, currentActivity.Id);
                }
            }

            // we expect baggage to be empty or contain a few items
            using (IEnumerator<KeyValuePair<string, string?>> e = currentActivity.Baggage.GetEnumerator())
            {
                if (e.MoveNext())
                {
                    var baggage = new List<string>();
                    do
                    {
                        KeyValuePair<string, string?> item = e.Current;
                        baggage.Add(new NameValueHeaderValue(WebUtility.UrlEncode(item.Key), WebUtility.UrlEncode(item.Value)).ToString());
                    }
                    while (e.MoveNext());
                    request.Headers.TryAddWithoutValidation(DiagnosticsHandlerLoggingStrings.CorrelationContextHeaderName, baggage);
                }
            }
        }

        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern",
            Justification = "The values being passed into Write have the commonly used properties being preserved with DynamicDependency.")]
        private static void Write<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] T>(
            DiagnosticSource diagnosticSource,
            string name,
            T value)
        {
            diagnosticSource.Write(name, value);
        }

        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern",
            Justification = "The args being passed into StartActivity have the commonly used properties being preserved with DynamicDependency.")]
        private static Activity StartActivity<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] T>(
            DiagnosticSource diagnosticSource,
            Activity activity,
            T? args)
        {
            return diagnosticSource.StartActivity(activity, args);
        }

        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern",
            Justification = "The args being passed into StopActivity have the commonly used properties being preserved with DynamicDependency.")]
        private static void StopActivity<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] T>(
            DiagnosticSource diagnosticSource,
            Activity activity,
            T? args)
        {
            diagnosticSource.StopActivity(activity, args);
        }

        #endregion
    }
```

##### 3.1.2 message handler

```c#
public abstract class MessageProcessingHandler : DelegatingHandler
{
    protected MessageProcessingHandler()
    {
    }
    
    protected MessageProcessingHandler(HttpMessageHandler innerHandler)        : base(innerHandler)
    {
    }
    
    protected abstract HttpRequestMessage ProcessRequest(HttpRequestMessage request,
                                                         CancellationToken cancellationToken);
    protected abstract HttpResponseMessage ProcessResponse(HttpResponseMessage response,
                                                           CancellationToken cancellationToken);
    
    protected internal sealed override HttpResponseMessage Send(HttpRequestMessage request,
                                                                CancellationToken cancellationToken)
    {
        if (request == null)
        {
            throw new ArgumentNullException(nameof(request), SR.net_http_handler_norequest);
        }
        
        // Since most of the SendAsync code is just Task handling, there's no reason to share the code.
        HttpRequestMessage newRequestMessage = ProcessRequest(request, cancellationToken);
        HttpResponseMessage response = base.Send(newRequestMessage, cancellationToken);
        HttpResponseMessage newResponseMessage = ProcessResponse(response, cancellationToken);
        return newResponseMessage;
    }
    
    protected internal sealed override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request,
                                                                           CancellationToken cancellationToken)
    {
        if (request == null)
        {
            throw new ArgumentNullException(nameof(request), SR.net_http_handler_norequest);
        }
        
        // ProcessRequest() and ProcessResponse() are supposed to be fast, so we call ProcessRequest() on the same
        // thread SendAsync() was invoked to avoid context switches. However, if ProcessRequest() throws, we have
        // to catch the exception since the caller doesn't expect exceptions when calling SendAsync(): The
        // expectation is that the returned task will get faulted on errors, but the async call to SendAsync()
        // should complete.
            var tcs = new SendState(this, cancellationToken);
            try
            {
                HttpRequestMessage newRequestMessage = ProcessRequest(request, cancellationToken);
                Task<HttpResponseMessage> sendAsyncTask = base.SendAsync(newRequestMessage, cancellationToken);

                // We schedule a continuation task once the inner handler completes in order to trigger the response
                // processing method. ProcessResponse() is only called if the task wasn't canceled before.
                sendAsyncTask.ContinueWithStandard(tcs, static (task, state) =>
                {
                    var sendState = (SendState)state!;
                    MessageProcessingHandler self = sendState._handler;
                    CancellationToken token = sendState._token;

                    if (task.IsFaulted)
                    {
                        sendState.TrySetException(task.Exception!.GetBaseException());
                        return;
                    }

                    if (task.IsCanceled)
                    {
                        sendState.TrySetCanceled(token);
                        return;
                    }

                    if (task.Result == null)
                    {
                        sendState.TrySetException(ExceptionDispatchInfo.SetCurrentStackTrace(new InvalidOperationException(SR.net_http_handler_noresponse)));
                        return;
                    }

                    try
                    {
                        HttpResponseMessage responseMessage = self.ProcessResponse(task.Result, token);
                        sendState.TrySetResult(responseMessage);
                    }
                    catch (OperationCanceledException e)
                    {
                        // If ProcessResponse() throws an OperationCanceledException check whether it is related to
                        // the cancellation token we received from the user. If so, cancel the Task.
                        HandleCanceledOperations(token, sendState, e);
                    }
                    catch (Exception e)
                    {
                        sendState.TrySetException(e);
                    }
                    // We don't pass the cancellation token to the continuation task, since we want to get called even
                    // if the operation was canceled: We'll set the Task returned to the user to canceled. Passing the
                    // cancellation token here would result in the continuation task to not be called at all. I.e. we
                    // would never complete the task returned to the caller of SendAsync().
                });
            }
            catch (OperationCanceledException e)
            {
                HandleCanceledOperations(cancellationToken, tcs, e);
            }
            catch (Exception e)
            {
                tcs.TrySetException(e);
            }

            return tcs.Task;
        }

        private static void HandleCanceledOperations(CancellationToken cancellationToken,
            TaskCompletionSource<HttpResponseMessage> tcs, OperationCanceledException e)
        {
            // Check if the exception was due to a cancellation. If so, check if the OperationCanceledException is
            // related to our CancellationToken. If it was indeed caused due to our cancellation token being
            // canceled, set the Task as canceled. Set it to faulted otherwise, since the OperationCanceledException
            // is not related to our cancellation token.
            if (cancellationToken.IsCancellationRequested && (e.CancellationToken == cancellationToken))
            {
                tcs.TrySetCanceled(cancellationToken);
            }
            else
            {
                tcs.TrySetException(e);
            }
        }

        // Private class used to capture the SendAsync state in
        // a closure, while simultaneously avoiding a tuple allocation.
        private sealed class SendState : TaskCompletionSource<HttpResponseMessage>
        {
            internal readonly MessageProcessingHandler _handler;
            internal readonly CancellationToken _token;

            public SendState(MessageProcessingHandler handler, CancellationToken token)
            {
                Debug.Assert(handler != null);

                _handler = handler;
                _token = token;
            }
        }
    }
```



#### 3.2 http client handler





