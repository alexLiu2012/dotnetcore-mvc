## about middlewares in http response



### 1. about



### 2. http response caching

#### 2.1 response cache entry

```c#
internal interface IResponseCacheEntry
{
}

```

##### 2.1.1 cached response

```c#
internal class CachedResponse : IResponseCacheEntry
{
    public DateTimeOffset Created { get; set; }    
    public int StatusCode { get; set; }    
    public IHeaderDictionary Headers { get; set; } = default!;    
    public CachedResponseBody Body { get; set; } = default!;
}

internal class CachedResponseBody
{
    public List<byte[]> Segments { get; }    
    public long Length { get; }
    
    public CachedResponseBody(List<byte[]> segments, long length)
    {
        Segments = segments;
        Length = length;
    }
    
    public async Task CopyToAsync(PipeWriter destination, CancellationToken cancellationToken)
    {
        if (destination == null)
        {
            throw new ArgumentNullException(nameof(destination));
        }
        
        foreach (var segment in Segments)
        {
            cancellationToken.ThrowIfCancellationRequested();            
            Copy(segment, destination);            
            await destination.FlushAsync();
        }
    }
    
    private static void Copy(byte[] segment, PipeWriter destination)
    {
        var span = destination.GetSpan(segment.Length);
        
        segment.CopyTo(span);
        destination.Advance(segment.Length);
    }
}

```

##### 2.1.2 cached vary by rules

```c#
internal class CachedVaryByRules : IResponseCacheEntry
{
    public string VaryByKeyPrefix { get; set; } = default!;    
    public StringValues Headers { get; set; }    
    public StringValues QueryKeys { get; set; }
}

```

##### 2.1.3 cache entry helper

```c#
internal static class CacheEntryHelpers
{
    internal static long EstimateCachedResponseSize(CachedResponse cachedResponse)
    {
        if (cachedResponse == null)
        {
            return 0L;
        }
        
        checked
        {
            // StatusCode
            long size = sizeof(int);
            
            // Headers
            if (cachedResponse.Headers != null)
            {
                foreach (var item in cachedResponse.Headers)
                {
                    size += (item.Key.Length * sizeof(char)) + EstimateStringValuesSize(item.Value);
                }
            }
            
            // Body
            if (cachedResponse.Body != null)
            {
                size += cachedResponse.Body.Length;
            }
            
            return size;
        }
    }
    
    internal static long EstimateCachedVaryByRulesySize(CachedVaryByRules? cachedVaryByRules)
    {
        if (cachedVaryByRules == null)
        {
            return 0L;
        }
        
        checked
        {
            var size = 0L;
            
            // VaryByKeyPrefix
            if (!string.IsNullOrEmpty(cachedVaryByRules.VaryByKeyPrefix))
            {
                size = cachedVaryByRules.VaryByKeyPrefix.Length * sizeof(char);
            }
            
            // Headers
            size += EstimateStringValuesSize(cachedVaryByRules.Headers);
            
            // QueryKeys
            size += EstimateStringValuesSize(cachedVaryByRules.QueryKeys);
            
            return size;
        }
    }
    
    internal static long EstimateStringValuesSize(StringValues stringValues)
    {
        checked
        {
            var size = 0L;
            
            for (var i = 0; i < stringValues.Count; i++)
            {
                var stringValue = stringValues[i];
                if (!string.IsNullOrEmpty(stringValue))
                {
                    size += stringValues[i].Length * sizeof(char);
                }
            }
            
            return size;
        }
    }
}

```

#### 2.2 response cache

```c#
internal interface IResponseCache
{    
    IResponseCacheEntry? Get(string key);        
    void Set(string key, IResponseCacheEntry entry, TimeSpan validFor);
}

```

##### 2.2.1 memory response cache

```c#
internal class MemoryResponseCache : IResponseCache
{
    private readonly IMemoryCache _cache;
    
    internal MemoryResponseCache(IMemoryCache cache)
    {
        // 注入 memory cache（需要 add memory cache 服务）
        _cache = cache ?? throw new ArgumentNullException(nameof(cache));
    }
    
    // 方法 - get
    public IResponseCacheEntry? Get(string key)
    {
        var entry = _cache.Get(key);
        
        if (entry is MemoryCachedResponse memoryCachedResponse)
        {
            return new CachedResponse
            {
                Created = memoryCachedResponse.Created,
                StatusCode = memoryCachedResponse.StatusCode,
                Headers = memoryCachedResponse.Headers,
                Body = memoryCachedResponse.Body
            };
        }
        else
        {
            return entry as IResponseCacheEntry;
        }
    }
    
    // 方法 - set
    public void Set(string key, IResponseCacheEntry entry, TimeSpan validFor)
    {
        if (entry is CachedResponse cachedResponse)
        {
            _cache.Set(
                key,
                new MemoryCachedResponse
                {
                    Created = cachedResponse.Created,
                    StatusCode = cachedResponse.StatusCode,
                    Headers = cachedResponse.Headers,
                    Body = cachedResponse.Body
                },
                new MemoryCacheEntryOptions
                {
                    AbsoluteExpirationRelativeToNow = validFor,
                    Size = CacheEntryHelpers.EstimateCachedResponseSize(cachedResponse)
                });
        }
        else
        {
            _cache.Set(
                key,
                entry,
                new MemoryCacheEntryOptions
                {
                    AbsoluteExpirationRelativeToNow = validFor,
                    Size = CacheEntryHelpers.EstimateCachedVaryByRulesySize(entry as CachedVaryByRules)
                });
        }
    }
}

```

##### 2.2.2 memory cached response

```c#
internal class MemoryCachedResponse
{
    public DateTimeOffset Created { get; set; }    
    public int StatusCode { get; set; }    
    public IHeaderDictionary Headers { get; set; } = new HeaderDictionary();    
    public CachedResponseBody Body { get; set; } = default!;
}

```

#### 2.3 provider

##### 2.3.1 response caching context

```c#
internal class ResponseCachingContext
{
    /* http response header 解析 ... */
    // response date
    private bool _parsedResponseDate;
    private DateTimeOffset? _responseDate;
    internal DateTimeOffset? ResponseDate
    {
        get
        {
            if (!_parsedResponseDate)
            {
                _parsedResponseDate = true;
                DateTimeOffset date;
                if (HeaderUtilities.TryParseDate(
                    	HttpContext.Response.Headers.Date.ToString(), 
                    	out date))
                {
                    _responseDate = date;
                }       
                else
                {
                    _responseDate = null;
                }
            }
            
            return _responseDate;
        }
        set
        {
            // Don't reparse the response date again if it's explicitly set
            _parsedResponseDate = true;
            _responseDate = value;
        }
    }
    
    // response expires        
    private bool _parsedResponseExpires;
    private DateTimeOffset? _responseExpires;
    internal DateTimeOffset? ResponseExpires
    {
        get
        {
            if (!_parsedResponseExpires)
            {
                _parsedResponseExpires = true;
                DateTimeOffset expires;
                if (HeaderUtilities.TryParseDate(
                    	HttpContext.Response.Headers.Expires.ToString(), 
                    	out expires))
                {
                    _responseExpires = expires;
                }
                else
                {
                    _responseExpires = null;
                }
            }
            return _responseExpires;
        }
    }
    
    // response max age
    private bool _parsedResponseMaxAge;
    private TimeSpan? _responseMaxAge;
    internal TimeSpan? ResponseMaxAge
    {
        get
        {
            if (!_parsedResponseMaxAge)
            {
                _parsedResponseMaxAge = true;
                HeaderUtilities.TryParseSeconds(
                    HttpContext.Response.Headers.CacheControl, 
                    CacheControlHeaderValue.MaxAgeString, 
                    out _responseMaxAge);
            }
            
            return _responseMaxAge;
        }
    }
    
    // response shared max age
    private bool _parsedResponseSharedMaxAge;
    private TimeSpan? _responseSharedMaxAge;
    internal TimeSpan? ResponseSharedMaxAge
    {
        get
        {
            if (!_parsedResponseSharedMaxAge)
            {
                _parsedResponseSharedMaxAge = true;
                HeaderUtilities.TryParseSeconds(
                    HttpContext.Response.Headers.CacheControl, 
                    CacheControlHeaderValue.SharedMaxAgeString, 
                    out _responseSharedMaxAge);
            }
            
            return _responseSharedMaxAge;
        }
    }    
    /* http response header 解析 ... */
    
    public HttpContext HttpContext { get; }
    internal ILogger Logger { get; }
    
    // 产生 response 的时间、标记
    public DateTimeOffset? ResponseTime { get; internal set; }    
    internal bool ResponseStarted { get; set; }
    
    // cache 标记、key
    internal bool ShouldCacheResponse { get; set; }    
    internal string BaseKey { get;  set; }    
    internal string StorageVaryKey { get;  set; }    
               
    // cached info
    internal IHeaderDictionary CachedResponseHeaders { get; set; }
    public CachedVaryByRules CachedVaryByRules { get; set; } 
    internal CachedResponse CachedResponse { get;  set; }    
    public TimeSpan? CachedEntryAge { get; internal set; }   
    internal TimeSpan CachedResponseValidFor { get;  set; } 
               
    // origin stream
    internal Stream OriginalResponseStream { get; set; }    
    // caching stream
    internal ResponseCachingStream ResponseCachingStream { get; set; }
                                            
    internal ResponseCachingContext(HttpContext httpContext, ILogger logger)
    {
        HttpContext = httpContext;
        Logger = logger;
    }                                        
}

```

##### 2.3.2 response caching key provider

```c#
//  接口
internal interface IResponseCachingKeyProvider
{
    string CreateBaseKey(ResponseCachingContext context);        
    string CreateStorageVaryByKey(ResponseCachingContext context);        
    IEnumerable<string> CreateLookupVaryByKeys(ResponseCachingContext context);
}

// 实现
internal class ResponseCachingKeyProvider : IResponseCachingKeyProvider
{
    // Use the record separator for delimiting components of the cache key to avoid possible collisions
    private static readonly char KeyDelimiter = '\x1e';
    // Use the unit separator for delimiting subcomponents of the cache key to avoid possible collisions
    private static readonly char KeySubDelimiter = '\x1f';
    
    private readonly ObjectPool<StringBuilder> _builderPool;
    private readonly ResponseCachingOptions _options;
    
    internal ResponseCachingKeyProvider(
        ObjectPoolProvider poolProvider, 
        IOptions<ResponseCachingOptions> options)
    {
        if (poolProvider == null)
        {
            throw new ArgumentNullException(nameof(poolProvider));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        _builderPool = poolProvider.CreateStringBuilderPool();
        _options = options.Value;
    }
            
    // 接口方法- create base key（不包含 vary）
    // GET<delimiter>SCHEME<delimiter>HOST:PORT/PATHBASE/PATH
    public string CreateBaseKey(ResponseCachingContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        // 解析 http context request
        var request = context.HttpContext.Request;
        var builder = _builderPool.Get();
        
        // 拼接 request info ...
        try
        {
            builder.AppendUpperInvariant(request.Method)
                   .Append(KeyDelimiter)
                   .AppendUpperInvariant(request.Scheme)
                   .Append(KeyDelimiter)
                   .AppendUpperInvariant(request.Host.Value);
            
            if (_options.UseCaseSensitivePaths)
            {
                builder.Append(request.PathBase.Value)
                       .Append(request.Path.Value);
            }
            else
            {
                builder.AppendUpperInvariant(request.PathBase.Value)
                       .AppendUpperInvariant(request.Path.Value);
            }
            
            return builder.ToString();
        }
        finally
        {
            _builderPool.Return(builder);
        }
    }
    
    // 接口方法 - creatre storage vary key（包含 vary）
    // BaseKey<delimiter>H<delimiter>HeaderName=HeaderValue<delimiter>Q<delimiter>QueryName=QueryValue1<subdelimiter>QueryValue2
    public string CreateStorageVaryByKey(ResponseCachingContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        // 从 response caching context 解析 vary by rules
        var varyByRules = context.CachedVaryByRules;
        // 如果 vary by rules 为 null，-> 抛出异常
        if (varyByRules == null)
        {
            throw new InvalidOperationException(
                $"{nameof(CachedVaryByRules)} must not be null on the {nameof(ResponseCachingContext)}");
        }
        
        // （能够解析 vary by rules），
        
        // 如果 vary by rules 的 headers、query kes 都为 null，-> 返回 vary by key prefix（default string，null？）
        if (StringValues.IsNullOrEmpty(varyByRules.Headers) && 
            StringValues.IsNullOrEmpty(varyByRules.QueryKeys))
        {
            return varyByRules.VaryByKeyPrefix;
        }
        
        // 解析 http context request
        var request = context.HttpContext.Request;
        var builder = _builderPool.Get();
        
        // 拼接 request info ...
        try
        {
            // Prepend with the Guid of the CachedVaryByRules
            builder.Append(varyByRules.VaryByKeyPrefix);
            
            // 1- Vary by headers
            var headersCount = varyByRules?.Headers.Count ?? 0;
            if (headersCount > 0)
            {
                // Append a group separator for the header segment of the cache key
                builder.Append(KeyDelimiter)
                       .Append('H');
                
                var requestHeaders = context.HttpContext.Request.Headers;
                for (var i = 0; i < headersCount; i++)
                {
                    var header = varyByRules!.Headers[i];
                    var headerValues = requestHeaders[header];
                    builder.Append(KeyDelimiter)
                           .Append(header)
                           .Append('=');
                    
                    var headerValuesArray = headerValues.ToArray();
                    Array.Sort(headerValuesArray, StringComparer.Ordinal);
                    
                    for (var j = 0; j < headerValuesArray.Length; j++)
                    {
                        builder.Append(headerValuesArray[j]);
                    }
                }
            }
            
            // 2- Vary by query keys
            if (varyByRules?.QueryKeys.Count > 0)
            {
                // Append a group separator for the query key segment of the cache key
                builder.Append(KeyDelimiter)
                       .Append('Q');
                
                if (varyByRules.QueryKeys.Count == 1 && 
                    string.Equals(varyByRules.QueryKeys[0], "*", StringComparison.Ordinal))
                {
                    // Vary by all available query keys
                    var queryArray = context.HttpContext.Request.Query.ToArray();
                    // Query keys are aggregated case-insensitively whereas the query values are compared ordinally.
                    Array.Sort(queryArray, QueryKeyComparer.OrdinalIgnoreCase);
                    
                    for (var i = 0; i < queryArray.Length; i++)
                    {
                        builder.Append(KeyDelimiter)
                               .AppendUpperInvariant(queryArray[i].Key)
                               .Append('=');
                        
                        var queryValueArray = queryArray[i].Value.ToArray();
                        Array.Sort(queryValueArray, StringComparer.Ordinal);
                        
                        for (var j = 0; j < queryValueArray.Length; j++)
                        {
                            if (j > 0)
                            {
                                builder.Append(KeySubDelimiter);
                            }
                            
                            builder.Append(queryValueArray[j]);
                        }
                    }
                }
                else
                {
                    for (var i = 0; i < varyByRules.QueryKeys.Count; i++)
                    {
                        var queryKey = varyByRules.QueryKeys[i];
                        var queryKeyValues = context.HttpContext.Request.Query[queryKey];
                        builder.Append(KeyDelimiter)
                               .Append(queryKey)
                               .Append('=');
                        
                        var queryValueArray = queryKeyValues.ToArray();
                        Array.Sort(queryValueArray, StringComparer.Ordinal);
                        
                        for (var j = 0; j < queryValueArray.Length; j++)
                        {
                            if (j > 0)
                            {
                                builder.Append(KeySubDelimiter);
                            }
                            
                            builder.Append(queryValueArray[j]);
                        }
                    }
                }
            }
            
            return builder.ToString();
        }
        finally
        {
            _builderPool.Return(builder);
        }
    }
    
    // 接口方法 - create lookup vary by keys
    public IEnumerable<string> CreateLookupVaryByKeys(ResponseCachingContext context)
    {
        return new string[] 
        { 
            CreateStorageVaryByKey(context) 
        };
    }
    
    private class QueryKeyComparer : IComparer<KeyValuePair<string, StringValues>>
    {
        public static QueryKeyComparer OrdinalIgnoreCase { get; } = new QueryKeyComparer(StringComparer.OrdinalIgnoreCase);
        
        private readonly StringComparer _stringComparer;
                        
        public QueryKeyComparer(StringComparer stringComparer)
        {
            _stringComparer = stringComparer;
        }
        
        public int Compare(KeyValuePair<string, StringValues> x, KeyValuePair<string, StringValues> y) => 
            _stringComparer.Compare(x.Key, y.Key);
    }
}

```

##### 2.3.3 response caching policy provider

```c#
// 接口
internal interface IResponseCachingPolicyProvider
{         
    bool AttemptResponseCaching(ResponseCachingContext context);            
    bool AllowCacheLookup(ResponseCachingContext context);            
    bool AllowCacheStorage(ResponseCachingContext context);            
    bool IsResponseCacheable(ResponseCachingContext context);             
    bool IsCachedEntryFresh(ResponseCachingContext context);
}

internal class ResponseCachingPolicyProvider : IResponseCachingPolicyProvider
{
    // 接口方法 - attempt response caching（request get/head，没有 authorization）
    public virtual bool AttemptResponseCaching(ResponseCachingContext context)
    {
        // 解析 http request
        var request = context.HttpContext.Request;
        
        // 如果 ruquest 不是 get、head，（不支持 caching），-> 返回 false
        if (!HttpMethods.IsGet(request.Method) && !HttpMethods.IsHead(request.Method))
        {
            context.Logger.RequestMethodNotCacheable(request.Method);
            return false;
        }
        
        // 如果 request header 包含 authorization，-> 返回 false（authorization 不能 caching）
        if (!StringValues.IsNullOrEmpty(request.Headers.Authorization))
        {
            context.Logger.RequestWithAuthorizationNotCacheable();
            return false;
        }
        
        return true;
    }
    
    // 接口方法 - allow cache lookup
    public virtual bool AllowCacheLookup(ResponseCachingContext context)
    {
        // 解析 request header 的 cache-control 头
        var requestHeaders = context.HttpContext.Request.Headers;
        var cacheControl = requestHeaders[HeaderNames.CacheControl];
        
        // 如果 request cache-control 不为空，
        if (!StringValues.IsNullOrEmpty(cacheControl))
        {
            // cache-control 是 "no cache"，（不使用 caching），-> 返回 false
            if (HeaderUtilities.ContainsCacheDirective(
                	cacheControl, 
                	CacheControlHeaderValue.NoCacheString))
            {
                context.Logger.RequestWithNoCacheNotCacheable();
                return false;
            }
        }
        // （否则），即 request cache-control 为空，亦即 request header 没有指定 cache-control，        
        else
        {
            // 如果能够从 request header 解析到 pragma，且其值为 no cache，-> 返回 false
            if (HeaderUtilities.ContainsCacheDirective(
                	requestHeaders[HeaderNames.Pragma], 
                	CacheControlHeaderValue.NoCacheString))
            {
                context.Logger.RequestWithPragmaNoCacheNotCacheable();
                return false;
            }
        }
        
        // （没有上述情况），-> 返回 true
        return true;
    }
    
    // 接口方法 - allow cache storage
    public virtual bool AllowCacheStorage(ResponseCachingContext context)
    {
        // Check request no-store
        return !HeaderUtilities.ContainsCacheDirective(
            context.HttpContext.Request.Headers.CacheControl, 
            CacheControlHeaderValue.NoStoreString);
    }
    
    // 接口方法 - is response cacheable（用于存）
    public virtual bool IsResponseCacheable(ResponseCachingContext context)
    {
        // 解析 response header 的 cache-control 头
        var responseCacheControlHeader = context.HttpContext.Response.Headers.CacheControl;
        
        // 如果 cache-control 没有包含 "public"，-> 返回 false
        if (!HeaderUtilities.ContainsCacheDirective(
            	responseCacheControlHeader, 
            	CacheControlHeaderValue.PublicString))
        {
            context.Logger.ResponseWithoutPublicNotCacheable();
            return false;
        }
        
        // 如果 cache-control 包含 "no stroe"，-> 返回 false
        if (HeaderUtilities.ContainsCacheDirective(
            	responseCacheControlHeader, 
            	CacheControlHeaderValue.NoStoreString))
        {
            context.Logger.ResponseWithNoStoreNotCacheable();
            return false;
        }
        
        // 如果 cache-control 包含 "no cache"，-> 返回 false
        if (HeaderUtilities.ContainsCacheDirective(
            	responseCacheControlHeader, 
            	CacheControlHeaderValue.NoCacheString))
        {
            context.Logger.ResponseWithNoCacheNotCacheable();
            return false;
        }
                
        // 如果 response header 包含 "set cookie"，-> 返回 false（cookie 不能 caching）
        var response = context.HttpContext.Response;                
        if (!StringValues.IsNullOrEmpty(response.Headers.SetCookie))
        {
            context.Logger.ResponseWithSetCookieNotCacheable();
            return false;
        }
        
        // 如果 response header 有 vary 且仅为 "*"，-> 返回 false
        var varyHeader = response.Headers.Vary;
        if (varyHeader.Count == 1 && 
            string.Equals(varyHeader, "*", StringComparison.OrdinalIgnoreCase))
        {
            context.Logger.ResponseWithVaryStarNotCacheable();
            return false;
        }
        
        // 如果 response header 的 cache-control 包含 "private"，-> 返回 false
        if (HeaderUtilities.ContainsCacheDirective(
            	responseCacheControlHeader, 
            	CacheControlHeaderValue.PrivateString))
        {
            context.Logger.ResponseWithPrivateNotCacheable();
            return false;
        }
        
        // 如果 http response 没有返回 200，-> 返回 false
        if (response.StatusCode != StatusCodes.Status200OK)
        {
            context.Logger.ResponseWithUnsuccessfulStatusCodeNotCacheable(response.StatusCode);
            return false;
        }
        
        /* Check response freshness */
        
        // 如果 response caching context 没有 response "date"
        if (!context.ResponseDate.HasValue)
        {
            // 且，response shared max age 没有值、response max age 没有值，
            // 且 response time > response expires，
            // -> 返回 false（old、not fresh）
            if (!context.ResponseSharedMaxAge.HasValue &&
                !context.ResponseMaxAge.HasValue &&
                context.ResponseTime!.Value >= context.ResponseExpires)
            {
                context.Logger.ExpirationExpiresExceeded(
                    context.ResponseTime.Value, 
                    context.ResponseExpires.Value);
                
                return false;
            }
        }
        // （否则），即 response caching context 有 response "date"，
        else
        {
            // 解析 age = (response time - response date)
            var age = context.ResponseTime!.Value - context.ResponseDate.Value;
            
            // [验证 shared max age] 
            // 如果 age > response shared max age，-> 返回 false（response 过期）
            if (age >= context.ResponseSharedMaxAge)
            {
                context.Logger.ExpirationSharedMaxAgeExceeded(age, context.ResponseSharedMaxAge.Value);
                return false;
            }
            // reponse 中没有 shared max age，
            else if (!context.ResponseSharedMaxAge.HasValue)
            {
                // [验证 max age]
                // 如果 age > response max age，-> 返回 false（response 过期）
                if (age >= context.ResponseMaxAge)
                {
                    context.Logger.ExpirationMaxAgeExceeded(age, context.ResponseMaxAge.Value);
                    return false;
                }
                // response 中没有 max age
                else if (!context.ResponseMaxAge.HasValue)
                {
                    // [验证 expires (http 1.0)]
                    // 如果 response time > response expires，-> 返回 false
                    if (context.ResponseTime.Value >= context.ResponseExpires)
                    {
                        context.Logger.ExpirationExpiresExceeded(context.ResponseTime.Value, context.ResponseExpires.Value);
                        return false;
                    }
                }
            }
        }
        
        // （没有上述情况），-> 返回 true（response is cachable）
        return true;
    }
    
    // 接口方法 - is cached entry fresh（用于取）
    public virtual bool IsCachedEntryFresh(ResponseCachingContext context)
    {
        // 解析 age (of cached entry)
        var age = context.CachedEntryAge!.Value;
        
        // 解析 cached response 的 cache-control 头
        var cachedCacheControlHeaders = context.CachedResponseHeaders[HeaderNames.CacheControl];
        // 解析 http request 的 cache-control 头
        var requestCacheControlHeaders = context.HttpContext.Request.Headers.CacheControl;
        
        // [添加 min-fresh]
        // 如果能够从 http request 的 cache-contro 解析 "min-fresh"，-> age += min-fresh
        if (HeaderUtilities.TryParseSeconds(
            	requestCacheControlHeaders, 
            	CacheControlHeaderValue.MinFreshString, 
            	out var minFresh))
        {
            age += minFresh.Value;
            context.Logger.ExpirationMinFreshAdded(minFresh.Value);
        }
        
       	// 解析 shared max age
        TimeSpan? cachedSharedMaxAge;
        HeaderUtilities.TryParseSeconds(
            cachedCacheControlHeaders, 
            CacheControlHeaderValue.SharedMaxAgeString, 
            out cachedSharedMaxAge);
        
        // [验证 shared max age]
        // 如果 age >= shared max age，-> 返回 false（cached entry 已经过期）
        if (age >= cachedSharedMaxAge)
        {
            // shared max age implies must revalidate
            context.Logger.ExpirationSharedMaxAgeExceeded(age, cachedSharedMaxAge.Value);
            return false;
        }
        // cached response 中没有 shared max value
        else if (!cachedSharedMaxAge.HasValue)
        {
            // 解析 http request max age
            TimeSpan? requestMaxAge;
            HeaderUtilities.TryParseSeconds(
                requestCacheControlHeaders, 
                CacheControlHeaderValue.MaxAgeString, 
                out requestMaxAge);            
            // 解析 cached max age
            TimeSpan? cachedMaxAge;
            HeaderUtilities.TryParseSeconds(
                cachedCacheControlHeaders, 
                CacheControlHeaderValue.MaxAgeString, 
                out cachedMaxAge);
            // 选取 request max age、cached max age 中的最小值
            var lowestMaxAge = cachedMaxAge < requestMaxAge ? cachedMaxAge : requestMaxAge ?? cachedMaxAge;
                        
            // [验证 max age]
            // 如果 age >= lowest max age，
            if (age >= lowestMaxAge)
            {
                // 如果 cached entry 的 cache-control 包含 "must revalidate" 或者 "proxy revalidate"，-> 返回 false
                if (HeaderUtilities.ContainsCacheDirective(
                    	cachedCacheControlHeaders, 
                    	CacheControlHeaderValue.MustRevalidateString) ||
                    HeaderUtilities.ContainsCacheDirective(
                        cachedCacheControlHeaders, 
                        CacheControlHeaderValue.ProxyRevalidateString))                    
                {
                    context.Logger.ExpirationMustRevalidate(age, lowestMaxAge.Value);
                    return false;
                }
                
                // 解析 http request 的 cache-control 的 max 
                TimeSpan? requestMaxStale;                
                var maxStaleExist = HeaderUtilities.ContainsCacheDirective(
                    requestCacheControlHeaders, 
                    CacheControlHeaderValue.MaxStaleString);
                
                HeaderUtilities.TryParseSeconds(
                    requestCacheControlHeaders, 
                    CacheControlHeaderValue.MaxStaleString, 
                    out requestMaxStale);

                // [验证 max stale]
                // 如果 http request 的 cache control 包含 max stale，且 max stale 为 null，-> 返回 true
                if (maxStaleExist && !requestMaxStale.HasValue)
                {
                    context.Logger.ExpirationInfiniteMaxStaleSatisfied(age, lowestMaxAge.Value);
                    return true;
                }                
                // 如果 max stale 有值，且 age - lowest max age < request max stale，-> 返回 true
                if (requestMaxStale.HasValue && age - lowestMaxAge < requestMaxStale)
                {
                    context.Logger.ExpirationMaxStaleSatisfied(age, lowestMaxAge.Value, requestMaxStale.Value);
                    return true;
                }
                
                // （由上，http request 中没有 stale），-> 返回 false
                context.Logger.ExpirationMaxAgeExceeded(age, lowestMaxAge.Value);
                return false;
            }
            // （age < lowest max age）
            // 如果 cached max age、request max age 都为 null，
            else if (!cachedMaxAge.HasValue && !requestMaxAge.HasValue)
            {
                // [验证 expiration (http 1.0)]
                DateTimeOffset expires;
                // 如果 cached entry 的 response header 包含 expires，
                // 并且 response cache context 的 response time >= expires（过期），-> 返回 false
                if (HeaderUtilities.TryParseDate(
                    	context.CachedResponseHeaders[HeaderNames.Expires].ToString(), 
                    	out expires) &&
                    context.ResponseTime!.Value >= expires)
                {
                    context.Logger.ExpirationExpiresExceeded(context.ResponseTime.Value, expires);
                    return false;
                }
            }
        }
        
        return true;
    }
}

```

#### 2.4 add response caching

```c#
public static class ResponseCachingServicesExtensions
{        
    public static IServiceCollection AddResponseCaching(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        // 注入 object pool provider
        services.TryAddSingleton<ObjectPoolProvider, DefaultObjectPoolProvider>();        
        return services;
    }

        
    public static IServiceCollection AddResponseCaching(
        this IServiceCollection services, 
        Action<ResponseCachingOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        // 注入 response caching options
        services.Configure(configureOptions);
        // 注入 response caching 服务
        services.AddResponseCaching();
        
        return services;
    }
}

```

##### 2.4.1 response caching options

```c#
public class ResponseCachingOptions
{    
    // The size limit for the response cache middleware in bytes. The default is set to 100 MB.
    // When this limit is exceeded, no new responses will be cached until older entries are evicted.    
    public long SizeLimit { get; set; } = 100 * 1024 * 1024;
        
    // The largest cacheable size for the response body in bytes. The default is set to 64 MB.
    // If the response body exceeds this limit, it will not be cached by the "ResponseCachingMiddleware"    
    public long MaximumBodySize { get; set; } = 64 * 1024 * 1024;
        
    public bool UseCaseSensitivePaths { get; set; } = false;
        
    // For testing purposes only.
    [EditorBrowsable(EditorBrowsableState.Never)]
    internal ISystemClock SystemClock { get; set; } = new SystemClock();
}

```

#### 2.5 use response caching

```c#
public static class ResponseCachingExtensions
{   
    public static IApplicationBuilder UseResponseCaching(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<ResponseCachingMiddleware>();
    }
}

```

##### 2.5.1 response caching middleware

```c#
public class ResponseCachingMiddleware
{
    private static readonly TimeSpan DefaultExpirationTimeSpan = TimeSpan.FromSeconds(10);
    
    // see https://tools.ietf.org/html/rfc7232#section-4.1
    private static readonly string[] HeadersToIncludeIn304 = new[] 
    { 
        "Cache-Control", 
        "Content-Location", 
        "Date", 
        "ETag", 
        "Expires", 
        "Vary" 
    };
    
    private readonly RequestDelegate _next;
    private readonly ResponseCachingOptions _options;
    private readonly ILogger _logger;
    private readonly IResponseCachingPolicyProvider _policyProvider;
    private readonly IResponseCache _cache;
    private readonly IResponseCachingKeyProvider _keyProvider;
        
    public ResponseCachingMiddleware(
        RequestDelegate next,
        IOptions<ResponseCachingOptions> options,
        ILoggerFactory loggerFactory,
        ObjectPoolProvider poolProvider) : 
    		this(
                next,
                options,
                loggerFactory,
                new ResponseCachingPolicyProvider(),
                new MemoryResponseCache(new MemoryCache(new MemoryCacheOptions
                {
                    SizeLimit = options.Value.SizeLimit
                })),
                new ResponseCachingKeyProvider(poolProvider, options))
    {
    }

    // for testing
    internal ResponseCachingMiddleware(
        RequestDelegate next,
        IOptions<ResponseCachingOptions> options,
        ILoggerFactory loggerFactory,
        IResponseCachingPolicyProvider policyProvider,
        IResponseCache cache,
        IResponseCachingKeyProvider keyProvider)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        if (loggerFactory == null)
        {
            throw new ArgumentNullException(nameof(loggerFactory));
        }
        if (policyProvider == null)
        {
            throw new ArgumentNullException(nameof(policyProvider));
        }
        if (cache == null)
        {
            throw new ArgumentNullException(nameof(cache));
        }
        if (keyProvider == null)
        {
            throw new ArgumentNullException(nameof(keyProvider));
        }
        
        _next = next;
        _options = options.Value;
        _logger = loggerFactory.CreateLogger<ResponseCachingMiddleware>();
        
        // 注入 cache、key provider、policy provider
        _policyProvider = policyProvider;
        _cache = cache;
        _keyProvider = keyProvider;
    }
       
    public async Task Invoke(HttpContext httpContext)
    {
        // 创建 response caching context（初始值）
        var context = new ResponseCachingContext(httpContext, _logger);
                        
        // 1- 如果可以 attempt response caching,    
        //（http get/head 方法，没有 authentication）      
        if (_policyProvider.AttemptResponseCaching(context))
        {
            // 1a- allow cache lookup，并且可以 serve from cache，-> serve & return [取！]
            // （http request cache-control 没有标记 no-cache     
            if (_policyProvider.AllowCacheLookup(context) && await TryServeFromCacheAsync(context))
            {
                return;
            }
            
            // （否则），即不是 allow cache lookup， 或者不能 serve from cache
            
            // 1b- 如果 allow cache storage（no storage 比 no cache 优先级高），[存！]
            // （http request cache-control 没有标记 no-storage，没有标注默认是 storage）
            if (_policyProvider.AllowCacheStorage(context))
            {
                // 1b.1- 插入 response stream
                ShimResponseStream(context);
                
                try
                {
                    // 下一个请求
                    await _next(httpContext);                                        
                    // 1b.2- start response
                    StartResponse(context);                                        
                    // 1b.3- Finalize the cache entry
                    FinalizeCacheBody(context);
                }
                finally
                {
                    // 1b.4- 消除 response stream                   
                    UnshimResponseStream(context);
                }
                
                return;
            }
        }
               
        // （由上），2- 不能 attemp response cache，通过 response caching feature 携带数据
        // 2.1- 
        AddResponseCachingFeature(httpContext);
        
        try
        {
            await _next(httpContext);
        }
        finally
        {
            // 2.2- 
            RemoveResponseCachingFeature(httpContext);
        }
    }
        
    internal static void AddResponseCachingFeature(HttpContext context)
    {
        if (context.Features.Get<IResponseCachingFeature>() != null)
        {
            throw new InvalidOperationException(
                $"Another instance of {nameof(ResponseCachingFeature)} already exists. 
                "Only one instance of {nameof(ResponseCachingMiddleware)} can be configured for an application.");
        }
        context.Features.Set<IResponseCachingFeature>(new ResponseCachingFeature());
    } 
                                                                      
    internal static void RemoveResponseCachingFeature(HttpContext context) =>
        context.Features.Set<IResponseCachingFeature?>(null);
    
    // Normalize order and casing
    internal static StringValues GetOrderCasingNormalizedStringValues(StringValues stringValues)
    {
        if (stringValues.Count == 1)
        {
            return new StringValues(stringValues.ToString().ToUpperInvariant());
        }
        else
        {
            var originalArray = stringValues.ToArray();
            var newArray = new string[originalArray.Length];
            
            for (var i = 0; i < originalArray.Length; i++)
            {
                newArray[i] = originalArray[i].ToUpperInvariant();
            }
            
            // Since the casing has already been normalized, use Ordinal comparison
            Array.Sort(newArray, StringComparer.Ordinal);
            
            return new StringValues(newArray);
        }
    }
}

```

##### - try serve from cache

```c#
public class ResponseCachingMiddleware
{
    /// serve "response caching context"
    internal async Task<bool> TryServeFromCacheAsync(ResponseCachingContext context)
    {
        // 创建 base key
        context.BaseKey = _keyProvider.CreateBaseKey(context);
        // 按照 base key 从 response cache（memory cache）解析 response cache entry
        var cacheEntry = _cache.Get(context.BaseKey);
        
        // 1- 如果 response cache entry 是 cached vary by rules，
        // -> 按照 cached vary by rules key 解析 response
        if (cacheEntry is CachedVaryByRules cachedVaryByRules)
        {
            // 更新 context 的 cached vary by rules，
            context.CachedVaryByRules = cachedVaryByRules;      
            // 按照 lookup vary by keys 解析 
            foreach (var varyKey in _keyProvider.CreateLookupVaryByKeys(context))
            {
                if (await TryServeCachedResponseAsync(context, _cache.Get(varyKey)))
                {
                    return true;
                }
            }
        }
        // （否则），即 response cache entry 不是 cached vary by rules
        // 2- 直接从 response cache entry 解析 response
        else
        {            
            if (await TryServeCachedResponseAsync(context, cacheEntry))
            {
                return true;
            }
        }
        
        // （由上，cache entry 不是 cached vary by rules，且不能从 response cache context 解析）
        
        // 如果 request header 包含 "only-if-cached"，-> 返回 504
        if (HeaderUtilities.ContainsCacheDirective(
            	context.HttpContext.Request.Headers.CacheControl, 
            	CacheControlHeaderValue.OnlyIfCachedString))
        {
            _logger.GatewayTimeoutServed();
            context.HttpContext.Response.StatusCode = StatusCodes.Status504GatewayTimeout;
            return true;
        }
        
        // 没有解析到 cached response，-> 返回 false
        _logger.NoResponseServed();
        return false;
    }
    
    /// server "response caching context" & "response cache entry"
    internal async Task<bool> TryServeCachedResponseAsync(
        ResponseCachingContext context, 
        IResponseCacheEntry? cacheEntry)
    {
        // 1- 如果 cached entry 不是 cached response，-> 返回 false，结束
        if (!(cacheEntry is CachedResponse cachedResponse))
        {
            return false;
        }
        
        // （由上），cached entry 是 cached response
        
        // 将 cached entry、cached entry header 注入 response caching context
        context.CachedResponse = cachedResponse;        
        context.CachedResponseHeaders = cachedResponse.Headers;        
        // 将 utc now 注入 response caching context，（response time）
        context.ResponseTime = _options.SystemClock.UtcNow;        
        // 计算 age 并注入   
        var cachedEntryAge = context.ResponseTime.Value - context.CachedResponse.Created;        
        context.CachedEntryAge = cachedEntryAge > TimeSpan.Zero ? cachedEntryAge : TimeSpan.Zero;
        
        // 如果 context 是 freshed（age 没有过期）,
        if (_policyProvider.IsCachedEntryFresh(context))
        {
            // 如果（cached response content）not modified
            if (ContentIsNotModified(context))
            {
                _logger.NotModifiedServed();
                // -> response status code = 304
                context.HttpContext.Response.StatusCode = StatusCodes.Status304NotModified;
                
                // 如果 response cached context 的 cached response headers 不为 null
                if (context.CachedResponseHeaders != null)
                {
                    // 遍历 Headers（cache-control，expires ...)
                    foreach (var key in HeadersToIncludeIn304)
                    {
                        // 从 cached responsed headers 解析 Headers 对应值，
                        if (context.CachedResponseHeaders.TryGetValue(key, out var values))
                        {
                            // 注入 response
                            context.HttpContext.Response.Headers[key] = values;
                        }
                    }
                }
            }
            // （否则），即（cached response content）modified
            else
            {
                var response = context.HttpContext.Response;
                
                // Copy the cached status code and response headers
                response.StatusCode = context.CachedResponse.StatusCode;
                foreach (var header in context.CachedResponse.Headers)
                {
                    response.Headers[header.Key] = header.Value;
                }
                
                // Note: int64 division truncates result and errors may be up to 1 second. This reduction in
                // accuracy of age calculation is considered appropriate since it is small compared to clock
                // skews and the "Age" header is an estimate of the real age of cached content.
                response.Headers.Age = 
                    HeaderUtilities.FormatNonNegativeInt64(context.CachedEntryAge.Value.Ticks / TimeSpan.TicksPerSecond);
                
                // Copy the cached response body
                var body = context.CachedResponse.Body;
                if (body.Length > 0)
                {
                    try
                    {
                        await body.CopyToAsync(response.BodyWriter, context.HttpContext.RequestAborted);
                    }
                    catch (OperationCanceledException)
                    {
                        context.HttpContext.Abort();
                    }
                }
                _logger.CachedResponseServed();
            }
            return true;
        }
        
        // （由上），response cached context（cached entry）不是 freshed，-> 返回 false
        return false;
    }
        
    internal static bool ContentIsNotModified(ResponseCachingContext context)
    {
        var cachedResponseHeaders = context.CachedResponseHeaders;
        var ifNoneMatchHeader = context.HttpContext.Request.Headers.IfNoneMatch;
        
        // 如果 http request 中 "if none match" 不为空，
        if (!StringValues.IsNullOrEmpty(ifNoneMatchHeader))
        {
            // "if none match header" 只有1个 value，并且是 any，-> 返回 true
            if (ifNoneMatchHeader.Count == 1 && 
                StringSegment.Equals(
                    ifNoneMatchHeader[0], 
                    EntityTagHeaderValue.Any.Tag, 
                    StringComparison.OrdinalIgnoreCase))
            {
                context.Logger.NotModifiedIfNoneMatchStar();
                return true;
            }
            
            EntityTagHeaderValue eTag;
            
            // "cached response headers" 包含 "etag"，
            // 并且可以从 cached response headers 解析 etag，
            // 可以从 cached response 的 if none match header 解析 if-none-match etags 集合
            if (!StringValues.IsNullOrEmpty(cachedResponseHeaders[HeaderNames.ETag]) && 
                EntityTagHeaderValue.TryParse(
                    cachedResponseHeaders[HeaderNames.ETag].ToString(), 
                    out eTag) && 
                EntityTagHeaderValue.TryParseList(
                    ifNoneMatchHeader, 
                    out var ifNoneMatchEtags))
            {
                // 遍历 none match etags
                for (var i = 0; i < ifNoneMatchEtags.Count; i++)
                {
                    var requestETag = ifNoneMatchEtags[i];
                    if (eTag.Compare(requestETag, useStrongComparison: false))
                    {
                        context.Logger.NotModifiedIfNoneMatchMatched(requestETag);
                        return true;
                    }
                }
            }
        }
        // （否则），即 htt request 的 "if none match" 为空
        else
        {
            var ifModifiedSince = context.HttpContext.Request.Headers.IfModifiedSince;
            if (!StringValues.IsNullOrEmpty(ifModifiedSince))
            {
                DateTimeOffset modified;
                if (!HeaderUtilities.TryParseDate(
                    	cachedResponseHeaders[HeaderNames.LastModified].ToString(), 
                    	out modified) &&
                    !HeaderUtilities.TryParseDate(
                        cachedResponseHeaders[HeaderNames.Date].ToString(), 
                        out modified))
                {
                    return false;
                }
                
                DateTimeOffset modifiedSince;
                if (HeaderUtilities.TryParseDate(
                    	ifModifiedSince.ToString(), 
                    	out modifiedSince) &&
                    modified <= modifiedSince)
                {
                    context.Logger.NotModifiedIfModifiedSinceSatisfied(modified, modifiedSince);
                    return true;
                }
            }
        }
        
        return false;
    }
}

```

##### - if allow cache storage

```c#
public class ResponseCachingMiddleware
{
    // 1b.1- shim response stream
    internal void ShimResponseStream(ResponseCachingContext context)
    {
        // 解析 http response body stream
        context.OriginalResponseStream = context.HttpContext.Response.Body;
        // 创建 response caching stream
        context.ResponseCachingStream = new ResponseCachingStream(
            context.OriginalResponseStream,
            _options.MaximumBodySize,
            StreamUtilities.BodySegmentSize,
            () => StartResponse(context));
        // 将 http response body 替换到 response caching stream
        context.HttpContext.Response.Body = context.ResponseCachingStream;
        
        // 注入 response caching feature
        AddResponseCachingFeature(context.HttpContext);
    }
    
    // 1b.2- start response
    internal void StartResponse(ResponseCachingContext context)
    {
        // 如果没有 start reponse，-> finalize cache header
        //如果 response 已经开始（started），忽略
        if (OnStartResponse(context))
        {
            FinalizeCacheHeaders(context);
        }
    }
            
    private bool OnStartResponse(ResponseCachingContext context)
    {
        // 如果 response cache context 没有标记 started，-> started = true ; response time = utc now
        if (!context.ResponseStarted)
        {
            
            context.ResponseStarted = true;
            context.ResponseTime = _options.SystemClock.UtcNow;
            
            return true;
        }        
        // context 标记了 started，-> false
        return false;
    }
    
    internal void FinalizeCacheHeaders(ResponseCachingContext context)
    {   
        if (OnFinalizeCacheHeaders(context))
        {
            // 向 cache（memory cache）写入 [base key, vary key, valid timespan]
            _cache.Set(
                context.BaseKey, 
                context.CachedVaryByRules, 
                context.CachedResponseValidFor);
        }
    }
    // 如果 response cachable，并且 vary 变化了，-> true   
    private bool OnFinalizeCacheHeaders(ResponseCachingContext context)
    {
        // 如果（response caching context 可以 response cache，
        if (_policyProvider.IsResponseCacheable(context))
        {
            var storeVaryByEntry = false;
            context.ShouldCacheResponse = true;
            
            // Create the cache entry now
            var response = context.HttpContext.Response;
            var varyHeaders = new StringValues(response.Headers.GetCommaSeparatedValues(HeaderNames.Vary));
            var varyQueryKeys = new StringValues(context.HttpContext.Features.Get<IResponseCachingFeature>()?.VaryByQueryKeys);
            context.CachedResponseValidFor = context.ResponseSharedMaxAge ??
                context.ResponseMaxAge ??
                (context.ResponseExpires - context.ResponseTime!.Value) ??
                DefaultExpirationTimeSpan;
            
            // Generate a base key if none exist
            if (string.IsNullOrEmpty(context.BaseKey))
            {
                context.BaseKey = _keyProvider.CreateBaseKey(context);
            }
            
            // Check if any vary rules exist
            if (!StringValues.IsNullOrEmpty(varyHeaders) || !StringValues.IsNullOrEmpty(varyQueryKeys))
            {
                // Normalize order and casing of vary by rules
                var normalizedVaryHeaders = GetOrderCasingNormalizedStringValues(varyHeaders);
                var normalizedVaryQueryKeys = GetOrderCasingNormalizedStringValues(varyQueryKeys);
                
                // Update vary rules if they are different
                if (context.CachedVaryByRules == null ||
                    !StringValues.Equals(context.CachedVaryByRules.QueryKeys, normalizedVaryQueryKeys) ||
                    !StringValues.Equals(context.CachedVaryByRules.Headers, normalizedVaryHeaders))
                {
                    context.CachedVaryByRules = new CachedVaryByRules
                    {
                        VaryByKeyPrefix = FastGuid.NewGuid().IdString,
                        Headers = normalizedVaryHeaders,
                        QueryKeys = normalizedVaryQueryKeys
                    };
                }
                
                // Always overwrite the CachedVaryByRules to update the expiry information
                _logger.VaryByRulesUpdated(normalizedVaryHeaders, normalizedVaryQueryKeys);
                storeVaryByEntry = true;
                
                context.StorageVaryKey = _keyProvider.CreateStorageVaryByKey(context);
            }
            
            // Ensure date header is set
            if (!context.ResponseDate.HasValue)
            {
                context.ResponseDate = context.ResponseTime!.Value;
                // Setting the date on the raw response headers.
                context.HttpContext.Response.Headers.Date = HeaderUtilities.FormatDate(context.ResponseDate.Value);
            }
            
            // Store the response on the state
            context.CachedResponse = new CachedResponse
            {
                Created = context.ResponseDate.Value,
                StatusCode = context.HttpContext.Response.StatusCode,
                Headers = new HeaderDictionary()
            };
            
            // 复制 age 以外的 http response header
            foreach (var header in context.HttpContext.Response.Headers)
            {
                if (!string.Equals(header.Key, HeaderNames.Age, StringComparison.OrdinalIgnoreCase))
                {
                    context.CachedResponse.Headers[header.Key] = header.Value;
                }
            }
            
            return storeVaryByEntry;
        }
        
        context.ResponseCachingStream.DisableBuffering();
        return false;
    }
    
    // 1b.3- finalize cache body
    internal void FinalizeCacheBody(ResponseCachingContext context)
    {
        if (context.ShouldCacheResponse && context.ResponseCachingStream.BufferingEnabled)
        {
            var contentLength = context.HttpContext.Response.ContentLength;
            var cachedResponseBody = context.ResponseCachingStream.GetCachedResponseBody();
            if (!contentLength.HasValue || 
                contentLength == cachedResponseBody.Length || 
                (cachedResponseBody.Length == 0 && HttpMethods.IsHead(context.HttpContext.Request.Method)))
            {
                var response = context.HttpContext.Response;
                // Add a content-length if required
                if (!response.ContentLength.HasValue && 
                    StringValues.IsNullOrEmpty(response.Headers.TransferEncoding))
                {
                    context.CachedResponse.Headers.ContentLength = cachedResponseBody.Length;
                }
                
                context.CachedResponse.Body = cachedResponseBody;
                _logger.ResponseCached();
                _cache.Set(
                    context.StorageVaryKey ?? context.BaseKey, 
                    context.CachedResponse, 
                    context.CachedResponseValidFor);
            }
            else
            {
                _logger.ResponseContentLengthMismatchNotCached();
            }
        }
        else
        {
            _logger.LogResponseNotCached();
        }
    }
    
    // 1b.4 unshim response stream
    internal static void UnshimResponseStream(ResponseCachingContext context)
    {
        // Unshim response stream
        context.HttpContext.Response.Body = context.OriginalResponseStream;        
        // Remove IResponseCachingFeature
        RemoveResponseCachingFeature(context.HttpContext);
    }
}

```

##### 2.5.2 response caching feature

```c#
public interface IResponseCachingFeature
{    
    string[]? VaryByQueryKeys { get; set; }
}

public class ResponseCachingFeature : IResponseCachingFeature
{
    private string[]? _varyByQueryKeys;
        
    public string[]? VaryByQueryKeys
    {
        get
        {
            return _varyByQueryKeys;
        }
        set
        {
            if (value?.Length > 1)
            {
                for (var i = 0; i < value.Length; i++)
                {
                    if (string.IsNullOrEmpty(value[i]))
                    {
                        throw new ArgumentException(
                            $"When {nameof(value)} contains more than one value, it cannot contain a null or empty value.", 
                            nameof(value));
                    }
                }
            }
            _varyByQueryKeys = value;
        }
    }
}

```







### 3. http response compression

#### 3.1 compression provider

```c#
public interface ICompressionProvider
{    
    string EncodingName { get; }    
    bool SupportsFlush { get; }        
    Stream CreateStream(Stream outputStream);
}

```

##### 3.1.1 variety of compression provider

###### 3.1.1.1 gzip compression provider

```c#
public class GzipCompressionProvider : ICompressionProvider
{
    private GzipCompressionProviderOptions Options { get; }
        
    public string EncodingName { get; } = "gzip";        
    public bool SupportsFlush => true;        
       
    public GzipCompressionProvider(IOptions<GzipCompressionProviderOptions> options)
    {
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        Options = options.Value;
    }        
    
    public Stream CreateStream(Stream outputStream)
        => new GZipStream(outputStream, Options.Level, leaveOpen: true);
}

public class GzipCompressionProviderOptions : IOptions<GzipCompressionProviderOptions>
{    
    public CompressionLevel Level { get; set; } = CompressionLevel.Fastest;        
    GzipCompressionProviderOptions IOptions<GzipCompressionProviderOptions>.Value => this;
}

```

###### 3.1.1.2 brotli compression provider

```c#
public class BrotliCompressionProvider : ICompressionProvider
{
    private BrotliCompressionProviderOptions Options { get; }       
    public string EncodingName { get; } = "br";       
    public bool SupportsFlush { get; } = true;       
    
    public BrotliCompressionProvider(IOptions<BrotliCompressionProviderOptions> options)
    {
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        Options = options.Value;
    }
            
    public Stream CreateStream(Stream outputStream)
    {
        return new BrotliStream(outputStream, Options.Level, leaveOpen: true);
    }
}

public class BrotliCompressionProviderOptions : IOptions<BrotliCompressionProviderOptions>
{   
    public CompressionLevel Level { get; set; } = CompressionLevel.Fastest;        
    BrotliCompressionProviderOptions IOptions<BrotliCompressionProviderOptions>.Value => this;
}

```

###### 3.1.1.3 compression provider factory

```c#
internal class CompressionProviderFactory : ICompressionProvider
{
    private Type ProviderType { get; }
    
    string ICompressionProvider.EncodingName
    {
        get { throw new NotSupportedException(); }
    }
    
    bool ICompressionProvider.SupportsFlush
    {
        get { throw new NotSupportedException(); }
    }
    
    public CompressionProviderFactory(Type providerType)
    {
        ProviderType = providerType;
    }
            
    public ICompressionProvider CreateInstance(IServiceProvider serviceProvider)
    {
        if (serviceProvider == null)
        {
            throw new ArgumentNullException(nameof(serviceProvider));
        }
        
        return (ICompressionProvider)ActivatorUtilities.CreateInstance(serviceProvider, ProviderType, Type.EmptyTypes);
    }
    
    Stream ICompressionProvider.CreateStream(Stream outputStream)
    {
        throw new NotSupportedException();
    }
}

```

##### 3.1.2 compression provider collection

```c#
public class CompressionProviderCollection : Collection<ICompressionProvider>
{          
    public void Add<TCompressionProvider>() where TCompressionProvider : ICompressionProvider
    {
        Add(typeof(TCompressionProvider));
    }
          
    public void Add(Type providerType)
    {
        if (providerType == null)
        {
            throw new ArgumentNullException(nameof(providerType));
        }
        
        if (!typeof(ICompressionProvider).IsAssignableFrom(providerType))
        {
            throw new ArgumentException(
                $"The provider must implement {nameof(ICompressionProvider)}.", 
                nameof(providerType));
        }
        
        var factory = new CompressionProviderFactory(providerType);
        Add(factory);
    }
}

```

##### 3.1.3 response compression provider

```c#
// 接口
public interface IResponseCompressionProvider
{    
    ICompressionProvider? GetCompressionProvider(HttpContext context);        
    bool ShouldCompressResponse(HttpContext context);        
    bool CheckRequestAcceptsCompression(HttpContext context);
}

// 实现
public class ResponseCompressionProvider : IResponseCompressionProvider
{
    private readonly ICompressionProvider[] _providers;
    private readonly HashSet<string> _mimeTypes;
    private readonly HashSet<string> _excludedMimeTypes;
    private readonly bool _enableForHttps;
    private readonly ILogger _logger;
    
    /// <summary>
    /// If no compression providers are specified then GZip is used by default.
    /// </summary>
    /// <param name="services">Services to use when instantiating compression providers.</param>
    /// <param name="options">The options for this instance.</param>
    public ResponseCompressionProvider(IServiceProvider services, IOptions<ResponseCompressionOptions> options)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        // 注入 response compression options
        var responseCompressionOptions = options.Value;
        
        // 从 options 解析 compression provider 集合
        _providers = responseCompressionOptions.Providers.ToArray();
        // 如果 provider 集合为空，-> 注入 gzip、brotli compression provider
        if (_providers.Length == 0)
        {
            // Use the factory so it can resolve IOptions<GzipCompressionProviderOptions> from DI.
            _providers = new ICompressionProvider[]
            {
                new CompressionProviderFactory(typeof(BrotliCompressionProvider)),
                new CompressionProviderFactory(typeof(GzipCompressionProvider)),
            };
        }
        
        // 遍历 compression provider 集合
        for (var i = 0; i < _providers.Length; i++)
        {
            // 如果 provider 是 compression provider factory，
            // -> 由 compression provider factory 创建 compression provider 注入并替换 providers 集合
            var factory = _providers[i] as CompressionProviderFactory;
            if (factory != null)
            {
                _providers[i] = factory.CreateInstance(services);
            }
        }
               
        var mimeTypes = responseCompressionOptions.MimeTypes;        
        if (mimeTypes == null || !mimeTypes.Any())
        {
            mimeTypes = ResponseCompressionDefaults.MimeTypes;
        }
        
        // 从 options 解析 mime types 集合（没有则创建 default types），=> hash set       
        _mimeTypes = new HashSet<string>(mimeTypes, StringComparer.OrdinalIgnoreCase);
        // 从 options 解析 exclude mime type 集合（没有则创建 empty），=> hash set
        _excludedMimeTypes = new HashSet<string>(
            responseCompressionOptions.ExcludedMimeTypes ?? Enumerable.Empty<string>(),
            StringComparer.OrdinalIgnoreCase
        );
        // 从 options 解析 enable for https
        _enableForHttps = responseCompressionOptions.EnableForHttps;
        
        _logger = services.GetRequiredService<ILogger<ResponseCompressionProvider>>();
    }
    
    // 方法- get compression provider
    public virtual ICompressionProvider? GetCompressionProvider(HttpContext context)
    {       
        // 从 http request 解析 accept encoding， e.g. Accept-Encoding: gzip, deflate, sdch
        var accept = context.Request.Headers.AcceptEncoding;
                
        // 如果 accept 为空，-> 返回 null
        if (StringValues.IsNullOrEmpty(accept))
        {
            Debug.Assert(false, "Duplicate check failed.");
            _logger.NoAcceptEncoding();
            return null;
        }
        
        // 如果不能从 accept 解析 encodings，或者解析的 encodings 为空，-> 返回 null
        if (!StringWithQualityHeaderValue.TryParseList(accept, out var encodings) || encodings.Count == 0)
        {
            _logger.NoAcceptEncoding();
            return null;
        }
        
        // 创建 compression provider candidate hashset 集合（预结果）
        var candidates = new HashSet<ProviderCandidate>();
        
        // 遍历解析到的 encodings
        foreach (var encoding in encodings)
        {
            // 解析 encoding name、quality
            var encodingName = encoding.Value;
            var quality = encoding.Quality.GetValueOrDefault(1);
            
            // 如果 quality 为 0，-> 下一个 encoding
            if (quality < double.Epsilon)
            {
                continue;
            }
            
            // 遍历 provider，
            for (int i = 0; i < _providers.Length; i++)
            {
                var provider = _providers[i];
                // 如果 provider 的 encoding name 与 encoding name 相同，-> 注入 candidate（预结果）
                if (StringSegment.Equals(
                    	provider.EncodingName, 
                    	encodingName, 
                    	StringComparison.OrdinalIgnoreCase))
                {
                    candidates.Add(new ProviderCandidate(provider.EncodingName, quality, i, provider));
                }
            }
            
            // Uncommon but valid options
            // 如果 encoding name 为 "*"，-> 注入所有 compression provider，结束！
            if (StringSegment.Equals("*", encodingName, StringComparison.Ordinal))
            {
                
                for (int i = 0; i < _providers.Length; i++)
                {
                    var provider = _providers[i];                                        
                    candidates.Add(new ProviderCandidate(provider.EncodingName, quality, i, provider));
                }
                
                break;
            }
            
            // 如果 encoding name 是 "identity"，
            if (StringSegment.Equals("identity", encodingName, StringComparison.OrdinalIgnoreCase))
            {
                // We add 'identity' to the list of "candidates" with a very low priority and no provider.
                // This will allow it to be ordered based on its quality (and priority) later in the method.
                candidates.Add(new ProviderCandidate(encodingName.Value, quality, priority: int.MaxValue, provider: null));
            }
        }
        
        // selected provider（预结果）
        ICompressionProvider? selectedProvider = null;
        // 如果 candidates 为 1 个或者没有，
        if (candidates.Count <= 1)
        {
            selectedProvider = candidates.FirstOrDefault().Provider;
        }
        // （否则），即 candidates 多于 1 个，-> 按照 quality 排序并选出 first
        else
        {
            selectedProvider = candidates
                .OrderByDescending(x => x.Quality)
                .ThenBy(x => x.Priority)
                .First().Provider;
        }
        
        // 如果 selected provider 为 null，-> 返回 null
        if (selectedProvider == null)
        {
            // "identity" would match as a candidate but not have a provider implementation
            _logger.NoCompressionProvider();
            return null;
        }
        
        // 返回解析到的 selected provider
        _logger.CompressingWith(selectedProvider.EncodingName);
        return selectedProvider;
    }
    
    // 方法- should compress response（服务端）
    public virtual bool ShouldCompressResponse(HttpContext context)
    {
        // 从 http context 解析 compression feature 的 mode（没有则使用 default
        var httpsMode = context.Features.Get<IHttpsCompressionFeature>()?.Mode ?? HttpsCompressionMode.Default;
        
        // Check if the app has opted into or out of compression over HTTPS
        
        // 如果 http request 是 https，
        // 但是 https mode 是 do not compression；或者 https mode 不是 compress，并且没有标注 enable for https
        // -> 返回 false
        if (context.Request.IsHttps && 
            (httpsMode == HttpsCompressionMode.DoNotCompress || 
             !(_enableForHttps || httpsMode == HttpsCompressionMode.Compress)))
        {
            _logger.NoCompressionForHttps();
            return false;
        }
        
        // 如果 http reponse header 包含 content-range，-> 返回 false
        if (context.Response.Headers.ContainsKey(HeaderNames.ContentRange))
        {
            _logger.NoCompressionDueToHeader(HeaderNames.ContentRange);
            return false;
        }
        
        // 如果 http reponse header 包含 content encoding，-> 返回 false
        if (context.Response.Headers.ContainsKey(HeaderNames.ContentEncoding))
        {
            _logger.NoCompressionDueToHeader(HeaderNames.ContentEncoding);
            return false;
        }
        
        var mimeType = context.Response.ContentType;
        
        // 如果 mime type 为空，-> 返回 false
        if (string.IsNullOrEmpty(mimeType))
        {
            _logger.NoCompressionForContentType(mimeType);
            return false;
        }
        
        // 如果 mime type 包含 subtype，解析 maintype
        var separator = mimeType.IndexOf(';');
        if (separator >= 0)
        {
            // Remove the content-type optional parameters
            mimeType = mimeType.Substring(0, separator);
            mimeType = mimeType.Trim();
        }
        
        // 判断，exact => main type => wildcard
        var shouldCompress = ShouldCompressExact(mimeType) 	 //check exact match type/subtype
            ?? ShouldCompressPartial(mimeType) 				//check partial match type/*
            ?? _mimeTypes.Contains("*/*"); 					//check wildcard */*
        
       
        if (shouldCompress)
        {
            _logger.ShouldCompressResponse();  
            return true;
        }
        
        _logger.NoCompressionForContentType(mimeType);
        return false;
    }
            
    private bool? ShouldCompressExact(string mimeType)
    {
        //Check excluded MIME types first, then included
        if (_excludedMimeTypes.Contains(mimeType))
        {
            return false;
        }
        
        if (_mimeTypes.Contains(mimeType))
        {
            return true;
        }
        
        return null;
    }
    
    private bool? ShouldCompressPartial(string? mimeType)
    {
        var slashPos = mimeType?.IndexOf('/');
        
        if (slashPos >= 0)
        {
            var partialMimeType = mimeType!.Substring(0, slashPos.Value) + "/*";
            return ShouldCompressExact(partialMimeType);
        }
        
        return null;
    }
    
    private readonly struct ProviderCandidate : IEquatable<ProviderCandidate>
    {
        public string EncodingName { get; }        
        public double Quality { get; }        
        public int Priority { get; }        
        public ICompressionProvider? Provider { get; }
        
        public ProviderCandidate(
            string encodingName, 
            double quality, 
            int priority, 
            ICompressionProvider? provider)
        {
            EncodingName = encodingName;
            Quality = quality;
            Priority = priority;
            Provider = provider;
        }
        
        public bool Equals(ProviderCandidate other)
        {
            return string.Equals(
                EncodingName, 
                other.EncodingName, 
                StringComparison.OrdinalIgnoreCase);
        }
        
        public override bool Equals(object? obj)
        {
            return obj is ProviderCandidate candidate && Equals(candidate);
        }
        
        public override int GetHashCode()
        {
            return StringComparer.OrdinalIgnoreCase.GetHashCode(EncodingName);
        }
    }
    
    // 方法- check request accept compression（客户端）
    public bool CheckRequestAcceptsCompression(HttpContext context)
    {
        // 如果 http request header 包含 accept encoding，-> 返回 false
        if (string.IsNullOrEmpty(context.Request.Headers.AcceptEncoding))
        {
            _logger.NoAcceptEncoding();
            return false;
        }
                
        _logger.RequestAcceptsCompression(); 
        return true;
    }
}

```

#### 3.2 add response compression

```c#
public static class ResponseCompressionServicesExtensions
{    
    public static IServiceCollection AddResponseCompression(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        services.TryAddSingleton<IResponseCompressionProvider, ResponseCompressionProvider>();
        return services;
    }
        
    public static IServiceCollection AddResponseCompression(
        this IServiceCollection services, 
        Action<ResponseCompressionOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        services.Configure(configureOptions);
        services.TryAddSingleton<IResponseCompressionProvider, ResponseCompressionProvider>();
        return services;
    }
}

```

##### 3.2.1 response compression options

```c#
public class ResponseCompressionOptions
{    
    public IEnumerable<string> MimeTypes { get; set; } = Enumerable.Empty<string>();        
    public IEnumerable<string> ExcludedMimeTypes { get; set; } = Enumerable.Empty<string>();        
    // This can be overridden per request using <see cref="IHttpsCompressionFeature"/>.   
    public bool EnableForHttps { get; set; }        
    public CompressionProviderCollection Providers { get; } = new CompressionProviderCollection();
}

```

##### 3.2.2 response compression defaults

```c#
public class ResponseCompressionDefaults
{   
    public static readonly IEnumerable<string> MimeTypes = new[]
    {
        // General
        "text/plain",
        // Static files
        "text/css",
        "application/javascript",
        // MVC
        "text/html",
        "application/xml",
        "text/xml",
        "application/json",
        "text/json",
        // WebAssembly
        "application/wasm",
    };
}

```

#### 3.3 use response compression

```c#
public static class ResponseCompressionBuilderExtensions
{    
    public static IApplicationBuilder UseResponseCompression(this IApplicationBuilder builder)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }
        
        return builder.UseMiddleware<ResponseCompressionMiddleware>();
    }
}

```

##### 3.3.1 response compression middleware

```c#
public class ResponseCompressionMiddleware
{
    private readonly RequestDelegate _next;    
    private readonly IResponseCompressionProvider _provider;
           
    public ResponseCompressionMiddleware(RequestDelegate next, IResponseCompressionProvider provider)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }
        if (provider == null)
        {
            throw new ArgumentNullException(nameof(provider));
        }
        
        _next = next;
        _provider = provider;
    }
        
    public async Task Invoke(HttpContext context)
    {
        if (!_provider.CheckRequestAcceptsCompression(context))
        {
            await _next(context);
            return;
        }
        
        // 解析 original body feature、compression feature
        var originalBodyFeature = context.Features.Get<IHttpResponseBodyFeature>();
        var originalCompressionFeature = context.Features.Get<IHttpsCompressionFeature>();
        
        Debug.Assert(originalBodyFeature != null);
        
        // 创建 response compression body，注入 http context
        var compressionBody = new ResponseCompressionBody(context, _provider, originalBodyFeature);        
        context.Features.Set<IHttpResponseBodyFeature>(compressionBody);
        context.Features.Set<IHttpsCompressionFeature>(compressionBody);
        
        try
        {
            await _next(context);
            await compressionBody.FinishCompressionAsync();
        }
        finally
        {
            context.Features.Set(originalBodyFeature);
            context.Features.Set(originalCompressionFeature);
        }
    }
}

```

##### 3.3.2 response compression body

```c#
internal class ResponseCompressionBody : 
	Stream, 
	IHttpResponseBodyFeature, 
	IHttpsCompressionFeature
{
    private readonly HttpContext _context;
    private readonly IResponseCompressionProvider _provider;
    private readonly IHttpResponseBodyFeature _innerBodyFeature;
    private readonly Stream _innerStream;
    
    private ICompressionProvider? _compressionProvider;
    private bool _compressionChecked;
    private Stream? _compressionStream;
    private PipeWriter? _pipeAdapter;
    private bool _providerCreated;
    private bool _autoFlush;
    private bool _complete;
    
    HttpsCompressionMode IHttpsCompressionFeature.Mode { get; set; } = HttpsCompressionMode.Default;
    
    public override bool CanRead => false;    
    public override bool CanSeek => false;    
    public override bool CanWrite => _innerStream.CanWrite;
    
    public override long Length
    {
        get { throw new NotSupportedException(); }
    }
    
    public override long Position
    {
        get { throw new NotSupportedException(); }
        set { throw new NotSupportedException(); }
    }
    
    public Stream Stream => this;
    
    public PipeWriter Writer
    {
        get
        {
            if (_pipeAdapter == null)
            {
                _pipeAdapter = PipeWriter.Create(Stream, new StreamPipeWriterOptions(leaveOpen: true));
            }
            
            return _pipeAdapter;
        }
    }
                   
    internal ResponseCompressionBody(
        HttpContext context, 
        IResponseCompressionProvider provider,
        IHttpResponseBodyFeature innerBodyFeature)
    {
        _context = context;
        _provider = provider;
        _innerBodyFeature = innerBodyFeature;
        _innerStream = innerBodyFeature.Stream;
    }
    
    internal async Task FinishCompressionAsync()
    {
        if (_complete)
        {
            return;
        }
        
        _complete = true;
        
        if (_pipeAdapter != null)
        {
            await _pipeAdapter.CompleteAsync();
        }
        
        if (_compressionStream != null)
        {
            await _compressionStream.DisposeAsync();
        }
        
        // Adds the compression headers for HEAD requests even if the body was not used.
        if (!_compressionChecked && HttpMethods.IsHead(_context.Request.Method))
        {
            InitializeCompressionHeaders();
        }
    }        
    
    public override void Flush()
    {
        if (!_compressionChecked)
        {
            OnWrite();
            // Flush the original stream to send the headers. Flushing the compression stream won't
            // flush the original stream if no data has been written yet.
            _innerStream.Flush();
            return;
        }
        
        if (_compressionStream != null)
        {
            _compressionStream.Flush();
        }
        else
        {
            _innerStream.Flush();
        }
    }
    
    public override Task FlushAsync(CancellationToken cancellationToken)
    {
        if (!_compressionChecked)
        {
            OnWrite();
            // Flush the original stream to send the headers. Flushing the compression stream won't
            // flush the original stream if no data has been written yet.
            return _innerStream.FlushAsync(cancellationToken);
        }
        
        if (_compressionStream != null)
        {
            return _compressionStream.FlushAsync(cancellationToken);
        }
        
        return _innerStream.FlushAsync(cancellationToken);
    }
    
    public override int Read(byte[] buffer, int offset, int count)
    {
        throw new NotSupportedException();
    }
    
    public override long Seek(long offset, SeekOrigin origin)
    {
        throw new NotSupportedException();
    }
    
    public override void SetLength(long value)
    {
        throw new NotSupportedException();
    }
    
    public override void Write(byte[] buffer, int offset, int count)
    {
        OnWrite();
        
        if (_compressionStream != null)
        {
            _compressionStream.Write(buffer, offset, count);
            if (_autoFlush)
            {
                _compressionStream.Flush();
            }
        }
        else
        {
            _innerStream.Write(buffer, offset, count);
        }
    }
    
    public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback? callback, object? state)
        => TaskToApm.Begin(WriteAsync(buffer, offset, count, CancellationToken.None), callback, state);
    
    public override void EndWrite(IAsyncResult asyncResult)
        => TaskToApm.End(asyncResult);
    
    public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        OnWrite();
        
        if (_compressionStream != null)
        {
            await _compressionStream.WriteAsync(buffer, offset, count, cancellationToken);
            if (_autoFlush)
            {
                await _compressionStream.FlushAsync(cancellationToken);
            }
        }
        else
        {
            await _innerStream.WriteAsync(buffer, offset, count, cancellationToken);
        }
    }
    
    private void InitializeCompressionHeaders()
    {
        if (_provider.ShouldCompressResponse(_context))
        {
            // If the MIME type indicates that the response could be compressed, caches will need to vary by the Accept-Encoding header
            var varyValues = _context.Response.Headers.GetCommaSeparatedValues(HeaderNames.Vary);
            var varyByAcceptEncoding = false;
            
            for (var i = 0; i < varyValues.Length; i++)
            {
                if (string.Equals(varyValues[i], HeaderNames.AcceptEncoding, StringComparison.OrdinalIgnoreCase))
                {
                    varyByAcceptEncoding = true;
                    break;
                }
            }
            
            if (!varyByAcceptEncoding)
            {
                _context.Response.Headers.Append(HeaderNames.Vary, HeaderNames.AcceptEncoding);
            }
            
            var compressionProvider = ResolveCompressionProvider();
            if (compressionProvider != null)
            {
                _context.Response.Headers.Append(HeaderNames.ContentEncoding, compressionProvider.EncodingName);
                _context.Response.Headers.Remove(HeaderNames.ContentMD5); // Reset the MD5 because the content changed.
                _context.Response.Headers.Remove(HeaderNames.ContentLength);
            }
        }
    }
    
    private void OnWrite()
    {
        if (!_compressionChecked)
        {
            _compressionChecked = true;
            
            InitializeCompressionHeaders();
            
            if (_compressionProvider != null)
            {
                _compressionStream = _compressionProvider.CreateStream(_innerStream);
            }
        }
    }
    
    private ICompressionProvider? ResolveCompressionProvider()
    {
        if (!_providerCreated)
        {
            _providerCreated = true;
            _compressionProvider = _provider.GetCompressionProvider(_context);
        }
        
        return _compressionProvider;
    }
    
    // For this to be effective it needs to be called before the first write.
    public void DisableBuffering()
    {
        if (ResolveCompressionProvider()?.SupportsFlush == false)
        {
            // Don't compress, some of the providers don't implement Flush (e.g. .NET 4.5.1 GZip/Deflate stream)
            // which would block real-time responses like SignalR.
            _compressionChecked = true;            
        }
        else
        {
            _autoFlush = true;
        }
        _innerBodyFeature.DisableBuffering();
    }
    
    public Task SendFileAsync(string path, long offset, long? count, CancellationToken cancellation)
    {
        OnWrite();
        
        if (_compressionStream != null)
        {
            return SendFileFallback.SendFileAsync(Stream, path, offset, count, cancellation);
        }
        
        return _innerBodyFeature.SendFileAsync(path, offset, count, cancellation);
    }
    
    public Task StartAsync(CancellationToken token = default)
    {
        OnWrite();
        return _innerBodyFeature.StartAsync(token);
    }
    
    public async Task CompleteAsync()
    {
        if (_complete)
        {
            return;
        }
        
        await FinishCompressionAsync(); // Sets _complete
        await _innerBodyFeature.CompleteAsync();
    }
}

```

