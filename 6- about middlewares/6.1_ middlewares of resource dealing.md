## variety of middleware of resource dealing



### 1. about



### 2. common

#### 2.1 shared options

##### 2.1.1 shared options

```c#
public class SharedOptions
{
    // request path
    private PathString _requestPath;
    public PathString RequestPath
    {
        get { return _requestPath; }
        set
        {
            if (value.HasValue && value.Value!.EndsWith("/", StringComparison.Ordinal))
            {
                throw new ArgumentException("Request path must not end in a slash");
            }
            _requestPath = value;
        }
    }
    
    // file provider
    public IFileProvider? FileProvider { get; set; }   
    
    // 标记- append trailing splash
    public bool RedirectToAppendTrailingSlash { get; set; } = true;
    
    public SharedOptions()
    {
        RequestPath = PathString.Empty;
    }                            
}

```

##### 2.1.2 abstract base

```c#
public abstract class SharedOptionsBase
{       
    // shared options
    protected SharedOptions SharedOptions { get; private set; }
        
    // request path
    public PathString RequestPath
    {
        get { return SharedOptions.RequestPath; }
        set { SharedOptions.RequestPath = value; }
    }
        
    // file provider
    public IFileProvider? FileProvider
    {
        get { return SharedOptions.FileProvider; }
        set { SharedOptions.FileProvider = value; }
    }
        
    // 标记- append trailing splash
    public bool RedirectToAppendTrailingSlash
    {
        get { return SharedOptions.RedirectToAppendTrailingSlash; }
        set { SharedOptions.RedirectToAppendTrailingSlash = value; }
    }
    
    protected SharedOptionsBase(SharedOptions sharedOptions)
    {
        if (sharedOptions == null)
        {
            throw new ArgumentNullException(nameof(sharedOptions));
        }
        
        SharedOptions = sharedOptions;
    }           
}



```

#### 2.2 file provider？

#### 2.3 web encoder?

### 3. static file

#### 3.1 static file options

```c#
public class StaticFileOptions : SharedOptionsBase
{
    public IContentTypeProvider ContentTypeProvider { get; set; } = default!;       
    public string? DefaultContentType { get; set; }       
    public bool ServeUnknownFileTypes { get; set; }      
    public HttpsCompressionMode HttpsCompression { get; set; } = HttpsCompressionMode.Compress;       
    public Action<StaticFileResponseContext> OnPrepareResponse { get; set; }
    
    public StaticFileOptions() : this(new SharedOptions())
    {
    }
        
    public StaticFileOptions(SharedOptions sharedOptions) : base(sharedOptions)
    {
        OnPrepareResponse = _ => { };
    }           
}

public class StaticFileResponseContext
{
    public HttpContext Context { get; }        
    public IFileInfo File { get; }
    
    public StaticFileResponseContext(
        HttpContext context, 
        IFileInfo file)
    {
        Context = context ?? throw new ArgumentNullException(nameof(context));
        File = file ?? throw new ArgumentNullException(nameof(file));
    }            
}

```

#### 3.2 use static file

```c#
public static class StaticFileExtensions
{     
    public static IApplicationBuilder UseStaticFiles(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<StaticFileMiddleware>();
    }
    
    public static IApplicationBuilder UseStaticFiles(
        this IApplicationBuilder app, 
        string requestPath)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseStaticFiles(new StaticFileOptions { RequestPath = new PathString(requestPath) });
    }
    
    public static IApplicationBuilder UseStaticFiles(
        this IApplicationBuilder app, 
        StaticFileOptions options)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        return app.UseMiddleware<StaticFileMiddleware>(Options.Create(options));
    }
}

```

##### 3.2.1 static file middleware

```c#
public class StaticFileMiddleware
{
    private readonly StaticFileOptions _options;
    private readonly PathString _matchUrl;
    private readonly RequestDelegate _next;
    private readonly ILogger _logger;
    private readonly IFileProvider _fileProvider;
    private readonly IContentTypeProvider _contentTypeProvider;
        
    public StaticFileMiddleware(
        RequestDelegate next, 
        IWebHostEnvironment hostingEnv, 
        IOptions<StaticFileOptions> options, 
        ILoggerFactory loggerFactory)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }        
        if (hostingEnv == null)
        {
            throw new ArgumentNullException(nameof(hostingEnv));
        }        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }        
        if (loggerFactory == null)
        {
            throw new ArgumentNullException(nameof(loggerFactory));
        }
        
        _next = next;
        _options = options.Value;
        
        // content type provider
        _contentTypeProvider = _options.ContentTypeProvider ?? new FileExtensionContentTypeProvider();
        // file provider
        _fileProvider = _options.FileProvider ?? Helpers.ResolveFileProvider(hostingEnv);
        // request path
        _matchUrl = _options.RequestPath;
        
        _logger = loggerFactory.CreateLogger<StaticFileMiddleware>();
    }
            
    public Task Invoke(HttpContext context)
    {
        // 1- 如果有 endpoint，
        if (!ValidateNoEndpoint(context))
        {
            _logger.EndpointMatched();
        }
        // 2- 如果 http request method 不是 valid，
        else if (!ValidateMethod(context))
        {
            _logger.RequestMethodNotSupported(context.Request.Method);
        }
        // 3- 如果 http request path 不是 valid
        else if (!ValidatePath(context, _matchUrl, out var subPath))
        {
            _logger.PathMismatch(subPath);
        }
        // 4- 如果不能解析 content type
        else if (!LookupContentType(
            		_contentTypeProvider, 
            		_options, 
            		subPath, 
            		out var contentType))
        {
            _logger.FileTypeNotSupported(subPath);
        }
        // 否则，即全满足上述条件，-> 5- try serve file
        else
        {
            // If we get here, we can try to serve the file
            return TryServeStaticFile(context, contentType, subPath);
        }
        
        // 不满足条件，-> 下一个中间件
        return _next(context);
    }
    
    // 1- 是否有 endpoint
    private static bool ValidateNoEndpoint(HttpContext context) => context.GetEndpoint() == null;
    
    // 2- 是否是 get/head method    
    private static bool ValidateMethod(HttpContext context)
    {
        return Helpers.IsGetOrHeadMethod(context.Request.Method);
    }
    
    // 3- 是否 validpath
    internal static bool ValidatePath(
        HttpContext context, 
        PathString matchUrl, 
        out PathString subPath) => 
        	Helpers.TryMatchPath(context, matchUrl, forDirectory: false, out subPath);
    
    // 4- 能够解析 content type
    internal static bool LookupContentType(
        IContentTypeProvider contentTypeProvider, 
        StaticFileOptions options, 
        PathString subPath, 
        out string? contentType)
    {
        if (contentTypeProvider.TryGetContentType(
            	subPath.Value!, 
            	out contentType))
        {
            return true;
        }
        
        if (options.ServeUnknownFileTypes)
        {
            contentType = options.DefaultContentType;
            return true;
        }
        
        return false;
    }
    
    // 5- try serve file
    private Task TryServeStaticFile(
        HttpContext context, 
        string? contentType, 
        PathString subPath)
    {
        var fileContext = new StaticFileContext(
            context, 
            _options, 
            _logger, 
            _fileProvider, 
            contentType, 
            subPath);
        
        if (!fileContext.LookupFileInfo())
        {
            _logger.FileNotFound(fileContext.SubPath);
        }
        else
        {
            // If we get here, we can try to serve the file
            return fileContext.ServeStaticFile(context, _next);
        }
        
        return _next(context);
    }
}

```

##### 3.2.2 static file context

```c#
internal struct StaticFileContext
{
    private readonly HttpContext _context;
    private readonly StaticFileOptions _options;
    private readonly HttpRequest _request;
    private readonly HttpResponse _response;
    
    private readonly string _method;
    private readonly string? _contentType;
    
    private RequestHeaders? _requestHeaders;
    private RequestHeaders RequestHeaders => _requestHeaders ??= _request.GetTypedHeaders();    
    
    private ResponseHeaders? _responseHeaders;
    private ResponseHeaders ResponseHeaders => _responseHeaders ??= _response.GetTypedHeaders();
    
    private RequestType _requestType;
    public bool IsHeadMethod => _requestType.HasFlag(RequestType.IsHead);    
    public bool IsGetMethod => _requestType.HasFlag(RequestType.IsGet);    
    public bool IsRangeRequest
    {
        get => _requestType.HasFlag(RequestType.IsRange);
        private set
        {
            if (value)
            {
                _requestType |= RequestType.IsRange;
            }
            else
            {
                _requestType &= ~RequestType.IsRange;
            }
        }
    }
        
    private readonly IFileProvider _fileProvider;
    private IFileInfo _fileInfo;        
    public string SubPath => _subPath.Value!;    
    public string PhysicalPath => _fileInfo.PhysicalPath;
       
    private EntityTagHeaderValue? _etag;    
    private RangeItemHeaderValue? _range;    
    private long _length;
    private readonly PathString _subPath;
    private DateTimeOffset _lastModified;    
    private PreconditionState _ifMatchState;
    private PreconditionState _ifNoneMatchState;
    private PreconditionState _ifModifiedSinceState;
    private PreconditionState _ifUnmodifiedSinceState;
    
    private readonly ILogger _logger;
    
    public StaticFileContext(
        HttpContext context, 
        StaticFileOptions options, 
        ILogger logger, 
        IFileProvider fileProvider, 
        string? contentType, 
        PathString subPath)
    {
        _context = context;
        _options = options;
        _request = context.Request;
        _response = context.Response;
        _logger = logger;
        _fileProvider = fileProvider;
        _method = _request.Method;
        _contentType = contentType;
        _fileInfo = default!;
        _etag = null;
        _requestHeaders = null;
        _responseHeaders = null;
        _range = null;
        
        _length = 0;
        _subPath = subPath;
        _lastModified = new DateTimeOffset();
        _ifMatchState = PreconditionState.Unspecified;
        _ifNoneMatchState = PreconditionState.Unspecified;
        _ifModifiedSinceState = PreconditionState.Unspecified;
        _ifUnmodifiedSinceState = PreconditionState.Unspecified;
        
        if (HttpMethods.IsGet(_method))
        {
            _requestType = RequestType.IsGet;
        }
        else if (HttpMethods.IsHead(_method))
        {
            _requestType = RequestType.IsHead;
        }
        else
        {
            _requestType = RequestType.Unspecified;
        }
    }
        
    public bool LookupFileInfo()
    {
        _fileInfo = _fileProvider.GetFileInfo(_subPath.Value);
        if (_fileInfo.Exists)
        {
            _length = _fileInfo.Length;            
            DateTimeOffset last = _fileInfo.LastModified;
            // Truncate to the second.
            _lastModified = new DateTimeOffset(
                last.Year, 
                last.Month, 
                last.Day, 
                last.Hour, 
                last.Minute, 
                last.Second, 
                last.Offset).ToUniversalTime();
            
            long etagHash = _lastModified.ToFileTime() ^ _length;
            _etag = new EntityTagHeaderValue('\"' + Convert.ToString(etagHash, 16) + '\"');
        }
        return _fileInfo.Exists;
    }
    // 方法- 分析 request header
    
    public void ComprehendRequestHeaders()
    {
        ComputeIfMatch();        
        ComputeIfModifiedSince();        
        ComputeRange();        
        ComputeIfRange();
    }
    // if match    
    private void ComputeIfMatch()
    {
        var requestHeaders = RequestHeaders;
        
        // 14.24 If-Match
        var ifMatch = requestHeaders.IfMatch;
        if (ifMatch?.Count > 0)
        {
            _ifMatchState = PreconditionState.PreconditionFailed;
            foreach (var etag in ifMatch)
            {
                if (etag.Equals(EntityTagHeaderValue.Any) || etag.Compare(_etag, useStrongComparison: true))
                {
                    _ifMatchState = PreconditionState.ShouldProcess;
                    break;
                }
            }
        }
        
        // 14.26 If-None-Match
        var ifNoneMatch = requestHeaders.IfNoneMatch;
        if (ifNoneMatch?.Count > 0)
        {
            _ifNoneMatchState = PreconditionState.ShouldProcess;
            foreach (var etag in ifNoneMatch)
            {
                if (etag.Equals(EntityTagHeaderValue.Any) || etag.Compare(_etag, useStrongComparison: true))
                {
                    _ifNoneMatchState = PreconditionState.NotModified;
                    break;
                }
            }
        }
    }
    // if modified since   
    private void ComputeIfModifiedSince()
    {
        var requestHeaders = RequestHeaders;
        var now = DateTimeOffset.UtcNow;
        
        // 14.25 If-Modified-Since
        var ifModifiedSince = requestHeaders.IfModifiedSince;
        if (ifModifiedSince.HasValue && ifModifiedSince <= now)
        {
            bool modified = ifModifiedSince < _lastModified;
            _ifModifiedSinceState = modified 
                ? PreconditionState.ShouldProcess 
                : PreconditionState.NotModified;
        }
        
        // 14.28 If-Unmodified-Since
        var ifUnmodifiedSince = requestHeaders.IfUnmodifiedSince;
        if (ifUnmodifiedSince.HasValue && ifUnmodifiedSince <= now)
        {
            bool unmodified = ifUnmodifiedSince >= _lastModified;
            _ifUnmodifiedSinceState = unmodified 
                ? PreconditionState.ShouldProcess 
                : PreconditionState.PreconditionFailed;
        }
    }
    // if range
    private void ComputeIfRange()
    {
        // 14.27 If-Range
        var ifRangeHeader = RequestHeaders.IfRange;
        if (ifRangeHeader != null)
        {
            // If the validator given in the If-Range header field matches the current validator for the selected 
            // representation of the target resource, then the server SHOULD process the Range header field as requested.  
            // If the validator does not match, the server MUST ignore the Range header field.
            if (ifRangeHeader.LastModified.HasValue)
            {
                if (_lastModified > ifRangeHeader.LastModified)
                {
                    IsRangeRequest = false;
                }
            }
            else if (_etag != null && 
                     ifRangeHeader.EntityTag != null && 
                     !ifRangeHeader.EntityTag.Compare(_etag, useStrongComparison: true))
            {
                IsRangeRequest = false;
            }
        }
    }
    // range
    private void ComputeRange()
    {
        // 14.35 Range
        // http://tools.ietf.org/html/draft-ietf-httpbis-p5-range-24
        
        // A server MUST ignore a Range header field received with a request method other than GET.
        if (!IsGetMethod)
        {
            return;
        }
        
        (var isRangeRequest, var range) = RangeHelper.ParseRange(
            _context, 
            RequestHeaders, 
            _length, 
            _logger);
        
        _range = range;
        IsRangeRequest = isRangeRequest;
    }
   
    // 方法- get precondition state
    public PreconditionState GetPreconditionState() => GetMaxPreconditionState(
        _ifMatchState, 
        _ifNoneMatchState, 
        _ifModifiedSinceState, 
        _ifUnmodifiedSinceState);
    
    private static PreconditionState GetMaxPreconditionState(params PreconditionState[] states)
    {
        PreconditionState max = PreconditionState.Unspecified;
        for (int i = 0; i < states.Length; i++)
        {
            if (states[i] > max)
            {
                max = states[i];
            }
        }
        return max;
    }
    
    // 方法- send status
    public Task SendStatusAsync(int statusCode)
    {
        ApplyResponseHeaders(statusCode);        
        _logger.Handled(statusCode, SubPath);
        return Task.CompletedTask;
    }
    
    public void ApplyResponseHeaders(int statusCode)
    {
        // 解析 response status code
        _response.StatusCode = statusCode;
        // 如果 status code < 400，
        if (statusCode < 400)
        {
            // these headers are returned for 200, 206, and 304 they are not returned for 412 and 416
            
            // 注入 content type
            if (!string.IsNullOrEmpty(_contentType))
            {
                _response.ContentType = _contentType;
            }
            
            var responseHeaders = ResponseHeaders;
            
            // 注入 last modified
            responseHeaders.LastModified = _lastModified;
            // 注入 etag
            responseHeaders.ETag = _etag;
            // 注入 accept range
            responseHeaders.Headers[HeaderNames.AcceptRanges] = "bytes";
        }
        // 如果 status code = 200
        if (statusCode == StatusCodes.Status200OK)
        {
            // this header is only returned here for 200; it already set to the returned range for 206
            // it is not returned for 304, 412, and 416
            
            // 注入 content length
            _response.ContentLength = _length;
        }
        
        _options.OnPrepareResponse(new StaticFileResponseContext(_context, _fileInfo!));
    }
    
    // 方法- send 
    public async Task SendAsync()
    {        
        SetCompressionMode();        
        ApplyResponseHeaders(StatusCodes.Status200OK);
        
        try
        {
            await _context.Response.SendFileAsync(
                _fileInfo, 
                0,
                _length, 
                _context.RequestAborted);
        }
        catch (OperationCanceledException ex)
        {
            // Don't throw this exception, it's most likely caused by the client disconnecting.
            _logger.WriteCancelled(ex);
        }
    }
    
    // 方法- send range
    internal async Task SendRangeAsync()
    {
        if (_range == null)
        {
            // 14.16 Content-Range - A server sending a response with status code 416 (Requested range not satisfiable)
            // SHOULD include a Content-Range field with a byte-range-resp-spec of "*". 
            // The instance-length specifies the current length of the selected resource. e.g. */length
            ResponseHeaders.ContentRange = new ContentRangeHeaderValue(_length);
            ApplyResponseHeaders(StatusCodes.Status416RangeNotSatisfiable);
            
            _logger.RangeNotSatisfiable(SubPath);
            return;
        }
        
        ResponseHeaders.ContentRange = ComputeContentRange(
            _range, 
            out var start, 
            out var length);
        
        _response.ContentLength = length;
        
        SetCompressionMode();
        ApplyResponseHeaders(StatusCodes.Status206PartialContent);
        
        try
        {
            var logPath = !string.IsNullOrEmpty(_fileInfo.PhysicalPath) 
                ? _fileInfo.PhysicalPath 
                : SubPath;
            
            _logger.SendingFileRange(
                _response.Headers[HeaderNames.ContentRange], 
                logPath);
            
            await _context.Response.SendFileAsync(
                _fileInfo, 
                start, 
                length, 
                _context.RequestAborted);
        }
        catch (OperationCanceledException ex)
        {
            // Don't throw this exception, it's most likely caused by the client disconnecting.
            _logger.WriteCancelled(ex);
        }
    }
    
    // Note: This assumes ranges have been normalized to absolute byte offsets.
    private ContentRangeHeaderValue ComputeContentRange(
        RangeItemHeaderValue range, 
        out long start, 
        out long length)
    {
        start = range.From!.Value;
        var end = range.To!.Value;
        length = end - start + 1;
        return new ContentRangeHeaderValue(start, end, _length);
    }
    
    // Only called when we expect to serve the body.
    private void SetCompressionMode()
    {
        var responseCompressionFeature = _context.Features.Get<IHttpsCompressionFeature>();
        if (responseCompressionFeature != null)
        {
            responseCompressionFeature.Mode = _options.HttpsCompression;
        }
    }
    
    // server static file
    public async Task ServeStaticFile(HttpContext context, RequestDelegate next)
    {
        // 分析 request header
        ComprehendRequestHeaders();
        // 判断 state
        switch (GetPreconditionState())
        {
            case PreconditionState.Unspecified:
            // state = unspecified / should process（需要 server 返回数据）    
            case PreconditionState.ShouldProcess:
                // 如果 request 是 head，-> send status，结束
                if (IsHeadMethod)
                {
                    await SendStatusAsync(StatusCodes.Status200OK);
                    return;
                }      
                // （不是 head request）
                try
                {
                    // 如果 request 是 range request，-> send range，结束
                    if (IsRangeRequest)
                    {
                        await SendRangeAsync();
                        return;
                    }
                    // （不是 range request），-> send，结束                                        
                    await SendAsync();
                    _logger.FileServed(SubPath, PhysicalPath);
                    return;
                }
                catch (FileNotFoundException)
                {
                    context.Response.Clear();
                }
                
                await next(context);
                return;
            // state = not modifed（缓存有效，返回 header）    
            case PreconditionState.NotModified:
                _logger.FileNotModified(SubPath);
                // -> send status
                await SendStatusAsync(StatusCodes.Status304NotModified);
                return;
            // state failed（解析缓存错误），-> 返回 412    
            case PreconditionState.PreconditionFailed:
                _logger.PreconditionFailed(SubPath);
                await SendStatusAsync(StatusCodes.Status412PreconditionFailed);
                return;
                
            default:
                var exception = new NotImplementedException(GetPreconditionState().ToString());
                Debug.Fail(exception.ToString());
                throw exception;
        }
    }
            
    internal enum PreconditionState : byte
    {
        Unspecified,
        NotModified,
        ShouldProcess,
        PreconditionFailed
    }
    
    [Flags]
    private enum RequestType : byte
    {
        Unspecified = 0b_000,
        IsHead = 0b_001,
        IsGet = 0b_010,
        IsRange = 0b_100,
    }
}

```

#### 3.3 static file in endpoint route

```c#
public static class StaticFilesEndpointRouteBuilderExtensions
{        
    // "MapFallbackToFile(IEndpointRouteBuilder, string)" is intended to handle cases where URL path of the request 
    // does not contain a filename, and no other endpoint has matched. 
    // This is convenient for routing requests for dynamic content to a SPA framework, while also allowing requests 
    // for non-existent files to result in an HTTP 404.
        
    public static IEndpointConventionBuilder MapFallbackToFile(
        this IEndpointRouteBuilder endpoints,
        string filePath)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (filePath == null)
        {
            throw new ArgumentNullException(nameof(filePath));
        }
        
        return endpoints.MapFallback(CreateRequestDelegate(endpoints, filePath));
    }
                
    public static IEndpointConventionBuilder MapFallbackToFile(
        this IEndpointRouteBuilder endpoints,
        string filePath,
        StaticFileOptions options)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (filePath == null)
        {
            throw new ArgumentNullException(nameof(filePath));
        }
        
        return endpoints.MapFallback(CreateRequestDelegate(endpoints, filePath, options));
    }
        
    public static IEndpointConventionBuilder MapFallbackToFile(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        string filePath)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(filePath));
        }        
        if (filePath == null)
        {
            throw new ArgumentNullException(nameof(filePath));
        }
        
        return endpoints.MapFallback(pattern, CreateRequestDelegate(endpoints, filePath));
    }
    
        
    public static IEndpointConventionBuilder MapFallbackToFile(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        string filePath,
        StaticFileOptions options)
    {
        if (endpoints == null)
        {
            throw new ArgumentNullException(nameof(endpoints));
        }        
        if (pattern == null)
        {
            throw new ArgumentNullException(nameof(filePath));
        }        
        if (filePath == null)
        {
            throw new ArgumentNullException(nameof(filePath));
        }
        
        return endpoints.MapFallback(pattern, CreateRequestDelegate(endpoints, filePath, options));
    }
    
    private static RequestDelegate CreateRequestDelegate(
        IEndpointRouteBuilder endpoints,
        string filePath,
        StaticFileOptions? options = null)
    {
        // 克隆 endpoint 的 application builder
        var app = endpoints.CreateApplicationBuilder();
        
        app.Use(next => 
        	context =>
                {
                    // 修改 request path 到 file path
                    context.Request.Path = "/" + filePath;                    
                    // 设置 endpoint 为 null，使 static file middleware 生效
                    context.SetEndpoint(null);
                    
                    return next(context);
                });
        
        /* 转向 use static file 中间件 */        
        if (options == null)
        {
            app.UseStaticFiles();
        }
        else
        {
            app.UseStaticFiles(options);
        }
        
        return app.Build();
    }
}

```

### 4. default file

#### 4.1 default file options

```c#
public class DefaultFilesOptions : SharedOptionsBase
{
    public IList<string> DefaultFileNames { get; set; }
    
    public DefaultFilesOptions() : this(new SharedOptions())
    {
    }
        
    public DefaultFilesOptions(SharedOptions sharedOptions) : base(sharedOptions)
    {
        // Prioritized list
        DefaultFileNames = new List<string>
        {
            "default.htm",
            "default.html",
            "index.htm",
            "index.html",
        };
    }            
}

```

#### 4.2 use default file

```c#
public static class DefaultFilesExtensions
{   
    public static IApplicationBuilder UseDefaultFiles(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<DefaultFilesMiddleware>();
    }
        
    public static IApplicationBuilder UseDefaultFiles(
        this IApplicationBuilder app, 
        string requestPath)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseDefaultFiles(new DefaultFilesOptions { RequestPath = new PathString(requestPath) });
    }
        
    public static IApplicationBuilder UseDefaultFiles(
        this IApplicationBuilder app, 
        DefaultFilesOptions options)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        return app.UseMiddleware<DefaultFilesMiddleware>(Options.Create(options));
    }
}

```

##### 4.2.1 default file middleware

```c#
public class DefaultFilesMiddleware
{
    private readonly DefaultFilesOptions _options;
    private readonly PathString _matchUrl;
    private readonly RequestDelegate _next;
    private readonly IFileProvider _fileProvider;
            
    public DefaultFilesMiddleware(
        RequestDelegate next, 
        IWebHostEnvironment hostingEnv, 
        IOptions<DefaultFilesOptions> options)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }        
        if (hostingEnv == null)
        {
            throw new ArgumentNullException(nameof(hostingEnv));
        }        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        _next = next;
        _options = options.Value;
        
        _fileProvider = _options.FileProvider ?? Helpers.ResolveFileProvider(hostingEnv);
        _matchUrl = _options.RequestPath;
    }
            
    public Task Invoke(HttpContext context)
    {
        // 如果 http context 没有 endpoint，request 是 get / head，并且 request 匹配 match url 且能得到 subpath        
        if (context.GetEndpoint() == null && 
            Helpers.IsGetOrHeadMethod(context.Request.Method) && 
            Helpers.TryMatchPath(
                context, 
                _matchUrl, 
                forDirectory: true, 
                subpath: out var subpath))
        {
            // 解析 directory contents
            var dirContents = _fileProvider.GetDirectoryContents(subpath.Value);
            // dir contents 存在，
            if (dirContents.Exists)
            {
                // 遍历 options 的 default file name
                for (int matchIndex = 0; matchIndex < _options.DefaultFileNames.Count; matchIndex++)
                {
                    // 按照 default file name 解析 default file (info)
                    string defaultFile = _options.DefaultFileNames[matchIndex];
                    var file = _fileProvider.GetFileInfo(subpath.Value + defaultFile);
                    // 如果 default file info 存在，-> request path 转到 file path
                    if (file.Exists)
                    {
                        // append splash & redirect                        
                        if (_options.RedirectToAppendTrailingSlash && 
                            !Helpers.PathEndsInSlash(context.Request.Path))
                        {
                            Helpers.RedirectToPathWithSlash(context);
                            return Task.CompletedTask;
                        }
                        // Match found, re-write the url. 
                        // A later middleware will actually serve the file.？？（static file middleware？）
                        context.Request.Path = new PathString(Helpers.GetPathValueWithSlash(context.Request.Path) + defaultFile);
                        break;
                    }
                }
            }
        }
        
        return _next(context);
    }
}

```

### 5. directory browser

#### 5.1 add directory browser

```c#
public static class DirectoryBrowserServiceExtensions
{    
    public static IServiceCollection AddDirectoryBrowser(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        services.AddWebEncoders();        
        return services;
    }
}

```

#### 5.2 use directory browser

```c#
public static class DirectoryBrowserExtensions
{    
    public static IApplicationBuilder UseDirectoryBrowser(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<DirectoryBrowserMiddleware>();
    }
        
    public static IApplicationBuilder UseDirectoryBrowser(
        this IApplicationBuilder app, 
        string requestPath)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseDirectoryBrowser(
            new DirectoryBrowserOptions  
            {
                RequestPath = new PathString(requestPath)
            });
    }
        
    public static IApplicationBuilder UseDirectoryBrowser(
        this IApplicationBuilder app, 
        DirectoryBrowserOptions options)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        return app.UseMiddleware<DirectoryBrowserMiddleware>(Options.Create(options));
    }
}

```

##### 5.2.1 directory browser options

```c#
public class DirectoryBrowserOptions : SharedOptionsBase
{
    public IDirectoryFormatter? Formatter { get; set; }
    
    public DirectoryBrowserOptions() : this(new SharedOptions())
    {
    }
        
    public DirectoryBrowserOptions(SharedOptions sharedOptions) : base(sharedOptions)
    {
    }    
}

```

##### 5.2.2 directory browser middleware

```c#
public class DirectoryBrowserMiddleware
{
    private readonly DirectoryBrowserOptions _options;
    private readonly PathString _matchUrl;
    private readonly RequestDelegate _next;
    private readonly IDirectoryFormatter _formatter;
    private readonly IFileProvider _fileProvider;
            
    public DirectoryBrowserMiddleware(
        RequestDelegate next, 
        IWebHostEnvironment hostingEnv, 
        IOptions<DirectoryBrowserOptions> options) : 
    		this(next, hostingEnv, HtmlEncoder.Default, options)
    {
    }
            
    public DirectoryBrowserMiddleware(
        RequestDelegate next, 
        IWebHostEnvironment hostingEnv, 
        HtmlEncoder encoder, 
        IOptions<DirectoryBrowserOptions> options)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }        
        if (hostingEnv == null)
        {
            throw new ArgumentNullException(nameof(hostingEnv));
        }        
        if (encoder == null)
        {
            throw new ArgumentNullException(nameof(encoder));
        }        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        _next = next;
        _options = options.Value;
        
        // 从 directory browser options 解析 
        _fileProvider = _options.FileProvider ?? Helpers.ResolveFileProvider(hostingEnv);
        _formatter = _options.Formatter ?? new HtmlDirectoryFormatter(encoder);
        _matchUrl = _options.RequestPath;
    }
            
    public Task Invoke(HttpContext context)
    {        
        // 如果 http context 没有 endpoint；request 是 get/head 方法；
        // request path 匹配 match url，且能够解析到 subpath；并且能够按照 subpath 解析 directory info
        if (context.GetEndpoint() == null && 
            Helpers.IsGetOrHeadMethod(context.Request.Method) && 
            Helpers.TryMatchPath(
                context, 
                _matchUrl, 
                forDirectory: true, 
                subpath: out var subpath) && 
            TryGetDirectoryInfo(subpath, out var contents))
        {            
            // append splash & redirect to directory path
            if (_options.RedirectToAppendTrailingSlash && 
                !Helpers.PathEndsInSlash(context.Request.Path))
            {
                Helpers.RedirectToPathWithSlash(context);
                return Task.CompletedTask;
            }
            // directory content
            return _formatter.GenerateContentAsync(context, contents);
        }
        
        return _next(context);
    }
    
    private bool TryGetDirectoryInfo(
        PathString subpath, 
        out IDirectoryContents contents)
    {
        contents = _fileProvider.GetDirectoryContents(subpath.Value);
        return contents.Exists;
    }
}

```

### 6. file server

#### 6.1 file server options

```c#
public class FileServerOptions : SharedOptionsBase
{
    public StaticFileOptions StaticFileOptions { get; private set; }        
    public DirectoryBrowserOptions DirectoryBrowserOptions { get; private set; }        
    public DefaultFilesOptions DefaultFilesOptions { get; private set; }     
    
    public bool EnableDirectoryBrowsing { get; set; }        
    public bool EnableDefaultFiles { get; set; }
    
    public FileServerOptions() : base(new SharedOptions())
    {
        StaticFileOptions = new StaticFileOptions(SharedOptions);
        DirectoryBrowserOptions = new DirectoryBrowserOptions(SharedOptions);
        DefaultFilesOptions = new DefaultFilesOptions(SharedOptions);
        EnableDefaultFiles = true;
    }            
}

```

#### 6.2 use file server

```c#
public static class FileServerExtensions
{    
    public static IApplicationBuilder UseFileServer(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseFileServer(new FileServerOptions());
    }
        
    public static IApplicationBuilder UseFileServer(
        this IApplicationBuilder app, 
        bool enableDirectoryBrowsing)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseFileServer(
            new FileServerOptions
            {
                EnableDirectoryBrowsing = enableDirectoryBrowsing
            });
    }
            
    public static IApplicationBuilder UseFileServer(
        this IApplicationBuilder app, 
        string requestPath)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        if (requestPath == null)
        {
            throw new ArgumentNullException(nameof(requestPath));
        }
        
        return app.UseFileServer(
            new FileServerOptions
            {
                RequestPath = new PathString(requestPath)
            });
    }
            
    public static IApplicationBuilder UseFileServer(
        this IApplicationBuilder app, 
        FileServerOptions options)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        if (options.EnableDefaultFiles)
        {
            app.UseDefaultFiles(options.DefaultFilesOptions);
        }
        
        if (options.EnableDirectoryBrowsing)
        {
            app.UseDirectoryBrowser(options.DirectoryBrowserOptions);
        }
        
        return app.UseStaticFiles(options.StaticFileOptions);
    }
}

```

### 7. spa static file

#### 7.1 add spa file

```c#
public static class SpaStaticFilesExtensions
{    
    public static void AddSpaStaticFiles(
        this IServiceCollection services,
        Action<SpaStaticFilesOptions>? configuration = null)
    {
        services.AddSingleton<ISpaStaticFileProvider>(serviceProvider =>
        	{
                // 解析 spa static file options
                var optionsProvider = serviceProvider.GetService<IOptions<SpaStaticFilesOptions>>()!;
                var options = optionsProvider.Value;
                
                // 配置 spa static file options
                configuration?.Invoke(options);

                // 如果 spa static file options 中 root path 为空，-> 抛出异常
                if (string.IsNullOrEmpty(options.RootPath))
                {
                    throw new InvalidOperationException(
                        $"No {nameof(SpaStaticFilesOptions.RootPath)} " +
                        $"was set on the {nameof(SpaStaticFilesOptions)}.");
                }

                return new DefaultSpaStaticFileProvider(serviceProvider, options);
            });
    }                   
}

```

##### 7.1.1 spa static file options

```c#
public class SpaStaticFilesOptions
{    
    public string RootPath { get; set; } = default!;
}

```

##### 7.1.2 spa static file provider

```c#
// 接口
public interface ISpaStaticFileProvider
{    
    IFileProvider? FileProvider { get; }
}

// default provider
internal class DefaultSpaStaticFileProvider : ISpaStaticFileProvider
{
    private IFileProvider? _fileProvider;
    public IFileProvider? FileProvider => _fileProvider;
    
    public DefaultSpaStaticFileProvider(
        IServiceProvider serviceProvider,
        SpaStaticFilesOptions options)
    {
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        if (string.IsNullOrEmpty(options.RootPath))
        {
            throw new ArgumentException(
                $"The {nameof(options.RootPath)} property of {nameof(options)} cannot be null or empty.");
        }
        
        // 解析 web host environment
        var env = serviceProvider.GetRequiredService<IWebHostEnvironment>();
        
        // 合并 web host environment 的 content root path 和 spa static file options 的 root path
        var absoluteRootPath = Path.Combine(
            env.ContentRootPath,
            options.RootPath);
        
        // 创建 physical file provider（如果 abs root path 不存在，忽略）
        if (Directory.Exists(absoluteRootPath))
        {
            _fileProvider = new PhysicalFileProvider(absoluteRootPath);
        }
    }        
}

```

#### 7.2 use spa file

##### 7.2.1 use spa static file

```c#
public static class SpaStaticFilesExtensions
{        
    public static void UseSpaStaticFiles(this IApplicationBuilder applicationBuilder)
    {
        UseSpaStaticFiles(applicationBuilder, new StaticFileOptions());
    }
           
    public static void UseSpaStaticFiles(
        this IApplicationBuilder applicationBuilder, 
        StaticFileOptions options)
    {
        if (applicationBuilder == null)
        {
            throw new ArgumentNullException(nameof(applicationBuilder));
        }        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        UseSpaStaticFilesInternal(
            applicationBuilder,            
            staticFileOptions: options,
            allowFallbackOnServingWebRootFiles: false);
    }
    
    internal static void UseSpaStaticFilesInternal(
        this IApplicationBuilder app,
        StaticFileOptions staticFileOptions,
        bool allowFallbackOnServingWebRootFiles)
    {
        if (staticFileOptions == null)
        {
            throw new ArgumentNullException(nameof(staticFileOptions));
        }
                
        // 如果 static file options 的 file provider 为 null，-> 解析 default file provider      
        if (staticFileOptions.FileProvider == null)
        {
            // 判断是否可以 serve static file（创建 file provider）
            var shouldServeStaticFiles = ShouldServeStaticFiles(
                app,
                allowFallbackOnServingWebRootFiles,
                out var fileProviderOrDefault);
            
            // 将 file provider 注入 static file options
            if (shouldServeStaticFiles)
            {
                staticFileOptions.FileProvider = fileProviderOrDefault;
            }
            else
            {                
                return;
            }
        }
        
        // 注册 use static file 中间件
        app.UseStaticFiles(staticFileOptions);
    }
    
    private static bool ShouldServeStaticFiles(
        IApplicationBuilder app,
        bool allowFallbackOnServingWebRootFiles,
        out IFileProvider? fileProviderOrDefault)
    {
        // 解析 spa static file provider
        var spaStaticFilesService = app.ApplicationServices.GetService<ISpaStaticFileProvider>();
        
        // 如果 spa static file provider 不为 null，
        if (spaStaticFilesService != null)
        {
            // 解析 spa static file provider 的 file provider
            fileProviderOrDefault = spaStaticFilesService.FileProvider;
            return fileProviderOrDefault != null;
        }
        // （否则），即 spa staic file provider 为 null，
        // 但是没有标记 allow fallback on serving web root files，-> 抛出异常
        else if (!allowFallbackOnServingWebRootFiles)
        {
            throw new InvalidOperationException(
                $"To use {nameof(UseSpaStaticFiles)}, you must " +
                $"first register an {nameof(ISpaStaticFileProvider)} in the service provider, typically " +
                $"by calling services.{nameof(AddSpaStaticFiles)}.");
        }
        // （否则），即 spa static file provider 为 null，
        // 但是标记了 allow fallback on serving web root files，-> true & default provide = null
        else
        {
            // Fall back on serving wwwroot
            fileProviderOrDefault = null;
            return true;
        }
    }
}

```

##### 7.2.2 use spa

```c#
public static class SpaApplicationBuilderExtensions
{       
    // This middleware should be placed late in the chain, so that other middleware for serving static files, 
    // MVC actions, etc., takes precedence.       
    public static void UseSpa(
        this IApplicationBuilder app, 
        Action<ISpaBuilder> configuration)
    {
        if (configuration == null)
        {
            throw new ArgumentNullException(nameof(configuration));
        }
                
        // 解析、克隆 spa options
        var optionsProvider = app.ApplicationServices.GetService<IOptions<SpaOptions>>()!;
        var options = new SpaOptions(optionsProvider.Value);
        
        // 创建、配置 spa builder
        var spaBuilder = new DefaultSpaBuilder(app, options);
        configuration.Invoke(spaBuilder);
        
        // 将 spa default page middleware 附加到 spa builder
        SpaDefaultPageMiddleware.Attach(spaBuilder);
    }
}

```

###### 7.2.2.1 spa default page middleware

```c#
internal class SpaDefaultPageMiddleware
{
    public static void Attach(ISpaBuilder spaBuilder)
    {
        if (spaBuilder == null)
        {
            throw new ArgumentNullException(nameof(spaBuilder));
        }
        
        // 获取 spa builder 的 application builder
        var app = spaBuilder.ApplicationBuilder;
        // 获取 spa builder 的 options
        var options = spaBuilder.Options;
        
        // Rewrite all requests to the default page
        app.Use(
            (context, next) =>
                {
                    // If we have an Endpoint, then this is a deferred match - just noop.
                    if (context.GetEndpoint() != null)
                    {
                        return next();
                    }
                    
                    context.Request.Path = options.DefaultPage;
                    return next();
                });
                
        // 注入 spa static file 中间件
        app.UseSpaStaticFilesInternal(
            options.DefaultPageStaticFileOptions ?? new StaticFileOptions(),
            allowFallbackOnServingWebRootFiles: true);
                
        // 注入中间件（如果没有找 static file，-> 抛出异常）
        app.Use(
            (context, next) =>
                {
                    // 如果有 endpoint，-> 下一个中间件
                    if (context.GetEndpoint() != null)
                    {
                        return next();
                    }
                    
                    // （否则），即没有 endpoint，-> 抛出异常
                    var message = "The SPA default page middleware could not return the default page '{options.DefaultPage}'" +
                        "because it was not found, and no other middleware handled the request.\n";
                    
                    // Try to clarify the common scenario where someone runs an application in Production environment 
                    // without first publishing the whole application or at least building the SPA.
                    var hostEnvironment = (IWebHostEnvironment?)context.RequestServices.GetService(typeof(IWebHostEnvironment));
                    
                    if (hostEnvironment != null && hostEnvironment.IsProduction())
                    {
                        message += "Your application is running in Production mode, so make sure it has been published, " +
                            "or that you have built your SPA manually. Alternatively you may wish to switch to the" +
                            "Development environment.\n";
                    }
                    
                    throw new InvalidOperationException(message);
                });
    }
}

```

#### 7.3 use spa server

##### 7.3.1 spa builder

```c#
// 接口
public interface ISpaBuilder
{    
    IApplicationBuilder ApplicationBuilder { get; } 
    SpaOptions Options { get; }
}

// 默认实现
internal class DefaultSpaBuilder : ISpaBuilder
{
    public IApplicationBuilder ApplicationBuilder { get; }    
    public SpaOptions Options { get; }
    
    public DefaultSpaBuilder(
        IApplicationBuilder applicationBuilder, 
        SpaOptions options)
    {
        ApplicationBuilder = applicationBuilder ?? throw new ArgumentNullException(nameof(applicationBuilder));        
        Options = options ?? throw new ArgumentNullException(nameof(options));
    }
}

```

###### 7.3.1.1 spa options

```c#
public class SpaOptions
{
    // default page
    private PathString _defaultPage = "/index.html";
    public PathString DefaultPage
    {
        get => _defaultPage;
        set
        {
            if (string.IsNullOrEmpty(value.Value))
            {
                throw new ArgumentException($"The value for {nameof(DefaultPage)} cannot be null or empty.");
            }
            
            _defaultPage = value;
        }
    }  
    
    // package manager command
    private string _packageManagerCommand = "npm";    
    public string PackageManagerCommand
    {
        get => _packageManagerCommand;
        set
        {
            if (string.IsNullOrEmpty(value))
            {
                throw new ArgumentException($"The value for {nameof(PackageManagerCommand)} cannot be null or empty.");
            }
            
            _packageManagerCommand = value;
        }
    }
    
    public StaticFileOptions? DefaultPageStaticFileOptions { get; set; }     
    
    // dev server info
    public string? SourcePath { get; set; }        
    public int DevServerPort { get; set; } = default(int);          
    public TimeSpan StartupTimeout { get; set; } = TimeSpan.FromSeconds(120);
                
    public SpaOptions()
    {
    }
           
    internal SpaOptions(SpaOptions copyFromOptions)
    {
        _defaultPage = copyFromOptions.DefaultPage;
        _packageManagerCommand = copyFromOptions.PackageManagerCommand;
        DefaultPageStaticFileOptions = copyFromOptions.DefaultPageStaticFileOptions;
        SourcePath = copyFromOptions.SourcePath;
        DevServerPort = copyFromOptions.DevServerPort;
    }                              
}

```

###### 7.3.1.2 spa proxying extensions

```c#
public static class SpaProxyingExtensions
{    
    // Configures the application to forward incoming requests to a local Single Page Application (SPA) development server. 
    // This is only intended to be used during development.     
    // Do not enable this middleware in production applications.
        
    public static void UseProxyToSpaDevelopmentServer(
        this ISpaBuilder spaBuilder,
        string baseUri)
    {
        UseProxyToSpaDevelopmentServer(
            spaBuilder, 
            new Uri(baseUri));
    }
        
    public static void UseProxyToSpaDevelopmentServer(
        this ISpaBuilder spaBuilder,
        Uri baseUri)
    {
        UseProxyToSpaDevelopmentServer(
            spaBuilder,
            () => Task.FromResult(baseUri));
    }
    
    public static void UseProxyToSpaDevelopmentServer(
        this ISpaBuilder spaBuilder,
        Func<Task<Uri>> baseUriTaskFactory)
    {
        // 解析（克隆）application builder
        var applicationBuilder = spaBuilder.ApplicationBuilder;
        // 解析 application stopping token (lifetime)
        var applicationStoppingToken = GetStoppingToken(applicationBuilder);
               
        // 使用 web socket 中间件（e.g. for augular）
        applicationBuilder.UseWebSockets();
        
        // 创建 never timeout http client
        var neverTimeOutHttpClient = SpaProxy.CreateHttpClientForProxy(Timeout.InfiniteTimeSpan);
        
        // Proxy all requests to the SPA development server
        applicationBuilder.Use(
            async (context, next) =>
            {
                var didProxyRequest = await SpaProxy.PerformProxyRequest(
                    context, 
                    neverTimeOutHttpClient, 
                    baseUriTaskFactory(), 
                    applicationStoppingToken,
                    proxy404s: true);
            });
    }
    
    private static CancellationToken GetStoppingToken(IApplicationBuilder appBuilder)
    {
        var applicationLifetime = appBuilder.ApplicationServices.GetRequiredService<IHostApplicationLifetime>();        
        return applicationLifetime.ApplicationStopping;
    }
}

```

###### 7.3.1.3 spa proxy

```c#
internal static class SpaProxy
{
    private const int DefaultWebSocketBufferSize = 4096;
    private const int StreamCopyBufferSize = 81920;
    
    // https://github.com/dotnet/aspnetcore/issues/16797
    private static readonly string[] NotForwardedHttpHeaders = new[] 
    { 
        "Connection" 
    };
    
    // Don't forward User-Agent/Accept because of https://github.com/aspnet/JavaScriptServices/issues/1469
    // Others just aren't applicable in proxy scenarios
    private static readonly string[] NotForwardedWebSocketHeaders = new[] 
    { 
        "Accept", 
        "Connection", 
        "Host", 
        "User-Agent", 
        "Upgrade", 
        "Sec-WebSocket-Key", 
        "Sec-WebSocket-Protocol", 
        "Sec-WebSocket-Version" 
    };
    
    public static HttpClient CreateHttpClientForProxy(TimeSpan requestTimeout)
    {
        var handler = new HttpClientHandler
        {
            AllowAutoRedirect = false,
            UseCookies = false,
        };
        
        return new HttpClient(handler)
        {
            Timeout = requestTimeout
        };
    }
    
    public static async Task<bool> PerformProxyRequest(
        HttpContext context,
        HttpClient httpClient,
        Task<Uri> baseUriTask,
        CancellationToken applicationStoppingToken,
        bool proxy404s)
    {
        // 创建 proxy cancellation token（by request abort & application stopping）
        var proxyCancellationToken = CancellationTokenSource.CreateLinkedTokenSource(
            context.RequestAborted,
            applicationStoppingToken).Token;
        
        // 解析 base uri
        var baseUri = await baseUriTask;
        // 解析 target uri (request uri on proxy server)
        var targetUri = new Uri(baseUri, context.Request.Path + context.Request.QueryString);
        
        try
        {
            // 如果是 web socket request
            if (context.WebSockets.IsWebSocketRequest)
            {
                await AcceptProxyWebSocketRequest(
                    context, 
                    ToWebSocketScheme(targetUri), 
                    proxyCancellationToken);
                
                return true;
            }
            // （否则），即不是 web socket request
            else
            {
                // 创建 proxy request message，
                using (var requestMessage = CreateProxyHttpRequest(context, targetUri))
                    // 发送 proxy request message
                    using (var responseMessage = await httpClient.SendAsync(
                        requestMessage,
                        HttpCompletionOption.ResponseHeadersRead,
                        proxyCancellationToken))
                {
                    // 如果没有标记 proxy 404s = true，
                    if (!proxy404s)
                    {
                        // 而 response status code 是 404，-> 返回 false
                        if (responseMessage.StatusCode == HttpStatusCode.NotFound)
                        {                            
                            return false;
                        }
                    }
                    
                    // 将 response message 注入原有 http context
                    await CopyProxyHttpResponse(
                        context, 
                        responseMessage, 
                        proxyCancellationToken);
        
                    return true;
                }
            }
        }
        catch (OperationCanceledException)
        {
            // If we're aborting because either the client disconnected, or the server is shutting down, 
            // don't treat this as an error.
            return true;
        }
        catch (IOException)
        {
            // This kind of exception can also occur if a proxy read/write gets interrupted due to the process shutting down.
            return true;
        }
        catch (HttpRequestException ex)
        {
            throw new HttpRequestException(
                $"Failed to proxy the request to {targetUri.ToString()}, because the request to " +                
                $"the proxy target failed. Check that the proxy target server is running and " +
                $"accepting requests to {baseUri.ToString()}.\n\n" +
                $"The underlying exception message was '{ex.Message}'." +
                $"Check the InnerException for more details.", 
                ex);
        }
    }
    
    // 1- 创建 proxy http request
    private static HttpRequestMessage CreateProxyHttpRequest(HttpContext context, Uri uri)
    {
        var request = context.Request;
        
        // 创建 request message（预结果）
        var requestMessage = new HttpRequestMessage();
        
        // 注入 body stream（request 不是 get、head、delete、trace）
        var requestMethod = request.Method;
        if (!HttpMethods.IsGet(requestMethod) &&
            !HttpMethods.IsHead(requestMethod) &&
            !HttpMethods.IsDelete(requestMethod) &&
            !HttpMethods.IsTrace(requestMethod))
        {
            var streamContent = new StreamContent(request.Body);
            requestMessage.Content = streamContent;
        }
        
        // 注入 request header
        foreach (var header in request.Headers)
        {
            // 如果是 not forwarded header，-> 下一个 header（忽略 this header）
            if (NotForwardedHttpHeaders.Contains(header.Key, StringComparer.OrdinalIgnoreCase))
            {
                continue;
            }
            
            if (!requestMessage.Headers.TryAddWithoutValidation(
                	header.Key, 
	                header.Value.ToArray()) && 
                requestMessage.Content != null)
            {
                requestMessage.Content?.Headers.TryAddWithoutValidation(
                    header.Key, 
                    header.Value.ToArray());
            }
        }
        
        requestMessage.Headers.Host = uri.Authority;
        requestMessage.RequestUri = uri;
        requestMessage.Method = new HttpMethod(request.Method);
        
        return requestMessage;
    }
    
    // 2- 注入 http response
    private static async Task CopyProxyHttpResponse(
        HttpContext context, 
        HttpResponseMessage responseMessage, 
        CancellationToken cancellationToken)
    {
        // 注入 status code
        context.Response.StatusCode = (int)responseMessage.StatusCode;
        
        // 将 response message header 注入 context response header
        foreach (var header in responseMessage.Headers)
        {
            context.Response.Headers[header.Key] = header.Value.ToArray();
        }
        // 将 response message content header 注入 context response header
        foreach (var header in responseMessage.Content.Headers)
        {
            context.Response.Headers[header.Key] = header.Value.ToArray();
        }
        
        // SendAsync removes chunking from the response. 
        // This removes the header so it doesn't expect a chunked response.
        context.Response.Headers.Remove("transfer-encoding");
        
        // 注入（复制）content stream
        using (var responseStream = await responseMessage.Content.ReadAsStreamAsync())
        {
            await responseStream.CopyToAsync(
                context.Response.Body, 
                StreamCopyBufferSize, 
                cancellationToken);
        }
    }
    
    // proxy web socket
    private static Uri ToWebSocketScheme(Uri uri)
    {
        if (uri == null)
        {
            throw new ArgumentNullException(nameof(uri));
        }
        
        var uriBuilder = new UriBuilder(uri);
        if (string.Equals(uriBuilder.Scheme, "https", StringComparison.OrdinalIgnoreCase))
        {
            uriBuilder.Scheme = "wss";
        }
        else if (string.Equals(uriBuilder.Scheme, "http", StringComparison.OrdinalIgnoreCase))
        {
            uriBuilder.Scheme = "ws";
        }
        
        return uriBuilder.Uri;
    }
    
    private static async Task<bool> AcceptProxyWebSocketRequest(
        HttpContext context, 
        Uri destinationUri, 
        CancellationToken cancellationToken)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }        
        if (destinationUri == null)
        {
            throw new ArgumentNullException(nameof(destinationUri));
        }
        
        using (var client = new ClientWebSocket())
        {
            foreach (var protocol in context.WebSockets.WebSocketRequestedProtocols)
            {
                client.Options.AddSubProtocol(protocol);
            }
            
            foreach (var headerEntry in context.Request.Headers)
            {
                if (!NotForwardedWebSocketHeaders.Contains(headerEntry.Key, StringComparer.OrdinalIgnoreCase))
                {
                    try
                    {
                        client.Options.SetRequestHeader(headerEntry.Key, headerEntry.Value);
                    }
                    catch (ArgumentException)
                    {
                        // On net461, certain header names are reserved and can't be set.
                        // We filter out the known ones via the test above, but there could be others arbitrarily set by the client. 
                        // It's not helpful to consider it an error, so just skip non-forwardable headers.
                        // The perf implications of handling this via a catch aren't an issue since this is a dev-time only feature.
                    }
                }
            }
            
            try
            {
                // Note that this is not really good enough to make Websockets work with Angular CLI middleware. For some reason, 
                // ConnectAsync takes over 1 second, on Windows, by which time the logic in SockJS has already timed out and made
                // it fall back on some other transport (xhr_streaming, usually). 
                // It's fine on Linux though, completing almost instantly.
                //
                // The slowness on Windows does not cause a problem though, because the transport fallback logic works correctly and 
                // doesn't surface any errors, but it would be better if ConnectAsync was fast enough and the initial Websocket 
                // transport could actually be used.
                await client.ConnectAsync(destinationUri, cancellationToken);
            }
            catch (WebSocketException)
            {
                context.Response.StatusCode = 400;
                return false;
            }
            
            using (var server = await context.WebSockets.AcceptWebSocketAsync(client.SubProtocol))
            {
                var bufferSize = DefaultWebSocketBufferSize;
                
                await Task.WhenAll(
                    PumpWebSocket(client, server, bufferSize, cancellationToken),
                    PumpWebSocket(server, client, bufferSize, cancellationToken));
            }
            
            return true;
        }
    }
            
    private static async Task PumpWebSocket(
        WebSocket source, 
        WebSocket destination, 
        int bufferSize, 
        CancellationToken cancellationToken)
    {
        if (bufferSize <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(bufferSize));
        }
        
        var buffer = new byte[bufferSize];
        
        while (true)
        {
            // Because WebSocket.ReceiveAsync doesn't work well with CancellationToken (it doesn't actually exit when 
            // the token notifies, at least not in the 'server' case), use polling. The perf might not be ideal, 
            // but this is a dev-time feature only.
            var resultTask = source.ReceiveAsync(
                new ArraySegment<byte>(buffer), 
                cancellationToken);
            
            while (true)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    return;
                }
                
                if (resultTask.IsCompleted)
                {
                    break;
                }
                
                await Task.Delay(100);
            }
            
            var result = resultTask.Result; 
            if (result.MessageType == WebSocketMessageType.Close)
            {
                if (destination.State == WebSocketState.Open || 
                    destination.State == WebSocketState.CloseReceived)
                {
                    await destination.CloseOutputAsync(
                        source.CloseStatus!.Value, 
                        source.CloseStatusDescription, 
                        cancellationToken);
                }
                
                return;
            }
            
            await destination.SendAsync(
                new ArraySegment<byte>(buffer, 0, result.Count), 
                result.MessageType, 
                result.EndOfMessage, 
                cancellationToken);
        }
    }
}

```

##### 7.3.2 node script runner

```c#
internal class NodeScriptRunner : IDisposable
{
    private Process? _npmProcess;
    public EventedStreamReader StdOut { get; }
    public EventedStreamReader StdErr { get; }
    
    private static Regex AnsiColorRegex = 
        new Regex("\x001b\\[[0-9;]*m", gexOptions.None, TimeSpan.FromSeconds(1));
    
    public NodeScriptRunner(
        string workingDirectory, 
        string scriptName, 
        string? arguments, 
        IDictionary<string, string>? envVars, 
        string pkgManagerCommand, 
        DiagnosticSource diagnosticSource, 
        CancellationToken applicationStoppingToken)
    {
        if (string.IsNullOrEmpty(workingDirectory))
        {
            throw new ArgumentException("Cannot be null or empty.", nameof(workingDirectory));
        }        
        if (string.IsNullOrEmpty(scriptName))
        {
            throw new ArgumentException("Cannot be null or empty.", nameof(scriptName));
        }        
        if (string.IsNullOrEmpty(pkgManagerCommand))
        {
            throw new ArgumentException("Cannot be null or empty.", nameof(pkgManagerCommand));
        }
        
        var exeToRun = pkgManagerCommand;
        var completeArguments = $"run {scriptName} -- {arguments ?? string.Empty}";
        if (OperatingSystem.IsWindows())
        {
            // On Windows, the node executable is a .cmd file, so it can't be executed directly 
            // (except with UseShellExecute=true, but that's no good, because it prevents capturing stdio). 
            // So we need to invoke it via "cmd /c".
            exeToRun = "cmd";
            completeArguments = $"/c {pkgManagerCommand} {completeArguments}";
        }
        
        var processStartInfo = new ProcessStartInfo(exeToRun)
        {
            Arguments = completeArguments,
            UseShellExecute = false,
            RedirectStandardInput = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            WorkingDirectory = workingDirectory
        };
        
        if (envVars != null)
        {
            foreach (var keyValuePair in envVars)
            {
                processStartInfo.Environment[keyValuePair.Key] = keyValuePair.Value;
            }
        }
        
        _npmProcess = LaunchNodeProcess(processStartInfo, pkgManagerCommand);
        StdOut = new EventedStreamReader(_npmProcess.StandardOutput);
        StdErr = new EventedStreamReader(_npmProcess.StandardError);
        
        applicationStoppingToken.Register(((IDisposable)this).Dispose);
        
        if (diagnosticSource.IsEnabled("Microsoft.AspNetCore.NodeServices.Npm.NpmStarted"))
        {
            diagnosticSource.Write(
                "Microsoft.AspNetCore.NodeServices.Npm.NpmStarted",
                new
                {
                    processStartInfo = processStartInfo,
                    process = _npmProcess
                });
        }
    }
    
    public void AttachToLogger(ILogger logger)
    {
        // When the node task emits complete lines, pass them through to the real logger
        StdOut.OnReceivedLine += line =>
        {
            if (!string.IsNullOrWhiteSpace(line))
            {
                // Node tasks commonly emit ANSI colors, but it wouldn't make sense to forward
                // those to loggers (because a logger isn't necessarily any kind of terminal)
                logger.LogInformation(StripAnsiColors(line));
            }
        };
        
        StdErr.OnReceivedLine += line =>
        {
            if (!string.IsNullOrWhiteSpace(line))
            {
                logger.LogError(StripAnsiColors(line));
            }
        };
        
        // But when it emits incomplete lines, assume this is progress information and
        // hence just pass it through to StdOut regardless of logger config.
        StdErr.OnReceivedChunk += chunk =>
        {
            Debug.Assert(chunk.Array != null);
            
            var containsNewline = 
                Array.IndexOf(
	                chunk.Array, 
    	            '\n', 
        	        chunk.Offset, 
            	    chunk.Count) >= 0;
            
            if (!containsNewline)
            {
                Console.Write(chunk.Array, chunk.Offset, chunk.Count);
            }
        };
    }
    
    private static string StripAnsiColors(string line) => AnsiColorRegex.Replace(line, string.Empty);
    
    private static Process LaunchNodeProcess(
        ProcessStartInfo startInfo, 
        string commandName)
    {
        try
        {
            var process = Process.Start(startInfo)!;
            
            // See equivalent comment in OutOfProcessNodeInstance.cs for why
            process.EnableRaisingEvents = true;
            
            return process;
        }
        catch (Exception ex)
        {
            var message = 
                $"Failed to start '{commandName}'. To resolve this:.\n\n" + 
                $"[1] Ensure that '{commandName}' is installed and can be found in one of the PATH directories.\n" + 
                $"    Current PATH enviroment variable is: {Environment.GetEnvironmentVariable("PATH") }\n" + 
                "    Make sure the executable is in one of those directories, or update your PATH.\n\n" + 
                "[2] See the InnerException for further details of the cause.";
            throw new InvalidOperationException(message, ex);
        }
    }
    
    void IDisposable.Dispose()
    {
        if (_npmProcess != null && !_npmProcess.HasExited)
        {
            _npmProcess.Kill(entireProcessTree: true);
            _npmProcess = null;
        }
    }
}

```

##### 7.3.3 use angular cli server

```c#
public static class AngularCliMiddlewareExtensions
{        
    // This feature should only be used in development. 
    // For production deployments, be sure not to enable the Angular CLI server.    
    public static void UseAngularCliServer(
        this ISpaBuilder spaBuilder,
        string npmScript)
    {
        if (spaBuilder == null)
        {
            throw new ArgumentNullException(nameof(spaBuilder));
        }
        
        var spaOptions = spaBuilder.Options;
        
        if (string.IsNullOrEmpty(spaOptions.SourcePath))
        {
            throw new InvalidOperationException(
                $"To use {nameof(UseAngularCliServer)}, you must supply a non-empty value for the {nameof(SpaOptions.SourcePath)} 
                "property of {nameof(SpaOptions)} when calling {nameof(SpaApplicationBuilderExtensions.UseSpa)}.");
        }
        
        AngularCliMiddleware.Attach(spaBuilder, npmScript);
    }
}

```

###### 7.3.3.1 angular cli middleware

```c#
internal static class AngularCliMiddleware
{
    private const string LogCategoryName = "Microsoft.AspNetCore.SpaServices";
    
    // This is a development-time only feature, so a very long timeout is fine
    private static TimeSpan RegexMatchTimeout = TimeSpan.FromSeconds(5); 

    public static void Attach(ISpaBuilder spaBuilder, string scriptName)
    {
        var pkgManagerCommand = spaBuilder.Options.PackageManagerCommand;
        var sourcePath = spaBuilder.Options.SourcePath;
        var devServerPort = spaBuilder.Options.DevServerPort;
        
        if (string.IsNullOrEmpty(sourcePath))
        {
            throw new ArgumentException("Cannot be null or empty", nameof(sourcePath));
        }        
        if (string.IsNullOrEmpty(scriptName))
        {
            throw new ArgumentException("Cannot be null or empty", nameof(scriptName));
        }
        
        // Start Angular CLI and attach to middleware pipeline
        var appBuilder = spaBuilder.ApplicationBuilder;
        var applicationStoppingToken = appBuilder.ApplicationServices
            								  .GetRequiredService<IHostApplicationLifetime>()
            								  .ApplicationStopping;
        var logger = LoggerFinder.GetOrCreateLogger(appBuilder, LogCategoryName);
        var diagnosticSource = appBuilder.ApplicationServices.GetRequiredService<DiagnosticSource>();
        var angularCliServerInfoTask = StartAngularCliServerAsync(
            sourcePath, 
            scriptName, 
            pkgManagerCommand, 
            devServerPort, 
            logger, 
            diagnosticSource, 
            applicationStoppingToken);
        
        SpaProxyingExtensions.UseProxyToSpaDevelopmentServer(
            spaBuilder, 
            () =>
            	{
                    // On each request, we create a separate startup task with its own timeout. 
                    // That way, even if the first request times out, subsequent requests could still work.
                    var timeout = spaBuilder.Options.StartupTimeout;
                    return angularCliServerInfoTask.WithTimeout(
                        timeout,      
                        $"The Angular CLI process did not start listening for requests within the timeout period of" +
                        "{timeout.TotalSeconds} seconds. Check the log output for error information.");
                });
    }
    
    private static async Task<Uri> StartAngularCliServerAsync(
        string sourcePath, 
        string scriptName, 
        string pkgManagerCommand, 
        int portNumber, 
        ILogger logger, 
        DiagnosticSource diagnosticSource, 
        CancellationToken applicationStoppingToken)
    {
        if (portNumber == default(int))
        {
            portNumber = TcpPortFinder.FindAvailablePort();
        }
        
        logger.LogInformation($"Starting @angular/cli on port {portNumber}...");
        
        var scriptRunner = new NodeScriptRunner(
            sourcePath, 
            scriptName, 
            $"--port {portNumber}", 
            null, 
            pkgManagerCommand, 
            diagnosticSource, 
            applicationStoppingToken);
        
        scriptRunner.AttachToLogger(logger);
        
        Match openBrowserLine;
        
        using (var stdErrReader = new EventedStreamStringReader(scriptRunner.StdErr))
        {
            try
            {
                openBrowserLine = await scriptRunner.StdOut.WaitForMatch(
                    new Regex("open your browser on (http\\S+)", RegexOptions.None, RegexMatchTimeout));
            }
            catch (EndOfStreamException ex)
            {
                throw new InvalidOperationException(
                    $"The {pkgManagerCommand} script '{scriptName}' exited without indicating that the " +                    
                    $"Angular CLI was listening for requests. The error output was: {stdErrReader.ReadAsString()}", 
                    ex);
            }
        }
        
        var uri = new Uri(openBrowserLine.Groups[1].Value);
        
        // Even after the Angular CLI claims to be listening for requests, there's a short period where it will give an error 
        // if you make a request too quickly
        await WaitForAngularCliServerToAcceptRequests(uri);
        
        return uri;
    }
    
    private static async Task WaitForAngularCliServerToAcceptRequests(Uri cliServerUri)
    {
        // To determine when it's actually ready, try making HEAD requests to '/'. If it
        // produces any HTTP response (even if it's 404) then it's ready. If it rejects the
        // connection then it's not ready. We keep trying forever because this is dev-mode
        // only, and only a single startup attempt will be made, and there's a further level
        // of timeouts enforced on a per-request basis.
        var timeoutMilliseconds = 1000;
        using (var client = new HttpClient())
        {
            while (true)
            {
                try
                {
                    // If we get any HTTP response, the CLI server is ready
                    await client.SendAsync(
                        new HttpRequestMessage(HttpMethod.Head, cliServerUri),
                        new CancellationTokenSource(timeoutMilliseconds).Token);
                    return;
                }
                catch (Exception)
                {
                    await Task.Delay(500);
                    
                    // Depending on the host's networking configuration, the requests 
                    // can take a while to go through, most likely due to the time spent 
                    // resolving 'localhost'.
                    // Each time we have a failure, allow a bit longer next time (up to a 
                    // maximum).
                    // This only influences the time until we regard the dev server as 
                    // 'ready', so it doesn't affect the runtime perf (even in dev mode) 
                    // once the first connection is made.
                    // Resolves https://github.com/aspnet/JavaScriptServices/issues/1611
                    if (timeoutMilliseconds < 10000)
                    {
                        timeoutMilliseconds += 3000;
                    }
                }
            }
        }
    }
}

```

##### 7.3.4 use react server

```c#
public static class ReactDevelopmentServerMiddlewareExtensions
{   
    // Handles requests by passing them through to an instance of the create-react-app 
    // server.
    // This means you can always serve up-to-date CLI-built resources without having
    // to run the create-react-app server manually.
    //
    // This feature should only be used in development. For production deployments, be
    // sure not to enable the create-react-app server.
    
    public static void UseReactDevelopmentServer(
        this ISpaBuilder spaBuilder,
        string npmScript)
    {
        if (spaBuilder == null)
        {
            throw new ArgumentNullException(nameof(spaBuilder));
        }
        
        var spaOptions = spaBuilder.Options;
        
        if (string.IsNullOrEmpty(spaOptions.SourcePath))
        {
            throw new InvalidOperationException(
                $"To use {nameof(UseReactDevelopmentServer)}, you must supply a non-empty 
                "value for the {nameof(SpaOptions.SourcePath)} property of 
                "{nameof(SpaOptions)} when calling 
                "{nameof(SpaApplicationBuilderExtensions.UseSpa)}.");
        }
        
        ReactDevelopmentServerMiddleware.Attach(spaBuilder, npmScript);
    }
}

```

###### 7.3.4.1 react server middleware

```c#
internal static class ReactDevelopmentServerMiddleware
{
    private const string LogCategoryName = "Microsoft.AspNetCore.SpaServices";
    
    // This is a development-time only feature, so a very long timeout is fine
    private static TimeSpan RegexMatchTimeout = TimeSpan.FromSeconds(5); 

    public static void Attach(
        ISpaBuilder spaBuilder,
        string scriptName)
    {
        var pkgManagerCommand = spaBuilder.Options.PackageManagerCommand;
        var sourcePath = spaBuilder.Options.SourcePath;
        var devServerPort = spaBuilder.Options.DevServerPort;
        if (string.IsNullOrEmpty(sourcePath))
        {
            throw new ArgumentException("Cannot be null or empty", nameof(sourcePath));
        }
        
        if (string.IsNullOrEmpty(scriptName))
        {
            throw new ArgumentException("Cannot be null or empty", nameof(scriptName));
        }
        
        // Start create-react-app and attach to middleware pipeline
        var appBuilder = spaBuilder.ApplicationBuilder;
        var applicationStoppingToken = 
            appBuilder.ApplicationServices
            		  .GetRequiredService<IHostApplicationLifetime>()
            		  .ApplicationStopping;
        var logger = LoggerFinder.GetOrCreateLogger(appBuilder, LogCategoryName);
        var diagnosticSource = 
            appBuilder.ApplicationServices
            		  .GetRequiredService<DiagnosticSource>();
        var portTask = StartCreateReactAppServerAsync(
            sourcePath, 
            scriptName, 
            pkgManagerCommand, 
            devServerPort, 
            logger, 
            diagnosticSource, 
            applicationStoppingToken);

        // Everything we proxy is hardcoded to target http://localhost because:
        // - the requests are always from the local machine (we're not accepting remote
        //   requests that go directly to the create-react-app server)
        // - given that, there's no reason to use https, and we couldn't even if we
        //   wanted to, because in general the create-react-app server has no certificate
        var targetUriTask = portTask.ContinueWith(task => new UriBuilder("http", "localhost", task.Result).Uri);
        
        SpaProxyingExtensions.UseProxyToSpaDevelopmentServer(
            spaBuilder, 
            () =>
            	{
                	// On each request, we create a separate startup task with its 
                    // own timeout. 
                    // That way, even if the first request times out, subsequent requests 
                    // could still work.
                    var timeout = spaBuilder.Options
                        					.StartupTimeout;
                    return targetUriTask.WithTimeout(timeout,
                    	$"The create-react-app server did not start listening for requests " +
                    	$"within the timeout period of {timeout.Seconds} seconds. " +
	                    $"Check the log output for error information.");
                });
    }
    
    private static async Task<int> StartCreateReactAppServerAsync(
        string sourcePath, 
        string scriptName, 
        string pkgManagerCommand, 
        int portNumber, 
        ILogger logger, 
        DiagnosticSource diagnosticSource, 
        CancellationToken applicationStoppingToken)
    {
        if (portNumber == default(int))
        {
            portNumber = TcpPortFinder.FindAvailablePort();
        }
        logger.LogInformation($"Starting create-react-app server on port {portNumber}...");
        
        var envVars = new Dictionary<string, string>
        {
            { "PORT", portNumber.ToString(CultureInfo.InvariantCulture) },
            // We don't want create-react-app to open its own extra browser window 
            // pointing to the internal dev server port
            { "BROWSER", "none" }, 
        };
        var scriptRunner = new NodeScriptRunner(
            sourcePath, 
            scriptName, 
            null, 
            envVars, 
            pkgManagerCommand, 
            diagnosticSource, 
            applicationStoppingToken);
        
        scriptRunner.AttachToLogger(logger);
        
        using (var stdErrReader = new EventedStreamStringReader(scriptRunner.StdErr))
        {
            try
            {
                // Although the React dev server may eventually tell us the URL it's 
                // listening on, it doesn't do so until it's finished compiling, and even 
                // then only if there were no compiler warnings. So instead of waiting for
                // that, consider it ready as soon as it starts listening for requests.
                await scriptRunner.StdOut.WaitForMatch(
                    new Regex("Starting the development server", RegexOptions.None, RegexMatchTimeout));
            }
            catch (EndOfStreamException ex)
            {
                throw new InvalidOperationException(
                    $"The {pkgManagerCommand} script '{scriptName}' exited without 
                    "indicating that the " +
                    $"create-react-app server was listening for requests. The error 
                    "output was: " +
                    $"{stdErrReader.ReadAsString()}", ex);
            }
        }
        
        return portNumber;
    }
}

```



