## middleware in http request



### 1. about



### 2. instead by nginx

#### 2.1 rewrite

##### 2.1.1 rules

```c#
// 接口
public interface IRule
{        
    void ApplyRule(RewriteContext context);
}

// rewrite context
public class RewriteContext
{   
    public HttpContext HttpContext { get; set; } = default!;    
    public IFileProvider StaticFileProvider { get; set; } = default!;        
    public ILogger Logger { get; set; } = NullLogger.Instance;        
    public RuleResult Result { get; set; }    
    internal StringBuilder Builder { get; set; } = new StringBuilder(64);
}

// rule result 枚举
public enum RuleResult
{   
    // Default value, continue applying rules.    
    ContinueRules,   
    // The rule ended the request by providing a response.   
    EndResponse,   
    // Stop applying rules and send context to the next middleware    
    SkipRemainingRules
}

```

##### 2.1.2 rewrite options

```c#
public class RewriteOptions
{    
    public IList<IRule> Rules { get; } = new List<IRule>();        
    public IFileProvider StaticFileProvider { get; set; } = default!;
}

```

###### 2.1.2.1 add rule

```c#
public static class RewriteOptionsExtensions
{
    // add by irule 实例
    public static RewriteOptions Add(this RewriteOptions options, IRule rule)
    {
        options.Rules.Add(rule);
        return options;
    }
         
    // add by action(rewrite context) 委托
    public static RewriteOptions Add(this RewriteOptions options, Action<RewriteContext> applyRule)
    {
        options.Rules.Add(new DelegateRule(applyRule));
        return options;
    }
}

```

```c#
// delegate rule
internal class DelegateRule : IRule
{
    private readonly Action<RewriteContext> _onApplyRule;
    
    public DelegateRule(Action<RewriteContext> onApplyRule)
    {
        _onApplyRule = onApplyRule;
    }
    
    public void ApplyRule(RewriteContext context) => _onApplyRule(context);
}

```

###### 2.1.2.2 add rewrite rule

```c#
public static class RewriteOptionsExtensions
{
    public static RewriteOptions AddRewrite(
        this RewriteOptions options, 
        string regex, 
        string replacement, 
        bool skipRemainingRules)
    {
        options.Rules.Add(new RewriteRule(regex, replacement, skipRemainingRules));
        return options;
    }
}

```

```c#
// rewrite rule
internal class RewriteRule : IRule
{
    private readonly TimeSpan _regexTimeout = TimeSpan.FromSeconds(1);
    
    public Regex InitialMatch { get; }
    public string Replacement { get; }
    public bool StopProcessing { get; }
    
    public RewriteRule(string regex, string replacement, bool stopProcessing)
    {
        if (string.IsNullOrEmpty(regex))
        {
            throw new ArgumentException(nameof(regex));
        }        
        if (string.IsNullOrEmpty(replacement))
        {
            throw new ArgumentException(nameof(replacement));
        }
        
        // 由传入的 regex (string) 创建 regex 表达式        
        InitialMatch = new Regex(
            regex, 
            RegexOptions.Compiled | RegexOptions.CultureInvariant, 
            _regexTimeout);
        // 注入 replace string（包含 $n 参数的模板）
        Replacement = replacement;
        // 标记 stop remaining rules
        StopProcessing = stopProcessing;
    }
    
    public virtual void ApplyRule(RewriteContext context)
    {
        // 解析 request path (relative path)
        var path = context.HttpContext.Request.Path;
        
        // regex match result（预结果）
        Match initMatchResults;
                
        if (path == PathString.Empty)
        {
            // request path = emtpy, -> 调用 regex(request path)
            initMatchResults = InitialMatch.Match(path.ToString());
        }
        else
        {
            // request path != empty, -> 调用 regex(request path.substring)
            initMatchResults = InitialMatch.Match(path.ToString().Substring(1));
        }
        
        // 如果 request path 匹配 regex，（即 match result = success）
        if (initMatchResults.Success)
        {
            // 使用 regex result 的模板替换 replace string，得到 rewrite 之后的结果字符串 result
            var result = initMatchResults.Result(Replacement);
            // 获取 http context 中 request 的引用
            var request = context.HttpContext.Request;
            
            // 如果标记了 stop processing，-> 将 rewrite context 的 result 置为 skip remaining rules result
            if (StopProcessing)
            {
                context.Result = RuleResult.SkipRemainingRules;
            }
            
            // 如果 rewrite result (string) 为空，-> rewrite result = "/"
            if (string.IsNullOrEmpty(result))
            {
                result = "/";
            }
            
            // 如果 rewrite result (string) 包含 scheme delimiter (":")，
            if (result.IndexOf(Uri.SchemeDelimiter, StringComparison.Ordinal) >= 0)
            {
                // 从 rewrite result 解析 scheme、host、path string、query、fragment
                string scheme;
                HostString host;
                PathString pathString;
                QueryString query;
                FragmentString fragment;                
                UriHelper.FromAbsolute(result, out scheme, out host, out pathString, out query, out fragment);
                
                // 将解析结果注入 http context request
                request.Scheme = scheme;
                request.Host = host;
                request.Path = pathString;
                request.QueryString = query.Add(request.QueryString);
            }
            // （否则，即 rewrite result string 不包含 ":"），
            else
            {
                var split = result.IndexOf('?');
                
                // 如果 rewrite result 包含 “？”（包含查询表达式）
                if (split >= 0)
                {
                    // 截取“？”之前的部分（不包含 query string）
                    var newPath = result.Substring(0, split);
                    
                    // 如果截取部分以 “/” 开头，-> 由截取部分创建 path，注入 http context request
                    if (newPath[0] == '/')
                    {
                        request.Path = PathString.FromUriComponent(newPath);
                    }
                    // 否则，由 “/” + 截取部分创建 path，注入 http context request
                    else
                    {
                        request.Path = PathString.FromUriComponent('/' + newPath);
                    }
                    
                    // 剩余部分创建为 query string，注入 http context request
                    request.QueryString = request.QueryString.Add(
                        QueryString.FromUriComponent(result.Substring(split)));
                }
                // （由上），rewrite result 不包含 “？”
                else
                {
                    // 如果 rewrite result 以 “/” 开头，由 rewrite result 创建 path， 注入 http context request
                    if (result[0] == '/')
                    {
                        request.Path = PathString.FromUriComponent(result);
                    }
                    // 否则，由 “/” + rewrite result 创建 path，注入 http context request
                    else
                    {
                        request.Path = PathString.FromUriComponent('/' + result);
                    }
                }
            }
            
            context.Logger.RewrittenRequest(result);
        }
    }
}

```

###### 2.1.2.3 add redirect rule

```c#
public static class RewriteOptionsExtensions
{
    public static RewriteOptions AddRedirect(
        this RewriteOptions options, 
        string regex, string replacement)
    {
        return AddRedirect(
            options, 
            regex, replacement, 
            // default status code = 302
            statusCode: StatusCodes.Status302Found);
    }
        
    public static RewriteOptions AddRedirect(
        this RewriteOptions options, 
        string regex, string replacement, int statusCode)
    {
        options.Rules.Add(new RedirectRule(regex, replacement, statusCode));
        return options;
    }
}

```

```c#
internal class RedirectRule : IRule
{
    private readonly TimeSpan _regexTimeout = TimeSpan.FromSeconds(1);
    
    public Regex InitialMatch { get; }
    public string Replacement { get; }
    public int StatusCode { get; }
    
    public RedirectRule(string regex, string replacement, int statusCode)
    {
        if (string.IsNullOrEmpty(regex))
        {
            throw new ArgumentException(nameof(regex));
        }        
        if (string.IsNullOrEmpty(replacement))
        {
            throw new ArgumentException(nameof(replacement));
        }
        
        // 注入 regex 表达式并转换为 regex
        InitialMatch = new Regex(regex, RegexOptions.Compiled | RegexOptions.CultureInvariant, _regexTimeout);
        // 注入 replace string（包含 $n 参数的模板）
        Replacement = replacement;
        // 注入希望 server 返回的 status code
        StatusCode = statusCode;
    }

    public virtual void ApplyRule(RewriteContext context)
    {
        // 获取 http context request 引用
        var request = context.HttpContext.Request;
        // 解析 request path（relative path）
        var path = request.Path;
        // 解析 request path base（use path base 方法设定）
        var pathBase = request.PathBase;
        
        // regex match result（预结果）
        Match initMatchResults;
        
        // 如果 request path 没有 value（request path = empty），-> 调用 regex(request path)
        if (!path.HasValue)
        {            
            initMatchResults = InitialMatch.Match(string.Empty);
        }
        // 否则，request path 由 value，-> 调用 regex(request path.substring)
        else
        {            
            initMatchResults = InitialMatch.Match(path.ToString().Substring(1));
        }
                
        // 如果 request path 匹配 regex（regex match result = success）
        if (initMatchResults.Success)
        {
            // 用 regex result 替换 replace string（得到 rewrite 之后的结果字符串）
            var newPath = initMatchResults.Result(Replacement);
            
            // 获取 http context response 引用
            var response = context.HttpContext.Response;            
            // 设置 http context response 的 status code（注入的 status code）
            response.StatusCode = StatusCode;
            // 设置 rewrite context result 为 end response
            context.Result = RuleResult.EndResponse;
            
            string encodedPath;
            
            // 如果 new path 为空
            if (string.IsNullOrEmpty(newPath))
            {
                // 解析 path base，如果也为空，-> "/"
                encodedPath = pathBase.HasValue ? pathBase.Value : "/";
            }
            // （否则），即 new path 不为空
            else
            {
                var host = default(HostString);                
                var schemeSplit = newPath.IndexOf(Uri.SchemeDelimiter, StringComparison.Ordinal);
                
                //
                if (schemeSplit >= 0)
                {
                    schemeSplit += Uri.SchemeDelimiter.Length;
                    var pathSplit = newPath.IndexOf('/', schemeSplit);
                    
                    if (pathSplit == -1)
                    {
                        host = new HostString(newPath.Substring(schemeSplit));
                        newPath = "/";
                    }
                    else
                    {
                        host = new HostString(newPath.Substring(schemeSplit, pathSplit - schemeSplit));
                        newPath = newPath.Substring(pathSplit);
                    }
                }
                
                if (newPath[0] != '/')
                {
                    newPath = '/' + newPath;
                }
                
                var resolvedQuery = request.QueryString;
                var resolvedPath = newPath;
                var querySplit = newPath.IndexOf('?');
                if (querySplit >= 0)
                {
                    resolvedQuery = request.QueryString.Add(QueryString.FromUriComponent(newPath.Substring(querySplit)));
                    resolvedPath = newPath.Substring(0, querySplit);
                }
                
                encodedPath = host.HasValue
                    ? UriHelper.BuildAbsolute(request.Scheme, host, pathBase, resolvedPath, resolvedQuery, default)
                    : UriHelper.BuildRelative(pathBase, resolvedPath, resolvedQuery, default);
            }
            
            // not using the HttpContext.Response.redirect here because status codes may be 301, 302, 307, 308
            response.Headers.Location = encodedPath;
            
            context.Logger.RedirectedRequest(newPath);
        }
    }
}

```

###### 2.1.2.4 redirect to www helper

```c#
internal static class RedirectToWwwHelper
{
    private const string Localhost = "localhost";
    
    public static bool IsHostInDomains(HttpRequest request, string[]? domains)
    {
        // 如果 request host 是 localhost，-> 返回 false
        if (request.Host.Host.Equals(Localhost, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }
        
        // 如果 domains 不为空，遍历 domains
        // 如果 request host 不包含在 domains，-> 返回 false
        if (domains != null)
        {
            var isHostInDomains = false;
            
            foreach (var domain in domains)
            {
                if (domain.Equals(request.Host.Host, StringComparison.OrdinalIgnoreCase))
                {
                    isHostInDomains = true;
                    break;
                }
            }
            
            if (!isHostInDomains)
            {
                return false;
            }
        }
        
        // （否则，即 domains 为空），-> 返回 true
        return true;
    }
    
    // 设置 redirect path (location)
    public static void SetRedirect(RewriteContext context, HostString newHost, int statusCode)
    {
        var request = context.HttpContext.Request;
        var response = context.HttpContext.Response;
        
        // 创建 redirect 的 绝对路径 (new host)
        var newUrl = UriHelper.BuildAbsolute(
            request.Scheme,
            newHost,
            request.PathBase,
            request.Path,
            request.QueryString);
        
        response.StatusCode = statusCode;
        response.Headers.Location = newUrl;
        context.Result = RuleResult.EndResponse;
    }
}

```

###### 2.1.2.5 add redirect to www rule

```c#
public static class RewriteOptionsExtensions
{            
    public static RewriteOptions AddRedirectToWww(
        this RewriteOptions options, 
        int statusCode)
    {
        options.Rules.Add(new RedirectToWwwRule(statusCode));
        return options;
    }
        
    public static RewriteOptions AddRedirectToWww(
        this RewriteOptions options, 
        int statusCode, 
        params string[] domains)
    {
        options.Rules.Add(new RedirectToWwwRule(statusCode, domains));
        return options;
    }
        
    // temporary, statue code = 307
    public static RewriteOptions AddRedirectToWww(this RewriteOptions options)
    {
        return AddRedirectToWww(options, statusCode: StatusCodes.Status307TemporaryRedirect);
    }
        
    public static RewriteOptions AddRedirectToWww(this RewriteOptions options, params string[] domains)
    {
        return AddRedirectToWww(options, statusCode: StatusCodes.Status307TemporaryRedirect, domains);
    }
        
    // permanent, statue code = 308
    public static RewriteOptions AddRedirectToWwwPermanent(this RewriteOptions options)
    {
        return AddRedirectToWww(options, statusCode: StatusCodes.Status308PermanentRedirect);
    }
        
    public static RewriteOptions AddRedirectToWwwPermanent(this RewriteOptions options, params string[] domains)
    {
        return AddRedirectToWww(options, statusCode: StatusCodes.Status308PermanentRedirect, domains);
    }
}

```

```c#
internal class RedirectToWwwRule : IRule
{
    private const string WwwDot = "www.";
    
    private readonly string[]? _domains;
    private readonly int _statusCode;
    
    public RedirectToWwwRule(int statusCode)
    {
        // 注入 status code
        _statusCode = statusCode;
    }
    
    public RedirectToWwwRule(int statusCode, params string[] domains)
    {
        if (domains == null)
        {
            throw new ArgumentNullException(nameof(domains));
        }        
        if (domains.Length < 1)
        {
            throw new ArgumentException($"One or more {nameof(domains)} must be provided.");
        }
        
        // 注入 domain 集合
        _domains = domains;
        // 注入希望 server 返回的 status code
        _statusCode = statusCode;
    }

    public void ApplyRule(RewriteContext context)
    {
        // 获取 http context request 引用
        var req = context.HttpContext.Request;
        // 判断 request host 是否在 domains
        var hostInDomains = RedirectToWwwHelper.IsHostInDomains(req, _domains);
        
        // 如果 request host 不在 domains，-> 返回（不会 redirect）
        if (!hostInDomains)
        {           
            context.Result = RuleResult.ContinueRules;
            return;
        }
        
        // （由上，request host 在 domains）
        
        // 如果 request host 以 "www." 开头，（已经是 www. 开头，不处理）
        if (req.Host.Value.StartsWith(WwwDot, StringComparison.OrdinalIgnoreCase))
        {
            // 将 rewrite context 的 result 置为 continue rules，返回
            context.Result = RuleResult.ContinueRules;
            return;
        }
        
        // 重定向 -> www. + origin host，with （注入的）statues code
        RedirectToWwwHelper.SetRedirect(
            context,
            new HostString($"www.{context.HttpContext.Request.Host.Value}"),
            _statusCode);
        
        context.Logger.RedirectedToWww();
    }
}

```

###### 2.1.2.6 add redirect to non www rule

```c#
public static class RewriteOptionsExtensions
{
    public static RewriteOptions AddRedirectToNonWww(
        this RewriteOptions options, 
        int statusCode)
    {
        options.Rules.Add(new RedirectToNonWwwRule(statusCode));
        return options;
    }
        
    public static RewriteOptions AddRedirectToNonWww(
        this RewriteOptions options, 
        int statusCode, 
        params string[] domains)
    {
        options.Rules.Add(new RedirectToNonWwwRule(statusCode, domains));
        return options;
    }
           
    // temporary, status code = 307
    public static RewriteOptions AddRedirectToNonWww(this RewriteOptions options)
    {
        return AddRedirectToNonWww(options, statusCode: StatusCodes.Status307TemporaryRedirect);
    }
        
    public static RewriteOptions AddRedirectToNonWww(this RewriteOptions options, params string[] domains)
    {
        return AddRedirectToNonWww(options, statusCode: StatusCodes.Status307TemporaryRedirect, domains);
    }    
    
    // permanent, status code = 308
    public static RewriteOptions AddRedirectToNonWwwPermanent(this RewriteOptions options)
    {
        return AddRedirectToNonWww(options, statusCode: StatusCodes.Status308PermanentRedirect);
    }
        
    public static RewriteOptions AddRedirectToNonWwwPermanent(this RewriteOptions options, params string[] domains)
    {
        return AddRedirectToNonWww(options, statusCode: StatusCodes.Status308PermanentRedirect, domains);
    }            
}

```

```c#
internal class RedirectToNonWwwRule : IRule
{
    private const string WwwDot = "www.";
    
    private readonly string[]? _domains;
    private readonly int _statusCode;
    
    public RedirectToNonWwwRule(int statusCode)
    {
        // 注入希望 server 返回的 status code
        _statusCode = statusCode;
    }
    
    public RedirectToNonWwwRule(int statusCode, params string[] domains)
    {
        if (domains == null)
        {
            throw new ArgumentNullException(nameof(domains));
        }        
        if (domains.Length < 1)
        {
            throw new ArgumentException($"One or more {nameof(domains)} must be provided.");
        }
        
        // 注入 domains 集合
        _domains = domains;
        // 注入希望 server 返回的 status code
        _statusCode = statusCode;
    }
    
    public void ApplyRule(RewriteContext context)
    {
        // 获取 http context request 引用
        var request = context.HttpContext.Request;
        // 判读 request host 是否在 domains
        var hostInDomains = RedirectToWwwHelper.IsHostInDomains(request, _domains);
        
        // 如果 request host 不在 domains，-> 返回（不会 redirect）
        if (!hostInDomains)
        {
            context.Result = RuleResult.ContinueRules;
            return;
        }
        
        // 如果 request host 不是以 "www." 开头，（已经不是 www. 开头，不处理）
        if (!request.Host.Value.StartsWith(WwwDot, StringComparison.OrdinalIgnoreCase))
        {
            // 将 rewrite context 的 result 置为 continue rules，返回
            context.Result = RuleResult.ContinueRules;
            return;
        }
        
        // 重定向 -> 不带 "www." 的 host，with （注入的）statues code
        RedirectToWwwHelper.SetRedirect(
            context,
            new HostString(request.Host.Value.Substring(4)), // We verified the hostname begins with "www." already.
            _statusCode);
        
        context.Logger.RedirectedToNonWww();
    }
}

```

###### 2.1.2.6 add redirect to https rule

```c#
public static class RewriteOptionsExtensions
{            
    public static RewriteOptions AddRedirectToHttps(
        this RewriteOptions options, 
        int statusCode)
    {
        return AddRedirectToHttps(options, statusCode, sslPort: null);
    }
        
    public static RewriteOptions AddRedirectToHttps(
        this RewriteOptions options, 
        int statusCode, 
        int? sslPort)
    {
        options.Rules.Add(new RedirectToHttpsRule { StatusCode = statusCode, SSLPort = sslPort });
        return options;
    }
    
    // temporary, statue code = 302
    public static RewriteOptions AddRedirectToHttps(this RewriteOptions options)
    {
        return AddRedirectToHttps(options, statusCode: StatusCodes.Status302Found, sslPort: null);
    }
    
    // permanert, status code = 301
    public static RewriteOptions AddRedirectToHttpsPermanent(this RewriteOptions options)
    {
        return AddRedirectToHttps(options, statusCode: StatusCodes.Status301MovedPermanently, sslPort: null);
    }
}

```

```c#
internal class RedirectToHttpsRule : IRule
{
    public int? SSLPort { get; set; }
    public int StatusCode { get; set; }
    
    public virtual void ApplyRule(RewriteContext context)
    {
        if (!context.HttpContext.Request.IsHttps)
        {
            var host = context.HttpContext.Request.Host;
            int port;
            
            // 如果指定了 ssl port，-> 拼接 host&ssl port => host
            if (SSLPort.HasValue && (port = SSLPort.GetValueOrDefault()) > 0)
            {
                // a specific SSL port is specified
                host = new HostString(host.Host, port);
            }
            // （否则，即没有指定 ssl port），-> host = host（不带 ssl port，即使用默认 port）
            else
            {
                // clear the port
                host = new HostString(host.Host);
            }
            
            var req = context.HttpContext.Request;
            var newUrl = UriHelper.BuildAbsolute("https", host, req.PathBase, req.Path, req.QueryString, default);
            
            var response = context.HttpContext.Response;
            response.StatusCode = StatusCode;
            // 注入 [location, new url]
            response.Headers.Location = newUrl;
            context.Result = RuleResult.EndResponse;
            context.Logger.RedirectedToHttps();
        }
    }
}

```

##### 2.1.3 use rewrite

```c#
public static class RewriteBuilderExtensions
{    
    public static IApplicationBuilder UseRewriter(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<RewriteMiddleware>();
    }
        
    public static IApplicationBuilder UseRewriter(this IApplicationBuilder app, RewriteOptions options)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        // put middleware in pipeline
        return app.UseMiddleware<RewriteMiddleware>(Options.Create(options));
    }
}

```

###### 2.1.3.1 rewrite middleware

```c#
public class RewriteMiddleware
{
    private readonly RequestDelegate _next;
    private readonly RewriteOptions _options;
    private readonly IFileProvider _fileProvider;
    private readonly ILogger _logger;
        
    public RewriteMiddleware(
        RequestDelegate next,
        IWebHostEnvironment hostingEnvironment,
        ILoggerFactory loggerFactory,
        IOptions<RewriteOptions> options)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        // 注入 next（request delegate）
        _next = next;
        // 注入 rewrite options（由 iptions 解析，如果没有 configure，创建 default<rewrite options>）
        _options = options.Value;
        // 从 rewrite options 解析 file provider；如果没有，从 hosting environment 解析
        _fileProvider = _options.StaticFileProvider ?? hostingEnvironment.WebRootFileProvider;
        _logger = loggerFactory.CreateLogger<RewriteMiddleware>();
    }
        
    public Task Invoke(HttpContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        // 创建 rewrite context
        var rewriteContext = new RewriteContext
        {
            HttpContext = context,
            StaticFileProvider = _fileProvider,
            Logger = _logger,
            Result = RuleResult.ContinueRules
        };
        
        // 遍历 rewrite options 的 rules 集合
        foreach (var rule in _options.Rules)
        {
            // 执行 rule
            rule.ApplyRule(rewriteContext);
            
            // 根据执行结果，logging
            switch (rewriteContext.Result)
            {                                        
                case RuleResult.ContinueRules:
                    _logger.RewriteMiddlewareRequestContinueResults(context.Request.GetEncodedUrl());
                    break;          
                    
                case RuleResult.EndResponse:
                    _logger.RewriteMiddlewareRequestResponseComplete(
                        context.Response.Headers.Location,
                        context.Response.StatusCode);
                    return Task.CompletedTask;        
                    
                case RuleResult.SkipRemainingRules:
                    _logger.RewriteMiddlewareRequestStopRules(context.Request.GetEncodedUrl());
                    return _next(context);  
                    
                default:
                    throw new ArgumentOutOfRangeException($"Invalid rule termination {rewriteContext.Result}");
            }
        }
        
        return _next(context);
    }
}

```

#### 2.2 https redirection

* 返回 30x，注入 [location, https://...]，默认 307

##### 2.2.1 add https redirection

```c#
public static class HttpsRedirectionServicesExtensions
{    
    public static IServiceCollection AddHttpsRedirection(
        this IServiceCollection services, 
        Action<HttpsRedirectionOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        // 配置（注入）https redirection options
        services.Configure(configureOptions);
        return services;
    }
}

```

###### 2.2.1.1 https redirection options

```c#
public class HttpsRedirectionOptions
{    
    public int RedirectStatusCode { get; set; } = StatusCodes.Status307TemporaryRedirect;
        
    // If the HttpsPort is not set, we will try to get the HttpsPort from the following:
    // -1. HTTPS_PORT environment variable
    // -2. IServerAddressesFeature
    // -If that fails then the middleware will log a warning and turn off.    
    public int? HttpsPort { get; set; }
}

```

##### 2.2.2 use https redirection

```c#
public static class HttpsPolicyBuilderExtensions
{    
    public static IApplicationBuilder UseHttpsRedirection(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        // 解析 server address feature
        var serverAddressFeature = app.ServerFeatures.Get<IServerAddressesFeature>();
        
        // 注册 https redirection middleware
        if (serverAddressFeature != null)
        {
            app.UseMiddleware<HttpsRedirectionMiddleware>(serverAddressFeature);
        }
        else
        {
            app.UseMiddleware<HttpsRedirectionMiddleware>();
        }
        
        return app;
    }
}

```

###### 2.2.2.1 https redirection middleware

```c#
public class HttpsRedirectionMiddleware
{
    private const int PortNotFound = -1;
    
    private readonly RequestDelegate _next;
    private readonly Lazy<int> _httpsPort;
    private readonly int _statusCode;    
    private readonly IServerAddressesFeature? _serverAddressesFeature;
    private readonly IConfiguration _config;
    private readonly ILogger _logger;
        
    public HttpsRedirectionMiddleware(
        RequestDelegate next, 
        IOptions<HttpsRedirectionOptions> options, 
        IConfiguration config, 
        ILoggerFactory loggerFactory)        
    {
        _next = next ?? throw new ArgumentNullException(nameof(next));
        _config = config ?? throw new ArgumentNullException(nameof(config));
        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        // 解析 https redirection options
        var httpsRedirectionOptions = options.Value;
        
        // 从 https redirection options 解析 https port
        if (httpsRedirectionOptions.HttpsPort.HasValue)
        {
            _httpsPort = new Lazy<int>(httpsRedirectionOptions.HttpsPort.Value);
        }
        // （由上），如果不能解析，从默认来源解析
        else
        {
            _httpsPort = new Lazy<int>(TryGetHttpsPort);
        }
        
        // 从 https redirection options 解析 status code
        _statusCode = httpsRedirectionOptions.RedirectStatusCode;
        
        _logger = loggerFactory.CreateLogger<HttpsRedirectionMiddleware>();
    }
        
    public HttpsRedirectionMiddleware(
        RequestDelegate next, 
        IOptions<HttpsRedirectionOptions> options, 
        IConfiguration config, 
        ILoggerFactory loggerFactory,
        IServerAddressesFeature serverAddressesFeature) : 
    		this(next, options, config, loggerFactory)
    {
        _serverAddressesFeature = serverAddressesFeature ?? throw new ArgumentNullException(nameof(serverAddressesFeature));
    }
        
    public Task Invoke(HttpContext context)
    {
        // 如果 request 已经是 https，-> 下一个 middleware
        if (context.Request.IsHttps)
        {
            return _next(context);
        }
        
        // 如果不能解析 https port（-1），-> 下一个 middleware
        var port = _httpsPort.Value;
        if (port == PortNotFound)
        {
            return _next(context);
        }
        
        // 创建（新的）host，with https port
        var host = context.Request.Host;
        if (port != 443)
        {
            host = new HostString(host.Host, port);
        }
        else
        {
            host = new HostString(host.Host);
        }
        
        // 创建 redirect url
        var request = context.Request;
        var redirectUrl = UriHelper.BuildAbsolute(
            "https", 
            host,
            request.PathBase,
            request.Path,
            request.QueryString);
        
        // 写回 response status code
        context.Response.StatusCode = _statusCode;   
        // 写回 response redirect url
        context.Response.Headers[HeaderNames.Location] = redirectUrl;
        
        _logger.RedirectingToHttps(redirectUrl);        
        return Task.CompletedTask;
    }
    
    //  Returns PortNotFound (-1) if we were unable to determine the port.
    private int TryGetHttpsPort()
    {
        // The IServerAddressesFeature will not be ready until the middleware is Invoked,
        // Order for finding the HTTPS port:
        // 1. Set in the HttpsRedirectionOptions
        // 2. HTTPS_PORT environment variable
        // 3. IServerAddressesFeature
        // 4. Fail if not sets
        
        var nullablePort = _config.GetValue<int?>("HTTPS_PORT") ?? _config.GetValue<int?>("ANCM_HTTPS_PORT");
        
        if (nullablePort.HasValue)
        {
            var port = nullablePort.Value;
            _logger.PortLoadedFromConfig(port);
            return port;
        }
        
        if (_serverAddressesFeature == null)
        {
            _logger.FailedToDeterminePort();
            return PortNotFound;
        }
        
        foreach (var address in _serverAddressesFeature.Addresses)
        {
            var bindingAddress = BindingAddress.Parse(address);
            if (bindingAddress.Scheme.Equals("https", StringComparison.OrdinalIgnoreCase))
            {
                // If we find multiple different https ports specified, throw
                if (nullablePort.HasValue && 
                    nullablePort != bindingAddress.Port)
                {
                    throw new InvalidOperationException(
                        "Cannot determine the https port from IServerAddressesFeature, multiple values were found. " +
                        "Set the desired port explicitly on HttpsRedirectionOptions.HttpsPort.");
                }
                else
                {
                    nullablePort = bindingAddress.Port;
                }
            }
        }
        
        if (nullablePort.HasValue)
        {
            var port = nullablePort.Value;
            _logger.PortFromServer(port);
            return port;
        }
        
        _logger.FailedToDeterminePort();
        return PortNotFound;
    }
}

```

#### 2.3 hsts

* 写入一个头 [strict transport security, max-age...]

##### 2.3.1 add hsts

```c#
public static class HstsServicesExtensions
{    
    public static IServiceCollection AddHsts(
        this IServiceCollection services, 
        Action<HstsOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        services.Configure(configureOptions);
        return services;
    }
}

```

###### 2.3.1.1 hsts options

```c#
public class HstsOptions
{        
    public TimeSpan MaxAge { get; set; } = TimeSpan.FromDays(30);       
    public bool IncludeSubDomains { get; set; }            
    public bool Preload { get; set; }
        
    public IList<string> ExcludedHosts { get; } = new List<string>
    {
        "localhost",
        "127.0.0.1", 	// ipv4
        "[::1]" 	    // ipv6
    };
}
```

##### 2.3.2 use hsts

```c#
public static class HstsBuilderExtensions
{    
    public static IApplicationBuilder UseHsts(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<HstsMiddleware>();
    }
}

```

###### 2.3.2.1 hsts middleware

```c#
public class HstsMiddleware
{
    private const string IncludeSubDomains = "; includeSubDomains";
    private const string Preload = "; preload";
    
    private readonly RequestDelegate _next;
    private readonly StringValues _strictTransportSecurityValue;
    private readonly IList<string> _excludedHosts;
    private readonly ILogger _logger;
        
    public HstsMiddleware(RequestDelegate next, IOptions<HstsOptions> options) : 
    	this(next, options, NullLoggerFactory.Instance) { }
    
    public HstsMiddleware(
        RequestDelegate next, 
        IOptions<HstsOptions> options, 
        ILoggerFactory loggerFactory)
    {
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        // 注入 next（request delegate）
        _next = next ?? throw new ArgumentNullException(nameof(next));
        // 注入 hsts options，没有则创建
        var hstsOptions = options.Value;
        
        // 从 hsts options 解析 max age
        var maxAge = 
            Convert.ToInt64(Math.Floor(hstsOptions.MaxAge.TotalSeconds)).ToString(CultureInfo.InvariantCulture);
        // 从 hsts options 解析 include sub domains（如果不能解析，置为 empty string）
        var includeSubdomains = hstsOptions.IncludeSubDomains ? IncludeSubDomains : StringSegment.Empty;
        // 从 hsts options 解析 preload（如果不能解析，置为 empty string）
        var preload = hstsOptions.Preload ? Preload : StringSegment.Empty;
        // 从 hsts options 解析 excluded host
        _excludedHosts = hstsOptions.ExcludedHosts;
        
        // 创建 hsts value string
        _strictTransportSecurityValue = new StringValues($"max-age={maxAge}{includeSubdomains}{preload}");
        
        _logger = loggerFactory.CreateLogger<HstsMiddleware>();
    }
                
    public Task Invoke(HttpContext context)
    {
        // 如果不是 https request，-> 下一个 middleware
        if (!context.Request.IsHttps)
        {
            _logger.SkippingInsecure();
            return _next(context);
        }
        
        // 如果是 excluded host，-> 下一个 middleware
        if (IsHostExcluded(context.Request.Host.Host))
        {
            _logger.SkippingExcludedHost(context.Request.Host.Host);
            return _next(context);
        }
 
        // 写入 response，header[strict transport security, max-age...]
        context.Response.Headers[HeaderNames.StrictTransportSecurity] = _strictTransportSecurityValue;        
        _logger.AddingHstsHeader();
        
        return _next(context);
    }
    
    private bool IsHostExcluded(string host)
    {
        if (_excludedHosts == null)
        {
            return false;
        }
        
        for (var i = 0; i < _excludedHosts.Count; i++)
        {
            if (string.Equals(host, _excludedHosts[i], StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }
        }
        
        return false;
    }
}

```

#### 2.4 http log

##### 2.4.1 add http log

```c#
public static class HttpLoggingServicesExtensions
{    
    public static IServiceCollection AddHttpLogging(
        this IServiceCollection services, 
        Action<HttpLoggingOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        services.Configure(configureOptions);
        return services;
    }
}

```

###### 2.4.1.1 http log options

```c#
public sealed class HttpLoggingOptions
{    
    public HttpLoggingFields LoggingFields { get; set; } = 
        HttpLoggingFields.RequestPropertiesAndHeaders | HttpLoggingFields.ResponsePropertiesAndHeaders;
    
    // request headers    
    internal HashSet<string> _internalRequestHeaders = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
    {
        HeaderNames.Accept,
        HeaderNames.AcceptEncoding,
        HeaderNames.AcceptLanguage,
        HeaderNames.Allow,
        HeaderNames.Connection,
        HeaderNames.ContentLength,
        HeaderNames.ContentType,
        HeaderNames.Host,
        HeaderNames.UserAgent
    };
    // If a request header is not present in the "RequestHeaders", the header name will be logged 
    // with a redacted value.    
    public ISet<string> RequestHeaders => _internalRequestHeaders;
    
    // response header
    internal HashSet<string> _internalResponseHeaders = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
    {
        HeaderNames.ContentLength,
        HeaderNames.ContentType,
        HeaderNames.TransferEncoding
    };    
    // If a response header is not present in the "ResponseHeaders", the header name will be logged 
    // with a redacted value.    
    public ISet<string> ResponseHeaders => _internalResponseHeaders;
                
    // If the request or response do not match the supported media type, the response body will not be logged.
    public MediaTypeOptions MediaTypeOptions { get; } = MediaTypeOptions.BuildDefaultMediaTypeOptions();
        
    // Maximum request body size to log (in bytes). Defaults to 32 KB.    
    public int RequestBodyLogLimit { get; set; } = 32 * 1024;
        
    // Maximum response body size to log (in bytes). Defaults to 32 KB.    
    public int ResponseBodyLogLimit { get; set; } = 32 * 1024;
}

```

##### 2.4.2 use http log

```c#
 public static class HttpLoggingBuilderExtensions
 {     
     public static IApplicationBuilder UseHttpLogging(this IApplicationBuilder app)
     {
         if (app == null)
         {
             throw new ArgumentNullException(nameof(app));
         }
         
         app.UseMiddleware<HttpLoggingMiddleware>();
         return app;
     }
 }

```

###### 2.4.2.1 http log middleware

```c#
internal sealed class HttpLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger _logger;
    private readonly IOptionsMonitor<HttpLoggingOptions> _options;
    private const int DefaultRequestFieldsMinusHeaders = 7;
    private const int DefaultResponseFieldsMinusHeaders = 2;
    private const string Redacted = "[Redacted]";
        
    public HttpLoggingMiddleware(
        RequestDelegate next, 
        IOptionsMonitor<HttpLoggingOptions> options, 
        ILogger<HttpLoggingMiddleware> logger)
    {
        _next = next ?? throw new ArgumentNullException(nameof(next));
        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }        
        if (logger == null)
        {
            throw new ArgumentNullException(nameof(logger));
        }
        
        _options = options;
        _logger = logger;
    }
        
    public Task Invoke(HttpContext context)
    {
        // 如果 logger 级别低于 information，-> not log!
        if (!_logger.IsEnabled(LogLevel.Information))
        {            
            return _next(context);
        }
        
        return InvokeInternal(context);
    }
        
    private async Task InvokeInternal(HttpContext context)
    {
        var options = _options.CurrentValue;
        
        /* log request */
        RequestBufferingStream? requestBufferingStream = null;
        Stream? originalBody = null;
        
        // 如果 http log options 的 fields 不为 none
        if ((HttpLoggingFields.Request & options.LoggingFields) != HttpLoggingFields.None)
        {
            var request = context.Request;
            var list = 
                new List<KeyValuePair<string, string?>>(request.Headers.Count + DefaultRequestFieldsMinusHeaders);
                        
            // request protocol
            if (options.LoggingFields.HasFlag(HttpLoggingFields.RequestProtocol))
            {
                AddToList(list, nameof(request.Protocol), request.Protocol);
            }
            // request method
            if (options.LoggingFields.HasFlag(HttpLoggingFields.RequestMethod))
            {
                AddToList(list, nameof(request.Method), request.Method);
            }
            // request scheme
            if (options.LoggingFields.HasFlag(HttpLoggingFields.RequestScheme))
            {
                AddToList(list, nameof(request.Scheme), request.Scheme);
            }
            // request path
            if (options.LoggingFields.HasFlag(HttpLoggingFields.RequestPath))
            {
                AddToList(list, nameof(request.PathBase), request.PathBase);
                AddToList(list, nameof(request.Path), request.Path);
            }
            // request query
            if (options.LoggingFields.HasFlag(HttpLoggingFields.RequestQuery))
            {
                AddToList(list, nameof(request.QueryString), request.QueryString.Value);
            }
            // request header
            if (options.LoggingFields.HasFlag(HttpLoggingFields.RequestHeaders))
            {
                FilterHeaders(list, request.Headers, options._internalRequestHeaders);
            }
            // request body
            if (options.LoggingFields.HasFlag(HttpLoggingFields.RequestBody))
            {
                if (MediaTypeHelpers.TryGetEncodingForMediaType(
                    	request.ContentType,
                    	options.MediaTypeOptions.MediaTypeStates,
                    	out var encoding))
                {
                    originalBody = request.Body;
                    requestBufferingStream = new RequestBufferingStream(
                        request.Body,
                        options.RequestBodyLogLimit,
                        _logger,
                        encoding);
                    request.Body = requestBufferingStream;
                }
                else
                {
                    _logger.UnrecognizedMediaType();
                }
            }
            
            var httpRequestLog = new HttpRequestLog(list);
            
            _logger.RequestLog(httpRequestLog);
        }
        
        /* log response */
        ResponseBufferingStream? responseBufferingStream = null;
        IHttpResponseBodyFeature? originalBodyFeature = null;
        
        try
        {
            var response = context.Response;
            
            if (options.LoggingFields.HasFlag(HttpLoggingFields.ResponseBody))
            {
                originalBodyFeature = context.Features.Get<IHttpResponseBodyFeature>()!;
                
                // TODO pool these.
                responseBufferingStream = new ResponseBufferingStream(
                    originalBodyFeature,
                    options.ResponseBodyLogLimit,
                    _logger,
                    context,
                    options.MediaTypeOptions.MediaTypeStates,
                    options);
                response.Body = responseBufferingStream;
                context.Features.Set<IHttpResponseBodyFeature>(responseBufferingStream);
            }
            
            await _next(context);

            if (requestBufferingStream?.HasLogged == false)
            {
                // If the middleware pipeline didn't read until 0 was returned from readasync,
                // make sure we log the request body.
                requestBufferingStream.LogRequestBody();
            }
            
            if (responseBufferingStream == null || responseBufferingStream.FirstWrite == false)
            {
                // No body, write headers here.
                LogResponseHeaders(response, options, _logger);
            }
            
            if (responseBufferingStream != null)
            {
                var responseBody = responseBufferingStream.GetString(responseBufferingStream.Encoding);
                if (!string.IsNullOrEmpty(responseBody))
                {
                    _logger.ResponseBody(responseBody);
                }
            }
        }
        finally
        {
            responseBufferingStream?.Dispose();
            
            if (originalBodyFeature != null)
            {
                context.Features.Set(originalBodyFeature);
            }
            
            requestBufferingStream?.Dispose();
            
            if (originalBody != null)
            {
                context.Request.Body = originalBody;
            }
        }
    }
    
    private static void AddToList(List<KeyValuePair<string, string?>> list, string key, string? value)
    {
        list.Add(new KeyValuePair<string, string?>(key, value));
    }
    
    public static void LogResponseHeaders(HttpResponse response, HttpLoggingOptions options, ILogger logger)
    {
        var list = new List<KeyValuePair<string, string?>>(
            response.Headers.Count + DefaultResponseFieldsMinusHeaders);
        
        if (options.LoggingFields.HasFlag(HttpLoggingFields.ResponseStatusCode))
        {
            list.Add(new KeyValuePair<string, string?>(
                nameof(response.StatusCode),                   
                response.StatusCode.ToString(CultureInfo.InvariantCulture)));
        }
        
        if (options.LoggingFields.HasFlag(HttpLoggingFields.ResponseHeaders))
        {
            FilterHeaders(list, response.Headers, options._internalResponseHeaders);
        }
        
        var httpResponseLog = new HttpResponseLog(list);
        
        logger.ResponseLog(httpResponseLog);
    }
    
    internal static void FilterHeaders(
        List<KeyValuePair<string, string?>> keyValues,
        IHeaderDictionary headers,
        HashSet<string> allowedHeaders)
    {
        foreach (var (key, value) in headers)
        {
            if (!allowedHeaders.Contains(key))
            {
                // Key is not among the "only listed" headers.
                keyValues.Add(new KeyValuePair<string, string?>(key, Redacted));
                continue;
            }
            keyValues.Add(new KeyValuePair<string, string?>(key, value.ToString()));
        }
    }
}

```

###### 2.4.2.2 http log field

```c#
[Flags]
public enum HttpLoggingFields : long
{    
    None = 0x0,  
    
    RequestPath = 0x1,
    RequestQuery = 0x2,        
    RequestProtocol = 0x4,            
    RequestMethod = 0x8,        
    RequestScheme = 0x10,
    
    ResponseStatusCode = 0x20,
       
    RequestHeaders = 0x40,        
    ResponseHeaders = 0x80,
        
    RequestTrailers = 0x100,        
    ResponseTrailers = 0x200,
        
    RequestBody = 0x400,        
    ResponseBody = 0x800,
        
    RequestProperties = RequestPath | RequestQuery | RequestProtocol | RequestMethod | RequestScheme,        
    RequestPropertiesAndHeaders = RequestProperties | RequestHeaders,
        
    ResponsePropertiesAndHeaders = ResponseStatusCode | ResponseHeaders,
        
    Request = RequestPropertiesAndHeaders | RequestBody,
        
    Response = ResponseStatusCode | ResponseHeaders | ResponseBody,
        
    All = Request | Response
}

```

#### 2.5 host filtering

##### 2.5.1 add host filtering

```c#
public static class HostFilteringServicesExtensions
{    
    public static IServiceCollection AddHostFiltering(
        this IServiceCollection services, 
        Action<HostFilteringOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        services.Configure(configureOptions);
        return services;
    }
}

```

###### 2.5.1.1 host filtering options

```c#
public class HostFilteringOptions
{
    // Port numbers must be excluded.
    // A top level wildcard "*" allows all non-empty hosts.
    // Subdomain wildcards are permitted. E.g. "*.example.com" matches subdomains like foo.example.com, 
    // but not the parent domain example.com.
    // Unicode host names are allowed but will be converted to punycode for matching.
    // IPv6 addresses must include their bounding brackets and be in their normalized form.
    public IList<string> AllowedHosts { get; set; } = new List<string>();
        
    // HTTP/1.0 does not require a host header.
    // Http/1.1 requires a host header, but says the value may be empty.    
    public bool AllowEmptyHosts { get; set; } = true;
    
    // 标记是否 inclue failure message，
    // 即 host 不是 allowed 时返回 default html
    public bool IncludeFailureMessage { get; set; } = true;
}

```

##### 2.5.2 use host filtering

```c#
public static class HostFilteringBuilderExtensions
{    
    public static IApplicationBuilder UseHostFiltering(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        app.UseMiddleware<HostFilteringMiddleware>();        
        return app;
    }
}

```

###### 2.5.2.1 host filtering middleware

```c#
public class HostFilteringMiddleware
{
    // Matches Http.Sys.
    private static readonly byte[] DefaultResponse = Encoding.ASCII.GetBytes(
        "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\"http://www.w3.org/TR/html4/strict.dtd\">\r\n" + 
        "<HTML><HEAD><TITLE>Bad Request</TITLE>\r\n"  + 
        "<META HTTP-EQUIV=\"Content-Type\" Content=\"text/html; charset=us-ascii\"></ HEAD >\r\n" + 
        "<BODY><h2>Bad Request - Invalid Hostname</h2>\r\n" + 
        "<hr><p>HTTP Error 400. The request hostname is invalid.</p>\r\n" + 
        "</BODY></HTML>");
    
    private readonly RequestDelegate _next;
    private readonly ILogger<HostFilteringMiddleware> _logger;
    private readonly IOptionsMonitor<HostFilteringOptions> _optionsMonitor;
    
    private HostFilteringOptions _options;    
    private IList<StringSegment>? _allowedHosts;
    private bool? _allowAnyNonEmptyHost;
        
    public HostFilteringMiddleware(
        RequestDelegate next, 
        ILogger<HostFilteringMiddleware> logger, 
        IOptionsMonitor<HostFilteringOptions> optionsMonitor)
    {
        // 注入 next（request delegate）
        _next = next ?? throw new ArgumentNullException(nameof(next));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
                
        // 注入 host filtering options，跟踪变化
        _optionsMonitor = optionsMonitor ?? throw new ArgumentNullException(nameof(optionsMonitor));
        _options = _optionsMonitor.CurrentValue;
        _optionsMonitor.OnChange(options =>
            {
                // Clear the cached settings so the next EnsureConfigured will re-evaluate.
                _options = options;
                _allowedHosts = new List<StringSegment>();
                _allowAnyNonEmptyHost = null;
            });
    }
    
    public Task Invoke(HttpContext context)
    {
        // 解析 allowed host
        var allowedHosts = EnsureConfigured();
        
        // 如果 request host 不包含在 allowed host，-> 拒绝！
        if (!CheckHost(context, allowedHosts))
        {
            return HostValidationFailed(context);
        }
        
        // （由上），rquest host 包含在 allowed host，-> call next()
        return _next(context);
    }
    
    /* ensure configure */
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private IList<StringSegment> EnsureConfigured()
    {
        if (_allowAnyNonEmptyHost == true || _allowedHosts?.Count > 0)
        {
            Debug.Assert(_allowedHosts != null);            
            return _allowedHosts;
        }
        
        return Configure();
    }
    
    // 解析（配置） allowed host
    private IList<StringSegment> Configure()
    {
        // 预结果
        var allowedHosts = new List<StringSegment>();
        
        // 如果 options 中 allowed host 不为空，且可以解析到通配符
        if (_options.AllowedHosts?.Count > 0 && 
            !TryProcessHosts(_options.AllowedHosts, allowedHosts))
        {
            _logger.WildcardDetected();
            _allowedHosts = allowedHosts;
            _allowAnyNonEmptyHost = true;
            return _allowedHosts;
        }
        
        if (allowedHosts.Count == 0)
        {
            throw new InvalidOperationException("No allowed hosts were configured.");
        }
        
        if (_logger.IsEnabled(LogLevel.Debug))
        {
            _logger.AllowedHosts(string.Join("; ", allowedHosts));
        }
        
        _allowedHosts = allowedHosts;
        return _allowedHosts;
    }
    
    // returns false if any wildcards were found
    private bool TryProcessHosts(IEnumerable<string> incoming, IList<StringSegment> results)
    {
        foreach (var entry in incoming)
        {
            // Punycode. Http.Sys requires you to register Unicode hosts, but the headers contain punycode.
            var host = new HostString(entry).ToUriComponent();
            
            if (IsTopLevelWildcard(host))
            {
                // Disable filtering
                return false;
            }
            
            if (!results.Contains(host, StringSegmentComparer.OrdinalIgnoreCase))
            {
                results.Add(host);
            }
        }
        
        return true;
    }
    
    private bool IsTopLevelWildcard(string host)
    {
        return (
            // HttpSys wildcard
            string.Equals("*", host, StringComparison.Ordinal) || 
            // Kestrel wildcard, IPv6 Any
            string.Equals("[::]", host, StringComparison.Ordinal) || 
            // IPv4 Any
            string.Equals("0.0.0.0", host, StringComparison.Ordinal)); 
    }        
        
    /* check host */
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool CheckHost(
        HttpContext context, 
        IList<StringSegment> allowedHosts)
    {
        // 从 http request 解析 host
        var host = context.Request.Headers[HeaderNames.Host].ToString();
        
        if (host.Length == 0)
        {
            return IsEmptyHostAllowed(context);
        }
        
        if (_allowAnyNonEmptyHost == true)
        {
            _logger.AllHostsAllowed();
            return true;
        }
        
        return CheckHostInAllowList(allowedHosts, host);
    }
    
    [MethodImpl(MethodImplOptions.NoInlining)]
    private bool IsEmptyHostAllowed(HttpContext context)
    {
        // Http/1.0 does not require the host header.
        // Http/1.1 requires the header but the value may be empty.
        if (!_options.AllowEmptyHosts)
        {
            _logger.RequestRejectedMissingHost(context.Request.Protocol);
            return false;
        }
        _logger.RequestAllowedMissingHost(context.Request.Protocol);
        return true;
    }
    
    [MethodImpl(MethodImplOptions.NoInlining)]
    private bool CheckHostInAllowList(
        IList<StringSegment> allowedHosts, 
        string host)
    {
        if (HostString.MatchesAny(new StringSegment(host), allowedHosts))
        {
            _logger.AllowedHostMatched(host);
            return true;
        }
        
        _logger.NoAllowedHostMatched(host);
        return false;
    }
    
    /* host validation failed */                                
    [MethodImpl(MethodImplOptions.NoInlining)]
    private Task HostValidationFailed(HttpContext context)
    {
        // -> 返回 400
        context.Response.StatusCode = 400;
        
        // 如果标记了 inclue failure message，-> 返回 default html        
        if (_options.IncludeFailureMessage)
        {
            context.Response.ContentLength = DefaultResponse.Length;
            context.Response.ContentType = "text/html";
            
            return context.Response.Body.WriteAsync(
                DefaultResponse, 
                0, 
                DefaultResponse.Length);
        }
        
        return Task.CompletedTask;
    }                        
}

```

#### 2.6 cors

* 支持 preflight，在 response 中加入头 [ access-control-allow ...]

##### 2.6.1 cors policy

```c#
public class CorsPolicy
{        
    // preflight max age
    private TimeSpan? _preflightMaxAge;
    public TimeSpan? PreflightMaxAge
    {
        get
        {
            return _preflightMaxAge;
        }
        set
        {
            if (value < TimeSpan.Zero)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(value), 
                    Resources.PreflightMaxAgeOutOfRange);
            }
            
            _preflightMaxAge = value;
        }
    }    
    
    // origins
    public IList<string> Origins { get; } = new List<string>();
    
    // allow any origin
    public bool AllowAnyOrigin
    {
        get
        {
            if (Origins == null || Origins.Count != 1 || Origins[0] != "*")
            {
                return false;
            }
            
            return true;
        }
    }
        
    // is origin allowed
    private Func<string, bool> _isOriginAllowed;
    internal bool IsDefaultIsOriginAllowed { get; private set; } = true;
    public Func<string, bool> IsOriginAllowed
    {
        get
        {
            return _isOriginAllowed;
        }
        set
        {
            _isOriginAllowed = value;
            IsDefaultIsOriginAllowed = false;
        }
    }
    
    // methods
    public IList<string> Methods { get; } = new List<string>();
    public bool AllowAnyMethod
    {
        get
        {
            if (Methods == null || Methods.Count != 1 || Methods[0] != "*")
            {
                return false;
            }
            
            return true;
        }
    }
    
    // headers
    public IList<string> Headers { get; } = new List<string>();
    public bool AllowAnyHeader
    {
        get
        {
            if (Headers == null || Headers.Count != 1 || Headers[0] != "*")
            {
                return false;
            }
            
            return true;
        }
    }            
    public IList<string> ExposedHeaders { get; } = new List<string>(); 
    
    public bool SupportsCredentials { get; set; }
    
    public CorsPolicy()
    {
        _isOriginAllowed = DefaultIsOriginAllowed;
    }
    
    private bool DefaultIsOriginAllowed(string origin)
    {
        return Origins.Contains(origin, StringComparer.Ordinal);
    }
                                                    
    public override string ToString()
    {
        var builder = new StringBuilder();
        builder.Append("AllowAnyHeader: ");
        builder.Append(AllowAnyHeader);
        builder.Append(", AllowAnyMethod: ");
        builder.Append(AllowAnyMethod);
        builder.Append(", AllowAnyOrigin: ");
        builder.Append(AllowAnyOrigin);
        builder.Append(", PreflightMaxAge: ");
        builder.Append(PreflightMaxAge.HasValue 
                       	   ? PreflightMaxAge.Value.TotalSeconds.ToString(CultureInfo.InvariantCulture) 
                       	   : "null");
        builder.Append(", SupportsCredentials: ");
        builder.Append(SupportsCredentials);
        builder.Append(", Origins: {");
        builder.AppendJoin(",", Origins);
        builder.Append("}");
        builder.Append(", Methods: {");
        builder.AppendJoin(",", Methods);
        builder.Append("}");
        builder.Append(", Headers: {");
        builder.AppendJoin(",", Headers);
        builder.Append("}");
        builder.Append(", ExposedHeaders: {");
        builder.AppendJoin(",", ExposedHeaders);
        builder.Append("}");
        return builder.ToString();
    }        
}

// 扩展方法
internal static class CorsPolicyExtensions
{
    private const string _WildcardSubdomain = "*.";
    
    public static bool IsOriginAnAllowedSubdomain(this CorsPolicy policy, string origin)
    {
        if (policy.Origins.Contains(origin))
        {
            return true;
        }
        
        if (Uri.TryCreate(origin, UriKind.Absolute, out var originUri))
        {
            return policy.Origins
                		.Where(o => o.Contains($"://{_WildcardSubdomain}"))
                		.Select(CreateDomainUri)
                		.Any(domain => UriHelpers.IsSubdomainOf(originUri, domain));
        }
        
        return false;
    }
    
    private static Uri CreateDomainUri(string origin)
    {
        return new Uri(origin.Replace(_WildcardSubdomain, string.Empty), UriKind.Absolute);
    }
}

```

###### 2.6.1.1 cors policy builder

* with origins, methods, headers, credentials

```c#
public class CorsPolicyBuilder
{
    private readonly CorsPolicy _policy = new CorsPolicy();
        
    public CorsPolicyBuilder(params string[] origins)
    {
        WithOrigins(origins);
    }
        
    public CorsPolicyBuilder(CorsPolicy policy)
    {
        Combine(policy);
    }
    
    private CorsPolicyBuilder Combine(CorsPolicy policy)
    {
        if (policy == null)
        {
            throw new ArgumentNullException(nameof(policy));
        }
        
        WithOrigins(policy.Origins.ToArray());
        WithHeaders(policy.Headers.ToArray());
        WithExposedHeaders(policy.ExposedHeaders.ToArray());
        WithMethods(policy.Methods.ToArray());
        SetIsOriginAllowed(policy.IsOriginAllowed);
        
        if (policy.PreflightMaxAge.HasValue)
        {
            SetPreflightMaxAge(policy.PreflightMaxAge.Value);
        }
        
        if (policy.SupportsCredentials)
        {
            AllowCredentials();
        }
        else
        {
            DisallowCredentials();
        }
        
        return this;
    }
    
    // with origins
    public CorsPolicyBuilder WithOrigins(params string[] origins)
    {
        if (origins is null)
        {
            throw new ArgumentNullException(nameof(origins));
        }
        
        foreach (var origin in origins)
        {
            var normalizedOrigin = GetNormalizedOrigin(origin);
            _policy.Origins.Add(normalizedOrigin);
        }
        
        return this;
    }
                           
    internal static string GetNormalizedOrigin(string origin)
    {
        if (origin is null)
        {
            throw new ArgumentNullException(nameof(origin));
        }
        
        if (Uri.TryCreate(origin, UriKind.Absolute, out var uri) &&
            (uri.Scheme == Uri.UriSchemeHttp || uri.Scheme == Uri.UriSchemeHttps) &&
            !string.Equals(uri.IdnHost, uri.Host, StringComparison.Ordinal))
        {
            var builder = new UriBuilder(
                uri.Scheme.ToLowerInvariant(), 
                uri.IdnHost.ToLowerInvariant());
            
            if (!uri.IsDefaultPort)
            {
                // Uri does not have a way to differentiate between a port value inferred by default 
                // (e.g. Port = 80 for http://www.example.com) and a default port value that is specified 
                // (e.g. Port = 80 for http://www.example.com:80). Although the HTTP or FETCH spec does not say
                // anything about including the default port as part of the Origin header, at the time of writing, 
                // browsers drop "default" port when navigating and when sending the Origin header. 
                // All this goes to say, it appears OK to drop an explicitly specified port,
                // if it is the default port when working with an IDN host.
                builder.Port = uri.Port;
            }
            
            return builder.Uri.GetComponents(UriComponents.SchemeAndServer, UriFormat.Unescaped);
        }
        
        return origin.ToLowerInvariant();
    }
    
    public CorsPolicyBuilder AllowAnyOrigin()        
    {
        _policy.Origins.Clear();
        _policy.Origins.Add(CorsConstants.AnyOrigin);
        return this;
    }
    
    // methods 
    public CorsPolicyBuilder WithMethods(params string[] methods)
    {
        foreach (var req in methods)
        {
            _policy.Methods.Add(req);
        }
        
        return this;
    }
    
    public CorsPolicyBuilder AllowAnyMethod()
    {
        _policy.Methods.Clear();
        _policy.Methods.Add("*");
        return this;
    }
    
    // headers
    public CorsPolicyBuilder WithHeaders(params string[] headers)
    {
        foreach (var req in headers)
        {
            _policy.Headers.Add(req);
        }
        return this;
    }
        
    public CorsPolicyBuilder WithExposedHeaders(params string[] exposedHeaders)
    {
        foreach (var req in exposedHeaders)
        {
            _policy.ExposedHeaders.Add(req);
        }
        
        return this;
    }
    
    public CorsPolicyBuilder AllowAnyHeader()
    {
        _policy.Headers.Clear();
        _policy.Headers.Add("*");
        return this;
    }
    
    // credentials
    public CorsPolicyBuilder AllowCredentials()
    {
        _policy.SupportsCredentials = true;
        return this;
    }
        
    public CorsPolicyBuilder DisallowCredentials()
    {
        _policy.SupportsCredentials = false;
        return this;
    }
                                                  
    public CorsPolicyBuilder SetPreflightMaxAge(TimeSpan preflightMaxAge)
    {
        _policy.PreflightMaxAge = preflightMaxAge;
        return this;
    }
        
    public CorsPolicyBuilder SetIsOriginAllowed(Func<string, bool> isOriginAllowed)
    {
        _policy.IsOriginAllowed = isOriginAllowed;
        return this;
    }
            
    public CorsPolicyBuilder SetIsOriginAllowedToAllowWildcardSubdomains()
    {
        _policy.IsOriginAllowed = _policy.IsOriginAnAllowedSubdomain;
        return this;
    }
    
    // 方法- builde    
    public CorsPolicy Build()
    {
        if (_policy.AllowAnyOrigin && _policy.SupportsCredentials)
        {
            throw new InvalidOperationException(Resources.InsecureConfiguration);
        }
        
        return _policy;
    }        
}

```

###### 2.6.1.2 cors policy provider

```c#
// 接口
public interface ICorsPolicyProvider
{    
    Task<CorsPolicy?> GetPolicyAsync(HttpContext context, string? policyName);
}

// 默认实现
public class DefaultCorsPolicyProvider : ICorsPolicyProvider
{
    private static readonly Task<CorsPolicy?> NullResult = Task.FromResult<CorsPolicy?>(null);
    private readonly CorsOptions _options;
        
    public DefaultCorsPolicyProvider(IOptions<CorsOptions> options)
    {
        _options = options.Value;
    }
        
    public Task<CorsPolicy?> GetPolicyAsync(HttpContext context, string? policyName)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        policyName ??= _options.DefaultPolicyName;
        if (_options.PolicyMap.TryGetValue(policyName, out var result))
        {
            return result.policyTask!;
        }
        
        return NullResult;
    }
}

```

###### 2.6.1.3 cors options

```c#
public class CorsOptions
{
    private string _defaultPolicyName = "__DefaultCorsPolicy";
    
    // cors policy 容器
    internal IDictionary<string, (CorsPolicy policy, Task<CorsPolicy> policyTask)> PolicyMap { get; } = 
        new Dictionary<string, (CorsPolicy, Task<CorsPolicy>)>(StringComparer.Ordinal);
        
    public string DefaultPolicyName
    {
        get => _defaultPolicyName;
        set
        {
            _defaultPolicyName = value ?? throw new ArgumentNullException(nameof(value));
        }
    }
        
    /* 方法- get policy */
    public CorsPolicy? GetPolicy(string name)
    {
        if (name == null)
        {
            throw new ArgumentNullException(nameof(name));
        }
        // 从 cors policy 容器解析 cors policy
        if (PolicyMap.TryGetValue(name, out var result))
        {
            return result.policy;
        }
        
        return null;
    }
    
    /* 方法- add default policy */
    public void AddDefaultPolicy(CorsPolicy policy)
    {
        if (policy == null)
        {
            throw new ArgumentNullException(nameof(policy));
        }
        
        AddPolicy(DefaultPolicyName, policy);
    }
        
    public void AddDefaultPolicy(Action<CorsPolicyBuilder> configurePolicy)
    {
        if (configurePolicy == null)
        {
            throw new ArgumentNullException(nameof(configurePolicy));
        }
        
        AddPolicy(DefaultPolicyName, configurePolicy);
    }
    
    /* 方法- add policy */ 
    public void AddPolicy(string name, CorsPolicy policy)
    {
        if (name == null)
        {
            throw new ArgumentNullException(nameof(name));
        }        
        if (policy == null)
        {
            throw new ArgumentNullException(nameof(policy));
        }
        
        PolicyMap[name] = (policy, Task.FromResult(policy));
    }
        
    public void AddPolicy(string name, Action<CorsPolicyBuilder> configurePolicy)
    {
        if (name == null)
        {
            throw new ArgumentNullException(nameof(name));
        }        
        if (configurePolicy == null)
        {
            throw new ArgumentNullException(nameof(configurePolicy));
        }
        
        // 创建、配置 cors policy builder
        var policyBuilder = new CorsPolicyBuilder();
        configurePolicy(policyBuilder); 
        // 由 cors policy builder 构建 policy
        var policy = policyBuilder.Build();        
        
        PolicyMap[name] = (policy, Task.FromResult(policy));
    }                
}

```

##### 2.6.2 cors service

```c#
// 接口
public interface ICorsService
{    
    CorsResult EvaluatePolicy(HttpContext context, CorsPolicy policy);    
    void ApplyResult(CorsResult result, HttpResponse response);    
}

// 实现
public class CorsService : ICorsService
{
    private readonly CorsOptions _options;
    private readonly ILogger _logger;
        
    public CorsService(IOptions<CorsOptions> options, ILoggerFactory loggerFactory)
    {
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }        
        if (loggerFactory == null)
        {
            throw new ArgumentNullException(nameof(loggerFactory));
        }
        
        _options = options.Value;
        _logger = loggerFactory.CreateLogger<CorsService>();
    }      
    
    private static void AddHeaderValues(IList<string> target, IList<string> headerValues)
    {
        if (headerValues == null)
        {
            return;
        }
        
        for (var i = 0; i < headerValues.Count; i++)
        {
            target.Add(headerValues[i]);
        }
    }
    
    private bool IsOriginAllowed(CorsPolicy policy, StringValues origin)
    {
        if (StringValues.IsNullOrEmpty(origin))
        {
            _logger.RequestDoesNotHaveOriginHeader();
            return false;
        }
        
        _logger.RequestHasOriginHeader(origin);
        if (policy.AllowAnyOrigin || policy.IsOriginAllowed(origin))
        {
            _logger.PolicySuccess();
            return true;
        }
        _logger.PolicyFailure();
        _logger.OriginNotAllowed(origin);
        return false;
    }
}

```

###### - evaluate policy

```c#
public class CorsService : ICorsService
{    
    public CorsResult EvaluatePolicy(HttpContext context, string policyName)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        // 按照 policy name 从 cors options 中解析 cors policy
        var policy = _options.GetPolicy(policyName);
        if (policy is null)
        {
            throw new InvalidOperationException(Resources.FormatPolicyNotFound(policyName));
        }
        
        return EvaluatePolicy(context, policy);
    }
           
    public CorsResult EvaluatePolicy(HttpContext context, CorsPolicy policy)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }        
        if (policy == null)
        {
            throw new ArgumentNullException(nameof(policy));
        }        
        if (policy.AllowAnyOrigin && policy.SupportsCredentials)
        {
            throw new ArgumentException(Resources.InsecureConfiguration, nameof(policy));
        }
        
        // 解析 origin
        var requestHeaders = context.Request.Headers;
        var origin = requestHeaders[CorsConstants.Origin];
        
        // 判断 is options request
        var isOptionsRequest = HttpMethods.IsOptions(context.Request.Method);
        
        // 判断 is preflight request
        var isPreflightRequest = isOptionsRequest && requestHeaders.ContainsKey(CorsConstants.AccessControlRequestMethod);

        if (isOptionsRequest && !isPreflightRequest)
        {
            _logger.IsNotPreflightRequest();
        }
        
        // 创建 cors result，
        var corsResult = new CorsResult
        {
            IsPreflightRequest = isPreflightRequest,
            IsOriginAllowed = IsOriginAllowed(policy, origin),
        };   
        
        // 1- 如果是 preflight request
        if (isPreflightRequest)
        {
            EvaluatePreflightRequest(context, policy, corsResult);
        }
        // 2- 不是 preflight request
        else
        {
            EvaluateRequest(context, policy, corsResult);
        }
        
        return corsResult;
    }
    
    // 1- for preflight request
    public virtual void EvaluatePreflightRequest(HttpContext context, CorsPolicy policy, CorsResult result)
    {
        PopulateResult(context, policy, result);
    }
    // 2- for request
    public virtual void EvaluateRequest(HttpContext context, CorsPolicy policy, CorsResult result)
    {
        PopulateResult(context, policy, result);
    }
                                            
    private static void PopulateResult(HttpContext context, CorsPolicy policy, CorsResult result)
    {
        // 解析 http request header
        var headers = context.Request.Headers;
        
        /* 1- 向 cors result 注入 allowed origin & vary by origin */
        // 如果 cors policy 标记了 allow any origin 
        if (policy.AllowAnyOrigin)
        {
            result.AllowedOrigin = CorsConstants.AnyOrigin;
            result.VaryByOrigin = policy.SupportsCredentials;
        }
        // （否则），即 cors policy 没有标记 allow any origin
        else
        {
            // 从 http request header 中解析 origin，注入 cors result
            var origin = headers[CorsConstants.Origin];
            
            result.AllowedOrigin = origin;
            result.VaryByOrigin = policy.Origins.Count > 1 || !policy.IsDefaultIsOriginAllowed;
        }
        
        /* 2- 向 cors result 注入 support credentials */
        result.SupportsCredentials = policy.SupportsCredentials;
        
        /* 3- 向 cors result 注入 preflight max age */
        result.PreflightMaxAge = policy.PreflightMaxAge;
        
        /* 4- 向 cors result 注入 allowed exposed headers */        
        AddHeaderValues(result.AllowedExposedHeaders, policy.ExposedHeaders);
        
        /* 5- 向 cors result 注入 allowed method */
        // 如果 cors policy 标记了 allow any method，
        var allowedMethods = policy.AllowAnyMethod 
            ? new[] {
            	// 从 http context request 解析 method
            	result.IsPreflightRequest 
                    ? (string)headers[CorsConstants.AccessControlRequestMethod] 
                    : context.Request.Method } 
        	// （否则），即 cors policy 没有标记 allow any method，-> 解析 cors policy 的 method
        	: policy.Methods;
        // 注入 allowed method
        AddHeaderValues(result.AllowedMethods, allowedMethods);
        
        /* 6- 向 cors policy 注入 allowed header */
        var allowedHeaders = policy.AllowAnyHeader 
            // 如果 cors policy 标记了 allow any header，-> 解析 http request header 的 access-control-request-headers
            ? headers.GetCommaSeparatedValues(CorsConstants.AccessControlRequestHeaders) 
            // （否则），即 cors policy 没有标记 allow any header，-> 解析 cors policy 的 header
            : policy.Headers;
        // 注入 allowed header
        AddHeaderValues(result.AllowedHeaders, allowedHeaders);
    }
}

```

###### - apply policy

```c#
public class CorsService : ICorsService
{
    // 方法- apply result
    public virtual void ApplyResult(CorsResult result, HttpResponse response)
    {
        if (result == null)
        {
            throw new ArgumentNullException(nameof(result));
        }        
        if (response == null)
        {
            throw new ArgumentNullException(nameof(response));
        }
        
        // 如果 cors result 验证 origin 不是 allowed，-> 结束
        if (!result.IsOriginAllowed)
        {
            // In case a server does not wish to participate in the CORS protocol, its HTTP response to the
            // CORS or CORS-preflight request must not include any of the above headers.
            return;
        }
        
        // （是 allowed origin）
        
        // http response header 注入 [access control allow origin, allowed origin]
        var headers = response.Headers;
        headers[CorsConstants.AccessControlAllowOrigin] = result.AllowedOrigin;
        
        // http response header 注入 [access control allow credential, ]
        if (result.SupportsCredentials)
        {
            headers[CorsConstants.AccessControlAllowCredentials] = "true";
        }
        
        // 如果是 preflight request，
        if (result.IsPreflightRequest)
        {
            _logger.IsPreflightRequest();
            
            // 注入 headers，`Access-Control-Allow-Methods`, `Access-Control-Allow-Headers`, `Access-Control-Max-Age`
            if (result.AllowedHeaders.Count > 0)
            {
                headers.SetCommaSeparatedValues(
                    CorsConstants.AccessControlAllowHeaders, 
                    result.AllowedHeaders.ToArray());
            }
            // 注入 method
            if (result.AllowedMethods.Count > 0)
            {
                headers.SetCommaSeparatedValues(
                    CorsConstants.AccessControlAllowMethods, 
                    result.AllowedMethods.ToArray());
            }
            // 注入 max age
            if (result.PreflightMaxAge.HasValue)
            {
                headers[CorsConstants.AccessControlMaxAge] = result
                    .PreflightMaxAge.Value.TotalSeconds.ToString(CultureInfo.InvariantCulture);
            }
        }
        // （否则），即不是 preflight request
        else
        {
            // 注入 header，`Access-Control-Expose-Headers`
            if (result.AllowedExposedHeaders.Count > 0)
            {
                headers.SetCommaSeparatedValues(
                    CorsConstants.AccessControlExposeHeaders, 
                    result.AllowedExposedHeaders.ToArray());
            }
        }
        // 注入 vary by origin
        if (result.VaryByOrigin)
        {
            headers.Append("Vary", "Origin");
        }
    }        
}

```



###### 2.6.2.1 cors constant

```c#
public static class CorsConstants
{    
    public static readonly string PreflightHttpMethod = HttpMethods.Options;        
    public static readonly string Origin = HeaderNames.Origin;        
    public static readonly string AnyOrigin = "*";        
    public static readonly string AccessControlRequestMethod = HeaderNames.AccessControlRequestMethod;        
    public static readonly string AccessControlRequestHeaders = HeaderNames.AccessControlRequestHeaders;        
    public static readonly string AccessControlAllowOrigin = HeaderNames.AccessControlAllowOrigin;        
    public static readonly string AccessControlAllowHeaders = HeaderNames.AccessControlAllowHeaders;        
    public static readonly string AccessControlExposeHeaders = HeaderNames.AccessControlExposeHeaders;        
    public static readonly string AccessControlAllowMethods = HeaderNames.AccessControlAllowMethods;        
    public static readonly string AccessControlAllowCredentials = HeaderNames.AccessControlAllowCredentials;        
    public static readonly string AccessControlMaxAge = HeaderNames.AccessControlMaxAge;
}

```

###### 2.6.2.2 cors result

```c#
public class CorsResult
{    
    private TimeSpan? _preflightMaxAge;    
    public TimeSpan? PreflightMaxAge
    {
        get
        {
            return _preflightMaxAge;
        }
        set
        {
            if (value < TimeSpan.Zero)
            {
                throw new ArgumentOutOfRangeException(nameof(value), Resources.PreflightMaxAgeOutOfRange);
            }
            _preflightMaxAge = value;
        }
    }
    public bool IsPreflightRequest { get; set; }        
    public string? AllowedOrigin { get; set; }       
    public bool IsOriginAllowed { get; set; }           
    public bool SupportsCredentials { get; set; }       
    public IList<string> AllowedMethods { get; } = new List<string>();    
    public IList<string> AllowedHeaders { get; } = new List<string>();    
    public IList<string> AllowedExposedHeaders { get; } = new List<string>();       
    public bool VaryByOrigin { get; set; }
    
    public override string ToString()
    {
        var builder = new StringBuilder();
        builder.Append("AllowCredentials: ");
        builder.Append(SupportsCredentials);
        builder.Append(", PreflightMaxAge: ");
        builder.Append(PreflightMaxAge.HasValue 
                       	   ? PreflightMaxAge.Value.TotalSeconds.ToString(CultureInfo.InvariantCulture) 
                       	   : "null");
        builder.Append(", AllowOrigin: ");
        builder.Append(AllowedOrigin);
        builder.Append(", AllowExposedHeaders: {");
        builder.AppendJoin(",", AllowedExposedHeaders);
        builder.Append("}");
        builder.Append(", AllowHeaders: {");
        builder.AppendJoin(",", AllowedHeaders);
        builder.Append("}");
        builder.Append(", AllowMethods: {");
        builder.AppendJoin(",", AllowedMethods);
        builder.Append("}");
        return builder.ToString();
    }
}

```

##### 2.6.3 add cors

```c#
public static class CorsServiceCollectionExtensions
{    
    public static IServiceCollection AddCors(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        services.AddOptions();        
        // 注入 cors service
        services.TryAdd(ServiceDescriptor.Transient<ICorsService, CorsService>());
        // 注入 cors policy provider
        services.TryAdd(ServiceDescriptor.Transient<ICorsPolicyProvider, DefaultCorsPolicyProvider>());
        
        return services;
    }
            
    public static IServiceCollection AddCors(this IServiceCollection services, Action<CorsOptions> setupAction)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }        
        if (setupAction == null)
        {
            throw new ArgumentNullException(nameof(setupAction));
        }
        
        services.AddCors();
        services.Configure(setupAction);
        
        return services;
    }
}

```

##### 2.6.4 use cors

```c#
public static class CorsMiddlewareExtensions
{    
    public static IApplicationBuilder UseCors(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<CorsMiddleware>();
    }
            
    public static IApplicationBuilder UseCors(this IApplicationBuilder app, string policyName)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<CorsMiddleware>(policyName);
    }
            
    public static IApplicationBuilder UseCors(
        this IApplicationBuilder app,
        Action<CorsPolicyBuilder> configurePolicy)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }        
        if (configurePolicy == null)
        {
            throw new ArgumentNullException(nameof(configurePolicy));
        }
        
        var policyBuilder = new CorsPolicyBuilder();
        configurePolicy(policyBuilder);
        return app.UseMiddleware<CorsMiddleware>(policyBuilder.Build());
    }
}

```

###### 2.6.4.1 cors middleware

```c#
public class CorsMiddleware
{
    // Property key is used by other systems, e.g. MVC, to check if CORS middleware has run
    private const string CorsMiddlewareWithEndpointInvokedKey = "__CorsMiddlewareWithEndpointInvoked";
    private static readonly object CorsMiddlewareWithEndpointInvokedValue = new object();
                        
    private readonly RequestDelegate _next;
    
    private readonly CorsPolicy? _policy;
    private readonly string? _corsPolicyName;        
    private ICorsService CorsService { get; }   
    
    private ILogger Logger { get; }
    
    public CorsMiddleware(
        RequestDelegate next,
        ICorsService corsService,
        ILoggerFactory loggerFactory) : 
    		this(next, corsService, loggerFactory, policyName: null)
    {
    }
       
    public CorsMiddleware(
        RequestDelegate next,
        ICorsService corsService,
        ILoggerFactory loggerFactory,
        string? policyName)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }        
        if (corsService == null)
        {
            throw new ArgumentNullException(nameof(corsService));
        }        
        if (loggerFactory == null)
        {
            throw new ArgumentNullException(nameof(loggerFactory));
        }
        
        _next = next;
        CorsService = corsService;
        _corsPolicyName = policyName;
        Logger = loggerFactory.CreateLogger<CorsMiddleware>();
    }
            
    public CorsMiddleware(
        RequestDelegate next,
        ICorsService corsService,
        CorsPolicy policy,
        ILoggerFactory loggerFactory)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }        
        if (corsService == null)
        {
            throw new ArgumentNullException(nameof(corsService));
        }        
        if (policy == null)
        {
            throw new ArgumentNullException(nameof(policy));
        }        
        if (loggerFactory == null)
        {
            throw new ArgumentNullException(nameof(loggerFactory));
        }
                
        _next = next;        
        CorsService = corsService;        
        _policy = policy;        
        Logger = loggerFactory.CreateLogger<CorsMiddleware>();
    }
            
    /// <inheritdoc />
    public Task Invoke(HttpContext context, ICorsPolicyProvider corsPolicyProvider)
    {
        // CORS policy resolution rules:        
        // 1. If there is an endpoint with IDisableCorsAttribute then CORS is not run
        // 2. If there is an endpoint with ICorsPolicyMetadata then use its policy or 
        //	  if there is an endpoint with IEnableCorsAttribute that has a policy name then fetch policy by name, 
        //	  prioritizing it above policy on middleware
        // 3. If there is no policy on middleware then use name on middleware
        
        // 从 http context 解析 endpoint
        var endpoint = context.GetEndpoint();
        // 向 endpoint 注入 'cors middleware with endpoint invoked key'（标记 processed cors middleware）
        if (endpoint != null)
        {            
            context.Items[CorsMiddlewareWithEndpointInvokedKey] = CorsMiddlewareWithEndpointInvokedValue;
        }
        
        // 如果 http context request 不包含 'cors constants.origin ()'，-> 下一个 middleware
        if (!context.Request.Headers.ContainsKey(CorsConstants.Origin))
        {
            return _next(context);
        }
        
        // Get the most significant CORS metadata for the endpoint
        // For backwards compatibility reasons this is then downcast to Enable/Disable metadata
        
        // 从 enpoint 解析 cors metadata，
        var corsMetadata = endpoint?.Metadata.GetMetadata<ICorsMetadata>();
        // 1- 如果 cors metadata 是 disable cors attribute
        if (corsMetadata is IDisableCorsAttribute)
        {
            // 如果 http reques 是 preflight request，但是标记了 disallow cors，-> 返回 204
            var isOptionsRequest = HttpMethods.IsOptions(context.Request.Method);            
            var isCorsPreflightRequest = 
                isOptionsRequest && context.Request.Headers.ContainsKey(CorsConstants.AccessControlRequestMethod);            
            if (isCorsPreflightRequest)
            {                
                context.Response.StatusCode = StatusCodes.Status204NoContent;
                return Task.CompletedTask;
            }
            
            return _next(context);
        }
        
        var corsPolicy = _policy;
        var policyName = _corsPolicyName;
        
        // 2- 如果 cors metadata 是 cors policy metadata，
        if (corsMetadata is ICorsPolicyMetadata corsPolicyMetadata)
        {
            // 从 cors policy metadata 解析 cors policy
            policyName = null;
            corsPolicy = corsPolicyMetadata.Policy;
        }
        // 3- 如果 cors metadata 是 enable cors attribute，并且 attribue 标记的 policy name 不为 null，
        else if (corsMetadata is IEnableCorsAttribute enableCorsAttribute &&
                 enableCorsAttribute.PolicyName != null)
        {
            // 从 cors enable attribute 解析 policy name
            policyName = enableCorsAttribute.PolicyName;
            corsPolicy = null;
        }
        
        // 如果 cors policy 为 null（cors metadata 是 cors enable attribute）
        if (corsPolicy == null)
        {
            // 从 cors policy provider（调用 invoke 时从 低 解析）解析 cors policy
            var policyTask = corsPolicyProvider.GetPolicyAsync(context, policyName);
            
            // 解析未完成，-> inovke core await
            if (!policyTask.IsCompletedSuccessfully)
            {                
                return InvokeCoreAwaited(context, policyTask);
            }
            // 解析完成，-> 得到 cors policy
            corsPolicy = policyTask.Result;
        }
        
        // 执行 evaluate & apply policy
        return EvaluateAndApplyPolicy(context, corsPolicy);
        
        async Task InvokeCoreAwaited(HttpContext context, Task<CorsPolicy?> policyTask)
        {
            var corsPolicy = await policyTask;
            await EvaluateAndApplyPolicy(context, corsPolicy);
        }
    }
    
    private Task EvaluateAndApplyPolicy(HttpContext context, CorsPolicy? corsPolicy)
    {
        // cors policy 为 null，->下一个middleware
        if (corsPolicy == null)
        {
            Logger.NoCorsPolicyFound();
            return _next(context);
        }
        
        // 由 cors service 执行 evaluate，得到 cors result
        var corsResult = CorsService.EvaluatePolicy(context, corsPolicy);
        
        // 1- 如果是 preflight request，
        if (corsResult.IsPreflightRequest)
        {
            // 由 cors service 执行 apply result
            CorsService.ApplyResult(corsResult, context.Response);            
            // 返回 204
            context.Response.StatusCode = StatusCodes.Status204NoContent;
            return Task.CompletedTask;
        }
        // 2- （不是 preflight request）
        else
        {
            // 向 http context response 注入委托（在 response starting 时执行 cors service 的 apply result
            context.Response.OnStarting(
                OnResponseStartingDelegate, 
                Tuple.Create(this, context, corsResult));
            
            return _next(context);
        }
    }
    
    private readonly Func<object, Task> OnResponseStartingDelegate = OnResponseStarting;
    private static Task OnResponseStarting(object state)
    {
        var (middleware, context, result) = (Tuple<CorsMiddleware, HttpContext, CorsResult>)state;
        
        try
        {
            middleware.CorsService.ApplyResult(result, context.Response);
        }
        catch (Exception exception)
        {
            middleware.Logger.FailedToSetCorsHeaders(exception);
        }
        
        return Task.CompletedTask;
    }
}

```

###### 2.6.4.2 cors policy metadata

```c#
public interface ICorsPolicyMetadata : ICorsMetadata
{    
    CorsPolicy Policy { get; }
}

public class CorsPolicyMetadata : ICorsPolicyMetadata
{
    public CorsPolicy Policy { get; }
    
    public CorsPolicyMetadata(CorsPolicy policy)
    {
        Policy = policy;
    }    
}

```

###### 2.6.4.3 disable cors attribute

```c#
public interface IDisableCorsAttribute : ICorsMetadata
{
}

[AttributeUsage(
    AttributeTargets.Class | AttributeTargets.Method, 
    AllowMultiple = false, 
    Inherited = false)]
public class DisableCorsAttribute : Attribute, IDisableCorsAttribute
{
}

```

###### 2.6.4.4 enable cors attribute

```c#
public interface IEnableCorsAttribute : ICorsMetadata
{    
    string? PolicyName { get; set; }
}

[AttributeUsage(
    AttributeTargets.Class | AttributeTargets.Method, 
    AllowMultiple = false, 
    Inherited = true)]
public class EnableCorsAttribute : Attribute, IEnableCorsAttribute
{        
    public string? PolicyName { get; set; }
    
    public EnableCorsAttribute() : this(policyName: null)
    {
    }
        
    public EnableCorsAttribute(string? policyName)
    {
        PolicyName = policyName;
    }            
}

```

### 3. websocket

#### 3.1 websocket helper

```c#
internal static class HandshakeHelpers
{    
    internal static class Constants
    {
        public static class Headers
        {                  
            public const string UpgradeWebSocket = "websocket"; 
            public const string ConnectionUpgrade = "Upgrade";
            public const string SupportedVersion = "13";
        }
    }
    
    public static readonly IEnumerable<string> NeededHeaders = new[]
    {
        HeaderNames.Upgrade,
        HeaderNames.Connection,
        HeaderNames.SecWebSocketKey,
        HeaderNames.SecWebSocketVersion
    };
    
    // "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
    // This uses C# compiler's ability to refer to static data directly. 
    private static ReadOnlySpan<byte> EncodedWebSocketKey => new byte[]
    {
        (byte)'2', (byte)'5', (byte)'8', (byte)'E', (byte)'A', (byte)'F', (byte)'A', (byte)'5',
        (byte)'-',
        (byte)'E', (byte)'9', (byte)'1', (byte)'4', 
        (byte)'-', 
        (byte)'4', (byte)'7', (byte)'D', (byte)'A',
        (byte)'-', 
        (byte)'9', (byte)'5', (byte)'C', (byte)'A', 
        (byte)'-', 
        (byte)'C', (byte)'5', (byte)'A', (byte)'B', (byte)'0', (byte)'D', (byte)'C', (byte)'8', 
        (byte)'5', (byte)'B', (byte)'1', (byte)'1'
    };
    
    // 方法- 验证是否支持 web socket request
    // （Verify Method, Upgrade, Connection, version,  key, etc..）
    public static bool CheckSupportedWebSocketRequest(
        string method, 
        IEnumerable<KeyValuePair<string, string>> headers)
    {
        bool validUpgrade = false, validConnection = false, validKey = false, validVersion = false;
        
        // validate method - 如果不是 get 方法，-> false
        if (!string.Equals("GET", method, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }
        
        // 遍历 request header，
        foreach (var pair in headers)
        {
            // validate connection - 如果 header 有 [connection, "upgrade"]，-> true
            if (string.Equals(HeaderNames.Connection, pair.Key, StringComparison.OrdinalIgnoreCase))
            {
                if (string.Equals(
                    	Constants.Headers.ConnectionUpgrade, 
                    	pair.Value, 
                    	StringComparison.OrdinalIgnoreCase))
                {
                    validConnection = true;
                }
            }
            // validate upgrade - 如果 header 有 [upgrade, "websocket"]，-> true
            else if (string.Equals(HeaderNames.Upgrade, pair.Key, StringComparison.OrdinalIgnoreCase))
            {
                if (string.Equals(
                    	Constants.Headers.UpgradeWebSocket, 
                    	pair.Value, 
                    	StringComparison.OrdinalIgnoreCase))
                {
                    validUpgrade = true;
                }
            }
            // validate version - 如果 header 有 [sec websocket version, "13"]
            else if (string.Equals(HeaderNames.SecWebSocketVersion, pair.Key, StringComparison.OrdinalIgnoreCase))
            {
                if (string.Equals(
                    	Constants.Headers.SupportedVersion, 
                    	pair.Value, 
                    	StringComparison.OrdinalIgnoreCase))
                {
                    validVersion = true;
                }
            }
            // validate key - 如果 header 有 [sec websocket key, ...]，
            else if (string.Equals(HeaderNames.SecWebSocketKey, pair.Key, StringComparison.OrdinalIgnoreCase))
            {
                // 验证 value 是否 request valid key
                validKey = IsRequestKeyValid(pair.Value);
            }
        }
        
        // 全部满足 -> true
        return validConnection && validUpgrade && validVersion && validKey;
    }
    
    // 方法- 验证 request key valid
    public static bool IsRequestKeyValid(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return false;
        }
        
        Span<byte> temp = stackalloc byte[16];
        var success = Convert.TryFromBase64String(value, temp, out var written);
        return success && written == 16;
    }
    
    // 方法- 创建 response header
    public static void GenerateResponseHeaders(
        string key, 
        string? subProtocol, 
        IHeaderDictionary headers)
    {
        // connection
        headers[HeaderNames.Connection] = Constants.Headers.ConnectionUpgrade;
        // upgrade
        headers[HeaderNames.Upgrade] = Constants.Headers.UpgradeWebSocket;
        // sec web socket accept
        headers[HeaderNames.SecWebSocketAccept] = CreateResponseKey(key);
        // sec web socket protocol
        if (!string.IsNullOrWhiteSpace(subProtocol))
        {
            headers[HeaderNames.SecWebSocketProtocol] = subProtocol;
        }
    }
                
    // 方法- 创建 response key
    public static string CreateResponseKey(string requestKey)
    {
        // "The value of this header field is constructed by concatenating /key/, defined above in step 4 in Section 4.2.2, 
        // with the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", taking the SHA-1 hash of this concatenated value to 
        // obtain a 20-byte value and base64-encoding"
        // https://tools.ietf.org/html/rfc6455#section-4.2.2 requestKey is already verified to be small (24 bytes) by 
        // 'IsRequestKeyValid()' and everything is 1:1 mapping to UTF8 bytes so this can be hardcoded to 60 bytes for the 
        // requestKey + static websocket string
        Span<byte> mergedBytes = stackalloc byte[60];
        Encoding.UTF8.GetBytes(requestKey, mergedBytes);
        EncodedWebSocketKey.CopyTo(mergedBytes.Slice(24));
        
        Span<byte> hashedBytes = stackalloc byte[20];
        var written = SHA1.HashData(mergedBytes, hashedBytes);
        if (written != 20)
        {
            throw new InvalidOperationException(
                "Could not compute the hash for the 'Sec-WebSocket-Accept' header.");
        }
        
        return Convert.ToBase64String(hashedBytes);
    }
}

```

#### 3.2 websocket feature

```c#
// 接口
public interface IHttpWebSocketFeature
{    
    bool IsWebSocketRequest { get; }        
    Task<WebSocket> AcceptAsync(WebSocketAcceptContext context);
}

// 实现
public class WebSocketMiddleware
{
    private class UpgradeHandshake : IHttpWebSocketFeature
    {
        private readonly HttpContext _context;
        private readonly IHttpUpgradeFeature _upgradeFeature;
        private readonly WebSocketOptions _options;
        
        // is websocket request
        private bool? _isWebSocketRequest;
        public bool IsWebSocketRequest
        {            
            get
            {
                // 如果 _isWebSocketRequest 为 null，
                if (_isWebSocketRequest == null)
                {
                    // 如果 http upgrade feature 不是 upgradable request，-> false
                    if (!_upgradeFeature.IsUpgradableRequest)
                    {
                        _isWebSocketRequest = false;
                    }
                    else
                    {
                        // 解析 http request (hand shake) header
                        var headers = new List<KeyValuePair<string, string>>();
                        foreach (string headerName in HandshakeHelpers.NeededHeaders)
                        {
                            foreach (var value in _context.Request.Headers.GetCommaSeparatedValues(headerName))
                            {
                                headers.Add(new KeyValuePair<string, string>(headerName, value));
                            }
                        }
                        
                        // 使用 hand shake helper 判断 is websocket request
                        _isWebSocketRequest = HandshakeHelpers.CheckSupportedWebSocketRequest(
                            _context.Request.Method, 
                            headers);
                    }
                }
                
                return _isWebSocketRequest.Value;
            }
        }
        
        public UpgradeHandshake(
            HttpContext context, 
            IHttpUpgradeFeature upgradeFeature, 
            WebSocketOptions options)
        {
            _context = context;
            _upgradeFeature = upgradeFeature;
            _options = options;
        }
                   
        // 方法- accept 
        public async Task<WebSocket> AcceptAsync(WebSocketAcceptContext acceptContext)
        {
            // 如果 http request 不是 websocket request，抛出异常
            if (!IsWebSocketRequest)
            {
                throw new InvalidOperationException("Not a WebSocket request.");
            }
            
            // 解析 sup protocol 
            string? subProtocol = null;            
            if (acceptContext != null)
            {
                subProtocol = acceptContext.SubProtocol;
            }
            
            // 解析 keep alive interval
            TimeSpan keepAliveInterval = _options.KeepAliveInterval;            
            var advancedAcceptContext = acceptContext as ExtendedWebSocketAcceptContext;
            if (advancedAcceptContext != null)
            {
                if (advancedAcceptContext.KeepAliveInterval.HasValue)
                {
                    keepAliveInterval = advancedAcceptContext.KeepAliveInterval.Value;
                }
            }
            
            // 解析 http request header - sec websocket key
            string key = _context.Request.Headers[HeaderNames.SecWebSocketKey];
            
            // 创建 http response header
            HandshakeHelpers.GenerateResponseHeaders(
                key, 
                subProtocol, 
                _context.Response.Headers);
                        
            // Sets status code to 101
            // 通过 upgrade feature 创建 stream
            Stream opaqueTransport = await _upgradeFeature.UpgradeAsync(); 
            
            return WebSocket.CreateFromStream(
                opaqueTransport, 
                isServer: true, 
                subProtocol: subProtocol, 
                keepAliveInterval: keepAliveInterval);
        }
    }
}
    
```

##### 3.2.1 webscoket accept context

```c#
public class WebSocketAcceptContext
{    
    public virtual string? SubProtocol { get; set; }
}

```

##### 3.2.2 extended websocket accept context

```c#
public class ExtendedWebSocketAcceptContext : WebSocketAcceptContext
{    
    public override string? SubProtocol { get; set; }                
    public TimeSpan? KeepAliveInterval { get; set; }
}

```

#### 3.3 add websocket

```c#
public static class WebSocketsDependencyInjectionExtensions
{    
    public static IServiceCollection AddWebSockets(
        this IServiceCollection services, 
        Action<WebSocketOptions> configure)
    {
        if (configure is null)
        {
            throw new ArgumentNullException(nameof(configure));
        }
        
        return services.Configure(configure);
    }
}

```

##### 3.3.1 websocket options

```c#
public class WebSocketOptions
{    
    public TimeSpan KeepAliveInterval { get; set; }    
    public IList<string> AllowedOrigins { get; }
    
    public WebSocketOptions()
    {
        KeepAliveInterval = TimeSpan.FromMinutes(2);
        AllowedOrigins = new List<string>();
    }        
}

```

#### 3.4 use websocket

```c#
public static class WebSocketMiddlewareExtensions
{        
    public static IApplicationBuilder UseWebSockets(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<WebSocketMiddleware>();
    }
        
    public static IApplicationBuilder UseWebSockets(
        this IApplicationBuilder app, 
        WebSocketOptions options)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        return app.UseMiddleware<WebSocketMiddleware>(Options.Create(options));
    }
}

```

##### 3.4.1 websocket middleware

```c#
public class WebSocketMiddleware
{
    private readonly RequestDelegate _next;
    private readonly WebSocketOptions _options;
    private readonly ILogger _logger;
    
    private readonly bool _anyOriginAllowed;
    private readonly List<string> _allowedOrigins;
        
    public WebSocketMiddleware(
        RequestDelegate next, 
        IOptions<WebSocketOptions> options, 
        ILoggerFactory loggerFactory)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        _next = next;
        _options = options.Value;
                
        // 解析 allowed origins
        _allowedOrigins = _options.AllowedOrigins.Select(o => o.ToLowerInvariant()).ToList();
        // 从 allowed options 解析 allow any origin (flag)
        _anyOriginAllowed = 
            _options.AllowedOrigins.Count == 0 || _options.AllowedOrigins.Contains("*", StringComparer.Ordinal);

         _logger = loggerFactory.CreateLogger<WebSocketMiddleware>();                   
    }
        
    public Task Invoke(HttpContext context)
    {        
        // 解析 upgrade feature
        var upgradeFeature = context.Features.Get<IHttpUpgradeFeature>();
        
        // 如果能解析到 upgrade featue，但是 websocket feature 为 null
        if (upgradeFeature != null && 
            context.Features.Get<IHttpWebSocketFeature>() == null)
        {
            // 创建 websocket feature (upgrade handshake)，            
            var webSocketFeature = new UpgradeHandshake(context, upgradeFeature, _options);
            // 并注入到 http context features
            context.Features.Set<IHttpWebSocketFeature>(webSocketFeature);
            
            // 如果没有标记 allow any orgin (flag)，即启用了 host 过滤
            if (!_anyOriginAllowed)
            {                
                // 解析 http request header - origin header
                var originHeader = context.Request.Headers[HeaderNames.Origin];
                
                // 如果 origin header 不为空，且（request）是 websocket request，
                if (!StringValues.IsNullOrEmpty(originHeader) && 
                    webSocketFeature.IsWebSocketRequest)
                {
                    // 但是如果 origin header 不在 allowed origins 集合中，-> 返回403
                    if (!_allowedOrigins.Contains(originHeader.ToString(), StringComparer.Ordinal))
                    {
                        _logger.LogDebug(
                            "Request origin {Origin} is not in the list of allowed origins.", 
                            originHeader);
                        
                        // 设置 status code = 403
                        context.Response.StatusCode = StatusCodes.Status403Forbidden;
                        return Task.CompletedTask;
                    }
                }
            }
        }
        
        return _next(context);
    }        
}

```



### 4. http override

#### 4.1 http method override

##### 4.1.1 http method override options

```c#
public class HttpMethodOverrideOptions
{    
    public string? FormFieldName { get; set; }
}

```

##### 4.1.2 use http method override

```c#
public static class HttpMethodOverrideExtensions
{    
    // Allows incoming POST request to override method type with type specified in header. 
    // This middleware is used when a client is limited to sending GET or POST methods but wants to invoke other HTTP methods.
    // By default, the X-HTTP-Method-Override request header is used to specify the HTTP method being tunneled.
    
    public static IApplicationBuilder UseHttpMethodOverride(this IApplicationBuilder builder)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }
        
        return builder.UseMiddleware<HttpMethodOverrideMiddleware>();
    }
        
    public static IApplicationBuilder UseHttpMethodOverride(
        this IApplicationBuilder builder, 
        HttpMethodOverrideOptions options)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        return builder.UseMiddleware<HttpMethodOverrideMiddleware>(Options.Create(options));
    }
}

```

###### 4.1.2.1 http method override middleware

```c#
public class HttpMethodOverrideMiddleware
{
    private const string xHttpMethodOverride = "X-Http-Method-Override";
    
    private readonly RequestDelegate _next;
    private readonly HttpMethodOverrideOptions _options;
        
    public HttpMethodOverrideMiddleware(
        RequestDelegate next, 
        IOptions<HttpMethodOverrideOptions> options)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        //
        _next = next;
        // 
        _options = options.Value;
    }
       
    public async Task Invoke(HttpContext context)
    {
        // 如果 request 是 post（只有 post 支持 method override）
        if (HttpMethods.IsPost(context.Request.Method))
        {
            // 如果 http method override options 中 form filed name 不为 null，
            if (_options.FormFieldName != null)
            {
                // 且有 form content type，
                if (context.Request.HasFormContentType)
                {
                    // 从 form 中解析 method type，并写回 http context request
                    var form = await context.Request.ReadFormAsync();                    
                    var methodType = form[_options.FormFieldName];
                    if (!string.IsNullOrEmpty(methodType))
                    {
                        context.Request.Method = methodType;
                    }
                }
            }
            // （否则），即 options 中 form field name 为 null，
            else
            {
                // 从 request header 中解析 "x-http-method-override"，并写回 http context response
                var xHttpMethodOverrideValue = context.Request.Headers[xHttpMethodOverride];
                if (!string.IsNullOrEmpty(xHttpMethodOverrideValue))
                {
                    context.Request.Method = xHttpMethodOverrideValue;
                }
            }
        }
                
        await _next(context);
    }
}

```

#### 4.2 forwarded header

##### 4.2.1 forwarded headers options

```c#
public class ForwardedHeadersOptions
{    
    // header name for "forwarded"
    public string ForwardedForHeaderName { get; set; } = ForwardedHeadersDefaults.XForwardedForHeaderName;        
    public string ForwardedHostHeaderName { get; set; } = ForwardedHeadersDefaults.XForwardedHostHeaderName;       
    public string ForwardedProtoHeaderName { get; set; } = ForwardedHeadersDefaults.XForwardedProtoHeaderName;
    
    // header name for "original"    
    public string OriginalForHeaderName { get; set; } = ForwardedHeadersDefaults.XOriginalForHeaderName;       
    public string OriginalHostHeaderName { get; set; } = ForwardedHeadersDefaults.XOriginalHostHeaderName;        
    public string OriginalProtoHeaderName { get; set; } = ForwardedHeadersDefaults.XOriginalProtoHeaderName;
       
    // headers flag
    public ForwardedHeaders ForwardedHeaders { get; set; }
        
    public int? ForwardLimit { get; set; } = 1;       
    public IList<IPAddress> KnownProxies { get; } = new List<IPAddress>() { IPAddress.IPv6Loopback };        
    public IList<IPNetwork> KnownNetworks { get; } = new List<IPNetwork>() { new IPNetwork(IPAddress.Loopback, 8) };                
    public IList<string> AllowedHosts { get; set;  } = new List<string>();        
    public bool RequireHeaderSymmetry { get; set; } = false;
}

```

###### 4.2.1.1 forwarded headers (enum)

```c#
[Flags]
public enum ForwardedHeaders
{        
    None = 0,	// Do not process any forwarders    			    
    XForwardedFor = 1 << 0,		// Process X-Forwarded-For (ip)    
    XForwardedHost = 1 << 1,   	// Process X-Forwarded-Host (host)    
    XForwardedProto = 1 << 2,   // Process X-Forwarded-Proto (protocol)      
    All = XForwardedFor | XForwardedHost | XForwardedProto
}

```

###### 4.2.1.2 forwarded headers defaults

```c#
public static class ForwardedHeadersDefaults
{    
    public static string XForwardedForHeaderName { get; } = "X-Forwarded-For";        
    public static string XForwardedHostHeaderName { get; } = "X-Forwarded-Host";        
    public static string XForwardedProtoHeaderName { get; } = "X-Forwarded-Proto";        
    
    public static string XOriginalForHeaderName { get; } = "X-Original-For";        
    public static string XOriginalHostHeaderName { get; } = "X-Original-Host";        
    public static string XOriginalProtoHeaderName { get; } = "X-Original-Proto";
}

```

##### 4.2.2 use forwarded headers

```c#
public static class ForwardedHeadersExtensions
{
    private const string ForwardedHeadersAdded = "ForwardedHeadersAdded";
         
    //
    public static IApplicationBuilder UseForwardedHeaders(
        this IApplicationBuilder builder, 
        ForwardedHeadersOptions options)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        return builder.UseMiddleware<ForwardedHeadersMiddleware>(Options.Create(options));
    }
    
    //
    public static IApplicationBuilder UseForwardedHeaders(this IApplicationBuilder builder)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }
        
        // 如果 application builder 没有标记 "forwarded headers added"，（只注入一次）
        if (!builder.Properties.ContainsKey(ForwardedHeadersAdded))
        {
            // 标记 forwarded headers add
            builder.Properties[ForwardedHeadersAdded] = true;
            // 注入 forwarded headers middleware
            return builder.UseMiddleware<ForwardedHeadersMiddleware>();
        }
        
        return builder;
    }                
}

```

###### 4.2.2.1 forwarded headers middleware

```c#
public class ForwardedHeadersMiddleware
{
    private static readonly bool[] HostCharValidity = new bool[127];
    private static readonly bool[] SchemeCharValidity = new bool[123];
               
    static ForwardedHeadersMiddleware()
    {
        // scheme, RFC 3986 scheme = ALPHA * (ALPHA / DIGIT / "+" / "-" / ".")
        SchemeCharValidity['+'] = true;
        SchemeCharValidity['-'] = true;
        SchemeCharValidity['.'] = true;
        
        // host, RFC 3986 except "*" / "+" / "," / ";" / "=" and "%" which are not allowed by Http.Sys
        HostCharValidity['!'] = true;
        HostCharValidity['$'] = true;
        HostCharValidity['&'] = true;
        HostCharValidity['\''] = true;
        HostCharValidity['('] = true;
        HostCharValidity[')'] = true;
        HostCharValidity['-'] = true;
        HostCharValidity['.'] = true;
        HostCharValidity['_'] = true;
        HostCharValidity['~'] = true;
        
        // digit
        for (var ch = '0'; ch <= '9'; ch++)
        {
            SchemeCharValidity[ch] = true;
            HostCharValidity[ch] = true;
        }
        
        // alpha
        for (var ch = 'A'; ch <= 'Z'; ch++)
        {
            SchemeCharValidity[ch] = true;
            HostCharValidity[ch] = true;
        }
        for (var ch = 'a'; ch <= 'z'; ch++)
        {
            SchemeCharValidity[ch] = true;
            HostCharValidity[ch] = true;
        }
    }
            
    private readonly ForwardedHeadersOptions _options;
    private readonly RequestDelegate _next;
    private readonly ILogger _logger;
    
    private bool _allowAllHosts;
    private IList<StringSegment>? _allowedHosts;
        
    public ForwardedHeadersMiddleware(
        RequestDelegate next, 
        ILoggerFactory loggerFactory, 
        IOptions<ForwardedHeadersOptions> options)
    {
        if (next == null)
        {
            throw new ArgumentNullException(nameof(next));
        }
        if (loggerFactory == null)
        {
            throw new ArgumentNullException(nameof(loggerFactory));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        // Make sure required options is not null or whitespace, otherwise thrown exceptions
        EnsureOptionNotNullorWhitespace(options.Value.ForwardedForHeaderName, nameof(options.Value.ForwardedForHeaderName));        
        EnsureOptionNotNullorWhitespace(options.Value.ForwardedHostHeaderName, nameof(options.Value.ForwardedHostHeaderName));        
        EnsureOptionNotNullorWhitespace(options.Value.ForwardedProtoHeaderName, nameof(options.Value.ForwardedProtoHeaderName));        
        EnsureOptionNotNullorWhitespace(options.Value.OriginalForHeaderName, nameof(options.Value.OriginalForHeaderName));        
        EnsureOptionNotNullorWhitespace(options.Value.OriginalHostHeaderName, nameof(options.Value.OriginalHostHeaderName));        
        EnsureOptionNotNullorWhitespace(options.Value.OriginalProtoHeaderName, nameof(options.Value.OriginalProtoHeaderName));
        
        // 注入 forwarded header options
        _options = options.Value;
        // 注入 next（request delegate）
        _next = next;        
        _logger = loggerFactory.CreateLogger<ForwardedHeadersMiddleware>();
        
        PreProcessHosts();
    }
    
    private static void EnsureOptionNotNullorWhitespace(
        string value, 
        string propertyName)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new ArgumentException($"options.{propertyName} is required", "options");
        }
    }
    
    private void PreProcessHosts()
    {
        // 如果 forwarded header options 的 allow hosts 为空，-> 认为 all host is allowed
        if (_options.AllowedHosts == null || _options.AllowedHosts.Count == 0)
        {
            _allowAllHosts = true;
            return;
        }
        
        // allowed host（预结果）
        var allowedHosts = new List<StringSegment>();
        
        // 遍历 forwarded header options 的 allow host 集合，
        foreach (var entry in _options.AllowedHosts)
        {            
            // Punycode. Http.Sys requires you to register Unicode hosts, but the headers contain punycode.
            var host = new HostString(entry).ToUriComponent();            
            
            // 如果 host 是 top level wildcard，-> 标记 allow all host，结束
            if (IsTopLevelWildcard(host))
            {                
                _allowAllHosts = true;
                return;
            }
            
            // 如果 forwarded headers options 的 host 不在 allow host（预结果）中，-> 添加
            if (!allowedHosts.Contains(host, StringSegmentComparer.OrdinalIgnoreCase))
            {
                allowedHosts.Add(host);
            }
        }
        
        _allowedHosts = allowedHosts;
    }
    
    private bool IsTopLevelWildcard(string host)
    {
        return (
            // HttpSys wildcard
            string.Equals("*", host, StringComparison.Ordinal) || 
            // Kestrel wildcard, IPv6 Any
            string.Equals("[::]", host, StringComparison.Ordinal) || 
            // IPv4 Any
            string.Equals("0.0.0.0", host, StringComparison.Ordinal)); 
    }
            
    // 方法- invoke
    public Task Invoke(HttpContext context)
    {
        ApplyForwarders(context);
        return _next(context);
    }
            
    public void ApplyForwarders(HttpContext context)
    {
        /* 封装 forwarded headers options 的 info => sets */
        // 预结果        
        string[]? forwardedFor = null, forwardedProto = null, forwardedHost = null;        
        bool checkFor = false, checkProto = false, checkHost = false;        
        int entryCount = 0;
        
        // 解析 http request、http request header
        var request = context.Request;
        var requestHeaders = context.Request.Headers;
        
        // 如果 forwarded header options 标记了 "x-forwarded-for"，
        if (_options.ForwardedHeaders.HasFlag(ForwardedHeaders.XForwardedFor))
        {
            // 解析 "x-forwarded-for" value
            checkFor = true;
            forwardedFor = requestHeaders.GetCommaSeparatedValues(_options.ForwardedForHeaderName);
            entryCount = Math.Max(forwardedFor.Length, entryCount);
        }
        
        // 如果 forwarded header options 标记了 "x-forwarded-proto"
        if (_options.ForwardedHeaders.HasFlag(ForwardedHeaders.XForwardedProto))
        {
            // 解析 "x-forwarded-proto" value
            checkProto = true;
            forwardedProto = requestHeaders.GetCommaSeparatedValues(_options.ForwardedProtoHeaderName);
            
            // 如果 forwarded header options 标记了 require header symmetry，
            // 并且 checkfor=true（即 forwarded_for 不为空）
            // 但是 forwarded_for 和 forwarded_proto 集合长度不同，
            // -> 抛出异常
            if (_options.RequireHeaderSymmetry && 
                checkFor && 
                forwardedFor!.Length != forwardedProto.Length)
            {
                _logger.LogWarning(1, "Parameter count mismatch between X-Forwarded-For and X-Forwarded-Proto.");
                return;
            }
            
            entryCount = Math.Max(forwardedProto.Length, entryCount);
        }
        
        // 如果 forwarded header options 标记了 "x-forwarded-host"
        if (_options.ForwardedHeaders.HasFlag(ForwardedHeaders.XForwardedHost))
        {
            // 解析 "x-forwarded-host" value
            checkHost = true;
            forwardedHost = requestHeaders.GetCommaSeparatedValues(_options.ForwardedHostHeaderName);
            
            // 如果 forwarded header options 标记了 require header symmetry，
            // 并且 checkfor=true（即 forwarded_for 不为空），但是 forwarded_for 和 forwarded_host 集合长度不同，
            // 或者 checkProto=true（即 forwarded_proto 不为空），但是 forwarded_proto 和 forwarded_host 集合长度不同，
            // -> 抛出异常
            if (_options.RequireHeaderSymmetry && 
                ((checkFor && forwardedFor!.Length != forwardedHost.Length)|| 
                 (checkProto && forwardedProto!.Length != forwardedHost.Length)))
            {
                _logger.LogWarning(1, "Parameter count mismatch between X-Forwarded-Host and X-Forwarded-For or X-Forwarded-Proto.");
                return;
            }
            
            entryCount = Math.Max(forwardedHost.Length, entryCount);
        }
        
        // 如果 forwarded headers options 标记了 forward limit，-> 截取 limit 长度的 forward header value
        if (_options.ForwardLimit.HasValue && entryCount > _options.ForwardLimit)
        {
            entryCount = _options.ForwardLimit.Value;
        }
        
        // 封装解析到的 forwarded info => sets（set of forwarders 实例）
        var sets = new SetOfForwarders[entryCount];
        for (int i = 0; i < sets.Length; i++)
        {
            // They get processed in reverse order, right to left.
            var set = new SetOfForwarders();
            if (checkFor && i < forwardedFor!.Length)
            {
                set.IpAndPortText = forwardedFor[forwardedFor.Length - i - 1];
            }
            if (checkProto && i < forwardedProto!.Length)
            {
                set.Scheme = forwardedProto[forwardedProto.Length - i - 1];
            }
            if (checkHost && i < forwardedHost!.Length)
            {
                set.Host = forwardedHost[forwardedHost.Length - i - 1];
            }
            sets[i] = set;
        }
        
        // 解析 http context 原有 info（origin），=> current values（set of forwarders 实例）
        var connection = context.Connection;
        var currentValues = new SetOfForwarders()
        {
            RemoteIpAndPort = connection.RemoteIpAddress != null 
                ? new IPEndPoint(connection.RemoteIpAddress, connection.RemotePort) 
                : null,
            // Host and Scheme initial values are never inspected, no need to set them here.
        };
        
        /* 执行 */
        var checkKnownIps = _options.KnownNetworks.Count > 0 || _options.KnownProxies.Count > 0;        
        bool applyChanges = false;
        int entriesConsumed = 0;
        /* 执行 -a */
        // 遍历 sets（封装的、解析的 forwarded info）=> check changes requirement
        for (; entriesConsumed < sets.Length; entriesConsumed++)
        {
            var set = sets[entriesConsumed];
            
            // 1- check for
            if (checkFor)
            {                
                // 如果 origin info 的 remoteIpAndPort 不为空，
                // 且 options 标记了 check known ip（包含 known newtork & proxies），
                // 但是 origin remote ip and port 不在 known address，-> 结束（不是 allowed forward ip）
                if (currentValues.RemoteIpAndPort != null && 
                    checkKnownIps && 
                    !CheckKnownAddress(currentValues.RemoteIpAndPort.Address))
                {
                    // Stop at the first unknown remote IP, but still apply changes processed so far.
                    _logger.LogDebug(1, "Unknown proxy: {RemoteIpAndPort}", currentValues.RemoteIpAndPort);
                    break;
                }
                
                // 如果能从 set（封装解析的 info）的 ip and port text 中解析 ip&port
                if (IPEndPoint.TryParse(set.IpAndPortText, out var parsedEndPoint))
                {
                    applyChanges = true;
                    // -> 将 ip&port 注入 set
                    set.RemoteIpAndPort = parsedEndPoint;
                    // -> 将 ip&port text、ip&port 注入 current set
                    currentValues.IpAndPortText = set.IpAndPortText;
                    currentValues.RemoteIpAndPort = set.RemoteIpAndPort;
                }
                // （否则，即不能从 set 解析 ip and port），但是 set 的 ip and port text 不为 null，-> 结束
                else if (!string.IsNullOrEmpty(set.IpAndPortText))
                {
                    // Stop at the first unparsable IP, but still apply changes processed so far.
                    _logger.LogDebug(1, "Unparsable IP: {IpAndPortText}", set.IpAndPortText);
                    break;
                }
                // （否则，即不能从 set 解析 ip and port，且 set 的 ip and port text 是 null），
                // 如果 forwarded headers options 标记了 require symmetry，-> 结束
                else if (_options.RequireHeaderSymmetry)
                {
                    _logger.LogWarning(2, "Missing forwarded IPAddress.");
                    return;
                }
            }
            
            // 2- check proto
            if (checkProto)
            {
                // 如果 set 的 scheme（解析到的 scheme）不为 null，且通过 validate
                if (!string.IsNullOrEmpty(set.Scheme) && 
                    TryValidateScheme(set.Scheme))
                {
                    applyChanges = true;
                    // 将 scheme 注入 current set
                    currentValues.Scheme = set.Scheme;
                }
                // （否则，即 set 的 scheme 为 null，或者不能 validate），
                // 如果 forwarded header options 标记了 symmetry，-> 结束
                // （因为执行到这里，说明 check for 没有错误，但是不能解析 scheme，不满足 symmetry）
                else if (_options.RequireHeaderSymmetry)
                {
                    _logger.LogWarning(
                        3, 
                        $"Forwarded scheme is not present, this is required by {nameof(_options.RequireHeaderSymmetry)}");
                    return;
                }
            }
            
            // 3- check host
            if (checkHost)
            {
                // 如果 set 的 host（解析到的 host）不为 null，且通过 validate，
                // 并且能够匹配 allowed host（或者 allow all hosts）
                if (!string.IsNullOrEmpty(set.Host) && 
                    TryValidateHost(set.Host) && 
                    (_allowAllHosts || HostString.MatchesAny(set.Host, _allowedHosts!)))
                {
                    applyChanges = true;
                    // 将 host 注入 current set
                    currentValues.Host = set.Host;
                }
                // （否则），即 host 为 null，或者不能 validate，或者不匹配 allowed host 集合，
                // 如果 options 标记了 require header symmetry，-> break！
                // （因为执行到这里，说明 check for & check proto 没有错误，但是不能解析 host，不满足 symmetry）
                else if (_options.RequireHeaderSymmetry)
                {
                    _logger.LogWarning(4, 
                        $"Incorrect number of x-forwarded-host header values, see {nameof(_options.RequireHeaderSymmetry)}.");
                    return;
                }
            }
        }
        
        /* 执行 -b */
        // 如果标记了 apply changes（-a 做的判断）
        if (applyChanges)
        {
            // 1- apply for
            if (checkFor && currentValues.RemoteIpAndPort != null)
            {
                // 注入 "original for"
                if (connection.RemoteIpAddress != null)
                {
                    // Save the original
                    requestHeaders[_options.OriginalForHeaderName] = 
                        new IPEndPoint(connection.RemoteIpAddress, connection.RemotePort).ToString();
                }                
                // 注入 "forwarded for"
                if (forwardedFor!.Length > entriesConsumed)
                {
                    // Truncate the consumed header values
                    requestHeaders[_options.ForwardedForHeaderName] = 
                        forwardedFor.Take(forwardedFor.Length - entriesConsumed).ToArray();
                }
                else
                {
                    // All values were consumed
                    requestHeaders.Remove(_options.ForwardedForHeaderName);
                }
                
                // 修改 http connection 的 (remote) ip&port
                connection.RemoteIpAddress = currentValues.RemoteIpAndPort.Address;                
                connection.RemotePort = currentValues.RemoteIpAndPort.Port;
            }
            
            // 2- check proto
            if (checkProto && currentValues.Scheme != null)
            {
                // 注入 "original proto"
                requestHeaders[_options.OriginalProtoHeaderName] = request.Scheme;
                // 注入 "forwarded proto"
                if (forwardedProto!.Length > entriesConsumed)
                {
                    // Truncate the consumed header values
                    requestHeaders[_options.ForwardedProtoHeaderName] = 
                        forwardedProto.Take(forwardedProto.Length - entriesConsumed).ToArray();
                }
                else
                {
                    // All values were consumed
                    requestHeaders.Remove(_options.ForwardedProtoHeaderName);
                }
                
                // 修改 http request 的 scheme
                request.Scheme = currentValues.Scheme;
            }
            
            // 3- check host
            if (checkHost && currentValues.Host != null)
            {
                // 注入 "original host"
                requestHeaders[_options.OriginalHostHeaderName] = request.Host.ToString();
                // 注入 "forwareded host"
                if (forwardedHost!.Length > entriesConsumed)
                {
                    // Truncate the consumed header values
                    requestHeaders[_options.ForwardedHostHeaderName] = 
                        forwardedHost.Take(forwardedHost.Length - entriesConsumed).ToArray();
                }
                else
                {
                    // All values were consumed
                    requestHeaders.Remove(_options.ForwardedHostHeaderName);
                }
                
                // 修改 http request 的 host
                request.Host = HostString.FromUriComponent(currentValues.Host);
            }
        }
    }
    
    private struct SetOfForwarders
    {
        public string IpAndPortText;
        public IPEndPoint? RemoteIpAndPort;
        public string Host;
        public string Scheme;
    }
    
    private bool CheckKnownAddress(IPAddress address)
    {
        if (address.IsIPv4MappedToIPv6)
        {
            var ipv4Address = address.MapToIPv4();
            if (CheckKnownAddress(ipv4Address))
            {
                return true;
            }
        }
        if (_options.KnownProxies.Contains(address))
        {
            return true;
        }
        foreach (var network in _options.KnownNetworks)
        {
            if (network.Contains(address))
            {
                return true;
            }
        }
        return false;
    }            
    
    // Empty was checked for by the caller
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryValidateScheme(string scheme)
    {
        for (var i = 0; i < scheme.Length; i++)
        {
            if (!IsValidSchemeChar(scheme[i]))
            {
                return false;
            }
        }
        return true;
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool IsValidSchemeChar(char ch)
    {
        return ch < SchemeCharValidity.Length && SchemeCharValidity[ch];
    }
    
    // Empty was checked for by the caller
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryValidateHost(string host)
    {
        if (host[0] == '[')
        {
            return TryValidateIPv6Host(host);
        }
        
        if (host[0] == ':')
        {
            // Only a port
            return false;
        }
        
        var i = 0;
        for (; i < host.Length; i++)
        {
            if (!IsValidHostChar(host[i]))
            {
                break;
            }
        }
        return TryValidateHostPort(host, i);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool IsValidHostChar(char ch)
    {
        return ch < HostCharValidity.Length && HostCharValidity[ch];
    }
    
    // The lead '[' was already checked
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryValidateIPv6Host(string hostText)
    {
        for (var i = 1; i < hostText.Length; i++)
        {
            var ch = hostText[i];
            if (ch == ']')
            {
                // [::1] is the shortest valid IPv6 host
                if (i < 4)
                {
                    return false;
                }
                return TryValidateHostPort(hostText, i + 1);
            }
            
            if (!IsHex(ch) && ch != ':' && ch != '.')
            {
                return false;
            }
        }
        
        // Must contain a ']'
        return false;
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryValidateHostPort(string hostText, int offset)
    {
        if (offset == hostText.Length)
        {
            // No port
            return true;
        }
        
        if (hostText[offset] != ':' || hostText.Length == offset + 1)
        {
            // Must have at least one number after the colon if present.
            return false;
        }
        
        for (var i = offset + 1; i < hostText.Length; i++)
        {
            if (!IsNumeric(hostText[i]))
            {
                return false;
            }
        }
        
        return true;
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool IsNumeric(char ch)
    {
        return '0' <= ch && ch <= '9';
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool IsHex(char ch)
    {
        return IsNumeric(ch) || ('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F');
    }
}

```

#### 4.2 certificate forwarding

##### 4.2.1 add certificate forwarding

```c#
public static class CertificateForwardingServiceExtensions
{    
    public static IServiceCollection AddCertificateForwarding(
        this IServiceCollection services,
        Action<CertificateForwardingOptions> configure)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }        
        if (configure == null)
        {
            throw new ArgumentNullException(nameof(configure));
        }
        
        services.AddOptions<CertificateForwardingOptions>().Validate(
            o => !string.IsNullOrEmpty(o.CertificateHeader), 
            "CertificateForwarderOptions.CertificateHeader cannot be null or empty.");
        
        return services.Configure(configure);
    }
}

```

###### 4.2.1.1 certificate forwarding options

```c#
public class CertificateForwardingOptions
{    
    public string CertificateHeader { get; set; } = "X-Client-Cert";        
    public Func<string, X509Certificate2> HeaderConverter = (headerValue) => 
        new X509Certificate2(Convert.FromBase64String(headerValue));
}

```

##### 4.2.2 use certificate forwarding

```c#
public static class CertificateForwardingBuilderExtensions
{    
    public static IApplicationBuilder UseCertificateForwarding(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<CertificateForwardingMiddleware>();
    }
}

```

###### 4.2.2.1 certificate forwarding middleware

```c#
public class CertificateForwardingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly CertificateForwardingOptions _options;
    private readonly ILogger _logger;
          
    public CertificateForwardingMiddleware(
        RequestDelegate next,
        ILoggerFactory loggerFactory,
        IOptions<CertificateForwardingOptions> options)
    {
        _next = next ?? throw new ArgumentNullException(nameof(next));
        
        if (loggerFactory == null)
        {
            throw new ArgumentNullException(nameof(loggerFactory));
        }
        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        _options = options.Value;
        _logger = loggerFactory.CreateLogger<CertificateForwardingMiddleware>();
    }
        
    public Task Invoke(HttpContext httpContext)
    {
        // 解析 http request header 的 certificate header ["x-client-cert"]
        var header = httpContext.Request.Headers[_options.CertificateHeader];
        
        // 如果 request header 中 certificate header value 不为空，
        if (!StringValues.IsNullOrEmpty(header))
        {
            // 注入 certificate forwarding feature (tls connection feature)
            httpContext.Features.Set<ITlsConnectionFeature>(
                new CertificateForwardingFeature(_logger, header, _options));
        }
        
        return _next(httpContext);
    }
}

```

###### 4.2.2.2 certificate forwarding feature

```c#
internal class CertificateForwardingFeature : ITlsConnectionFeature
{
    private ILogger _logger;
    private StringValues _header;
    private CertificateForwardingOptions _options;
    private X509Certificate2? _certificate;
    
    public CertificateForwardingFeature(
        ILogger logger, 
        StringValues header, 
        CertificateForwardingOptions options)
    {
        _logger = logger;
        _options = options;
        _header = header;
    }
    
    public X509Certificate2? ClientCertificate
    {
        get
        {
            if (_certificate == null)
            {
                try
                {
                    _certificate = _options.HeaderConverter(_header);
                }
                catch (Exception e)
                {
                    _logger.NoCertificate(e);
                }
            }
            return _certificate;
        }
        
        set => _certificate = value;
    }
    
    public Task<X509Certificate2?> GetClientCertificateAsync(CancellationToken cancellationToken) => 
        Task.FromResult(ClientCertificate);
}

```

### 5. header propagation

#### 5.1 header propagation entry

```c#
public class HeaderPropagationEntry
{
    public string InboundHeaderName { get; }
    public string CapturedHeaderName { get; }
    
    // When present, the delegate will be evaluated once per request to provide the transformed header value. 
    // The delegate will be called regardless of whether a header with the name corresponding to "InboundHeaderName"
    // is present in the request. 
    // If the result of evaluating "ValueFilter" is null or empty, it will not be added to the propagated values.    
    public Func<HeaderPropagationContext, StringValues>? ValueFilter { get; }
    
    public HeaderPropagationEntry(
        string inboundHeaderName,
        string capturedHeaderName,
        Func<HeaderPropagationContext, StringValues>? valueFilter)
    {
        if (inboundHeaderName == null)
        {
            throw new ArgumentNullException(nameof(inboundHeaderName));
        }        
        if (capturedHeaderName == null)
        {
            throw new ArgumentNullException(nameof(capturedHeaderName));
        }
        
        InboundHeaderName = inboundHeaderName;
        CapturedHeaderName = capturedHeaderName;
        // May be null
        ValueFilter = valueFilter; 
    }    
}

```

##### 5.1.1 header propagation context

```c#
public readonly struct HeaderPropagationContext
{
    public HttpContext HttpContext { get; }    
    public string HeaderName { get; }    
    public StringValues HeaderValue { get; }
    
    public HeaderPropagationContext(
        HttpContext httpContext, 
        string headerName, 
        StringValues headerValue)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }        
        if (headerName == null)
        {
            throw new ArgumentNullException(nameof(headerName));
        }
        
        HttpContext = httpContext;
        HeaderName = headerName;
        HeaderValue = headerValue;
    }    
}

```

##### 5.1.2 header propagation entry collection

```c#
public sealed class HeaderPropagationEntryCollection : Collection<HeaderPropagationEntry>
{    
    //
    public void Add(string headerName)
    {
        if (headerName == null)
        {
            throw new ArgumentNullException(nameof(headerName));
        }
        
        Add(new HeaderPropagationEntry(headerName, headerName, valueFilter: null));
    }
    
    //
    public void Add(
        string headerName, 
        Func<HeaderPropagationContext, StringValues> valueFilter)
    {
        if (headerName == null)
        {
            throw new ArgumentNullException(nameof(headerName));
        }
        
        Add(new HeaderPropagationEntry(headerName, headerName, valueFilter));
    }
        
    //
    public void Add(
        string inboundHeaderName, 
        string outboundHeaderName)
    {
        if (inboundHeaderName == null)
        {
            throw new ArgumentNullException(nameof(inboundHeaderName));
        }        
        if (outboundHeaderName == null)
        {
            throw new ArgumentNullException(nameof(outboundHeaderName));
        }
        
        Add(new HeaderPropagationEntry(inboundHeaderName, outboundHeaderName, valueFilter: null));
    }
         
    //
    public void Add(
        string inboundHeaderName,
        string outboundHeaderName,
        Func<HeaderPropagationContext, StringValues> valueFilter)
    {
        if (inboundHeaderName == null)
        {
            throw new ArgumentNullException(nameof(inboundHeaderName));
        }        
        if (outboundHeaderName == null)
        {
            throw new ArgumentNullException(nameof(outboundHeaderName));
        }
        
        Add(new HeaderPropagationEntry(inboundHeaderName, outboundHeaderName, valueFilter));
    }
}

```



#### 5.2 add header propagation

```c#
public static class HeaderPropagationServiceCollectionExtensions
{                   
    public static IServiceCollection AddHeaderPropagation(
        this IServiceCollection services, 
        Action<HeaderPropagationOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }        
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        services.Configure(configureOptions);
        services.AddHeaderPropagation();        
        return services;
    }
    
     public static IServiceCollection AddHeaderPropagation(this IServiceCollection services)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        
        services.TryAddSingleton<HeaderPropagationValues>();        
        return services;
    }
}

```

##### 5.2.1 header propagation values

```c#
public class HeaderPropagationValues
{
    private readonly static AsyncLocal<IDictionary<string, StringValues>?> _headers = 
        new AsyncLocal<IDictionary<string, StringValues>?>();
    
    public IDictionary<string, StringValues>? Headers
    {
        get { return _headers.Value; }
        set { _headers.Value = value; }
    }
}

```

##### 5.2.2 header propagation options

```c#
public class HeaderPropagationOptions
{    
    // Entries in "Headers" are processed in order while capturing headers inside "HeaderPropagationMiddleware". 
    // This can cause an earlier entry to take precedence over a later entry if they have the same 
    // "HeaderPropagationEntry.CapturedHeaderName"
    public HeaderPropagationEntryCollection Headers { get; set; } = new HeaderPropagationEntryCollection();
}


```

#### 5.3 header propagation message handler

```c#
public class HeaderPropagationMessageHandler : DelegatingHandler
{
    private readonly HeaderPropagationValues _values;
    private readonly HeaderPropagationMessageHandlerOptions _options;
            
    public HeaderPropagationMessageHandler(
        HeaderPropagationMessageHandlerOptions options, 
        HeaderPropagationValues values)
    {
        _options = options ?? throw new ArgumentNullException(nameof(options));
        _values = values ?? throw new ArgumentNullException(nameof(values));
    }
           
    // If an header with the same name is already present in the request, even if empty, 
    // the corresponding propagated header will not be added.    
    protected override Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request, 
        CancellationToken cancellationToken)
    {
        var captured = _values.Headers;
        if (captured == null)
        {
            var message =
                $"The {nameof(HeaderPropagationValues)}.{nameof(HeaderPropagationValues.Headers)} property has not been " +
                $"initialized. Register the header propagation middleware by adding" + 
                $"'app.nameof(HeaderPropagationApplicationBuilderExtensions.UseHeaderPropagation)}()' " +
                $"in the 'Configure(...)' method. Header propagation can only be used within the context of an HTTP request.";
            
            throw new InvalidOperationException(message);
        }
                
        var entries = _options.Headers;
        for (var i = 0; i < entries.Count; i++)
        {
            var entry = entries[i];
            var hasContent = request.Content != null;
            
            if (!request.Headers.TryGetValues(entry.OutboundHeaderName, out var _) &&
                !(hasContent && 
                  request.Content!.Headers.TryGetValues(entry.OutboundHeaderName, out var _)))
            {
                if (captured.TryGetValue(entry.CapturedHeaderName, out var stringValues) &&
                    !StringValues.IsNullOrEmpty(stringValues))
                {
                    if (stringValues.Count == 1)
                    {
                        var value = (string)stringValues;
                        if (!request.Headers.TryAddWithoutValidation(entry.OutboundHeaderName, value) && 
                            hasContent)
                        {
                            request.Content!.Headers.TryAddWithoutValidation(entry.OutboundHeaderName, value);
                        }
                    }
                    else
                    {
                        var values = (string[])stringValues;
                        if (!request.Headers.TryAddWithoutValidation(entry.OutboundHeaderName, values) && 
                            hasContent)
                        {
                            request.Content!.Headers.TryAddWithoutValidation(entry.OutboundHeaderName, values);
                        }
                    }
                }
            }
        }
        
        return base.SendAsync(request, cancellationToken);
    }
}

```

##### 5.3.1 handler options

```c#
public class HeaderPropagationMessageHandlerOptions
{    
    public HeaderPropagationMessageHandlerEntryCollection Headers { get; set; } = 
        new HeaderPropagationMessageHandlerEntryCollection();
}

```

##### 5.3.2 handler entry

```c#
public class HeaderPropagationMessageHandlerEntry
{
    public string CapturedHeaderName { get; }
    public string OutboundHeaderName { get; }
    
    public HeaderPropagationMessageHandlerEntry(
        string capturedHeaderName,
        string outboundHeaderName)
    {
        if (capturedHeaderName == null)
        {
            throw new ArgumentNullException(nameof(capturedHeaderName));
        }        
        if (outboundHeaderName == null)
        {
            throw new ArgumentNullException(nameof(outboundHeaderName));
        }
        
        CapturedHeaderName = capturedHeaderName;
        OutboundHeaderName = outboundHeaderName;
    }        
}

```

###### 5.3.2.1 handler entry collection

```c#
public sealed class HeaderPropagationMessageHandlerEntryCollection : 
	Collection<HeaderPropagationMessageHandlerEntry>
{    
    public void Add(string headerName)
    {
        if (headerName == null)
        {
            throw new ArgumentNullException(nameof(headerName));
        }
        
        Add(new HeaderPropagationMessageHandlerEntry(headerName, headerName));
    }
        
    public void Add(string capturedHeaderName, string outboundHeaderName)
    {
        if (capturedHeaderName == null)
        {
            throw new ArgumentNullException(nameof(capturedHeaderName));
        }
        if (outboundHeaderName == null)
        {
            throw new ArgumentNullException(nameof(outboundHeaderName));
        }
        
        Add(new HeaderPropagationMessageHandlerEntry(capturedHeaderName, outboundHeaderName));
    }
}

```

#### 5.4 add header propagation

```c#
public static class HeaderPropagationHttpClientBuilderExtensions
{   
    // When using this method, all the configured headers will be applied to the outgoing HTTP requests.
    
    public static IHttpClientBuilder AddHeaderPropagation(this IHttpClientBuilder builder)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }
        
        builder.Services.AddHeaderPropagation();
        
        builder.AddHttpMessageHandler(services =>
            {
                var options = new HeaderPropagationMessageHandlerOptions();
                var middlewareOptions = services.GetRequiredService<IOptions<HeaderPropagationOptions>>();
                for (var i = 0; i < middlewareOptions.Value.Headers.Count; i++)
                {
                    var header = middlewareOptions.Value.Headers[i];
                    options.Headers.Add(header.CapturedHeaderName, header.CapturedHeaderName);
                }
                return new HeaderPropagationMessageHandler(
                    options, 
                    services.GetRequiredService<HeaderPropagationValues>());
            });
        
        return builder;
    }
            
    public static IHttpClientBuilder AddHeaderPropagation(
        this IHttpClientBuilder builder, 
        Action<HeaderPropagationMessageHandlerOptions> configure)
    {
        if (builder == null)
        {
            throw new ArgumentNullException(nameof(builder));
        }        
        if (configure == null)
        {
            throw new ArgumentNullException(nameof(configure));
        }
        
        builder.Services.AddHeaderPropagation();
        
        builder.AddHttpMessageHandler(services =>
            {
                var options = new HeaderPropagationMessageHandlerOptions();
                configure(options);
                return new HeaderPropagationMessageHandler(
                    options, 
                    services.GetRequiredService<HeaderPropagationValues>());
            });
        
        return builder;
    }
}

```

#### 5.4 use header propagation

```c#
public static class HeaderPropagationApplicationBuilderExtensions
{
    private static readonly string _unableToFindServices = string.Format(
        CultureInfo.CurrentCulture,
        "Unable to find the required services. Please add all the required services by calling '{0}.{1}'"
        "inside the call to 'ConfigureServices(...)' in the application startup code.",
        nameof(IServiceCollection),
        nameof(HeaderPropagationServiceCollectionExtensions.AddHeaderPropagation));
            
    public static IApplicationBuilder UseHeaderPropagation(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }        
        if (app.ApplicationServices.GetService<HeaderPropagationValues>() == null)
        {
            throw new InvalidOperationException(_unableToFindServices);
        }
        
        return app.UseMiddleware<HeaderPropagationMiddleware>();
    }
}

```

##### 5.4.1 header propagation middleware

```c#
public class HeaderPropagationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly HeaderPropagationOptions _options;
    private readonly HeaderPropagationValues _values;
            
    public HeaderPropagationMiddleware(
        RequestDelegate next, 
        IOptions<HeaderPropagationOptions> options, 
        HeaderPropagationValues values)
    {
        _next = next ?? throw new ArgumentNullException(nameof(next));
        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        _options = options.Value;        
        _values = values ?? throw new ArgumentNullException(nameof(values));
    }
                
    public Task Invoke(HttpContext context)
    {
        // We need to intialize the headers because the message handler will use this to detect misconfiguration.
        var headers = _values.Headers ??= new Dictionary<string, StringValues>(StringComparer.OrdinalIgnoreCase);
        
        // Perf: avoid foreach since we don't define a struct enumerator.
        var entries = _options.Headers;
        for (var i = 0; i < entries.Count; i++)
        {
            var entry = entries[i];
            
            // We intentionally process entries in order, and allow earlier entries to
            // take precedence over later entries when they have the same output name.
            if (!headers.ContainsKey(entry.CapturedHeaderName))
            {
                var value = GetValue(context, entry);
                if (!StringValues.IsNullOrEmpty(value))
                {
                    headers.Add(entry.CapturedHeaderName, value);
                }
            }
        }
        
        return _next.Invoke(context);
    }
    
    private static StringValues GetValue(HttpContext context, HeaderPropagationEntry entry)
    {
        context.Request.Headers.TryGetValue(entry.InboundHeaderName, out var value);
        if (entry.ValueFilter != null)
        {
            value = entry.ValueFilter(
                new HeaderPropagationContext(context, entry.InboundHeaderName, value));
        }
        
        return value;
    }
}

```

### 6. request localization

#### 6.1 request culture

```c#
public class RequestCulture
{
    public CultureInfo Culture { get; }        
    public CultureInfo UICulture { get; }
                
    public RequestCulture(CultureInfo culture) : this(culture, culture)
    {
    }
    
    public RequestCulture(string culture) : this(culture, culture)
    {
    }

    public RequestCulture(string culture, string uiCulture) : this (new CultureInfo(culture), new CultureInfo(uiCulture))
    {
    }
    
    public RequestCulture(CultureInfo culture, CultureInfo uiCulture)
    {
        if (culture == null)
        {
            throw new ArgumentNullException(nameof(culture));
        }        
        if (uiCulture == null)
        {
            throw new ArgumentNullException(nameof(uiCulture));
        }
        
        Culture = culture;
        UICulture = uiCulture;
    }            
}

```

#### 6.2 request culture provider

```c#
public interface IRequestCultureProvider
{    
    Task<ProviderCultureResult?> DetermineProviderCultureResult(HttpContext httpContext);
}

public abstract class RequestCultureProvider : IRequestCultureProvider
{
    protected static readonly Task<ProviderCultureResult?> NullProviderCultureResult = 
        Task.FromResult(default(ProviderCultureResult));  
    
    public RequestLocalizationOptions? Options { get; set; }    
    public abstract Task<ProviderCultureResult?> DetermineProviderCultureResult(HttpContext httpContext);
}

public class ProviderCultureResult
{
    public IList<StringSegment> Cultures { get; }       
    public IList<StringSegment> UICultures { get; }
            
    public ProviderCultureResult(StringSegment culture) : 
    	this(new List<StringSegment> { culture }, new List<StringSegment> { culture })
    {
    }
       
    public ProviderCultureResult(StringSegment culture, StringSegment uiCulture) : 
    	this(new List<StringSegment> { culture }, new List<StringSegment> { uiCulture })
    {
    }
       
    public ProviderCultureResult(IList<StringSegment> cultures) : 
    	this(cultures, cultures)
    {
    }
       
    public ProviderCultureResult(IList<StringSegment> cultures, IList<StringSegment> uiCultures)
    {
        Cultures = cultures;
        UICultures = uiCultures;
    }           
}

```

##### 6.2.1 query string request culture provider

```c#
public class QueryStringRequestCultureProvider : RequestCultureProvider
{   
    // Defaults to "culture".    
    public string QueryStringKey { get; set; } = "culture";        
    // Defaults to "ui-culture".   
    public string UIQueryStringKey { get; set; } = "ui-culture";
    
    public override Task<ProviderCultureResult?> DetermineProviderCultureResult(HttpContext httpContext)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        // 解析 http request
        var request = httpContext.Request;
        
        // 如果 request 的 query string 没有值，-> 返回 null provider result
        if (!request.QueryString.HasValue)
        {
            return NullProviderCultureResult;
        }
        
        string? queryCulture = null;
        string? queryUICulture = null;
        
        // 从 request query string 中按照 "query string key" 解析 query culture
        if (!string.IsNullOrWhiteSpace(QueryStringKey))
        {
            queryCulture = request.Query[QueryStringKey];
        }
        // 从 request query string 中按照 "ui query string key" 解析 query ui culture
        if (!string.IsNullOrWhiteSpace(UIQueryStringKey))
        {
            queryUICulture = request.Query[UIQueryStringKey];
        }
        
        // query cultrue & ui query cultrue 都为 null，-> null provider result
        if (queryCulture == null && queryUICulture == null)
        {
            // No values specified for either so no match
            return NullProviderCultureResult;
        }
        
        // query ui culture 为 null，设置为 query culture
        if (queryCulture != null && queryUICulture == null)
        {
            // Value for culture but not for UI culture so default to culture value for both
            queryUICulture = queryCulture;
        }
        // query culture 为 null，设置为 query ui culture
        else if (queryCulture == null && queryUICulture != null)
        {
            // Value for UI culture but not for culture so default to UI culture value for both
            queryCulture = queryUICulture;
        }
        
        // 创建 provider culture result 并返回
        var providerResultCulture = new ProviderCultureResult(queryCulture, queryUICulture);        
        return Task.FromResult<ProviderCultureResult?>(providerResultCulture);
    }
}

```

##### 6.2.2 cookie request culture provider

```c#
public class CookieRequestCultureProvider : RequestCultureProvider
{
    private static readonly char _cookieSeparator = '|';
    private static readonly string _culturePrefix = "c=";
    private static readonly string _uiCulturePrefix = "uic=";           
    public static readonly string DefaultCookieName = ".AspNetCore.Culture";
        
    public string CookieName { get; set; } = DefaultCookieName;
    
    /// <inheritdoc />
    public override Task<ProviderCultureResult?> DetermineProviderCultureResult(HttpContext httpContext)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        // 按照 cookie name (.aspnetcore.culture) 从 http context 解析 cookie
        
        var cookie = httpContext.Request.Cookies[CookieName];
        // 如果 cookie 为空，-> null provider
        if (string.IsNullOrEmpty(cookie))
        {
            return NullProviderCultureResult;
        }
        
        // 解析并创建 provider        
        var providerResultCulture = ParseCookieValue(cookie);        
        return Task.FromResult<ProviderCultureResult?>(providerResultCulture);
    }
                   
    public static ProviderCultureResult? ParseCookieValue(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return null;
        }
        
        // 按照 cookie separator ("|") 分解 culture cookie value
        var parts = value.Split(_cookieSeparator, StringSplitOptions.RemoveEmptyEntries);
        // 如果不能得到 2个字段 (culture、ui culture)
        if (parts.Length != 2)
        {
            return null;
        }
        
        // 解析 culture、ui culture 的 cookie part
        var potentialCultureName = parts[0];
        var potentialUICultureName = parts[1];
        
        // 如果 culture、ui culture 不是以 prefix 开头 (c=, uic=)，-> 结束
        if (!potentialCultureName.StartsWith(_culturePrefix, StringComparison.Ordinal) || 
            !potentialUICultureName.StartsWith(_uiCulturePrefix, StringComparison.Ordinal))
        {
            return null;
        }
        
        // 从 part 解析 culture name、ui culture name
        var cultureName = potentialCultureName.Substring(_culturePrefix.Length);
        var uiCultureName = potentialUICultureName.Substring(_uiCulturePrefix.Length);
        
        // 如果 culture name 和 ui culture name 都为 null，-> 结束
        if (cultureName == null && uiCultureName == null)
        {
            // No values specified for either so no match
            return null;
        }
        // 如果 ui culture name 为 null，设置为 culture name
        if (cultureName != null && uiCultureName == null)
        {
            // Value for culture but not for UI culture so default to culture value for both
            uiCultureName = cultureName;
        }
        // 如果 culture name 为 null，设置为 ui culture name
        else if (cultureName == null && uiCultureName != null)
        {
            // Value for UI culture but not for culture so default to UI culture value for both
            cultureName = uiCultureName;
        }
        
        return new ProviderCultureResult(cultureName, uiCultureName);
    }
    
    // 创建 cookie value（用于写入 http context）   
    public static string MakeCookieValue(RequestCulture requestCulture)
    {
        if (requestCulture == null)
        {
            throw new ArgumentNullException(nameof(requestCulture));
        }
        
        return string.Join(_cookieSeparator,
                           $"{_culturePrefix}{requestCulture.Culture.Name}",
                           $"{_uiCulturePrefix}{requestCulture.UICulture.Name}");
    }
}

```

##### 6.2.3 accept language header request culture provider

```c#
public class AcceptLanguageHeaderRequestCultureProvider : RequestCultureProvider
{        
    // Defaults to <c>3</c>.     
    public int MaximumAcceptLanguageHeaderValuesToTry { get; set; } = 3;
       
    public override Task<ProviderCultureResult?> DetermineProviderCultureResult(HttpContext httpContext)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        var acceptLanguageHeader = httpContext.Request.GetTypedHeaders().AcceptLanguage;
        
        if (acceptLanguageHeader == null || acceptLanguageHeader.Count == 0)
        {
            return NullProviderCultureResult;
        }
        
        var languages = acceptLanguageHeader.AsEnumerable();
        
        if (MaximumAcceptLanguageHeaderValuesToTry > 0)
        {
            // We take only the first configured number of languages from the header and then order those that we
            // attempt to parse as a CultureInfo to mitigate potentially spinning CPU on lots of parse attempts.
            languages = languages.Take(MaximumAcceptLanguageHeaderValuesToTry);
        }
        
        var orderedLanguages = languages.OrderByDescending(h => h,      StringWithQualityHeaderValueComparer.QualityComparer)
					                  .Select(x => x.Value).ToList();

        if (orderedLanguages.Count > 0)
        {
            return Task.FromResult<ProviderCultureResult?>(new ProviderCultureResult(orderedLanguages));
        }
        
        return NullProviderCultureResult;
    }
}

```

##### 6.2.4 custom request culture provider

```c#
public class CustomRequestCultureProvider : RequestCultureProvider
{
    private readonly Func<HttpContext, Task<ProviderCultureResult?>> _provider;
        
    public CustomRequestCultureProvider(Func<HttpContext, Task<ProviderCultureResult?>> provider)
    {
        if (provider == null)
        {
            throw new ArgumentNullException(nameof(provider));
        }
        
        _provider = provider;
    }
        
    public override Task<ProviderCultureResult?> DetermineProviderCultureResult(HttpContext httpContext)
    {
        if (httpContext == null)
        {
            throw new ArgumentNullException(nameof(httpContext));
        }
        
        return _provider(httpContext);
    }
}

```

#### 6.3 add request localization

```c#
public static class RequestLocalizationServiceCollectionExtensions
{
    public static IServiceCollection AddRequestLocalization(
        this IServiceCollection services, 
        Action<RequestLocalizationOptions> configureOptions)
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        return services.Configure(configureOptions);
    }
        
    public static IServiceCollection AddRequestLocalization<TService>(
        this IServiceCollection services, 
        Action<RequestLocalizationOptions, TService> configureOptions) where TService : class
    {
        if (services == null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (configureOptions == null)
        {
            throw new ArgumentNullException(nameof(configureOptions));
        }
        
        services.AddOptions<RequestLocalizationOptions>().Configure(configureOptions);
        return services;
    }
}

```

##### 6.3.1 request localization options

```c#
public class RequestLocalizationOptions
{
    private RequestCulture _defaultRequestCulture = new RequestCulture(CultureInfo.CurrentCulture, CultureInfo.CurrentUICulture);
    public RequestCulture DefaultRequestCulture
    {
        get
        {
            return _defaultRequestCulture;
        }
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }
            
            _defaultRequestCulture = value;
        }
    }
    
    public IList<CultureInfo>? SupportedCultures { get; set; } = new List<CultureInfo> { CultureInfo.CurrentCulture };       
    public IList<CultureInfo>? SupportedUICultures { get; set; } = new List<CultureInfo> { CultureInfo.CurrentUICulture };       
    public IList<IRequestCultureProvider> RequestCultureProviders { get; set; }
       
    public bool FallBackToParentCultures { get; set; } = true;                    
    public bool FallBackToParentUICultures { get; set; } = true;   
    public bool ApplyCurrentCultureToResponseHeaders { get; set; }
            
    public RequestLocalizationOptions()
    {
        RequestCultureProviders = new List<IRequestCultureProvider>
        {
            new QueryStringRequestCultureProvider { Options = this },
            new CookieRequestCultureProvider { Options = this },
            new AcceptLanguageHeaderRequestCultureProvider { Options = this }
        };
    }
                           
    // 方法- add culture
    public RequestLocalizationOptions AddSupportedCultures(params string[] cultures)
    {
        var supportedCultures = new List<CultureInfo>(cultures.Length);
        
        foreach (var culture in cultures)
        {
            supportedCultures.Add(new CultureInfo(culture));
        }
        
        SupportedCultures = supportedCultures;
        return this;
    }

    // 方法- add ui culture
    public RequestLocalizationOptions AddSupportedUICultures(params string[] uiCultures)
    {
        var supportedUICultures = new List<CultureInfo>(uiCultures.Length);
        foreach (var culture in uiCultures)
        {
            supportedUICultures.Add(new CultureInfo(culture));
        }
        
        SupportedUICultures = supportedUICultures;
        return this;
    }
    
    // 方法- set default culture
    public RequestLocalizationOptions SetDefaultCulture(string defaultCulture)
    {
        DefaultRequestCulture = new RequestCulture(defaultCulture);
        return this;
    }
}

public static class RequestLocalizationOptionsExtensions
{
    // 扩展方法- add culture provider
    public static RequestLocalizationOptions AddInitialRequestCultureProvider(
        this RequestLocalizationOptions requestLocalizationOptions,
        RequestCultureProvider requestCultureProvider)
    {
        if (requestLocalizationOptions == null)
        {
            throw new ArgumentNullException(nameof(requestLocalizationOptions));
        }        
        if (requestCultureProvider == null)
        {
            throw new ArgumentNullException(nameof(requestCultureProvider));
        }
        
        requestLocalizationOptions.RequestCultureProviders.Insert(0, requestCultureProvider);        
        return requestLocalizationOptions;
    }
}

```

#### 6.4 use request localization

```c#
public static class ApplicationBuilderExtensions
{    
    public static IApplicationBuilder UseRequestLocalization(this IApplicationBuilder app)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }
        
        return app.UseMiddleware<RequestLocalizationMiddleware>();
    }
        
    public static IApplicationBuilder UseRequestLocalization(
        this IApplicationBuilder app,
        RequestLocalizationOptions options)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        return app.UseMiddleware<RequestLocalizationMiddleware>(Options.Create(options));
    }
    
   
    public static IApplicationBuilder UseRequestLocalization(
        this IApplicationBuilder app,
        Action<RequestLocalizationOptions> optionsAction)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }        
        if (optionsAction == null)
        {
            throw new ArgumentNullException(nameof(optionsAction));
        }
        
        var options = new RequestLocalizationOptions();
        optionsAction.Invoke(options);
        
        return app.UseMiddleware<RequestLocalizationMiddleware>(Options.Create(options));
    }
                    
    public static IApplicationBuilder UseRequestLocalization(
        this IApplicationBuilder app,
        // Note that the first culture is the default culture name.    
        params string[] cultures)
    {
        if (app == null)
        {
            throw new ArgumentNullException(nameof(app));
        }        
        if (cultures == null)
        {
            throw new ArgumentNullException(nameof(cultures));
        }
        
        if (cultures.Length == 0)
        {
            throw new ArgumentException(Resources.Exception_CulturesShouldNotBeEmpty);
        }
        
        var options = new RequestLocalizationOptions()
            .AddSupportedCultures(cultures)
            .AddSupportedUICultures(cultures)
            .SetDefaultCulture(cultures[0]);
        
        return app.UseMiddleware<RequestLocalizationMiddleware>(Options.Create(options));
    }
}

```

##### 6.4.1 request localization middleware

```c#
public class RequestLocalizationMiddleware
{
    private static readonly int MaxCultureFallbackDepth = 5;
    
    private readonly RequestDelegate _next;      
    private readonly RequestLocalizationOptions _options;
    private readonly ILogger _logger;
       
    public RequestLocalizationMiddleware(
        RequestDelegate next, 
        IOptions<RequestLocalizationOptions> options, 
        ILoggerFactory loggerFactory)
    {
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        //
        _next = next ?? throw new ArgumentNullException(nameof(next));
        //
        _options = options.Value;
        
        _logger = loggerFactory?.CreateLogger<RequestLocalizationMiddleware>() ?? throw new ArgumentNullException(nameof(loggerFactory));
        
    }
       
    public async Task Invoke(HttpContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
                
        var requestCulture = _options.DefaultRequestCulture;        
        IRequestCultureProvider? winningProvider = null;
        
        // 如果 request localization options 指定了 provider
        // （ providers 不为 null）
        if (_options.RequestCultureProviders != null)
        {
            /* 1- 解析 culture */
            // 遍历 providers，
            foreach (var provider in _options.RequestCultureProviders)
            {
                // 由 provider 解析 result culture
                var providerResultCulture = await provider.DetermineProviderCultureResult(context);
                
                // 如果解析失败（result culture 为 null），-> 下一个 provider
                if (providerResultCulture == null)
                {
                    continue;
                }
                
                // （由上），获取解析的 result culture 中的 cultures、ui cultures
                var cultures = providerResultCulture.Cultures;
                var uiCultures = providerResultCulture.UICultures;
                
                CultureInfo? cultureInfo = null;
                CultureInfo? uiCultureInfo = null;
                
                // 如果 options 的 supported cultures 不为 null，-> 解析 culture
                if (_options.SupportedCultures != null)
                {                   
                    cultureInfo = GetCultureInfo(
                        cultures,
                        _options.SupportedCultures,
                        _options.FallBackToParentCultures);
                    
                    if (cultureInfo == null)
                    {
                        _logger.UnsupportedCultures(provider.GetType().Name, cultures);
                    }
                }
                // 如果 options 的 supported ui cultures 不为 null，-> 解析 ui culture
                if (_options.SupportedUICultures != null)
                {
                    uiCultureInfo = GetCultureInfo(
                        uiCultures,
                        _options.SupportedUICultures,
                        _options.FallBackToParentUICultures);
                    
                    if (uiCultureInfo == null)
                    {
                        _logger.UnsupportedUICultures(provider.GetType().Name, uiCultures);
                    }
                }
                // 如果解析到的 culture、ui culture 都为 null，-> 下一个 provider
                if (cultureInfo == null && uiCultureInfo == null)
                {
                    continue;
                }
                
                // （由上），culture、ui culture 至少一个不为 null，
                // -> 得到结果，终止遍历
                cultureInfo ??= _options.DefaultRequestCulture.Culture;
                uiCultureInfo ??= _options.DefaultRequestCulture.UICulture;
                
                var result = new RequestCulture(cultureInfo, uiCultureInfo);
                requestCulture = result;
                winningProvider = provider;
                break;
            }
        }
        
        /* 执行 culture 相关 */
        
        // 由解析得到的 request culture、provider 创建 request culture feature，注入 http context
        context.Features.Set<IRequestCultureFeature>(new RequestCultureFeature(requestCulture, winningProvider));
        
        // 将执行线程的 culture 设置为 request culture
        SetCurrentThreadCulture(requestCulture);
        
        // 如果 optionns 标记了 apply culture to response，-> 注入 response header
        if (_options.ApplyCurrentCultureToResponseHeaders)
        {
            context.Response.Headers.Add(HeaderNames.ContentLanguage, requestCulture.UICulture.Name);
        }
        
        await _next(context);
    }
    
    
    private static void SetCurrentThreadCulture(RequestCulture requestCulture)
    {
        CultureInfo.CurrentCulture = requestCulture.Culture;
        CultureInfo.CurrentUICulture = requestCulture.UICulture;
    }
    
    private static CultureInfo? GetCultureInfo(
        IList<StringSegment> cultureNames,
        IList<CultureInfo> supportedCultures,
        bool fallbackToParentCultures)
    {
        // 遍历 culture names，
        foreach (var cultureName in cultureNames)
        {
            // 按照 culture name 解析 culture，            
            if (cultureName != null)
            {
                var cultureInfo = GetCultureInfo(
                    cultureName, 
                    supportedCultures, 
                    fallbackToParentCultures, 
                    currentDepth: 0);
                
                // 一旦解析成功，-> 返回 culture 且 结束遍历
                if (cultureInfo != null)
                {
                    return cultureInfo;
                }
            }
        }
        
        return null;
    }
    
    private static CultureInfo? GetCultureInfo(
        StringSegment cultureName,
        IList<CultureInfo> supportedCultures,
        bool fallbackToParentCultures,
        int currentDepth)
    {
        // 从 supported cultures 解析 culture
        var culture = GetCultureInfo(cultureName, supportedCultures);
        
        // 如果 culture 为 null（即不能解析），
        // 但是 标记了 fallback toparent culture，且 current depth < max，
        // -> 递归解析 parent culture
        if (culture == null && 
            fallbackToParentCultures && 
            currentDepth < MaxCultureFallbackDepth)
        {
            var lastIndexOfHyphen = cultureName.LastIndexOf('-');
            
            if (lastIndexOfHyphen > 0)
            {
                // Trim the trailing section from the culture name, e.g. "fr-FR" becomes "fr"
                var parentCultureName = cultureName.Subsegment(0, lastIndexOfHyphen);
                
                culture = GetCultureInfo(
                    parentCultureName, 
                    supportedCultures, 
                    fallbackToParentCultures, 
                    currentDepth + 1);
            }
        }
        
        return culture;
    }
    
    private static CultureInfo? GetCultureInfo(StringSegment name, IList<CultureInfo>? supportedCultures)
    {
        // 传入参数为 null，-> 返回 null
        if (name == null || supportedCultures == null)
        {
            return null;
        }
        
        // 从 supported culture 中解析 “第一个” 与 name 同名的 culture
        var culture = supportedCultures.FirstOrDefault(
            supportedCulture => StringSegment.Equals(supportedCulture.Name, name, StringComparison.OrdinalIgnoreCase));
                
        if (culture == null)
        {
            return null;
        }
        
        return CultureInfo.ReadOnly(culture);
    }        
}

```

##### 6.4.2 request localization feature

```c#
public interface IRequestCultureFeature
{    
    RequestCulture RequestCulture { get; }    
    IRequestCultureProvider? Provider { get; }
}

public class RequestCultureFeature : IRequestCultureFeature
{
    public RequestCulture RequestCulture { get; }        
    public IRequestCultureProvider? Provider { get; }
    
    public RequestCultureFeature(RequestCulture requestCulture, IRequestCultureProvider? provider)
    {
        if (requestCulture == null)
        {
            throw new ArgumentNullException(nameof(requestCulture));
        }
        
        RequestCulture = requestCulture;
        Provider = provider;
    }    
}

```



