## about action and controller in mvc



### 1. about



### 2. action & controller

#### 2.1 action descriptor

##### 2.1.1 action descriptor (base)

```c#
public class ActionDescriptor
{     
    public string Id { get; }
    public virtual string? DisplayName { get; set; }
    public IDictionary<object, object> Properties { get; set; } = default!;
    
    public IDictionary<string, string> RouteValues { get; set; }   
    public AttributeRouteInfo? AttributeRouteInfo { get; set; }
    public IList<object> EndpointMetadata { get; set; } = Array.Empty<ParameterDescriptor>();          
    
    public IList<ParameterDescriptor> Parameters { get; set; } = Array.Empty<ParameterDescriptor>();          
    public IList<ParameterDescriptor> BoundProperties { get; set; } = Array.Empty<ParameterDescriptor>();       
    public IList<IActionConstraintMetadata>? ActionConstraints { get; set; }                                      
    public IList<FilterDescriptor> FilterDescriptors { get; set; } = Array.Empty<FilterDescriptor>();
    
    public ActionDescriptor()
    {         
        Id = Guid.NewGuid().ToString();
        // 创建 property 集合（default）
        Properties = new Dictionary<object, object>();
        // 创建 route value 集合（default）
        RouteValues = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
    }                                      
}

```

###### 2.1.1.1 扩展方法

```c#
public static class ActionDescriptorExtensions
{
    // get property
    public static T GetProperty<T>(this ActionDescriptor actionDescriptor)
    {
        if (actionDescriptor == null)
        {
            throw new ArgumentNullException(nameof(actionDescriptor));
        }
        
        if (actionDescriptor.Properties.TryGetValue(typeof(T), out var value))
        {
            return (T)value;
        }
        else
        {
            return default!;
        }
    }
    
    // set property
    public static void SetProperty<T>(
        this ActionDescriptor actionDescriptor, 
        T value)
    {
        if (actionDescriptor == null)
        {
            throw new ArgumentNullException(nameof(actionDescriptor));
        }        
        if (value == null)
        {
            throw new ArgumentNullException(nameof(value));
        }
        
        actionDescriptor.Properties[typeof(T)] = value;
    }
}

```

##### 2.1.2 parameter descriptor

```c#
public class ParameterDescriptor
{    
    public string Name { get; set; } = default!;        
    public Type ParameterType { get; set; } = default!;        
    public BindingInfo? BindingInfo { get; set; }
}

```

##### 2.1.3 filter descriptor

```c#
[DebuggerDisplay("Filter = {Filter.ToString(),nq}, Order = {Order}")]
public class FilterDescriptor
{
    public IFilterMetadata Filter { get; }        
    public int Order { get; set; }
    public int Scope { get; }
           
    public FilterDescriptor(
        IFilterMetadata filter, 
        int filterScope)
    {
        if (filter == null)
        {
            throw new ArgumentNullException(nameof(filter));
        }
        
        Filter = filter;
        Scope = filterScope;
        
        // 如果 filter 实现了 ordered filter 接口，
        // 将 ordered filter 接口 order 赋值到 this.Order
        if (Filter is IOrderedFilter orderedFilter)
        {
            Order = orderedFilter.Order;
        }
    }            
}

```

##### 2.1.4 action descriptor provider 接口

```c#
public interface IActionDescriptorProvider
{    
    int Order { get; }
        
    void OnProvidersExecuting(ActionDescriptorProviderContext context);        
    void OnProvidersExecuted(ActionDescriptorProviderContext context);
}

```

###### 2.1.4.1 action descriptor provider context

```c#
public class ActionDescriptorProviderContext
{        
    public IList<ActionDescriptor> Results { get; } = new List<ActionDescriptor>();
}

```

#### 2.2 action descriptor collection

##### 2.2.1 action descriptor collection 

```c#
public class ActionDescriptorCollection
{
    public IReadOnlyList<ActionDescriptor> Items { get; }        
    public int Version { get; }
    
    public ActionDescriptorCollection(
        IReadOnlyList<ActionDescriptor> items, 
        int version)
    {
        if (items == null)
        {
            throw new ArgumentNullException(nameof(items));
        }
        
        Items = items;
        Version = version;
    }            
}

```

##### 2.2.2 action descriptor collection provider

```c#
// 接口
public interface IActionDescriptorCollectionProvider
{    
    ActionDescriptorCollection ActionDescriptors { get; }
}

// 抽象基类
public abstract class ActionDescriptorCollectionProvider : IActionDescriptorCollectionProvider
{    
    public abstract ActionDescriptorCollection ActionDescriptors { get; }        
    public abstract IChangeToken GetChangeToken();
}

```

##### 2.2.3 default action descriptor collection provider

###### 2.2.3.1 action descriptor change provider

```c#
public interface IActionDescriptorChangeProvider
{    
    IChangeToken GetChangeToken();
}

```

###### 2.2.3.2 default action descriptor collection provider

```c#
internal class DefaultActionDescriptorCollectionProvider : ActionDescriptorCollectionProvider
{
    // action descriptor provider 集合
    private readonly IActionDescriptorProvider[] _actionDescriptorProviders;
    // action descriptor cahange provider 集合
    private readonly IActionDescriptorChangeProvider[] _actionDescriptorChangeProviders;
    
    // The lock is used to protect WRITES to the following 
    // (do not need to protect reads once initialized).
    private readonly object _lock;
    
    /* 结果 */
    private ActionDescriptorCollection? _collection;
    /* change token */
    private IChangeToken? _changeToken;
    private CancellationTokenSource? _cancellationTokenSource;
    
    private int _version = 0;
    
    public DefaultActionDescriptorCollectionProvider(
        IEnumerable<IActionDescriptorProvider> actionDescriptorProviders,
        IEnumerable<IActionDescriptorChangeProvider> actionDescriptorChangeProviders)
    {
        // 注入 action descriptor provider
        _actionDescriptorProviders = 
            actionDescriptorProviders.OrderBy(p => p.Order)
            						 .ToArray();
        // 注入 action descriptor change provider
        _actionDescriptorChangeProviders = 
            actionDescriptorChangeProviders.ToArray();
        
        _lock = new object();
        
        /* change token 触发 update collection */
        // IMPORTANT: this needs to be the last thing we do in the constructor. 
        // Change notifications can happen immediately!
        ChangeToken.OnChange(
            			GetCompositeChangeToken,
			            UpdateCollection);
    }
    
    private IChangeToken GetCompositeChangeToken()
    {
        if (_actionDescriptorChangeProviders.Length == 1)
        {
            return _actionDescriptorChangeProviders[0].GetChangeToken();
        }
        
       
        var changeTokens = new IChangeToken[_actionDescriptorChangeProviders.Length];
        
         /* 遍历 action descriptor change provider，
           将其 change token 注入 change tokens 集合 */
        for (var i = 0; i < _actionDescriptorChangeProviders.Length; i++)
        {
            changeTokens[i] = _actionDescriptorChangeProviders[i].GetChangeToken();
        }
        
        return new CompositeChangeToken(changeTokens);
    }
    
    private void UpdateCollection()
    {
        // Using the lock to initialize writes means that we serialize changes. This eliminates
        // the potential for changes to be processed out of order - the risk is that newer data
        // could be overwritten by older data.
        lock (_lock)
        {
            var context = new ActionDescriptorProviderContext();
            
            // 遍历 action descriptor provider 集合，调用 executing 方法
            for (var i = 0; i < _actionDescriptorProviders.Length; i++)
            {
                _actionDescriptorProviders[i].OnProvidersExecuting(context);
            }
            // 遍历 action descriptor provider 集合，调用 executed 方法
            for (var i = _actionDescriptorProviders.Length - 1; i >= 0; i--)
            {
                _actionDescriptorProviders[i].OnProvidersExecuted(context);
            }
            
            // The sequence for an update is important because we don't want anyone to obtain
            // the new change token but the old action descriptor collection.
            // 1. Obtain the old cancellation token source (don't trigger it yet)
            // 2. Set the new action descriptor collection
            // 3. Set the new change token
            // 4. Trigger the old cancellation token source
            //
            // Consumers who poll will observe a new action descriptor collection at 
            // step 2 - they will see the new collection and ignore the change token.
            //
            // Consumers who listen to the change token will re-query at step 4 - they 
            // will see the new collection and new change token.
            //
            // Anyone who acquires the collection and change token between steps 2 and 3 
            // will be notified of a no-op change at step 4.
            
            // Step 1.
            var oldCancellationTokenSource = _cancellationTokenSource;
            
            // Step 2.
            _collection = new ActionDescriptorCollection(
                new ReadOnlyCollection<ActionDescriptor>(context.Results),
                _version++);
            
            // Step 3.
            _cancellationTokenSource = new CancellationTokenSource();
            _changeToken = new CancellationChangeToken(_cancellationTokenSource.Token);
            
            // Step 4 - might be null if it's the first time.
            oldCancellationTokenSource?.Cancel();
        }
    }
    
    /* 实现 action descriptor collection provider 的 action descriptors 属性 */
    
    public override ActionDescriptorCollection ActionDescriptors
    {
        get
        {
            Initialize();
            Debug.Assert(_collection != null);
            Debug.Assert(_changeToken != null);
            
            return _collection;
        }
    }

    /* 实现 change token 接口 get change token 方法 */    
    
    public override IChangeToken GetChangeToken()
    {
        Initialize();
        Debug.Assert(_collection != null);
        Debug.Assert(_changeToken != null);
        
        return _changeToken;
    }
    
    // 初始化，更新 aciton descriptor collection
    private void Initialize()
    {
        // Using double-checked locking on initialization because we fire change token 
        // callbacks when the collection changes. We don't want to do that repeatedly 
        // for redundant changes.
        //
        // The main call path of this code on the first call is async initialization 
        // from Endpoint Routing which is done in a non-blocking way so in practice no 
        // caller will ever block here.
        if (_collection == null)
        {
            lock (_lock)
            {
                if (_collection == null)
                {
                    UpdateCollection();
                }
            }
        }
    }        
}

```

#### 2.3 action invoker

##### 2.3.1 action invoker 接口

```c#
public interface IActionInvoker
{    
    Task InvokeAsync();
}

```

##### 2.3.2 action invoker provider

```c#
public interface IActionInvokerProvider
{    
    int Order { get; }
        
    void OnProvidersExecuting(ActionInvokerProviderContext context);   
    void OnProvidersExecuted(ActionInvokerProviderContext context);
}

```

###### 2.3.2.1 action invoker provider context

```c#
public class ActionInvokerProviderContext
{
    public ActionContext ActionContext { get; }        
    public IActionInvoker? Result { get; set; }
    
    public ActionInvokerProviderContext(ActionContext actionContext)
    {
        if (actionContext == null)
        {
            throw new ArgumentNullException(nameof(actionContext));
        }
        
        ActionContext = actionContext;
    }            
}

```

##### 2.3.3 action invoker factory

###### 2.3.3.1 接口

```c#
public interface IActionInvokerFactory
{    
    IActionInvoker? CreateInvoker(ActionContext actionContext);
}

```

###### 2.3.3.2 action invoker factory

```c#
internal class ActionInvokerFactory : IActionInvokerFactory
{
    private readonly IActionInvokerProvider[] _actionInvokerProviders;
    
    public ActionInvokerFactory(IEnumerable<IActionInvokerProvider> actionInvokerProviders)
    {
        _actionInvokerProviders = actionInvokerProviders.OrderBy(item => item.Order)
            										.ToArray();
    }
    
    public IActionInvoker? CreateInvoker(ActionContext actionContext)
    {
        var context = new ActionInvokerProviderContext(actionContext);
        
        foreach (var provider in _actionInvokerProviders)
        {
            provider.OnProvidersExecuting(context);
        }
        
        for (var i = _actionInvokerProviders.Length - 1; i >= 0; i--)
        {
            _actionInvokerProviders[i].OnProvidersExecuted(context);
        }
        
        return context.Result;
    }
}

```

#### 2.4 action selector

##### 2.4.1 接口

```c#
public interface IActionSelector
{
   
    // Used by conventional routing to select the set of actions that match the route values for the current request. 
    // Action constraints associated with the candidates are not invoked by this method   
    //
    // Attribute routing does not call this method.    
    IReadOnlyList<ActionDescriptor>? SelectCandidates(RouteContext context);

    // Used by conventional routing after calling <see cref="SelectCandidates"/> to apply action constraints and
    // disambiguate between multiple candidates.
    //
    // Used by attribute routing to apply action constraints and disambiguate between multiple candidates.   
    ActionDescriptor? SelectBestCandidate(RouteContext context, IReadOnlyList<ActionDescriptor> candidates);
}

```

##### 2.4.2 action selector

```c#
internal class ActionSelector : IActionSelector
{
    private readonly IActionDescriptorCollectionProvider _actionDescriptorCollectionProvider;
    private readonly ActionConstraintCache _actionConstraintCache;
    private readonly ILogger _logger;
    
    private ActionSelectionTable<ActionDescriptor>? _cache;
    
      
    public ActionSelector(
        IActionDescriptorCollectionProvider actionDescriptorCollectionProvider,
        ActionConstraintCache actionConstraintCache,
        ILoggerFactory loggerFactory)
    {
        _actionDescriptorCollectionProvider = actionDescriptorCollectionProvider;
        _logger = loggerFactory.CreateLogger<ActionSelector>();
        _actionConstraintCache = actionConstraintCache;
    }
    
    private ActionSelectionTable<ActionDescriptor> Current
    {
        get
        {
            var actions = _actionDescriptorCollectionProvider.ActionDescriptors;
            var cache = Volatile.Read(ref _cache);
            
            if (cache != null && cache.Version == actions.Version)
            {
                return cache;
            }
            
            cache = ActionSelectionTable<ActionDescriptor>.Create(actions);
            Volatile.Write(ref _cache, cache);
            return cache;
        }
    }
    
    public IReadOnlyList<ActionDescriptor> SelectCandidates(RouteContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        var cache = Current;
        
        var matches = cache.Select(context.RouteData.Values);
        if (matches.Count > 0)
        {
            return matches;
        }
        
        _logger.NoActionsMatched(context.RouteData.Values);
        return matches;
    }
    
    public ActionDescriptor? SelectBestCandidate(RouteContext context, IReadOnlyList<ActionDescriptor> candidates)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        if (candidates == null)
        {
            throw new ArgumentNullException(nameof(candidates));
        }
        
        var finalMatches = EvaluateActionConstraints(context, candidates);
        
        if (finalMatches == null || finalMatches.Count == 0)
        {
            return null;
        }
        else if (finalMatches.Count == 1)
        {
            var selectedAction = finalMatches[0];
            
            return selectedAction;
        }
        else
        {
            var actionNames = string.Join(
                Environment.NewLine,
                finalMatches.Select(a => a.DisplayName));
            
            _logger.AmbiguousActions(actionNames);
            
            var message = Resources.FormatDefaultActionSelector_AmbiguousActions(
                Environment.NewLine,
                actionNames);
            
            throw new AmbiguousActionException(message);
        }
    }
    
    private IReadOnlyList<ActionDescriptor>? EvaluateActionConstraints(
        RouteContext context,
        IReadOnlyList<ActionDescriptor> actions)
    {
        var actionsCount = actions.Count;
        var candidates = new List<ActionSelectorCandidate>(actionsCount);
        
        // Perf: Avoid allocations
        for (var i = 0; i < actionsCount; i++)
        {
            var action = actions[i];
            var constraints = _actionConstraintCache.GetActionConstraints(context.HttpContext, action);
            candidates.Add(new ActionSelectorCandidate(action, constraints));
        }
        
        var matches = EvaluateActionConstraintsCore(context, candidates, startingOrder: null);
        
        List<ActionDescriptor>? results = null;
        if (matches != null)
        {
            var matchesCount = matches.Count;
            results = new List<ActionDescriptor>(matchesCount);
            // Perf: Avoid allocations
            for (var i = 0; i < matchesCount; i++)
            {
                var candidate = matches[i];
                results.Add(candidate.Action);
            }
        }
        
        return results;
    }
    
    private IReadOnlyList<ActionSelectorCandidate>? EvaluateActionConstraintsCore(
        RouteContext context,
        IReadOnlyList<ActionSelectorCandidate> candidates,
        int? startingOrder)
    {
        // Find the next group of constraints to process. This will be the lowest value of
        // order that is higher than startingOrder.
        int? order = null;
        
        // Perf: Avoid allocations
        for (var i = 0; i < candidates.Count; i++)
        {
            var candidate = candidates[i];
            if (candidate.Constraints != null)
            {
                for (var j = 0; j < candidate.Constraints.Count; j++)
                {
                    var constraint = candidate.Constraints[j];
                    if ((startingOrder == null || constraint.Order > startingOrder) &&
                        (order == null || constraint.Order < order))
                    {
                        order = constraint.Order;
                    }
                }
            }
        }
        
        // If we don't find a next then there's nothing left to do.
        if (order == null)
        {
            return candidates;
        }
        
        // Since we have a constraint to process, bisect the set of actions into those with and without a
        // constraint for the current order.
        var actionsWithConstraint = new List<ActionSelectorCandidate>();
        var actionsWithoutConstraint = new List<ActionSelectorCandidate>();
        
        var constraintContext = new ActionConstraintContext
        {
            Candidates = candidates,
            RouteContext = context
        };
        
        // Perf: Avoid allocations
        for (var i = 0; i < candidates.Count; i++)
        {
            var candidate = candidates[i];
            var isMatch = true;
            var foundMatchingConstraint = false;
            
            if (candidate.Constraints != null)
            {
                constraintContext.CurrentCandidate = candidate;
                for (var j = 0; j < candidate.Constraints.Count; j++)
                {
                    var constraint = candidate.Constraints[j];
                    if (constraint.Order == order)
                    {
                        foundMatchingConstraint = true;
                        
                        if (!constraint.Accept(constraintContext))
                        {
                            isMatch = false;
                            _logger.ConstraintMismatch(
                                candidate.Action.DisplayName,
                                candidate.Action.Id,
                                constraint);
                            break;
                        }
                    }
                }
            }
            
            if (isMatch && foundMatchingConstraint)
            {
                actionsWithConstraint.Add(candidate);
            }
            else if (isMatch)
            {
                actionsWithoutConstraint.Add(candidate);
            }
        }
        
        // If we have matches with constraints, those are better so try to keep processing those
        if (actionsWithConstraint.Count > 0)
        {
            var matches = EvaluateActionConstraintsCore(context, actionsWithConstraint, order);
            if (matches?.Count > 0)
            {
                return matches;
            }
        }
        
        // If the set of matches with constraints can't work, then process the set without constraints.
        if (actionsWithoutConstraint.Count == 0)
        {
            return null;
        }
        else
        {
            return EvaluateActionConstraintsCore(context, actionsWithoutConstraint, order);
        }
    }
}

```

##### 2.4.3 action selector table

```c#
// Common infrastructure for things that look up actions by route values.
    //
    // The ActionSelectionTable stores a mapping of route-values -> items for each known set of
    // of route-values. We actually build two of these mappings, one for case-sensitive (fast path) and one for
    // case-insensitive (slow path).
    //
    // This is necessary because MVC routing/action-selection is always case-insensitive. So we're going to build
    // a case-sensitive dictionary that will behave like the a case-insensitive dictionary when you hit one of the
    // canonical entries. When you don't hit a case-sensitive match it will try the case-insensitive dictionary
    // so you still get correct behaviors.
    //
    // The difference here is because while MVC is case-insensitive, doing a case-sensitive comparison is much
    // faster. We also expect that most of the URLs we process are canonically-cased because they were generated
    // by Url.Action or another routing api.
    //
    // This means that for a set of actions like:
    //      { controller = "Home", action = "Index" } -> HomeController::Index1()
    //      { controller = "Home", action = "index" } -> HomeController::Index2()
    //
    // Both of these actions match "Index" case-insensitively, but there exist two known canonical casings,
    // so we will create an entry for "Index" and an entry for "index". Both of these entries match **both**
    // actions.
    internal class ActionSelectionTable<TItem>
    {
        private ActionSelectionTable(
            int version, 
            string[] routeKeys,
            Dictionary<string[], List<TItem>> ordinalEntries,
            Dictionary<string[], List<TItem>> ordinalIgnoreCaseEntries)
        {
            Version = version;
            RouteKeys = routeKeys;
            OrdinalEntries = ordinalEntries;
            OrdinalIgnoreCaseEntries = ordinalIgnoreCaseEntries;
        }
        
        public int Version { get; }

        private string[] RouteKeys { get; }

        private Dictionary<string[], List<TItem>> OrdinalEntries { get; }

        private Dictionary<string[], List<TItem>> OrdinalIgnoreCaseEntries { get; }

        public static ActionSelectionTable<ActionDescriptor> Create(ActionDescriptorCollection actions)
        {
            return CreateCore<ActionDescriptor>(

                // We need to store the version so the cache can be invalidated if the actions change.
                version: actions.Version,

                // For action selection, ignore attribute routed actions
                items: actions.Items.Where(a => a.AttributeRouteInfo == null),

                getRouteKeys: a => a.RouteValues?.Keys,
                getRouteValue: (a, key) =>
                {
                    string? value = null;
                    a.RouteValues?.TryGetValue(key, out value);
                    return value ?? string.Empty;
                });
        }

        public static ActionSelectionTable<Endpoint> Create(IEnumerable<Endpoint> endpoints)
        {
            return CreateCore<Endpoint>(
                
                // we don't use version for endpoints
                version: 0, 

                // Exclude RouteEndpoints - we only process inert endpoints here. 
                items: endpoints.Where(e =>
                {
                    return e.GetType() == typeof(Endpoint);
                }),

                getRouteKeys: e => e.Metadata.GetMetadata<ActionDescriptor>()?.RouteValues?.Keys,
                getRouteValue: (e, key) =>
                {
                    string? value = null;
                    e.Metadata.GetMetadata<ActionDescriptor>()?.RouteValues?.TryGetValue(key, out value);
                    return Convert.ToString(value, CultureInfo.InvariantCulture) ?? string.Empty;
                });
        }

        private static ActionSelectionTable<T> CreateCore<T>(
            int version,
            IEnumerable<T> items,
            Func<T, IEnumerable<string>?> getRouteKeys,
            Func<T, string, string> getRouteValue)
        {       
            // We need to build two maps for all of the route values.
            var ordinalEntries = new Dictionary<string[], List<T>>(StringArrayComparer.Ordinal);
            var ordinalIgnoreCaseEntries = new Dictionary<string[], List<T>>(StringArrayComparer.OrdinalIgnoreCase);

            // We need to hold on to an ordered set of keys for the route values. We'll use these later to
            // extract the set of route values from an incoming request to compare against our maps of known
            // route values.
            var routeKeys = new SortedSet<string>(StringComparer.OrdinalIgnoreCase);

            foreach (var item in items)
            {
                var keys = getRouteKeys(item);
                if (keys != null)
                {
                    foreach (var key in keys)
                    {
                        routeKeys.Add(key);
                    }
                }
            }

            foreach (var item in items)
            {
                // This is a conventionally routed action - so we need to extract the route values associated
                // with this action (in order) so we can store them in our dictionaries.
                var index = 0;
                var routeValues = new string[routeKeys.Count];
                foreach (var key in routeKeys)
                {
                    var value = getRouteValue(item, key);
                    routeValues[index++] = value;
                }

                if (!ordinalIgnoreCaseEntries.TryGetValue(routeValues, out var entries))
                {
                    entries = new List<T>();
                    ordinalIgnoreCaseEntries.Add(routeValues, entries);
                }

                entries.Add(item);

                // We also want to add the same (as in reference equality) list of actions to the ordinal entries.
                // We'll keep updating `entries` to include all of the actions in the same equivalence class -
                // meaning, all conventionally routed actions for which the route values are equal ignoring case.
                //
                // `entries` will appear in `OrdinalIgnoreCaseEntries` exactly once and in `OrdinalEntries` once
                // for each variation of casing that we've seen.
                if (!ordinalEntries.ContainsKey(routeValues))
                {
                    ordinalEntries.Add(routeValues, entries);
                }
            }

            return new ActionSelectionTable<T>(version, routeKeys.ToArray(), ordinalEntries, ordinalIgnoreCaseEntries);
        }

        public IReadOnlyList<TItem> Select(RouteValueDictionary values)
        {
            // Select works based on a string[] of the route values in a pre-calculated order. This code extracts
            // those values in the correct order.
            var routeKeys = RouteKeys;
            var routeValues = new string[routeKeys.Length];
            for (var i = 0; i < routeKeys.Length; i++)
            {
                values.TryGetValue(routeKeys[i], out var value);
                routeValues[i] = value as string ?? Convert.ToString(value, CultureInfo.InvariantCulture) ?? string.Empty;
            }

            // Now look up, first case-sensitive, then case-insensitive.
            if (OrdinalEntries.TryGetValue(routeValues, out var matches) ||
                OrdinalIgnoreCaseEntries.TryGetValue(routeValues, out matches))
            {
                Debug.Assert(matches != null);
                Debug.Assert(matches.Count >= 0);
                return matches;
            }

            return Array.Empty<TItem>();
        }
    }
```

#### 2.5 resource invoker







### 3. controller

#### 3.1 controller action

##### 3.1.1 controller action descriptor

```c#
[DebuggerDisplay("{DisplayName}")]
public class ControllerActionDescriptor : ActionDescriptor
{   
    public string ControllerName { get; set; } = default!;    
    public virtual string ActionName { get; set; } = default!;    
    public MethodInfo MethodInfo { get; set; } = default!;    
    public TypeInfo ControllerTypeInfo { get; set; } = default!;    
    
    internal ControllerActionInvokerCacheEntry? CacheEntry { get; set; }
        
    public override string? DisplayName
    {
        get
        {
            if (base.DisplayName == null && ControllerTypeInfo != null && MethodInfo != null)
            {
                base.DisplayName = string.Format(
                    CultureInfo.InvariantCulture,
                    "{0}.{1} ({2})",
                    TypeNameHelper.GetTypeDisplayName(ControllerTypeInfo),
                    MethodInfo.Name,
                    ControllerTypeInfo.Assembly.GetName().Name);
            }
            
            return base.DisplayName!;
        }
        
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }
            
            base.DisplayName = value;
        }
    }
}

```

##### 3.1.2 controller bound property

###### 3.1.2.1 property info parameter descriptor

```c#
public interface IPropertyInfoParameterDescriptor
{       
    PropertyInfo PropertyInfo { get; }
}

```

###### 3.1.2.2 controller bound property descriptor

```c#
public class ControllerBoundPropertyDescriptor : ParameterDescriptor, IPropertyInfoParameterDescriptor
{    
    public PropertyInfo PropertyInfo { get; set; } = default!;
}

```

##### 3.1.3. controller parameter descriptor

###### 3.1.3.1 parameter info parameter descriptor

```c#
public interface IParameterInfoParameterDescriptor
{    
    ParameterInfo ParameterInfo { get; }
}

```

###### 3.1.3.2 controller parameter descriptor

```c#
public class ControllerParameterDescriptor : ParameterDescriptor, IParameterInfoParameterDescriptor
{    
    public ParameterInfo ParameterInfo { get; set; } = default!;
}

```

##### 3.1.4 controller action descriptor provider

```c#
internal class ControllerActionDescriptorProvider : IActionDescriptorProvider
    {
        private readonly ApplicationPartManager _partManager;
        private readonly ApplicationModelFactory _applicationModelFactory;

        public ControllerActionDescriptorProvider(
            ApplicationPartManager partManager,
            ApplicationModelFactory applicationModelFactory)
        {
            if (partManager == null)
            {
                throw new ArgumentNullException(nameof(partManager));
            }

            if (applicationModelFactory == null)
            {
                throw new ArgumentNullException(nameof(applicationModelFactory));
            }

            _partManager = partManager;
            _applicationModelFactory = applicationModelFactory;
        }

        public int Order => -1000;

        /// <inheritdoc />
        public void OnProvidersExecuting(ActionDescriptorProviderContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }

            foreach (var descriptor in GetDescriptors())
            {
                context.Results.Add(descriptor);
            }
        }

        /// <inheritdoc />
        public void OnProvidersExecuted(ActionDescriptorProviderContext context)
        {
            // After all of the providers have run, we need to provide a 'null' for each all of route values that
            // participate in action selection.
            //
            // This is important for scenarios like Razor Pages, that use the 'page' route value. An action that
            // uses 'page' shouldn't match when 'action' is set, and an action that uses 'action' shouldn't match when
            // 'page is specified.
            //
            // Or for another example, consider areas. A controller that's not in an area needs a 'null' value for
            // area so it can't match when the route produces an 'area' value.
            var keys = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            for (var i = 0; i < context.Results.Count; i++)
            {
                var action = context.Results[i];
                foreach (var key in action.RouteValues.Keys)
                {
                    keys.Add(key);
                }
            }

            for (var i = 0; i < context.Results.Count; i++)
            {
                var action = context.Results[i];
                foreach (var key in keys)
                {
                    if (!action.RouteValues.ContainsKey(key))
                    {
                        action.RouteValues.Add(key, null);
                    }
                }
            }
        }

        internal IEnumerable<ControllerActionDescriptor> GetDescriptors()
        {
            var controllerTypes = GetControllerTypes();
            var application = _applicationModelFactory.CreateApplicationModel(controllerTypes);
            return ControllerActionDescriptorBuilder.Build(application);
        }

        private IEnumerable<TypeInfo> GetControllerTypes()
        {
            var feature = new ControllerFeature();
            _partManager.PopulateFeature(feature);

            return feature.Controllers;
        }
    }
```

##### 3.1.5 controller action descriptor builder

```c#
internal static class ControllerActionDescriptorBuilder
    {
        public static IList<ControllerActionDescriptor> Build(ApplicationModel application)
        {
            return ApplicationModelFactory.Flatten(application, CreateActionDescriptor);
        }

        private static ControllerActionDescriptor CreateActionDescriptor(
            ApplicationModel application,
            ControllerModel controller,
            ActionModel action,
            SelectorModel selector)
        {
            var actionDescriptor = new ControllerActionDescriptor
            {
                ActionName = action.ActionName,
                MethodInfo = action.ActionMethod,
            };

            actionDescriptor.ControllerName = controller.ControllerName;
            actionDescriptor.ControllerTypeInfo = controller.ControllerType;
            AddControllerPropertyDescriptors(actionDescriptor, controller);

            AddActionConstraints(actionDescriptor, selector);
            AddEndpointMetadata(actionDescriptor, selector);
            AddAttributeRoute(actionDescriptor, selector);
            AddParameterDescriptors(actionDescriptor, action);
            AddActionFilters(actionDescriptor, action.Filters, controller.Filters, application.Filters);
            AddApiExplorerInfo(actionDescriptor, application, controller, action);
            AddRouteValues(actionDescriptor, controller, action);
            AddProperties(actionDescriptor, action, controller, application);

            return actionDescriptor;
        }

        private static void AddControllerPropertyDescriptors(ActionDescriptor actionDescriptor, ControllerModel controller)
        {
            actionDescriptor.BoundProperties = controller.ControllerProperties
                .Where(p => p.BindingInfo != null)
                .Select(CreateParameterDescriptor)
                .ToList();
        }

        private static void AddParameterDescriptors(ActionDescriptor actionDescriptor, ActionModel action)
        {
            var parameterDescriptors = new List<ParameterDescriptor>(action.Parameters.Count);
            foreach (var parameter in action.Parameters)
            {
                var parameterDescriptor = CreateParameterDescriptor(parameter);
                parameterDescriptors.Add(parameterDescriptor);
            }

            actionDescriptor.Parameters = parameterDescriptors;
        }
        
        private static ParameterDescriptor CreateParameterDescriptor(ParameterModel parameterModel)
        {
            var parameterDescriptor = new ControllerParameterDescriptor()
            {
                Name = parameterModel.ParameterName,
                ParameterType = parameterModel.ParameterInfo.ParameterType,
                BindingInfo = parameterModel.BindingInfo,
                ParameterInfo = parameterModel.ParameterInfo,
            };

            return parameterDescriptor;
        }

        private static ParameterDescriptor CreateParameterDescriptor(PropertyModel propertyModel)
        {
            var parameterDescriptor = new ControllerBoundPropertyDescriptor()
            {
                BindingInfo = propertyModel.BindingInfo,
                Name = propertyModel.PropertyName,
                ParameterType = propertyModel.PropertyInfo.PropertyType,
                PropertyInfo = propertyModel.PropertyInfo,
            };

            return parameterDescriptor;
        }

        private static void AddApiExplorerInfo(
            ControllerActionDescriptor actionDescriptor,
            ApplicationModel application,
            ControllerModel controller,
            ActionModel action)
        {
            var isVisible =
                action.ApiExplorer?.IsVisible ??
                controller.ApiExplorer?.IsVisible ??
                application.ApiExplorer?.IsVisible ??
                false;

            var isVisibleSetOnActionOrController =
                action.ApiExplorer?.IsVisible ??
                controller.ApiExplorer?.IsVisible ??
                false;

            // ApiExplorer isn't supported on conventional-routed actions, but we still allow you to configure
            // it at the application level when you have a mix of controller types. We'll just skip over enabling
            // ApiExplorer for conventional-routed controllers when this happens.
            var isVisibleSetOnApplication = application.ApiExplorer?.IsVisible ?? false;

            if (isVisibleSetOnActionOrController && !IsAttributeRouted(actionDescriptor))
            {
                // ApiExplorer is only supported on attribute routed actions.
                throw new InvalidOperationException(Resources.FormatApiExplorer_UnsupportedAction(
                    actionDescriptor.DisplayName));
            }
            else if (isVisibleSetOnApplication && !IsAttributeRouted(actionDescriptor))
            {
                // This is the case where we're going to be lenient, just ignore it.
            }
            else if (isVisible)
            {
                Debug.Assert(IsAttributeRouted(actionDescriptor));

                var apiExplorerActionData = new ApiDescriptionActionData()
                {
                    GroupName = action.ApiExplorer?.GroupName ?? controller.ApiExplorer?.GroupName,
                };

                actionDescriptor.SetProperty(apiExplorerActionData);
            }
        }

        private static void AddProperties(
            ControllerActionDescriptor actionDescriptor,
            ActionModel action,
            ControllerModel controller,
            ApplicationModel application)
        {
            foreach (var item in application.Properties)
            {
                actionDescriptor.Properties[item.Key] = item.Value;
            }

            foreach (var item in controller.Properties)
            {
                actionDescriptor.Properties[item.Key] = item.Value;
            }

            foreach (var item in action.Properties)
            {
                actionDescriptor.Properties[item.Key] = item.Value;
            }
        }

        private static void AddActionFilters(
            ControllerActionDescriptor actionDescriptor,
            IEnumerable<IFilterMetadata> actionFilters,
            IEnumerable<IFilterMetadata> controllerFilters,
            IEnumerable<IFilterMetadata> globalFilters)
        {
            actionDescriptor.FilterDescriptors =
                actionFilters.Select(f => new FilterDescriptor(f, FilterScope.Action))
                .Concat(controllerFilters.Select(f => new FilterDescriptor(f, FilterScope.Controller)))
                .Concat(globalFilters.Select(f => new FilterDescriptor(f, FilterScope.Global)))
                .OrderBy(d => d, FilterDescriptorOrderComparer.Comparer)
                .ToList();
        }

        private static void AddActionConstraints(ControllerActionDescriptor actionDescriptor, SelectorModel selectorModel)
        {
            if (selectorModel.ActionConstraints?.Count > 0)
            {
                actionDescriptor.ActionConstraints = new List<IActionConstraintMetadata>(selectorModel.ActionConstraints);
            }
        }

        private static void AddEndpointMetadata(ControllerActionDescriptor actionDescriptor, SelectorModel selectorModel)
        {
            if (selectorModel.EndpointMetadata?.Count > 0)
            {
                actionDescriptor.EndpointMetadata = new List<object>(selectorModel.EndpointMetadata);
            }
        }

        private static void AddAttributeRoute(ControllerActionDescriptor actionDescriptor, SelectorModel selectorModel)
        {
            if (selectorModel.AttributeRouteModel != null)
            {
                actionDescriptor.AttributeRouteInfo = new AttributeRouteInfo
                {
                    Template = selectorModel.AttributeRouteModel.Template,
                    Order = selectorModel.AttributeRouteModel.Order ?? 0,
                    Name = selectorModel.AttributeRouteModel.Name,
                    SuppressLinkGeneration = selectorModel.AttributeRouteModel.SuppressLinkGeneration,
                    SuppressPathMatching = selectorModel.AttributeRouteModel.SuppressPathMatching,
                };
            }
        }

        public static void AddRouteValues(
            ControllerActionDescriptor actionDescriptor,
            ControllerModel controller,
            ActionModel action)
        {
            // Apply all the constraints defined on the action, then controller (for example, [Area])
            // to the actions. Also keep track of all the constraints that require preventing actions
            // without the constraint to match. For example, actions without an [Area] attribute on their
            // controller should not match when a value has been given for area when matching a url or
            // generating a link.
            foreach (var kvp in action.RouteValues)
            {
                // Skip duplicates
                if (!actionDescriptor.RouteValues.ContainsKey(kvp.Key))
                {
                    actionDescriptor.RouteValues.Add(kvp.Key, kvp.Value);
                }
            }

            foreach (var kvp in controller.RouteValues)
            {
                // Skip duplicates - this also means that a value on the action will take precedence
                if (!actionDescriptor.RouteValues.ContainsKey(kvp.Key))
                {
                    actionDescriptor.RouteValues.Add(kvp.Key, kvp.Value);
                }
            }

            // Lastly add the 'default' values
            if (!actionDescriptor.RouteValues.ContainsKey("action"))
            {
                actionDescriptor.RouteValues.Add("action", action.ActionName ?? string.Empty);
            }

            if (!actionDescriptor.RouteValues.ContainsKey("controller"))
            {
                actionDescriptor.RouteValues.Add("controller", controller.ControllerName);
            }
        }

        private static bool IsAttributeRouted(ActionDescriptor actionDescriptor)
        {
            return actionDescriptor.AttributeRouteInfo != null;
        }
    }
```



#### 3.2 controller activator

##### 3.2.1 controller activator

```c#
public interface IControllerActivator
{    
    object Create(ControllerContext context);
        
    void Release(ControllerContext context, object controller);        
    ValueTask ReleaseAsync(ControllerContext context, object controller)
    {
        Release(context, controller);
        return default;
    }
}

```

###### 3.2.1.1 default controller activator

```c#
internal class DefaultControllerActivator : IControllerActivator
{
    private readonly ITypeActivatorCache _typeActivatorCache;
       
    public DefaultControllerActivator(ITypeActivatorCache typeActivatorCache)
    {
        if (typeActivatorCache == null)
        {
            throw new ArgumentNullException(nameof(typeActivatorCache));
        }
        
        _typeActivatorCache = typeActivatorCache;
    }
       
    public object Create(ControllerContext controllerContext)
    {
        if (controllerContext == null)
        {
            throw new ArgumentNullException(nameof(controllerContext));
        }
        
        if (controllerContext.ActionDescriptor == null)
        {
            throw new ArgumentException(
                Resources.FormatPropertyOfTypeCannotBeNull(
                    nameof(ControllerContext.ActionDescriptor),
                    nameof(ControllerContext)));
        }
        
        var controllerTypeInfo = controllerContext.ActionDescriptor.ControllerTypeInfo;
        
        if (controllerTypeInfo == null)
        {
            throw new ArgumentException(
                Resources.FormatPropertyOfTypeCannotBeNull(
                    nameof(controllerContext.ActionDescriptor.ControllerTypeInfo),
                    nameof(ControllerContext.ActionDescriptor)));
        }
        
        var serviceProvider = controllerContext.HttpContext.RequestServices;
        return _typeActivatorCache.CreateInstance<object>(serviceProvider, controllerTypeInfo.AsType());
    }
       
    public void Release(ControllerContext context, object controller)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        if (controller is IDisposable disposable)
        {
            disposable.Dispose();
        }
    }
    
    public ValueTask ReleaseAsync(ControllerContext context, object controller)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        if (controller is IAsyncDisposable asyncDisposable)
        {
            return asyncDisposable.DisposeAsync();
        }
        
        Release(context, controller);
        return default;
    }
}

```

###### 3.2.1.2 service based controller activator

```c#
public class ServiceBasedControllerActivator : IControllerActivator
    {
        /// <inheritdoc />
        public object Create(ControllerContext actionContext)
        {
            if (actionContext == null)
            {
                throw new ArgumentNullException(nameof(actionContext));
            }

            var controllerType = actionContext.ActionDescriptor.ControllerTypeInfo.AsType();

            return actionContext.HttpContext.RequestServices.GetRequiredService(controllerType);
        }

        /// <inheritdoc />
        public virtual void Release(ControllerContext context, object controller)
        {
        }
    }
```

##### 3.2.2 controller activator provider

```c#
public interface IControllerActivatorProvider
{   
    Func<ControllerContext, object> CreateActivator(ControllerActionDescriptor descriptor);
    
    Action<ControllerContext, object>? CreateReleaser(ControllerActionDescriptor descriptor);        
    Func<ControllerContext, object, ValueTask>? CreateAsyncReleaser(ControllerActionDescriptor descriptor)
    {
        var releaser = CreateReleaser(descriptor);
        if (releaser is null)
        {
            return static (_, _) => default;
        }
        
        return (context, controller) =>
        {
            releaser.Invoke(context, controller);
            return default;
        };
    }
}

```

###### 3.2.2.1 controller activator provider

```c#
public class ControllerActivatorProvider : IControllerActivatorProvider
{
    private static readonly Action<ControllerContext, object> _dispose = Dispose;
    private static readonly Func<ControllerContext, object, ValueTask> _disposeAsync = DisposeAsync;
    private static readonly Func<ControllerContext, object, ValueTask> _syncDisposeAsync = SyncDisposeAsync;
    private readonly Func<ControllerContext, object>? _controllerActivatorCreate;
    private readonly Action<ControllerContext, object>? _controllerActivatorRelease;
    private readonly Func<ControllerContext, object, ValueTask>? _controllerActivatorReleaseAsync;
    
    public ControllerActivatorProvider(IControllerActivator controllerActivator)        
    {
        if (controllerActivator == null)
        {
            throw new ArgumentNullException(nameof(controllerActivator));
        }
        
        // Compat: Delegate to controllerActivator if it's not the default implementation.
        if (controllerActivator.GetType() != typeof(DefaultControllerActivator))
        {
            _controllerActivatorCreate = controllerActivator.Create;
            _controllerActivatorRelease = controllerActivator.Release;
            _controllerActivatorReleaseAsync = controllerActivator.ReleaseAsync;
        }
    }
    
    /// <inheritdoc/>
    public Func<ControllerContext, object> CreateActivator(ControllerActionDescriptor descriptor)
    {
        if (descriptor == null)
        {
            throw new ArgumentNullException(nameof(descriptor));
        }
        
        var controllerType = descriptor.ControllerTypeInfo?.AsType();
        if (controllerType == null)
        {
            throw new ArgumentException(
                Resources.FormatPropertyOfTypeCannotBeNull(
                    nameof(descriptor.ControllerTypeInfo),
                    nameof(descriptor)),
                nameof(descriptor));
        }
        
        if (_controllerActivatorCreate != null)
        {
            return _controllerActivatorCreate;
        }
        
        var typeActivator = ActivatorUtilities.CreateFactory(controllerType, Type.EmptyTypes);
        return controllerContext => typeActivator(controllerContext.HttpContext.RequestServices, arguments: null);
    }
    
    /// <inheritdoc/>
    public Action<ControllerContext, object>? CreateReleaser(ControllerActionDescriptor descriptor)
    {
        if (descriptor == null)
        {
            throw new ArgumentNullException(nameof(descriptor));
        }
        
        if (_controllerActivatorRelease != null)
        {
            return _controllerActivatorRelease;
        }
        
        if (typeof(IDisposable).GetTypeInfo().IsAssignableFrom(descriptor.ControllerTypeInfo))
        {
            return _dispose;
        }
        
        return null;
    }
    
    /// <inheritdoc/>
    public Func<ControllerContext, object, ValueTask>? CreateAsyncReleaser(ControllerActionDescriptor descriptor)
    {
        if (descriptor == null)
        {
            throw new ArgumentNullException(nameof(descriptor));
        }
        
        if (_controllerActivatorReleaseAsync != null)
        {
            return _controllerActivatorReleaseAsync;
        }
        
        if (typeof(IAsyncDisposable).GetTypeInfo().IsAssignableFrom(descriptor.ControllerTypeInfo))
        {
            return _disposeAsync;
        }
        
        if (typeof(IDisposable).GetTypeInfo().IsAssignableFrom(descriptor.ControllerTypeInfo))
        {
            return _syncDisposeAsync;
        }
        
        return null;
    }
    
    private static void Dispose(ControllerContext context, object controller)
    {
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        ((IDisposable)controller).Dispose();
    }
    
    private static ValueTask DisposeAsync(ControllerContext context, object controller)
    {
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        return ((IAsyncDisposable)controller).DisposeAsync();
    }
    
    private static ValueTask SyncDisposeAsync(ControllerContext context, object controller)
    {
        Dispose(context, controller);
        return default;
    }
}

```

#### 3.3 controller property activator

##### 3.3.1 controller  property activator

```c#
internal interface IControllerPropertyActivator
{
    void Activate(ControllerContext context, object controller);    
    Action<ControllerContext, object> GetActivatorDelegate(ControllerActionDescriptor actionDescriptor);
}

```

###### 3.3.1.1 default controller property activator

```c#
internal class DefaultControllerPropertyActivator : IControllerPropertyActivator
{
    private static readonly Func<Type, PropertyActivator<ControllerContext>[]> _getPropertiesToActivate = GetPropertiesToActivate;
    private object _initializeLock = new object();
    private bool _initialized;
    private ConcurrentDictionary<Type, PropertyActivator<ControllerContext>[]>? _activateActions;
    
    public void Activate(ControllerContext context, object controller)
    {
        LazyInitializer.EnsureInitialized(
            ref _activateActions,
            ref _initialized,
            ref _initializeLock);
        
        var controllerType = controller.GetType();
        var propertiesToActivate = _activateActions!.GetOrAdd(
            controllerType,
            _getPropertiesToActivate);
        
        for (var i = 0; i < propertiesToActivate.Length; i++)
        {
            var activateInfo = propertiesToActivate[i];
            activateInfo.Activate(controller, context);
        }
    }
    
    public Action<ControllerContext, object> GetActivatorDelegate(ControllerActionDescriptor actionDescriptor)
    {
        if (actionDescriptor == null)
        {
            throw new ArgumentNullException(nameof(actionDescriptor));
        }
        
        var controllerType = actionDescriptor.ControllerTypeInfo?.AsType();
        if (controllerType == null)
        {
            throw new ArgumentException(
                Resources.FormatPropertyOfTypeCannotBeNull(
                    nameof(actionDescriptor.ControllerTypeInfo),
                    nameof(actionDescriptor)),
                nameof(actionDescriptor));
        }
        
        var propertiesToActivate = GetPropertiesToActivate(controllerType);
        void Activate(ControllerContext controllerContext, object controller)
        {
            for (var i = 0; i < propertiesToActivate.Length; i++)
            {
                var activateInfo = propertiesToActivate[i];
                activateInfo.Activate(controller, controllerContext);
            }
        }
        
        return Activate;
    }
    
    private static PropertyActivator<ControllerContext>[] GetPropertiesToActivate(Type type)
    {
        IEnumerable<PropertyActivator<ControllerContext>> activators;
        activators = PropertyActivator<ControllerContext>.GetPropertiesToActivate(
            type,
            typeof(ActionContextAttribute),
            p => new PropertyActivator<ControllerContext>(p, c => c));
        
        activators = activators.Concat(PropertyActivator<ControllerContext>.GetPropertiesToActivate(
            type,
            typeof(ControllerContextAttribute),
            p => new PropertyActivator<ControllerContext>(p, c => c)));
        
        return activators.ToArray();
    }
}

```

##### 3.3.2 controller property activator provider?

```c#

```

#### 3.4 controller binder delegate

##### 3.4.1 controller binder delegate

```c#
internal delegate Task ControllerBinderDelegate(
    ControllerContext controllerContext,
    object controller,
    Dictionary<string, object?> arguments);

```

##### 3.4.2 controller binder delegate provider

```c#
internal static class ControllerBinderDelegateProvider
{
    public static ControllerBinderDelegate? CreateBinderDelegate(
        ParameterBinder parameterBinder,
        IModelBinderFactory modelBinderFactory,
        IModelMetadataProvider modelMetadataProvider,
        ControllerActionDescriptor actionDescriptor,
        MvcOptions mvcOptions)
    {
        if (parameterBinder == null)
        {
            throw new ArgumentNullException(nameof(parameterBinder));
        }        
        if (modelBinderFactory == null)
        {
            throw new ArgumentNullException(nameof(modelBinderFactory));
        }        
        if (modelMetadataProvider == null)
        {
            throw new ArgumentNullException(nameof(modelMetadataProvider));
        }        
        if (actionDescriptor == null)
        {
            throw new ArgumentNullException(nameof(actionDescriptor));
        }        
        if (mvcOptions == null)
        {
            throw new ArgumentNullException(nameof(mvcOptions));
        }
        
        var parameterBindingInfo = GetParameterBindingInfo(
            modelBinderFactory,
            modelMetadataProvider,
            actionDescriptor);
        
        var propertyBindingInfo = GetPropertyBindingInfo(
            modelBinderFactory, 
            modelMetadataProvider, 
            actionDescriptor);
        
        if (parameterBindingInfo == null && propertyBindingInfo == null)
        {
            return null;
        }
        
        var parameters = actionDescriptor.Parameters switch
        {
                List<ParameterDescriptor> list => list.ToArray(),
                _ => actionDescriptor.Parameters.ToArray()
        };
        
        var properties = actionDescriptor.BoundProperties switch
        {
                List<ParameterDescriptor> list => list.ToArray(),
                _ => actionDescriptor.BoundProperties.ToArray()
        };
        
        return Bind;
        
        async Task Bind(
            ControllerContext controllerContext, 
            object controller, 
            Dictionary<string, object?> arguments)
        {
            var (success, valueProvider) = await CompositeValueProvider.TryCreateAsync(
                controllerContext, 
                controllerContext.ValueProviderFactories);
            
            if (!success)
            {
                return;
            }
            
            Debug.Assert(valueProvider is not null);
            
            for (var i = 0; i < parameters.Length; i++)
            {
                var parameter = parameters[i];
                var bindingInfo = parameterBindingInfo![i];
                var modelMetadata = bindingInfo.ModelMetadata;
                
                if (!modelMetadata.IsBindingAllowed)
                {
                    continue;
                }
                
                var result = await parameterBinder.BindModelAsync(
                    controllerContext,
                    bindingInfo.ModelBinder,
                    valueProvider,
                    parameter,
                    modelMetadata,
                    value: null,
                    container: null); // Parameters do not have containers.
                
                if (result.IsModelSet)
                {
                    arguments[parameter.Name] = result.Model;
                }
            }
            
            for (var i = 0; i < properties.Length; i++)
            {
                var property = properties[i];
                var bindingInfo = propertyBindingInfo![i];
                var modelMetadata = bindingInfo.ModelMetadata;
                
                if (!modelMetadata.IsBindingAllowed)
                {
                    continue;
                }
                
                var result = await parameterBinder.BindModelAsync(
                    controllerContext,
                    bindingInfo.ModelBinder,
                    valueProvider,
                    property,
                    modelMetadata,
                    value: null,
                    container: controller);
                
                if (result.IsModelSet)
                {
                    PropertyValueSetter.SetValue(
                        bindingInfo.ModelMetadata, 
                        controller, 
                        result.Model);
                }
            }
        }
    }
    
    private static BinderItem[]? GetParameterBindingInfo(
        IModelBinderFactory modelBinderFactory,
        IModelMetadataProvider modelMetadataProvider,
        ControllerActionDescriptor actionDescriptor)
    {
        var parameters = actionDescriptor.Parameters;
        if (parameters.Count == 0)
        {
            return null;
        }
        
        var parameterBindingInfo = new BinderItem[parameters.Count];
        for (var i = 0; i < parameters.Count; i++)
        {
            var parameter = parameters[i];
            
            ModelMetadata metadata;
            if (modelMetadataProvider is ModelMetadataProvider modelMetadataProviderBase &&
                parameter is ControllerParameterDescriptor controllerParameterDescriptor)
            {
                // The default model metadata provider derives from ModelMetadataProvider
                // and can therefore supply information about attributes applied to parameters.
                metadata = modelMetadataProviderBase.GetMetadataForParameter(controllerParameterDescriptor.ParameterInfo);
            }
            else
            {
                // For backward compatibility, if there's a custom model metadata provider that
                // only implements the older IModelMetadataProvider interface, access the more
                // limited metadata information it supplies. In this scenario, validation attributes
                // are not supported on parameters.
                metadata = modelMetadataProvider.GetMetadataForType(parameter.ParameterType);
            }
            
            var binder = modelBinderFactory.CreateBinder(new ModelBinderFactoryContext
                                                         {
                                                             BindingInfo = parameter.BindingInfo,
                                                             Metadata = metadata,
                                                             CacheToken = parameter,
                                                         });
            
            parameterBindingInfo[i] = new BinderItem(binder, metadata);
        }
        
        return parameterBindingInfo;
    }
    
    private static BinderItem[]? GetPropertyBindingInfo(
        IModelBinderFactory modelBinderFactory,
        IModelMetadataProvider modelMetadataProvider,
        ControllerActionDescriptor actionDescriptor)
    {
        var properties = actionDescriptor.BoundProperties;
        if (properties.Count == 0)
        {
            return null;
        }
        
        var propertyBindingInfo = new BinderItem[properties.Count];
        var controllerType = actionDescriptor.ControllerTypeInfo.AsType();
        for (var i = 0; i < properties.Count; i++)
        {
            var property = properties[i];
            var metadata = modelMetadataProvider.GetMetadataForProperty(controllerType, property.Name);
            var binder = modelBinderFactory.CreateBinder(new ModelBinderFactoryContext
                                                         {
                                                             BindingInfo = property.BindingInfo,
                                                             Metadata = metadata,
                                                             CacheToken = property,
                                                         });
            
            propertyBindingInfo[i] = new BinderItem(binder, metadata);
        }
        
        return propertyBindingInfo;
    }
    
    private readonly struct BinderItem
    {
        public IModelBinder ModelBinder { get; }        
        public ModelMetadata ModelMetadata { get; }
        
        public BinderItem(IModelBinder modelBinder, ModelMetadata modelMetadata)
        {
            ModelBinder = modelBinder;
            ModelMetadata = modelMetadata;
        }                
    }
}

```

#### 3.5 controller feature

##### 3.5.1 controller feature

```c#
public class ControllerFeature
{    
    public IList<TypeInfo> Controllers { get; } = new List<TypeInfo>();
}

```

##### 3.5.2 controller feature provider

```c#
public class ControllerFeatureProvider : IApplicationFeatureProvider<ControllerFeature>
{
    private const string ControllerTypeNameSuffix = "Controller";
    
    /// <inheritdoc />
    public void PopulateFeature(
        IEnumerable<ApplicationPart> parts,
        ControllerFeature feature)
    {
        foreach (var part in parts.OfType<IApplicationPartTypeProvider>())
        {
            foreach (var type in part.Types)
            {
                if (IsController(type) && !feature.Controllers.Contains(type))
                {
                    feature.Controllers.Add(type);
                }
            }
        }
    }
       
    protected virtual bool IsController(TypeInfo typeInfo)
    {
        if (!typeInfo.IsClass)
        {
            return false;
        }
        
        if (typeInfo.IsAbstract)
        {
            return false;
        }
        
        // We only consider public top-level classes as controllers. IsPublic returns false for nested classes, 
        // regardless of visibility modifiers
        if (!typeInfo.IsPublic)
        {
            return false;
        }
        
        if (typeInfo.ContainsGenericParameters)
        {
            return false;
        }
        
        if (typeInfo.IsDefined(typeof(NonControllerAttribute)))
        {
            return false;
        }
        
        if (!typeInfo.Name.EndsWith(ControllerTypeNameSuffix, StringComparison.OrdinalIgnoreCase) &&
            !typeInfo.IsDefined(typeof(ControllerAttribute)))
        {
            return false;
        }
        
        return true;
    }
}

```

#### 3.6 controller factory

##### 3.6.1 controller factory

```c#
public interface IControllerFactory
{    
    object CreateController(ControllerContext context);
        
    void ReleaseController(ControllerContext context, object controller);        
    ValueTask ReleaseControllerAsync(ControllerContext context, object controller)
    {
        ReleaseController(context, controller);
        return default;
    }
}

```

###### 3.6.1.1 default controller factory

```c#
internal class DefaultControllerFactory : IControllerFactory
{
    private readonly IControllerActivator _controllerActivator;
    private readonly IControllerPropertyActivator[] _propertyActivators;
    
    public DefaultControllerFactory(
        IControllerActivator controllerActivator,
        IEnumerable<IControllerPropertyActivator> propertyActivators)
    {
        if (controllerActivator == null)
        {
            throw new ArgumentNullException(nameof(controllerActivator));
        }        
        if (propertyActivators == null)
        {
            throw new ArgumentNullException(nameof(propertyActivators));
        }
        
        _controllerActivator = controllerActivator;
        _propertyActivators = propertyActivators.ToArray();
    }
        
    public object CreateController(ControllerContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        if (context.ActionDescriptor == null)
        {
            throw new ArgumentException(
                Resources.FormatPropertyOfTypeCannotBeNull(
                    nameof(ControllerContext.ActionDescriptor),
                    nameof(ControllerContext)));
        }
        
        var controller = _controllerActivator.Create(context);
        foreach (var propertyActivator in _propertyActivators)
        {
            propertyActivator.Activate(context, controller);
        }
        
        return controller;
    }
       
    public void ReleaseController(ControllerContext context, object controller)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        _controllerActivator.Release(context, controller);
    }
    
    public ValueTask ReleaseControllerAsync(ControllerContext context, object controller)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }        
        if (controller == null)
        {
            throw new ArgumentNullException(nameof(controller));
        }
        
        return _controllerActivator.ReleaseAsync(context, controller);
    }
}

```

##### 3.6.2 controller factory provider

```c#
public interface IControllerFactoryProvider
{    
    Func<ControllerContext, object> CreateControllerFactory(ControllerActionDescriptor descriptor);
        
    Action<ControllerContext, object>? CreateControllerReleaser(ControllerActionDescriptor descriptor);        
    Func<ControllerContext, object, ValueTask>? CreateAsyncControllerReleaser(ControllerActionDescriptor descriptor)
    {
        var releaser = CreateControllerReleaser(descriptor);
        if (releaser is null)
        {
            return static (_, _) => default;
        }
        
        return (context, controller) =>
        {
            releaser.Invoke(context, controller);
            return default;
        };
    }
}

```

###### 3.6.2.1 controller factory provider

```c#
internal class ControllerFactoryProvider : IControllerFactoryProvider
{
    private readonly IControllerActivatorProvider _activatorProvider;
    private readonly Func<ControllerContext, object>? _factoryCreateController;
    private readonly Action<ControllerContext, object>? _factoryReleaseController;
    private readonly Func<ControllerContext, object, ValueTask>? _factoryReleaseControllerAsync;
    private readonly IControllerPropertyActivator[] _propertyActivators;
    
    public ControllerFactoryProvider(
        IControllerActivatorProvider activatorProvider,
        IControllerFactory controllerFactory,
        IEnumerable<IControllerPropertyActivator> propertyActivators)
    {
        if (activatorProvider == null)
        {
            throw new ArgumentNullException(nameof(activatorProvider));
        }
        
        if (controllerFactory == null)
        {
            throw new ArgumentNullException(nameof(controllerFactory));
        }
        
        _activatorProvider = activatorProvider;
        
        // Compat: Delegate to the IControllerFactory if it's not the default implementation.
        if (controllerFactory.GetType() != typeof(DefaultControllerFactory))
        {
            _factoryCreateController = controllerFactory.CreateController;
            _factoryReleaseController = controllerFactory.ReleaseController;
            _factoryReleaseControllerAsync = controllerFactory.ReleaseControllerAsync;
        }
        
        _propertyActivators = propertyActivators.ToArray();
    }
    
    public Func<ControllerContext, object> CreateControllerFactory(ControllerActionDescriptor descriptor)
    {
        if (descriptor == null)
        {
            throw new ArgumentNullException(nameof(descriptor));
        }
        
        var controllerType = descriptor.ControllerTypeInfo?.AsType();
        if (controllerType == null)
        {
            throw new ArgumentException(
                Resources.FormatPropertyOfTypeCannotBeNull(
                    nameof(descriptor.ControllerTypeInfo),
                    nameof(descriptor)),
                nameof(descriptor));
        }
        
        if (_factoryCreateController != null)
        {
            return _factoryCreateController;
        }
        
        var controllerActivator = _activatorProvider.CreateActivator(descriptor);
        var propertyActivators = GetPropertiesToActivate(descriptor);
        object CreateController(ControllerContext controllerContext)
        {
            var controller = controllerActivator(controllerContext);
            for (var i = 0; i < propertyActivators.Length; i++)
            {
                var propertyActivator = propertyActivators[i];
                propertyActivator(controllerContext, controller);
            }
            
            return controller;
        }
        
        return CreateController;
    }
    
    public Action<ControllerContext, object>? CreateControllerReleaser(ControllerActionDescriptor descriptor)
    {
        if (descriptor == null)
        {
            throw new ArgumentNullException(nameof(descriptor));
        }
        
        var controllerType = descriptor.ControllerTypeInfo?.AsType();
        if (controllerType == null)
        {
            throw new ArgumentException(
                Resources.FormatPropertyOfTypeCannotBeNull(
                    nameof(descriptor.ControllerTypeInfo),
                    nameof(descriptor)),
                nameof(descriptor));
        }
        
        if (_factoryReleaseController != null)
        {
            return _factoryReleaseController;
        }
        
        return _activatorProvider.CreateReleaser(descriptor);
    }
    
    public Func<ControllerContext, object, ValueTask>? CreateAsyncControllerReleaser(ControllerActionDescriptor descriptor)
    {
        if (descriptor == null)
        {
            throw new ArgumentNullException(nameof(descriptor));
        }
        
        var controllerType = descriptor.ControllerTypeInfo?.AsType();
        if (controllerType == null)
        {
            throw new ArgumentException(
                Resources.FormatPropertyOfTypeCannotBeNull(
                    nameof(descriptor.ControllerTypeInfo),
                    nameof(descriptor)),
                nameof(descriptor));
        }
        
        if (_factoryReleaseControllerAsync != null)
        {
            return _factoryReleaseControllerAsync;
        }
        
        return _activatorProvider.CreateAsyncReleaser(descriptor);
    }
    
    private Action<ControllerContext, object>[] GetPropertiesToActivate(ControllerActionDescriptor actionDescriptor)
    {
        var propertyActivators = new Action<ControllerContext, object>[_propertyActivators.Length];
        for (var i = 0; i < _propertyActivators.Length; i++)
        {
            var activatorProvider = _propertyActivators[i];
            propertyActivators[i] = activatorProvider.GetActivatorDelegate(actionDescriptor);
        }
        
        return propertyActivators;
    }
}

```



###### 3.2.1.3 type activator cache

```c#
internal interface ITypeActivatorCache
    {
        /// <summary>
        /// Creates an instance of <typeparamref name="TInstance"/>.
        /// </summary>
        /// <param name="serviceProvider">The <see cref="IServiceProvider"/> used to resolve dependencies for
        /// <paramref name="optionType"/>.</param>
        /// <param name="optionType">The <see cref="Type"/> of the <typeparamref name="TInstance"/> to create.</param>
        TInstance CreateInstance<TInstance>(IServiceProvider serviceProvider, Type optionType);
    }

internal class TypeActivatorCache : ITypeActivatorCache
    {
        private readonly Func<Type, ObjectFactory> _createFactory =
            (type) => ActivatorUtilities.CreateFactory(type, Type.EmptyTypes);
        private readonly ConcurrentDictionary<Type, ObjectFactory> _typeActivatorCache =
               new ConcurrentDictionary<Type, ObjectFactory>();

        /// <inheritdoc/>
        public TInstance CreateInstance<TInstance>(
            IServiceProvider serviceProvider,
            Type implementationType)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentNullException(nameof(serviceProvider));
            }

            if (implementationType == null)
            {
                throw new ArgumentNullException(nameof(implementationType));
            }

            var createFactory = _typeActivatorCache.GetOrAdd(implementationType, _createFactory);
            return (TInstance)createFactory(serviceProvider, arguments: null);
        }
    }
```



#### 3.7 controller action invoker

##### 3.7.1 controller action invoker cache entry

```c#
internal class ControllerActionInvokerCacheEntry
{
    public Func<ControllerContext, object> ControllerFactory { get; }    
    public Func<ControllerContext, object, ValueTask>? ControllerReleaser { get; }    
    public ControllerBinderDelegate? ControllerBinderDelegate { get; }    
    public FilterItem[] CachedFilters { get; }
    internal ObjectMethodExecutor ObjectMethodExecutor { get; }    
    internal ActionMethodExecutor ActionMethodExecutor { get; }
    
    internal ControllerActionInvokerCacheEntry(
        FilterItem[] cachedFilters,
        Func<ControllerContext, object> controllerFactory,
        Func<ControllerContext, object, ValueTask>? controllerReleaser,
        ControllerBinderDelegate? controllerBinderDelegate,
        ObjectMethodExecutor objectMethodExecutor,
        ActionMethodExecutor actionMethodExecutor)
    {
        ControllerFactory = controllerFactory;
        ControllerReleaser = controllerReleaser;
        ControllerBinderDelegate = controllerBinderDelegate;
        CachedFilters = cachedFilters;
        ObjectMethodExecutor = objectMethodExecutor;
        ActionMethodExecutor = actionMethodExecutor;
    }                
}

```







###### 3.2.1.2  object method executor

```c#

```

###### 3.2.1.3 action method executor

```c#
internal abstract class ActionMethodExecutor
    {
        private static readonly ActionMethodExecutor[] Executors = new ActionMethodExecutor[]
        {
            // Executors for sync methods
            new VoidResultExecutor(),
            new SyncActionResultExecutor(),
            new SyncObjectResultExecutor(),

            // Executors for async methods
            new AwaitableResultExecutor(),
            new TaskResultExecutor(),
            new TaskOfIActionResultExecutor(),
            new TaskOfActionResultExecutor(),
            new AwaitableObjectResultExecutor(),
        };

        public abstract ValueTask<IActionResult> Execute(
            IActionResultTypeMapper mapper,
            ObjectMethodExecutor executor,
            object controller,
            object?[]? arguments);

        protected abstract bool CanExecute(ObjectMethodExecutor executor);

        public static ActionMethodExecutor GetExecutor(ObjectMethodExecutor executor)
        {
            for (var i = 0; i < Executors.Length; i++)
            {
                if (Executors[i].CanExecute(executor))
                {
                    return Executors[i];
                }
            }

            Debug.Fail("Should not get here");
            throw new Exception();
        }

        // void LogMessage(..)
        private class VoidResultExecutor : ActionMethodExecutor
        {
            public override ValueTask<IActionResult> Execute(
                IActionResultTypeMapper mapper,
                ObjectMethodExecutor executor,
                object controller,
                object?[]? arguments)
            {
                executor.Execute(controller, arguments);
                return new ValueTask<IActionResult>(new EmptyResult());
            }

            protected override bool CanExecute(ObjectMethodExecutor executor)
                => !executor.IsMethodAsync && executor.MethodReturnType == typeof(void);
        }

        // IActionResult Post(..)
        // CreatedAtResult Put(..)
        private class SyncActionResultExecutor : ActionMethodExecutor
        {
            public override ValueTask<IActionResult> Execute(
                IActionResultTypeMapper mapper,
                ObjectMethodExecutor executor,
                object controller,
                object?[]? arguments)
            {
                var actionResult = (IActionResult)executor.Execute(controller, arguments)!;
                EnsureActionResultNotNull(executor, actionResult);

                return new ValueTask<IActionResult>(actionResult);
            }

            protected override bool CanExecute(ObjectMethodExecutor executor)
                => !executor.IsMethodAsync && typeof(IActionResult).IsAssignableFrom(executor.MethodReturnType);
        }

        // Person GetPerson(..)
        // object Index(..)
        private class SyncObjectResultExecutor : ActionMethodExecutor
        {
            public override ValueTask<IActionResult> Execute(
                IActionResultTypeMapper mapper,
                ObjectMethodExecutor executor,
                object controller,
                object?[]? arguments)
            {
                // Sync method returning arbitrary object
                var returnValue = executor.Execute(controller, arguments);
                var actionResult = ConvertToActionResult(mapper, returnValue, executor.MethodReturnType);
                return new ValueTask<IActionResult>(actionResult);
            }

            // Catch-all for sync methods
            protected override bool CanExecute(ObjectMethodExecutor executor) => !executor.IsMethodAsync;
        }

        // Task SaveState(..)
        private class TaskResultExecutor : ActionMethodExecutor
        {
            public override async ValueTask<IActionResult> Execute(
                IActionResultTypeMapper mapper,
                ObjectMethodExecutor executor,
                object controller,
                object?[]? arguments)
            {
                await (Task)executor.Execute(controller, arguments)!;
                return new EmptyResult();
            }

            protected override bool CanExecute(ObjectMethodExecutor executor) => executor.MethodReturnType == typeof(Task);
        }

        // CustomAsync PerformActionAsync(..)
        // Custom task-like type with no return value.
        private class AwaitableResultExecutor : ActionMethodExecutor
        {
            public override async ValueTask<IActionResult> Execute(
                IActionResultTypeMapper mapper,
                ObjectMethodExecutor executor,
                object controller,
                object?[]? arguments)
            {
                await executor.ExecuteAsync(controller, arguments);
                return new EmptyResult();
            }

            protected override bool CanExecute(ObjectMethodExecutor executor)
            {
                // Async method returning void
                return executor.IsMethodAsync && executor.AsyncResultType == typeof(void);
            }
        }

        // Task<IActionResult> Post(..)
        private class TaskOfIActionResultExecutor : ActionMethodExecutor
        {
            public override async ValueTask<IActionResult> Execute(
                IActionResultTypeMapper mapper,
                ObjectMethodExecutor executor,
                object controller,
                object?[]? arguments)
            {
                // Async method returning Task<IActionResult>
                // Avoid extra allocations by calling Execute rather than ExecuteAsync and casting to Task<IActionResult>.
                var returnValue = executor.Execute(controller, arguments);
                var actionResult = await (Task<IActionResult>)returnValue!;
                EnsureActionResultNotNull(executor, actionResult);

                return actionResult;
            }

            protected override bool CanExecute(ObjectMethodExecutor executor)
                => typeof(Task<IActionResult>).IsAssignableFrom(executor.MethodReturnType);
        }

        // Task<PhysicalFileResult> DownloadFile(..)
        // ValueTask<ViewResult> GetViewsAsync(..)
        private class TaskOfActionResultExecutor : ActionMethodExecutor
        {
            public override async ValueTask<IActionResult> Execute(
                IActionResultTypeMapper mapper,
                ObjectMethodExecutor executor,
                object controller,
                object?[]? arguments)
            {
                // Async method returning awaitable-of-IActionResult (e.g., Task<ViewResult>)
                // We have to use ExecuteAsync because we don't know the awaitable's type at compile time.
                var actionResult = (IActionResult)await executor.ExecuteAsync(controller, arguments);
                EnsureActionResultNotNull(executor, actionResult);
                return actionResult;
            }

            protected override bool CanExecute(ObjectMethodExecutor executor)
            {
                // Async method returning awaitable-of - IActionResult(e.g., Task<ViewResult>)
                return executor.IsMethodAsync && typeof(IActionResult).IsAssignableFrom(executor.AsyncResultType);
            }
        }

        // Task<object> GetPerson(..)
        // Task<Customer> GetCustomerAsync(..)
        private class AwaitableObjectResultExecutor : ActionMethodExecutor
        {
            public override async ValueTask<IActionResult> Execute(
                IActionResultTypeMapper mapper,
                ObjectMethodExecutor executor,
                object controller,
                object?[]? arguments)
            {
                // Async method returning awaitable-of-nonvoid
                var returnValue = await executor.ExecuteAsync(controller, arguments);
                var actionResult = ConvertToActionResult(mapper, returnValue, executor.AsyncResultType!);
                return actionResult;
            }

            protected override bool CanExecute(ObjectMethodExecutor executor) => true;
        }

        private static void EnsureActionResultNotNull(ObjectMethodExecutor executor, IActionResult actionResult)
        {
            if (actionResult == null)
            {
                var type = executor.AsyncResultType ?? executor.MethodReturnType;
                throw new InvalidOperationException(Resources.FormatActionResult_ActionReturnValueCannotBeNull(type));
            }
        }

        private IActionResult ConvertToActionResult(IActionResultTypeMapper mapper, object? returnValue, Type declaredType)
        {
            var result = (returnValue as IActionResult) ?? mapper.Convert(returnValue, declaredType);
            if (result == null)
            {
                throw new InvalidOperationException(Resources.FormatActionResult_ActionReturnValueCannotBeNull(declaredType));
            }

            return result;
        }
    }
```

##### 3.7.2 controller action invoker cache

```c#
internal class ControllerActionInvokerCache
{
    private readonly ParameterBinder _parameterBinder;
    private readonly IModelBinderFactory _modelBinderFactory;
    private readonly IModelMetadataProvider _modelMetadataProvider;
    private readonly IFilterProvider[] _filterProviders;
    private readonly IControllerFactoryProvider _controllerFactoryProvider;
    private readonly MvcOptions _mvcOptions;
    
    public ControllerActionInvokerCache(
        ParameterBinder parameterBinder,
        IModelBinderFactory modelBinderFactory,
        IModelMetadataProvider modelMetadataProvider,
        IEnumerable<IFilterProvider> filterProviders,
        IControllerFactoryProvider factoryProvider,
        IOptions<MvcOptions> mvcOptions)
    {
        _parameterBinder = parameterBinder;
        _modelBinderFactory = modelBinderFactory;
        _modelMetadataProvider = modelMetadataProvider;
        _filterProviders = filterProviders.OrderBy(item => item.Order).ToArray();
        _controllerFactoryProvider = factoryProvider;
        _mvcOptions = mvcOptions.Value;
    }
    
    public (ControllerActionInvokerCacheEntry cacheEntry, IFilterMetadata[] filters) GetCachedResult(ControllerContext controllerContext)
    {
        var actionDescriptor = controllerContext.ActionDescriptor;
        
        IFilterMetadata[] filters;
        
        var cacheEntry = actionDescriptor.CacheEntry;
        
        // We don't care about thread safety here
        if (cacheEntry is null)
        {
            var filterFactoryResult = FilterFactory.GetAllFilters(_filterProviders, controllerContext);
            filters = filterFactoryResult.Filters;
            
            var parameterDefaultValues = ParameterDefaultValues.GetParameterDefaultValues(actionDescriptor.MethodInfo);
            
            var objectMethodExecutor = ObjectMethodExecutor.Create(
                actionDescriptor.MethodInfo,
                actionDescriptor.ControllerTypeInfo,
                parameterDefaultValues);
            
            var controllerFactory = _controllerFactoryProvider.CreateControllerFactory(actionDescriptor);
            var controllerReleaser = _controllerFactoryProvider.CreateAsyncControllerReleaser(actionDescriptor);
            var propertyBinderFactory = ControllerBinderDelegateProvider.CreateBinderDelegate(
                _parameterBinder,
                _modelBinderFactory,
                _modelMetadataProvider,
                actionDescriptor,
                _mvcOptions);
            
            var actionMethodExecutor = ActionMethodExecutor.GetExecutor(objectMethodExecutor);
            
            cacheEntry = new ControllerActionInvokerCacheEntry(
                filterFactoryResult.CacheableFilters,
                controllerFactory,
                controllerReleaser,
                propertyBinderFactory,
                objectMethodExecutor,
                actionMethodExecutor);
            
            actionDescriptor.CacheEntry = cacheEntry;
        }
        else
        {
            // Filter instances from statically defined filter descriptors + from filter providers
            filters = FilterFactory.CreateUncachedFilters(_filterProviders, controllerContext, cacheEntry.CachedFilters);
        }
        
        return (cacheEntry, filters);
    }
}

```

##### 3.7.3 controller action invoker

```c#
internal class ControllerActionInvoker : ResourceInvoker, IActionInvoker
{
    private readonly ControllerActionInvokerCacheEntry _cacheEntry;    
    
    private readonly ControllerContext _controllerContext;    
    internal ControllerContext ControllerContext => _controllerContext;
    
    private Dictionary<string, object?>? _arguments;    
    private ActionExecutingContextSealed? _actionExecutingContext;
    private ActionExecutedContextSealed? _actionExecutedContext;
    
    internal ControllerActionInvoker(
        ILogger logger,
        DiagnosticListener diagnosticListener,
        IActionContextAccessor actionContextAccessor,
        IActionResultTypeMapper mapper,            
        ControllerContext controllerContext,
        ControllerActionInvokerCacheEntry cacheEntry,
        IFilterMetadata[] filters)            
        	: base(
                diagnosticListener, 
                logger, 
                actionContextAccessor, 
                mapper, 
                controllerContext, 
                filters, 
                controllerContext.ValueProviderFactories)
    {
        if (cacheEntry == null)
        {
            throw new ArgumentNullException(nameof(cacheEntry));
        }
        
        _cacheEntry = cacheEntry;
        _controllerContext = controllerContext;
    }
            
    protected override ValueTask ReleaseResources()
    {
        if (_instance != null && _cacheEntry.ControllerReleaser != null)
        {
            return _cacheEntry.ControllerReleaser(_controllerContext, _instance);
        }
        
        return default;
    }
    
    private Task Next(
        ref State next, 
        ref Scope scope, 
        ref object? state, 
        ref bool isCompleted)
    {
        switch (next)
        {
            case State.ActionBegin:
            {
                var controllerContext = _controllerContext;
                
                _cursor.Reset();
                
                _logger.ExecutingControllerFactory(controllerContext);
                
                _instance = _cacheEntry.ControllerFactory(controllerContext);
                
                _logger.ExecutedControllerFactory(controllerContext);
                
                _arguments = 
                    new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
                
                var task = BindArgumentsAsync();
                if (task.Status != TaskStatus.RanToCompletion)
                {
                    next = State.ActionNext;
                    return task;
                }
                
                goto case State.ActionNext;
            }
                
            case State.ActionNext:
            {
                var current = _cursor.GetNextFilter<IActionFilter, IAsyncActionFilter>();
                if (current.FilterAsync != null)
                {
                    if (_actionExecutingContext == null)
                    {
                        _actionExecutingContext = 
                            new ActionExecutingContextSealed(
                            _controllerContext, 
                            _filters, 
                            _arguments!, 
                            _instance!);
                    }
                    
                    state = current.FilterAsync;
                    goto case State.ActionAsyncBegin;
                }
                else if (current.Filter != null)
                {
                    if (_actionExecutingContext == null)
                    {
                        _actionExecutingContext = 
                            new ActionExecutingContextSealed(
	                            _controllerContext, 
                                _filters, 
                                _arguments!, 
                                _instance!);
                    }
                    
                    state = current.Filter;
                    goto case State.ActionSyncBegin;
                }
                else
                {
                    goto case State.ActionInside;
                }
            }
                
            case State.ActionAsyncBegin:
            {
                Debug.Assert(state != null);
                Debug.Assert(_actionExecutingContext != null);
                
                var filter = (IAsyncActionFilter)state;
                var actionExecutingContext = _actionExecutingContext;
                
                _diagnosticListener
                    .BeforeOnActionExecution(
                    actionExecutingContext, 
                    filter);
                _logger.BeforeExecutingMethodOnFilter(
                    MvcCoreLoggerExtensions.ActionFilter,
                    nameof(IAsyncActionFilter.OnActionExecutionAsync),
                    filter);
                    
                var task = filter
                    .OnActionExecutionAsync(
                    	actionExecutingContext, 
                    	InvokeNextActionFilterAwaitedAsync);
                if (task.Status != TaskStatus.RanToCompletion)
                {
                    next = State.ActionAsyncEnd;
                    return task;
                }
                
                goto case State.ActionAsyncEnd;
            }
                
            case State.ActionAsyncEnd:
            {
                Debug.Assert(state != null);
                Debug.Assert(_actionExecutingContext != null);
                
                var filter = (IAsyncActionFilter)state;
                
                if (_actionExecutedContext == null)
                {
                    // If we get here then the filter didn't call 'next' 
                    // indicating a short circuit.
                    _logger.ActionFilterShortCircuited(filter);
                    
                    _actionExecutedContext = 
                        new ActionExecutedContextSealed(
                        	_controllerContext,
                        	_filters,
                        	_instance!)
                    	{
                            Canceled = true,
                            Result = _actionExecutingContext.Result,
                        };
                    }
                    
                    _diagnosticListener
                        .AfterOnActionExecution(
                        	_actionExecutedContext, 
                        	filter);
                    _logger.AfterExecutingMethodOnFilter(
                        MvcCoreLoggerExtensions.ActionFilter,
                        nameof(IAsyncActionFilter.OnActionExecutionAsync),
                        filter);
                
                goto case State.ActionEnd;
            }
                
            case State.ActionSyncBegin:
            {
                Debug.Assert(state != null);
                Debug.Assert(_actionExecutingContext != null);
                
                var filter = (IActionFilter)state;
                var actionExecutingContext = _actionExecutingContext;
                
                _diagnosticListener
                    .BeforeOnActionExecuting(
                    	actionExecutingContext, 
                    	filter);
                _logger.BeforeExecutingMethodOnFilter(
                    MvcCoreLoggerExtensions.ActionFilter,
                    nameof(IActionFilter.OnActionExecuting),
                    filter);
                
                filter.OnActionExecuting(actionExecutingContext);
                
                _diagnosticListener
                    .AfterOnActionExecuting(
                    	actionExecutingContext, 
                    	filter);
                _logger.AfterExecutingMethodOnFilter(
                    MvcCoreLoggerExtensions.ActionFilter,
                    nameof(IActionFilter.OnActionExecuting),
                    filter);
                
                if (actionExecutingContext.Result != null)
                {
                    // Short-circuited by setting a result.
                    _logger.ActionFilterShortCircuited(filter);
                    
                    _actionExecutedContext = 
                        new ActionExecutedContextSealed(
                        	_actionExecutingContext,
	                        _filters,
    	                    _instance!)
        	            {
            	            Canceled = true,
                	        Result = _actionExecutingContext.Result,
                    	};
                    
                    goto case State.ActionEnd;
                }
                
                var task = InvokeNextActionFilterAsync();
                if (task.Status != TaskStatus.RanToCompletion)
                {
                    next = State.ActionSyncEnd;
                    return task;
                }
                
                goto case State.ActionSyncEnd;
            }
                
            case State.ActionSyncEnd:
            {
                Debug.Assert(state != null);
                Debug.Assert(_actionExecutingContext != null);
                Debug.Assert(_actionExecutedContext != null);
                
                var filter = (IActionFilter)state;
                var actionExecutedContext = _actionExecutedContext;
                
                _diagnosticListener
                    .BeforeOnActionExecuted(
                    	actionExecutedContext, 
                    	filter);
                _logger.BeforeExecutingMethodOnFilter(
                    MvcCoreLoggerExtensions.ActionFilter,
                    nameof(IActionFilter.OnActionExecuted),
                    filter);
                
                filter.OnActionExecuted(actionExecutedContext);
                
                _diagnosticListener
                    .AfterOnActionExecuted(
                    	actionExecutedContext, 
                    	filter);
                _logger.AfterExecutingMethodOnFilter(
                    MvcCoreLoggerExtensions.ActionFilter,
                    nameof(IActionFilter.OnActionExecuted),
                    filter);
                
                goto case State.ActionEnd;
            }
                
            case State.ActionInside:
            {
                var task = InvokeActionMethodAsync();
                if (task.Status != TaskStatus.RanToCompletion)
                {
                    next = State.ActionEnd;
                    return task;
                }
                
                goto case State.ActionEnd;
            }
                
            case State.ActionEnd:
            {
                if (scope == Scope.Action)
                {
                    if (_actionExecutedContext == null)
                    {
                        _actionExecutedContext = 
                            new ActionExecutedContextSealed(
                            	_controllerContext, 
	                            _filters, 
                              	_instance!)
                        	{
                                Result = _result,
                            };
                    }
                    
                    isCompleted = true;
                    return Task.CompletedTask;
                }
                
                var actionExecutedContext = _actionExecutedContext;
                Rethrow(actionExecutedContext);
                
                if (actionExecutedContext != null)
                {
                    _result = actionExecutedContext.Result;
                }
                
                isCompleted = true;
                return Task.CompletedTask;
            }
                
            default:
                throw new InvalidOperationException();
        }
    }
    
    private Task InvokeNextActionFilterAsync()
    {
        try
        {
            var next = State.ActionNext;
            var state = (object?)null;
            var scope = Scope.Action;
            var isCompleted = false;
            while (!isCompleted)
            {
                var lastTask = Next(ref next, ref scope, ref state, ref isCompleted);
                if (!lastTask.IsCompletedSuccessfully)
                {
                    return Awaited(this, lastTask, next, scope, state, isCompleted);
                }
            }
        }
        catch (Exception exception)
        {
            _actionExecutedContext = 
                new ActionExecutedContextSealed(
                	_controllerContext, 
                	_filters, 
                	_instance!)
            {
                ExceptionDispatchInfo = ExceptionDispatchInfo.Capture(exception),
            };
        }
        
        Debug.Assert(_actionExecutedContext != null);
        return Task.CompletedTask;
        
        static async Task Awaited(
            ControllerActionInvoker invoker, 
            Task lastTask, 
            State next, 
            Scope scope, 
            object? state, 
            bool isCompleted)
        {
            try
            {
                await lastTask;
                
                while (!isCompleted)
                {
                    await invoker.Next(
                        ref next, 
                        ref scope, 
                        ref state, 
                        ref isCompleted);
                }
            }
            catch (Exception exception)
            {
                invoker._actionExecutedContext = 
                    new ActionExecutedContextSealed(
                    	invoker._controllerContext, 
                    	invoker._filters, 
                    	invoker._instance!)
                {
                    ExceptionDispatchInfo = ExceptionDispatchInfo.Capture(exception),
                };
            }
            
            Debug.Assert(invoker._actionExecutedContext != null);
        }
    }
    
    private Task<ActionExecutedContext> InvokeNextActionFilterAwaitedAsync()
    {
        Debug.Assert(_actionExecutingContext != null);
        if (_actionExecutingContext.Result != null)
        {
            // If we get here, 
            // it means that an async filter set a result AND called next(). This is forbidden.
            return Throw();
        }
        
        var task = InvokeNextActionFilterAsync();
        if (!task.IsCompletedSuccessfully)
        {
            return Awaited(this, task);
        }
        
        Debug.Assert(_actionExecutedContext != null);
        return Task.FromResult<ActionExecutedContext>(_actionExecutedContext);
        
        static async Task<ActionExecutedContext> Awaited(
            ControllerActionInvoker invoker, 
            Task task)
        {
            await task;
            
            Debug.Assert(invoker._actionExecutedContext != null);
            return invoker._actionExecutedContext;
        }
#pragma warning disable CS1998
    	static async Task<ActionExecutedContext> Throw()
		{
    		var message = 
                Resources.FormatAsyncActionFilter_InvalidShortCircuit(
                	typeof(IAsyncActionFilter).Name,
	                nameof(ActionExecutingContext.Result),
    	            typeof(ActionExecutingContext).Name,
        	        typeof(ActionExecutionDelegate).Name);
    
		    throw new InvalidOperationException(message);
		}
#pragma warning restore CS1998
    }
    
    private Task InvokeActionMethodAsync()
    {
        if (_diagnosticListener.IsEnabled() || _logger.IsEnabled(LogLevel.Trace))
        {
            return Logged(this);
        }
        
        var objectMethodExecutor = _cacheEntry.ObjectMethodExecutor;
        var actionMethodExecutor = _cacheEntry.ActionMethodExecutor;
        var orderedArguments = PrepareArguments(_arguments, objectMethodExecutor);
        
        var actionResultValueTask = actionMethodExecutor.Execute(_mapper, objectMethodExecutor, _instance!, orderedArguments);
        if (actionResultValueTask.IsCompletedSuccessfully)
        {
            _result = actionResultValueTask.Result;
        }
        else
        {
            return Awaited(this, actionResultValueTask);
        }
        
        return Task.CompletedTask;
        
        static async Task Awaited(ControllerActionInvoker invoker, ValueTask<IActionResult> actionResultValueTask)
        {
            invoker._result = await actionResultValueTask;
        }
        
        static async Task Logged(ControllerActionInvoker invoker)
        {
            var controllerContext = invoker._controllerContext;
            var objectMethodExecutor = invoker._cacheEntry.ObjectMethodExecutor;
            var controller = invoker._instance;
            var arguments = invoker._arguments;
            var actionMethodExecutor = invoker._cacheEntry.ActionMethodExecutor;
            var orderedArguments = PrepareArguments(arguments, objectMethodExecutor);
            
            var diagnosticListener = invoker._diagnosticListener;
            var logger = invoker._logger;
            
            IActionResult? result = null;
            try
            {
                diagnosticListener.BeforeControllerActionMethod(
                    controllerContext,
                    arguments,
                    controller);
                logger.ActionMethodExecuting(controllerContext, orderedArguments);
                var stopwatch = ValueStopwatch.StartNew();
                var actionResultValueTask = actionMethodExecutor.Execute(invoker._mapper, objectMethodExecutor, controller!, orderedArguments);
                if (actionResultValueTask.IsCompletedSuccessfully)
                {
                    result = actionResultValueTask.Result;
                }
                else
                {
                    result = await actionResultValueTask;
                }
                
                invoker._result = result;
                logger.ActionMethodExecuted(controllerContext, result, stopwatch.GetElapsedTime());
            }
            finally
            {
                diagnosticListener.AfterControllerActionMethod(
                    controllerContext,
                    arguments,
                    controllerContext,
                    result);
            }
        }
    }
    
    /// <remarks><see cref="ResourceInvoker.InvokeFilterPipelineAsync"/> for details on what the
    /// variables in this method represent.</remarks>
    protected override Task InvokeInnerFilterAsync()
    {
        try
        {
            var next = State.ActionBegin;
            var scope = Scope.Invoker;
            var state = (object?)null;
            var isCompleted = false;
            
            while (!isCompleted)
            {
                var lastTask = Next(ref next, ref scope, ref state, ref isCompleted);
                if (!lastTask.IsCompletedSuccessfully)
                {
                    return Awaited(this, lastTask, next, scope, state, isCompleted);
                }
            }
            
            return Task.CompletedTask;
        }
        catch (Exception ex)
        {
            // Wrap non task-wrapped exceptions in a Task,
            // as this isn't done automatically since the method is not async.
            return Task.FromException(ex);
        }
        
        static async Task Awaited(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, object? state, bool isCompleted)
        {
            await lastTask;
            
            while (!isCompleted)
            {
                await invoker.Next(ref next, ref scope, ref state, ref isCompleted);
            }
        }
    }
    
    private static void Rethrow(ActionExecutedContextSealed? context)
    {
        if (context == null)
        {
            return;
        }
        
        if (context.ExceptionHandled)
        {
            return;
        }
        
        if (context.ExceptionDispatchInfo != null)
        {
            context.ExceptionDispatchInfo.Throw();
        }
        
        if (context.Exception != null)
        {
            throw context.Exception;
        }
    }
    
    private Task BindArgumentsAsync()
    {
        // Perf: Avoid allocating async state machines where possible. We only need the state
        // machine if you need to bind properties or arguments.
        var actionDescriptor = _controllerContext.ActionDescriptor;
        if (actionDescriptor.BoundProperties.Count == 0 &&
            actionDescriptor.Parameters.Count == 0)
        {
            return Task.CompletedTask;
        }
        
        Debug.Assert(_cacheEntry.ControllerBinderDelegate != null);
        return _cacheEntry.ControllerBinderDelegate(_controllerContext, _instance, _arguments!);
    }
    
    private static object?[]? PrepareArguments(
        IDictionary<string, object?>? actionParameters,
        ObjectMethodExecutor actionMethodExecutor)
    {
        var declaredParameterInfos = actionMethodExecutor.MethodParameters;
        var count = declaredParameterInfos.Length;
        if (count == 0)
        {
            return null;
        }
        
        Debug.Assert(actionParameters != null, "Expect arguments to be initialized.");
        
        var arguments = new object?[count];
        for (var index = 0; index < count; index++)
        {
            var parameterInfo = declaredParameterInfos[index];
            
            if (!actionParameters.TryGetValue(parameterInfo.Name!, out var value))
            {
                value = actionMethodExecutor.GetDefaultValueForParameter(index);
            }
            
            arguments[index] = value;
        }
        
        return arguments;
    }
    
    private enum Scope
    {
        Invoker,
        Action,
    }
    
    private enum State
    {
        ActionBegin,
        ActionNext,
        ActionAsyncBegin,           
        ActionAsyncEnd,
        ActionSyncBegin,
        ActionSyncEnd,
        ActionInside,
        ActionEnd,
    }
    
    private sealed class ActionExecutingContextSealed : ActionExecutingContext
    {
        public ActionExecutingContextSealed(ActionContext actionContext, IList<IFilterMetadata> filters, IDictionary<string, object?> actionArguments, object controller) : base(actionContext, filters, actionArguments, controller) { }
    }
    
    private sealed class ActionExecutedContextSealed : ActionExecutedContext
    {
        public ActionExecutedContextSealed(ActionContext actionContext, IList<IFilterMetadata> filters, object controller) : base(actionContext, filters, controller) { }
    }
}

```



##### 3.7.4 controller action invoker provider

```c#
internal class ControllerActionInvokerProvider : IActionInvokerProvider
{
    private readonly ControllerActionInvokerCache _controllerActionInvokerCache;
    private readonly IReadOnlyList<IValueProviderFactory> _valueProviderFactories;
    private readonly int _maxModelValidationErrors;
    private readonly ILogger _logger;
    private readonly DiagnosticListener _diagnosticListener;
    private readonly IActionResultTypeMapper _mapper;
    private readonly IActionContextAccessor _actionContextAccessor;
    
    public int Order => -1000;
    
    public ControllerActionInvokerProvider(
        ControllerActionInvokerCache controllerActionInvokerCache,
        IOptions<MvcOptions> optionsAccessor,
        ILoggerFactory loggerFactory,
        DiagnosticListener diagnosticListener,
        IActionResultTypeMapper mapper) : 
    		this(
                controllerActionInvokerCache, 
                optionsAccessor, 
                loggerFactory, 
                diagnosticListener, 
                mapper, 
                null)
    {
    }
    
    public ControllerActionInvokerProvider(
        ControllerActionInvokerCache controllerActionInvokerCache,
        IOptions<MvcOptions> optionsAccessor,
        ILoggerFactory loggerFactory,
        DiagnosticListener diagnosticListener,
        IActionResultTypeMapper mapper,
        IActionContextAccessor? actionContextAccessor)
    {
        _controllerActionInvokerCache = controllerActionInvokerCache;
        _valueProviderFactories = optionsAccessor.Value.ValueProviderFactories.ToArray();
        _maxModelValidationErrors = optionsAccessor.Value.MaxModelValidationErrors;
        _logger = loggerFactory.CreateLogger<ControllerActionInvoker>();
        _diagnosticListener = diagnosticListener;
        _mapper = mapper;
        _actionContextAccessor = actionContextAccessor ?? ActionContextAccessor.Null;
    }
            
    /// <inheritdoc />
    public void OnProvidersExecuting(ActionInvokerProviderContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        if (context.ActionContext.ActionDescriptor is ControllerActionDescriptor)
        {
            var controllerContext = new ControllerContext(context.ActionContext)
            {
                // PERF: These are rarely going to be changed, so let's go copy-on-write.
                ValueProviderFactories = new CopyOnWriteList<IValueProviderFactory>(_valueProviderFactories)
            };
            controllerContext.ModelState.MaxAllowedErrors = _maxModelValidationErrors;
            
            var (cacheEntry, filters) = _controllerActionInvokerCache.GetCachedResult(controllerContext);
            
            var invoker = new ControllerActionInvoker(
                _logger,
                _diagnosticListener,
                _actionContextAccessor,
                _mapper,
                controllerContext,
                cacheEntry,
                filters);
            
            context.Result = invoker;
        }
    }
    
    /// <inheritdoc />
    public void OnProvidersExecuted(ActionInvokerProviderContext context)
    {
    }
}

```

### 4. api explorer

#### 4.1 api description

##### 4.1.1 api description

```c#
[DebuggerDisplay("{ActionDescriptor.DisplayName,nq}")]
public class ApiDescription
{                
    public string? GroupName { get; set; }        
    public string? HttpMethod { get; set; }
    public string RelativePath { get; set; } = default!;
    public IDictionary<object, object> Properties { get; } = new Dictionary<object, object>();
    
    public ActionDescriptor ActionDescriptor { get; set; } = default!;
    public IList<ApiParameterDescription> ParameterDescriptions { get; } = 
        new List<ApiParameterDescription>();                                
    public IList<ApiRequestFormat> SupportedRequestFormats { get; } = 
        new List<ApiRequestFormat>();        
    public IList<ApiResponseType> SupportedResponseTypes { get; } = 
        new List<ApiResponseType>();
}

```

###### 4.1.1.1 api parameter description

```c#
public class ApiParameterDescription
{             
    public string Name { get; set; } = default!; 
    public Type Type { get; set; } = default!;  
    public bool IsRequired { get; set; }        
    public object? DefaultValue { get; set; }
    public ModelMetadata ModelMetadata { get; set; } = default!;   
    public BindingSource Source { get; set; } = default!;        
    public BindingInfo? BindingInfo { get; set; }         
    
    public ApiParameterRouteInfo? RouteInfo { get; set; }  
    public ParameterDescriptor ParameterDescriptor { get; set; } = default!;        
    
}

```

###### 4.1.1.2 api parameter route info

```c#
public class ApiParameterRouteInfo
{    
    public object? DefaultValue { get; set; }        
    public bool IsOptional { get; set; }
    
    public IEnumerable<IRouteConstraint>? Constraints { get; set; }  
}

```

###### 4.1.1.3 api request format

```c#
public class ApiRequestFormat
{    
    public IInputFormatter Formatter { get; set; } = default!;        
    public string MediaType { get; set; } = default!;
}

```

###### 4.1.1.4 api response format

```c#
public class ApiResponseFormat
{
    public IOutputFormatter Formatter { get; set; } = default!;       
    public string MediaType { get; set; } = default!;
}

```

###### 4.1.1.5 api response type

```c#
public class ApiResponseType
{    
    public IList<ApiResponseFormat> ApiResponseFormats { get; set; } = 
        new List<ApiResponseFormat>();        
    public ModelMetadata? ModelMetadata { get; set; }        
    public Type? Type { get; set; }        
    public int StatusCode { get; set; }        
    public bool IsDefaultResponse { get; set; }
}

```

##### 4.1.2扩展方法 - get & set property

```c#
public static class ApiDescriptionExtensions
{    
    public static T GetProperty<T>(this ApiDescription apiDescription)
    {
        if (apiDescription == null)
        {
            throw new ArgumentNullException(nameof(apiDescription));
        }
        
        object value;
        if (apiDescription.Properties.TryGetValue(typeof(T), out value))
        {
            return (T)value;
        }
        else
        {
            return default(T);
        }
    }
        
    public static void SetProperty<T>(this ApiDescription apiDescription, T value)
    {
        if (apiDescription == null)
        {
            throw new ArgumentNullException(nameof(apiDescription));
        }        
        if (value == null)
        {
            throw new ArgumentNullException(nameof(value));
        }
        
        apiDescription.Properties[typeof(T)] = value;
    }
}

```

##### 4.1.3 api description provider

```c#
public interface IApiDescriptionProvider
{    
    int Order { get; }     
    
    void OnProvidersExecuting(ApiDescriptionProviderContext context);
    void OnProvidersExecuted(ApiDescriptionProviderContext context);
}

```

###### 4.1.3.1 api description provider context

```c#
public class ApiDescriptionProviderContext
{
    public IReadOnlyList<ActionDescriptor> Actions { get; }        
    public IList<ApiDescription> Results { get; }
    
    public ApiDescriptionProviderContext(IReadOnlyList<ActionDescriptor> actions)
    {
        if (actions == null)
        {
            throw new ArgumentNullException(nameof(actions));
        }
        
        Actions = actions;        
        Results = new List<ApiDescription>();
    }            
}

```

##### 4.1.4 default api description provider

```c#
public class DefaultApiDescriptionProvider : IApiDescriptionProvider
{
    private readonly MvcOptions _mvcOptions;
    private readonly ApiResponseTypeProvider _responseTypeProvider;
    private readonly RouteOptions _routeOptions;
    private readonly IInlineConstraintResolver _constraintResolver;
    private readonly IModelMetadataProvider _modelMetadataProvider;
    
     /// <inheritdoc />
    public int Order => -1000;    
    
    public DefaultApiDescriptionProvider(
        IOptions<MvcOptions> optionsAccessor,
        IInlineConstraintResolver constraintResolver,
        IModelMetadataProvider modelMetadataProvider,
        IActionResultTypeMapper mapper,
        IOptions<RouteOptions> routeOptions)
    {
        _mvcOptions = optionsAccessor.Value;
        _constraintResolver = constraintResolver;
        _modelMetadataProvider = modelMetadataProvider;
        _responseTypeProvider = 
            new ApiResponseTypeProvider(
            	modelMetadataProvider, 
            	mapper, 
            	_mvcOptions);
        _routeOptions = routeOptions.Value;
    }
    
     public void OnProvidersExecuting(ApiDescriptionProviderContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        /* 遍历 api description provider context actions 中，
           controller action 类型（标记了 controller 属性？？） */ 
        foreach (var action in context.Actions.OfType<ControllerActionDescriptor>())
        {
            // 如果 action 的 route info 标记了 suppress path matching，忽略            
            if (action.AttributeRouteInfo != null && 
                action.AttributeRouteInfo.SuppressPathMatching)
            {
                continue;
            }
            
            /* a- 解析 http method */
            // 获取 api description action data，            
            var extensionData = action.GetProperty<ApiDescriptionActionData>();
                                    
            if (extensionData != null)
            {
                // 并从中获取 http methods，
                var httpMethods = GetHttpMethods(action);
                
                // 创建 methods 对应的 result (api descriptioin)，
            	// 注入 api descritpion provider context 的 result
                foreach (var httpMethod in httpMethods)
                {
                    context.Results
                        	/* b- 创建 api description */
                           .Add(CreateApiDescription(
                               		action, 
		                            httpMethod, 
        		                    extensionData.GroupName));
                }
            }
        }
    }           
    
    /// <inheritdoc />
    public void OnProvidersExecuted(ApiDescriptionProviderContext context)
    {
    }                                                                 
    
}


```

##### 4.1.4.1 get http method

```c#
public class DefaultApiDescriptionProvider : IApiDescriptionProvider
{
    private IEnumerable<string> GetHttpMethods(ControllerActionDescriptor action)
    {
        // 如果标记了 action constraint
        if (action.ActionConstraints != null && 
            action.ActionConstraints.Count > 0)
        {
            // 获取 action constraint 中的 http method action constraint 的 http method
            return action.ActionConstraints
                		 .OfType<HttpMethodActionConstraint>()
                		 .SelectMany(c => c.HttpMethods);
        }
        // 否则，即没有标记 action constraint
        else
        {
            // 返回 empty
            return new string[] { null };
        }
    }
}

```

###### 4.1.4.2 create api description

```c#
public class DefaultApiDescriptionProvider : IApiDescriptionProvider
{
    private ApiDescription CreateApiDescription(
        ControllerActionDescriptor action,
        string httpMethod,
        string groupName)
    {
        /* b1- 从 action 中解析 route template */
        var parsedTemplate = ParseTemplate(action);
        // 创建 api description -- 预结果
        var apiDescription = new ApiDescription()
        {
            ActionDescriptor = action,
            GroupName = groupName,
            HttpMethod = httpMethod,
            /* b2- 获取 relative path */
            RelativePath = GetRelativePath(parsedTemplate),
        };
        
        // 从 route template 中解析 template parameter（模板形参）
        var templateParameters = 
            parsedTemplate
            	?.Parameters
            	?.ToList() 
            	?? new List<TemplatePart>();
        /* b3- 创建 api parameter context */
        var parameterContext = 
            new ApiParameterContext(
            		_modelMetadataProvider, 
            		action, 
	            	templateParameters);
        
        /* b4- 从 parameter context 中解析 parameter，*/        
        foreach (var parameter in GetParameters(parameterContext))
        {
            // 将 parameter 注入 api description（预结果）
            apiDescription.ParameterDescriptions.Add(parameter);
        }
        
        /* b5- 解析 request metadata attribute */
        var requestMetadataAttributes = GetRequestMetadataAttributes(action);
        
        /* 解析 api response type， */
        var apiResponseTypes = _responseTypeProvider.GetApiResponseTypes(action);
        foreach (var apiResponseType in apiResponseTypes)
        {
            // 将 api response type 注入 api description 的 support response types
            apiDescription.SupportedResponseTypes.Add(apiResponseType);
        }
        
        // It would be possible here to configure an action with multiple body parameters, 
        // in which case you could end up with duplicate data.
        if (apiDescription.ParameterDescriptions.Count > 0)
        {
            /* b6- 从 request metadata attribute 中解析 content type*/
            var contentTypes = GetDeclaredContentTypes(requestMetadataAttributes);
            
            foreach (var parameter in apiDescription.ParameterDescriptions)
            {
                // 如果 parameter 来自 body，
                if (parameter.Source == BindingSource.Body)
                {
                    /* b7- 解析 supported format */
                    // For request body bound parameters, 
                    // determine the content types supported by input formatters.
                    var requestFormats = GetSupportedFormats(contentTypes, parameter.Type);
                    foreach (var format in requestFormats)
                    {
                        apiDescription.SupportedRequestFormats.Add(format);
                    }
                }
                // 如果 parameter 来自 formfile
                else if (parameter.Source == BindingSource.FormFile)
                {
                    /* 创建 content type 对应的 api request format，
                       注入 api descritption 的 supported request format 中 */
                    // Add all declared media types 
                    // since FormFiles do not get processed by formatters.
                    foreach (var contentType in contentTypes)
                    {
                        apiDescription
                            .SupportedRequestFormats
                            .Add(new ApiRequestFormat
                                 {
                                     MediaType = contentType,                           
                                 });
                    }
                }
            }
        }
        
        return apiDescription;
    }
}
    
```

#### 4.2 api description group collection

##### 4.2.1 api description group collection

```c#
public class ApiDescriptionGroupCollection
{
    public int Version { get; }    
    public IReadOnlyList<ApiDescriptionGroup> Items { get; }
    
    public ApiDescriptionGroupCollection(
        IReadOnlyList<ApiDescriptionGroup> items, 
        int version)
    {
        if (items == null)
        {
            throw new ArgumentNullException(nameof(items));
        }
        
        Items = items;
        Version = version;
    }                    
}

```

###### 4.2.1.1 api description group

```c#
public class ApiDescriptionGroup
{
    public string GroupName { get; }            
    public IReadOnlyList<ApiDescription> Items { get; }
    
    public ApiDescriptionGroup(string groupName, IReadOnlyList<ApiDescription> items)
    {
        GroupName = groupName;
        Items = items;
    }            
}

```

##### 4.2.2 api description group collection provider

```c#
public interface IApiDescriptionGroupCollectionProvider
{        
    ApiDescriptionGroupCollection ApiDescriptionGroups { get; }
}

```

###### 4.2.2.1 api description group collection provider

```c#
public class ApiDescriptionGroupCollectionProvider : IApiDescriptionGroupCollectionProvider
{
    private readonly IActionDescriptorCollectionProvider _actionDescriptorCollectionProvider;
    private readonly IApiDescriptionProvider[] _apiDescriptionProviders;
    
    private ApiDescriptionGroupCollection _apiDescriptionGroups;
    /// <inheritdoc />
    public ApiDescriptionGroupCollection ApiDescriptionGroups
    {
        get
        {
            var actionDescriptors = _actionDescriptorCollectionProvider.ActionDescriptors;
            if (_apiDescriptionGroups == null || 
                _apiDescriptionGroups.Version != actionDescriptors.Version)
            {
                _apiDescriptionGroups = GetCollection(actionDescriptors);
            }
            
            return _apiDescriptionGroups;
        }
    }
    
    private ApiDescriptionGroupCollection GetCollection(
        ActionDescriptorCollection actionDescriptors)
    {
        var context = new ApiDescriptionProviderContext(actionDescriptors.Items);
        
        foreach (var provider in _apiDescriptionProviders)
        {
            provider.OnProvidersExecuting(context);
        }
        
        for (var i = _apiDescriptionProviders.Length - 1; i >= 0; i--)
        {
            _apiDescriptionProviders[i].OnProvidersExecuted(context);
        }
        
        var groups = 
            context.Results
            	   .GroupBy(d => d.GroupName)
    	           .Select(g => new ApiDescriptionGroup(g.Key, g.ToArray()))
	               .ToArray();
        
        return new ApiDescriptionGroupCollection(
            		   groups, 
            		   actionDescriptors.Version);
    }
        
    public ApiDescriptionGroupCollectionProvider(
        IActionDescriptorCollectionProvider actionDescriptorCollectionProvider,
        IEnumerable<IApiDescriptionProvider> apiDescriptionProviders)
    {
        _actionDescriptorCollectionProvider = actionDescriptorCollectionProvider;
        _apiDescriptionProviders = 
            apiDescriptionProviders.OrderBy(item => item.Order).ToArray();
    }                
}

```















### 2. application model

#### 2.1 (application) model

##### 2.1.1 model interface

###### 2.1.1.1 api explorer model

```c#
public interface IApiExplorerModel
{   
    ApiExplorerModel ApiExplorer { get; set; }
}

```

###### 2.1.1.2 property model

```c#
public interface IPropertyModel
{   
    IDictionary<object, object> Properties { get; }
}

```

###### 2.1.1.3 common model

```c#
public interface ICommonModel : IPropertyModel
{    
    IReadOnlyList<object> Attributes { get; }    
    MemberInfo MemberInfo { get; }    
    string Name { get; }
}

```

###### 2.1.1.4 binding model

```c#
public interface IBindingModel
{    
    BindingInfo? BindingInfo { get; set; }
}

```

###### 2.1.1.5 filter model

```c#
public interface IFilterModel
{    
    IList<IFilterMetadata> Filters { get; }
}

```

##### 2.1.2 models

###### 2.1.2.1 application model

```c#
[DebuggerDisplay("ApplicationModel: Controllers: {Controllers.Count}, Filters: {Filters.Count}")]
public class ApplicationModel : IPropertyModel, IFilterModel, IApiExplorerModel
{
    // api explorer model 接口
    public ApiExplorerModel ApiExplorer { get; set; }    
    // property model 接口
    public IDictionary<object, object> Properties { get; }
    // filter model 接口
    public IList<IFilterMetadata> Filters { get; } 
    
    public IList<ControllerModel> Controllers { get; }    
                  
    public ApplicationModel()
    {
        // 创建 model（预结果？）
        ApiExplorer = new ApiExplorerModel();
        Controllers = new List<ControllerModel>();
        Filters = new List<IFilterMetadata>();
        Properties = new Dictionary<object, object>();
    }                    
}

```

###### 2.1.2.2 api explorer model

```c#
public class ApiExplorerModel
{
    public bool? IsVisible { get; set; }        
    public string? GroupName { get; set; }
    
    public ApiExplorerModel()
    {
    }
            
    public ApiExplorerModel(ApiExplorerModel other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        GroupName = other.GroupName;
        IsVisible = other.IsVisible;
    }            
}

```

###### 2.1.2.3 controller model

```c#
[DebuggerDisplay("{DisplayName}")]
public class ControllerModel : ICommonModel, IFilterModel, IApiExplorerModel
{
    // common model 接口
    public IReadOnlyList<object> Attributes { get; }
    MemberInfo ICommonModel.MemberInfo => ControllerType;    
    string ICommonModel.Name => ControllerName;
    // filter model 接口
    public IList<IFilterMetadata> Filters { get; }   
    // api explorer model 接口
    public ApiExplorerModel ApiExplorer { get; set; }     
                   
    public ApplicationModel? Application { get; set; }      
    // 关联 common model 的 name
    public string ControllerName { get; set; } = default!;        
    // 关联 common model 的 member info
    public TypeInfo ControllerType { get; }   
    
    public IList<ActionModel> Actions { get; }   
    public IList<PropertyModel> ControllerProperties { get; }        
    public IList<SelectorModel> Selectors { get; }
    
    public IDictionary<string, string?> RouteValues { get; }        
    public IDictionary<object, object> Properties { get; }        
            
    public string DisplayName
    {
        get
        {
            var controllerType = TypeNameHelper.GetTypeDisplayName(ControllerType);
            var controllerAssembly = ControllerType.Assembly.GetName().Name;
            return $"{controllerType} ({controllerAssembly})";
        }
    }
    
    public ControllerModel(
        TypeInfo controllerType,
        IReadOnlyList<object> attributes)
    {
        if (controllerType == null)
        {
            throw new ArgumentNullException(nameof(controllerType));
        }        
        if (attributes == null)
        {
            throw new ArgumentNullException(nameof(attributes));
        }
        
        // 注入 controller type info
        ControllerType = controllerType;
        
        // 创建 sub models & comps
        Actions = new List<ActionModel>();
        ApiExplorer = new ApiExplorerModel();
        Attributes = new List<object>(attributes);
        ControllerProperties = new List<PropertyModel>();
        Filters = new List<IFilterMetadata>();
        Properties = new Dictionary<object, object>();
        RouteValues = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);
        Selectors = new List<SelectorModel>();
    }
        
    public ControllerModel(ControllerModel other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        ControllerName = other.ControllerName;
        ControllerType = other.ControllerType;
        
        // Still part of the same application
        Application = other.Application;
        
        // These are just metadata, safe to create new collections
        Attributes = new List<object>(other.Attributes);
        Filters = new List<IFilterMetadata>(other.Filters);
        RouteValues = new Dictionary<string, string?>(other.RouteValues, StringComparer.OrdinalIgnoreCase);
        Properties = new Dictionary<object, object>(other.Properties);
        
        // Make a deep copy of other 'model' types.
        Actions = new List<ActionModel>(other.Actions.Select(a => new ActionModel(a) { Controller = this }));
        ApiExplorer = new ApiExplorerModel(other.ApiExplorer);
        ControllerProperties = 
            new List<PropertyModel>(other.ControllerProperties.Select(p => new PropertyModel(p) { Controller = this }));
        Selectors = new List<SelectorModel>(other.Selectors.Select(s => new SelectorModel(s)));
    }            
}

```

###### 2.1.2.4 parameter model base

```c#
public abstract class ParameterModelBase : IBindingModel
{           
    public Type ParameterType { get; } 
    // 类似 property model 接口
    public IDictionary<object, object> Properties { get; }   
    // 类似 common model 接口
    public string Name { get; protected set; } = default!;  
    public IReadOnlyList<object> Attributes { get; }       
    // binding model 接口             
    public BindingInfo? BindingInfo { get; set; }
   
    protected ParameterModelBase(
        Type parameterType,
        IReadOnlyList<object> attributes)
    {
        // 注入 parameter type 
        ParameterType = parameterType ?? throw new ArgumentNullException(nameof(parameterType));
        // 注入 attribute 集合
        Attributes = new List<object>(attributes ?? throw new ArgumentNullException(nameof(attributes)));
        // 创建 property 集合
        Properties = new Dictionary<object, object>();
    }
        
    protected ParameterModelBase(ParameterModelBase other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        ParameterType = other.ParameterType;
        Attributes = new List<object>(other.Attributes);
        BindingInfo = other.BindingInfo == null ? null : new BindingInfo(other.BindingInfo);
        Name = other.Name;
        Properties = new Dictionary<object, object>(other.Properties);
    }        
}

```

###### 2.1.2.5 property model

```c#
[DebuggerDisplay("PropertyModel: Name={PropertyName}")]
public class PropertyModel : ParameterModelBase, ICommonModel, IBindingModel
{        
    // 类似 common model 接口
    public string PropertyName
    {
        get => Name;
        set => Name = value;
    }
    MemberInfo ICommonModel.MemberInfo => PropertyInfo; 
    public new IReadOnlyList<object> Attributes => base.Attributes; 
    // 类似 property 接口
    public new IDictionary<object, object> Properties => base.Properties;       
       
    public ControllerModel Controller { get; set; } = default!;    
    // 关联 common model 的 member info
    public PropertyInfo PropertyInfo { get; }
    // 关联 common model 的 name
    
    
    public PropertyModel(
        PropertyInfo propertyInfo,
        IReadOnlyList<object> attributes) : 
    		base(
                propertyInfo.PropertyType, 
                attributes)
    {
        PropertyInfo = propertyInfo ?? throw new ArgumentNullException(nameof(propertyInfo));
    }
       
    public PropertyModel(PropertyModel other) : base(other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        Controller = other.Controller;
        BindingInfo = other.BindingInfo == null ? null : new BindingInfo(other.BindingInfo);
        PropertyInfo = other.PropertyInfo;
    }          
}
```

###### 2.1.2.6 action model

```c#
[DebuggerDisplay("{DisplayName}")]
public class ActionModel : ICommonModel, IFilterModel, IApiExplorerModel
{
    // common model 接口
    string ICommonModel.Name => ActionName;  
    MemberInfo ICommonModel.MemberInfo => ActionMethod;    
    public IReadOnlyList<object> Attributes { get; }        
    // filter model 接口
    public IList<IFilterMetadata> Filters { get; }   
    // api explorer model 接口
    public ApiExplorerModel ApiExplorer { get; set; }    
    
    // 关联 common model 的 name   
    public string ActionName { get; set; } = default!;        
    // 关联 common model 的 member info
    public MethodInfo ActionMethod { get; }     
    
    public ControllerModel Controller { get; set; } = default!;                 
    public IList<ParameterModel> Parameters { get; }    
    public IList<SelectorModel> Selectors { get; }
    
    public IOutboundParameterTransformer? RouteParameterTransformer { get; set; }        
    // The value of <see cref="ActionName"/> is considered an implicit route value corresponding to the key <c>action</c> 
    // and the value of <see cref="ControllerModel.ControllerName"/> is considered an implicit route value corresponding 
    // to the key <c>controller</c>. 
    // These entries will be implicitly added to <see cref="ActionDescriptor.RouteValues"/> when the action descriptor 
    // is created, but will not be visible in <see cref="RouteValues"/>.        
    public IDictionary<string, string?> RouteValues { get; }        
    /// Entries will take precedence over entries with the same key in
    /// <see cref="ApplicationModel.Properties"/> and <see cref="ControllerModel.Properties"/>.    
    public IDictionary<object, object> Properties { get; }    
                          
    public string DisplayName
    {
        get
        {
            if (Controller == null)
            {
                return ActionMethod.Name;                
            }
            
            var controllerType = TypeNameHelper.GetTypeDisplayName(Controller.ControllerType);
            var controllerAssembly = Controller?.ControllerType.Assembly.GetName().Name;
            return $"{controllerType}.{ActionMethod.Name} ({controllerAssembly})";
        }
    }
    
    public ActionModel(
        MethodInfo actionMethod,
        IReadOnlyList<object> attributes)
    {
        if (actionMethod == null)
        {
            throw new ArgumentNullException(nameof(actionMethod));
        }        
        if (attributes == null)
        {
            throw new ArgumentNullException(nameof(attributes));
        }
        
        ActionMethod = actionMethod;
        
        ApiExplorer = new ApiExplorerModel();
        Attributes = new List<object>(attributes);
        Filters = new List<IFilterMetadata>();
        Parameters = new List<ParameterModel>();
        RouteValues = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);
        Properties = new Dictionary<object, object>();
        Selectors = new List<SelectorModel>();
    }
        
    public ActionModel(ActionModel other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        ActionMethod = other.ActionMethod;
        ActionName = other.ActionName;
        RouteParameterTransformer = other.RouteParameterTransformer;
        
        // Not making a deep copy of the controller, this action still belongs to the same controller.
        Controller = other.Controller;
        
        // These are just metadata, safe to create new collections
        Attributes = new List<object>(other.Attributes);
        Filters = new List<IFilterMetadata>(other.Filters);
        Properties = new Dictionary<object, object>(other.Properties);
        RouteValues = new Dictionary<string, string?>(other.RouteValues, StringComparer.OrdinalIgnoreCase);
        
        // Make a deep copy of other 'model' types.
        ApiExplorer = new ApiExplorerModel(other.ApiExplorer);
        Parameters = new List<ParameterModel>(other.Parameters.Select(p => new ParameterModel(p) { Action = this }));
        Selectors = new List<SelectorModel>(other.Selectors.Select(s => new SelectorModel(s)));
    }            
}

```

###### 2.1.2.6 parameter model

```c#
[DebuggerDisplay("ParameterModel: Name={ParameterName}")]
public class ParameterModel : ParameterModelBase, ICommonModel
{
    // common model 接口
    public string ParameterName
    {
        get => Name;
        set => Name = value;
    }
    MemberInfo ICommonModel.MemberInfo => ParameterInfo.Member;    
    public new IReadOnlyList<object> Attributes => base.Attributes;    
        
    public ActionModel Action { get; set; } = default!;        
    public new IDictionary<object, object> Properties => base.Properties;    
    // 关联 common model 的 member info     
    public ParameterInfo ParameterInfo { get; }
            
    public string DisplayName
    {
        get
        {
            var parameterTypeName = TypeNameHelper.GetTypeDisplayName(
                ParameterInfo.ParameterType, 
                fullName: false);
            
            return $"{parameterTypeName} {ParameterName}";
        }
    }
    
    public ParameterModel(
        ParameterInfo parameterInfo,
        IReadOnlyList<object> attributes) : 
    		base(
                parameterInfo.ParameterType, 
                attributes)
    {
        ParameterInfo = parameterInfo ?? throw new ArgumentNullException(nameof(parameterInfo));
    }
       
    public ParameterModel(ParameterModel other) : base(other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        Action = other.Action;
        ParameterInfo = other.ParameterInfo;
    }    
}

```

###### 2.1.2.7 selector model

```c#
public class SelectorModel
{
    public AttributeRouteModel? AttributeRouteModel { get; set; }    
    public IList<IActionConstraintMetadata> ActionConstraints { get; }        
    public IList<object> EndpointMetadata { get; }
    
    public SelectorModel()
    {
        ActionConstraints = new List<IActionConstraintMetadata>();
        EndpointMetadata = new List<object>();
    }
    
    public SelectorModel(SelectorModel other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        ActionConstraints = new List<IActionConstraintMetadata>(other.ActionConstraints);
        EndpointMetadata = new List<object>(other.EndpointMetadata);
        
        if (other.AttributeRouteModel != null)
        {
            AttributeRouteModel = new AttributeRouteModel(other.AttributeRouteModel);
        }
    }    
}

```

###### 2.1.2.8 attribute route model

```c#
public class AttributeRouteModel
{
    private static readonly AttributeRouteModel _default = new AttributeRouteModel();
    
    public IRouteTemplateProvider? Attribute { get; }            
    public string? Template { get; set; }        
    public int? Order { get; set; }        
    public string? Name { get; set; }        
    public bool SuppressLinkGeneration { get; set; }        
    public bool SuppressPathMatching { get; set; }        
    public bool IsAbsoluteTemplate => Template != null && IsOverridePattern(Template);
    
    
    public AttributeRouteModel()
    {
    }
        
    public AttributeRouteModel(IRouteTemplateProvider templateProvider)
    {
        if (templateProvider == null)
        {
            throw new ArgumentNullException(nameof(templateProvider));
        }
        
        Attribute = templateProvider;
        Template = templateProvider.Template;
        Order = templateProvider.Order;
        Name = templateProvider.Name;
    }
       
    public AttributeRouteModel(AttributeRouteModel other)
    {
        if (other == null)
        {
            throw new ArgumentNullException(nameof(other));
        }
        
        Attribute = other.Attribute;
        Name = other.Name;
        Order = other.Order;
        Template = other.Template;
        SuppressLinkGeneration = other.SuppressLinkGeneration;
        SuppressPathMatching = other.SuppressPathMatching;
    }
        
    public static AttributeRouteModel? CombineAttributeRouteModel(
        AttributeRouteModel? left,
        AttributeRouteModel? right)
    {
        right = right ?? _default;
        
        // If the right template is an override template (starts with / or ~/)
        // we ignore the values from left.
        if (left == null || IsOverridePattern(right.Template))
        {
            left = _default;
        }
        
        var combinedTemplate = CombineTemplates(left.Template, right.Template);
        
        // The action is not attribute routed.
        if (combinedTemplate == null)
        {
            return null;
        }
        
        return new AttributeRouteModel()
        {
            Template = combinedTemplate,
            Order = right.Order ?? left.Order,
            Name = ChooseName(left, right),
            SuppressLinkGeneration = left.SuppressLinkGeneration || right.SuppressLinkGeneration,
            SuppressPathMatching = left.SuppressPathMatching || right.SuppressPathMatching,
        };
    }
        
    public static string? CombineTemplates(string? prefix, string? template)
    {
        var result = CombineCore(prefix, template);
        return CleanTemplate(result);
    }
    
    
    // Route templates starting with "~/" or "/" can be used to override the prefix.    
    public static bool IsOverridePattern(string? template)
    {
        return template != null &&
               (template.StartsWith("~/", StringComparison.Ordinal) ||
               template.StartsWith("/", StringComparison.Ordinal));
    }
    
    private static string? ChooseName(
        AttributeRouteModel left,
        AttributeRouteModel right)
    {
        if (right.Name == null && 
            string.IsNullOrEmpty(right.Template))
        {
            return left.Name;
        }
        else
        {
            return right.Name;
        }
    }
    
    private static string? CombineCore(string? left, string? right)
    {
        if (left == null && right == null)
        {
            return null;
        }
        else if (right == null)
        {
            return left;
        }
        else if (IsEmptyLeftSegment(left) || IsOverridePattern(right))
        {
            return right;
        }
        
        if (left!.EndsWith("/", StringComparison.Ordinal))
        {
            return left + right;
        }
        
        // Both templates contain some text.
        return left + "/" + right;
    }
    
    private static bool IsEmptyLeftSegment(string? template)
    {
        return template == null ||
               template.Equals(string.Empty, StringComparison.Ordinal) ||
               template.Equals("~/", StringComparison.Ordinal) ||
               template.Equals("/", StringComparison.Ordinal);
    }
    
    private static string? CleanTemplate(string? result)
    {
        if (result == null)
        {
            return null;
        }
        
        // This is an invalid combined template, so we don't want to accidentally clean it and produce a valid template. 
        // For that reason we ignore the clean up process for it.
        if (result.Equals("//", StringComparison.Ordinal))
        {
            return result;
        }

        var startIndex = 0;
        if (result.StartsWith("/", StringComparison.Ordinal))
        {
            startIndex = 1;
        }
        else if (result.StartsWith("~/", StringComparison.Ordinal))
        {
            startIndex = 2;
        }
        
        // We are in the case where the string is "/" or "~/"
        if (startIndex == result.Length)
        {
            return string.Empty;
        }
        
        var subStringLength = result.Length - startIndex;
        if (result.EndsWith("/", StringComparison.Ordinal))
        {
            subStringLength--;
        }
        
        return result.Substring(startIndex, subStringLength);
    }
        
    public static string ReplaceTokens(
        string template, 
        IDictionary<string, string?> values)
    {
        return ReplaceTokens(template, values, routeTokenTransformer: null);
    }
       
    public static string ReplaceTokens(
        string template, 
        IDictionary<string, string?> values, 
        IOutboundParameterTransformer? routeTokenTransformer)
    {
        var builder = new StringBuilder();
        var state = TemplateParserState.Plaintext;
        
        int? tokenStart = null;
        var scope = 0;
        
        // We'll run the loop one extra time with 'null' to detect the end of the string.
        for (var i = 0; i <= template.Length; i++)
        {
            var c = i < template.Length ? (char?)template[i] : null;
            switch (state)
            {
                case TemplateParserState.Plaintext:
                    if (c == '[')
                    {
                        scope++;
                        state = TemplateParserState.SeenLeft;
                        break;
                    }
                    else if (c == ']')
                    {
                        state = TemplateParserState.SeenRight;
                        break;
                    }
                    else if (c == null)
                    {
                        // We're at the end of the string, nothing left to do.
                        break;
                    }
                    else
                    {
                        builder.Append(c);
                        break;
                    }
                case TemplateParserState.SeenLeft:
                    if (c == '[')
                    {
                        // This is an escaped left-bracket
                        builder.Append(c);
                        state = TemplateParserState.Plaintext;
                        break;
                    }
                    else if (c == ']')
                    {
                        // This is zero-width parameter - not allowed.
                        var message = Resources.FormatAttributeRoute_TokenReplacement_InvalidSyntax(
                            template,
                            Resources.AttributeRoute_TokenReplacement_EmptyTokenNotAllowed);
                        
                        throw new InvalidOperationException(message);
                    }
                    else if (c == null)
                    {
                        // This is a left-bracket at the end of the string.
                        var message = Resources.FormatAttributeRoute_TokenReplacement_InvalidSyntax(
                            template,
                            Resources.AttributeRoute_TokenReplacement_UnclosedToken);
                        
                        throw new InvalidOperationException(message);
                    }
                    else
                    {
                        tokenStart = i;
                        state = TemplateParserState.InsideToken;
                        break;
                    }
                case TemplateParserState.SeenRight:
                    if (c == ']')
                    {
                        // This is an escaped right-bracket
                        builder.Append(c);
                        state = TemplateParserState.Plaintext;
                        break;
                    }
                    else if (c == null)
                    {
                        // This is an imbalanced right-bracket at the end of the string.
                        var message = Resources.FormatAttributeRoute_TokenReplacement_InvalidSyntax(
                            template,
                            Resources.AttributeRoute_TokenReplacement_ImbalancedSquareBrackets);
                        
                        throw new InvalidOperationException(message);
                    }
                    else
                    {
                        // This is an imbalanced right-bracket.
                        var message = Resources.FormatAttributeRoute_TokenReplacement_InvalidSyntax(
                            template,
                            Resources.AttributeRoute_TokenReplacement_ImbalancedSquareBrackets);
                        
                        throw new InvalidOperationException(message);
                    }
                case TemplateParserState.InsideToken:
                    if (c == '[')
                    {
                        state = TemplateParserState.InsideToken | TemplateParserState.SeenLeft;
                        break;
                    }
                    else if (c == ']')
                    {
                        --scope;
                        state = TemplateParserState.InsideToken | TemplateParserState.SeenRight;
                        break;
                    }
                    else if (c == null)
                    {
                        // This is an unclosed replacement token
                        var message = Resources.FormatAttributeRoute_TokenReplacement_InvalidSyntax(
                            template,
                            Resources.AttributeRoute_TokenReplacement_UnclosedToken);
                        
                        throw new InvalidOperationException(message);
                    }
                    else
                    {
                        // This is a just part of the parameter
                        break;
                    }
                case TemplateParserState.InsideToken | TemplateParserState.SeenLeft:
                    if (c == '[')
                    {
                        // This is an escaped left-bracket
                        state = TemplateParserState.InsideToken;
                        break;
                    }
                    else
                    {
                        // Unescaped left-bracket is not allowed inside a token.
                        var message = Resources.FormatAttributeRoute_TokenReplacement_InvalidSyntax(
                            template,
                            Resources.AttributeRoute_TokenReplacement_UnescapedBraceInToken);
                        
                        throw new InvalidOperationException(message);
                    }
                case TemplateParserState.InsideToken | TemplateParserState.SeenRight:
                    if (c == ']' && scope == 0)
                    {
                        // This is an escaped right-bracket
                        state = TemplateParserState.InsideToken;
                        break;
                    }
                    else
                    {
                        // This is the end of a replacement token.
                        var token = template.Substring(tokenStart!.Value, i - tokenStart.Value - 1)
                            			   .Replace("[[", "[")
                            			   .Replace("]]", "]");
                        
                        if (!values.TryGetValue(token, out var value))
                        {
                            // Value not found
                            var message = Resources.FormatAttributeRoute_TokenReplacement_ReplacementValueNotFound(
                                template,
                                token,
                                string.Join(", ", values.Keys.OrderBy(k => k, StringComparer.OrdinalIgnoreCase)));
                            
                            throw new InvalidOperationException(message);
                        }
                        
                        if (routeTokenTransformer != null)
                        {
                            value = routeTokenTransformer.TransformOutbound(value);
                        }
                        
                        builder.Append(value);
                        
                        if (c == '[')
                        {
                            state = TemplateParserState.SeenLeft;
                        }
                        else if (c == ']')
                        {
                            state = TemplateParserState.SeenRight;
                        }
                        else if (c == null)
                        {
                            state = TemplateParserState.Plaintext;
                        }
                        else
                        {
                            builder.Append(c);
                            state = TemplateParserState.Plaintext;
                        }
                        
                        scope = 0;
                        tokenStart = null;
                        break;
                    }
            }
        }
        
        return builder.ToString();
    }
    
    [Flags]
    private enum TemplateParserState : uint
    {
        // default state - allow non-special characters to pass through to the buffer.
        Plaintext = 0,        
        // We're inside a replacement token, may be combined with other states to detect
        // a possible escaped bracket inside the token.
        InsideToken = 1,        
        // We've seen a left brace, need to see the next character to find out if it's escaped or not.
        SeenLeft = 2,        
        // We've seen a right brace, need to see the next character to find out if it's escaped or not.
        SeenRight = 4,
    }
}

```

###### 2.1.2.9 action attribute route model

```c#
internal static class ActionAttributeRouteModel
{
    public static IEnumerable<SelectorModel> FlattenSelectors(ActionModel actionModel)
    {
        // Loop through all attribute routes defined on the controller. 
        // These perform a cross-product with all of the action-level attribute routes.
        var controllerSelectors = actionModel.Controller.Selectors
            							   .Where(sm => sm.AttributeRouteModel != null)
							               .ToList();        
        
        // We also include metadata and action constraints from the controller even when there are no routes, 
        // or when an action overrides the route template.
        SelectorModel? additionalSelector = null;
        if (actionModel.Controller.Selectors.Count > 0)
        {
            // This logic seems arbitrary but there's a good reason for it.
            // 
            // When we build the controller level selectors, any metadata or action constraints that aren't 
            // IRouteTemplateProvider will be included in all selectors. 
            // So we pick any selector and then grab all of the stuff that isn't IRouteTemplateProvider then we've 
            // found all of the items that aren't routes.
            //
            // This is fragile wrt application model customizing the data - but no one has run into an issue with this 
            // and its pretty esoteric.
            additionalSelector = new SelectorModel(actionModel.Controller.Selectors.First());
            additionalSelector.AttributeRouteModel = null;
            
            for (var i = additionalSelector.ActionConstraints.Count - 1; i >= 0; i--)
            {
                if (additionalSelector.ActionConstraints[i] is IRouteTemplateProvider)
                {
                    additionalSelector.ActionConstraints.RemoveAt(i);
                }
            }
            
            for (var i = additionalSelector.EndpointMetadata.Count - 1; i >= 0; i--)
            {
                if (additionalSelector.EndpointMetadata[i] is IRouteTemplateProvider)
                {
                    additionalSelector.EndpointMetadata.RemoveAt(i);
                }
            }
        }
        
        var actionConstraints = new List<IActionConstraintMetadata>();
        
        foreach (var actionSelector in actionModel.Selectors)
        {
            var actionRouteModel = actionSelector.AttributeRouteModel;
            
            // We check the action to see if the template allows combination behavior (It doesn't start with / or ~/) 
            // so that in the case where we have multiple [Route] attributes on the controller we don't end up creating multiple
            if (actionRouteModel != null && actionRouteModel.IsAbsoluteTemplate)
            {
                // We're overriding the routes from the controller, but any *unbound* constraints still apply.
                var selector = new SelectorModel(actionSelector);
                
                selector.AttributeRouteModel = AttributeRouteModel.CombineAttributeRouteModel(
                    left: null,
                    right: actionRouteModel);
                
                AddActionConstraints(selector, additionalSelector?.ActionConstraints);
                AddEndpointMetadata(selector, additionalSelector?.EndpointMetadata);
                
                yield return selector;
            }
            else if (controllerSelectors.Count > 0)
            {
                for (var i = 0; i < controllerSelectors.Count; i++)
                {
                    var controllerSelector = controllerSelectors[i];
                    
                    // We're using the attribute routes from the controller
                    var selector = new SelectorModel(actionSelector);
                    
                    selector.AttributeRouteModel = AttributeRouteModel.CombineAttributeRouteModel(
                        controllerSelector.AttributeRouteModel,
                        actionRouteModel);
                    
                    AddActionConstraints(selector, controllerSelector.ActionConstraints);
                    AddEndpointMetadata(selector, controllerSelector.EndpointMetadata);
                    
                    // No need to include the additional selector here because it would duplicate data in controllerSelector.             
                    yield return selector;
                }
            }
            else
            {
                // There are no routes on the controller, but any *unbound* constraints still apply.
                var selector = new SelectorModel(actionSelector);
                
                selector.AttributeRouteModel = AttributeRouteModel.CombineAttributeRouteModel(
                    left: null,
                    right: actionRouteModel);
                
                AddActionConstraints(selector, additionalSelector?.ActionConstraints);
                AddEndpointMetadata(selector, additionalSelector?.EndpointMetadata);
                
                yield return selector;
            }
        }
    }
    
    private static void AddActionConstraints(
        SelectorModel selector, 
        IList<IActionConstraintMetadata>? actionConstraints)
    {
        if (actionConstraints != null)
        {
            for (var i = 0; i < actionConstraints.Count;i++)
            {
                selector.ActionConstraints.Add(actionConstraints[i]);
            }
        }
    }
    
    private static void AddEndpointMetadata(
        SelectorModel selector, 
        IList<object>? controllerMetadata)
    {
        if (controllerMetadata != null)
        {
            // It is criticial to get the order in which metadata appears in endpoint metadata correct. 
            // More significant metadata must appear later in the sequence. In this case, the values in `controllerMetadata` 
            // should have their order preserved, but appear earlier than the entries in `selector.EndpointMetadata`.
            for (var i = 0; i < controllerMetadata.Count; i++)
            {
                selector.EndpointMetadata.Insert(i, controllerMetadata[i]);
            }
        }
    }
    
    public static IEnumerable<(AttributeRouteModel? route, SelectorModel actionSelector, SelectorModel? controllerSelector)> 
        GetAttributeRoutes(ActionModel actionModel)
    {
        var controllerAttributeRoutes = actionModel.Controller
            									.Selectors
            									.Where(sm => sm.AttributeRouteModel != null)
            									.Select(sm => sm.AttributeRouteModel)
            									.ToList();
        
        foreach (var actionSelectorModel in actionModel.Selectors)
        {
            var actionRouteModel = actionSelectorModel.AttributeRouteModel;
            
            // We check the action to see if the template allows combination behavior (It doesn't start with / or ~/) 
            // so that in the case where we have multiple [Route] attributes on the controller we don't end up creating multiple
            if (actionRouteModel != null && 
                actionRouteModel.IsAbsoluteTemplate)
            {
                var route = AttributeRouteModel.CombineAttributeRouteModel(
                    left: null,
                    right: actionRouteModel);
                
                yield return (route, actionSelectorModel, null);
            }
            else if (controllerAttributeRoutes.Count > 0)
            {
                for (var i = 0; i < actionModel.Controller.Selectors.Count; i++)
                {
                    // We're using the attribute routes from the controller
                    var controllerSelector = actionModel.Controller.Selectors[i];
                    
                    var route = AttributeRouteModel.CombineAttributeRouteModel(
                        controllerSelector.AttributeRouteModel,
                        actionRouteModel);
                    
                    yield return (route, actionSelectorModel, controllerSelector);
                }
            }
            
            else
            {
                var route = AttributeRouteModel.CombineAttributeRouteModel(
                    left: null,
                    right: actionRouteModel);
                
                yield return (route, actionSelectorModel, null);
            }
        }
    }
}

```

#### 2.2 application model provider

##### 2.2.1 application model provider 接口

```c#
public interface IApplicationModelProvider
{    
    int Order { get; }        
    void OnProvidersExecuting(ApplicationModelProviderContext context);        
    void OnProvidersExecuted(ApplicationModelProviderContext context);
}

```

###### 2.2.1.1 application model provider context

```c#
public class ApplicationModelProviderContext
{
    public IEnumerable<TypeInfo> ControllerTypes { get; }    
    public ApplicationModel Result { get; } = new ApplicationModel();
    
    public ApplicationModelProviderContext(IEnumerable<TypeInfo> controllerTypes)
    {
        if (controllerTypes == null)
        {
            throw new ArgumentNullException(nameof(controllerTypes));
        }
        // 注入 controller type 集合
        ControllerTypes = controllerTypes;
    }   
}

```

##### 2.2.2 default application model provider

```c#
internal class DefaultApplicationModelProvider : IApplicationModelProvider
{
    private readonly MvcOptions _mvcOptions;
    private readonly IModelMetadataProvider _modelMetadataProvider;
    private readonly Func<ActionContext, bool> _supportsAllRequests;
    private readonly Func<ActionContext, bool> _supportsNonGetRequests;
    
    public int Order => -1000;
    
    
    
    
    public DefaultApplicationModelProvider(
        IOptions<MvcOptions> mvcOptionsAccessor,
        IModelMetadataProvider modelMetadataProvider)
    {
        _mvcOptions = mvcOptionsAccessor.Value;
        _modelMetadataProvider = modelMetadataProvider;
        
        _supportsAllRequests = _ => true;
        _supportsNonGetRequests = context => !string.Equals(
            context.HttpContext.Request.Method, 
            "GET", 
            StringComparison.OrdinalIgnoreCase);
    }
    
   
    public void OnProvidersExecuting(ApplicationModelProviderContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        foreach (var filter in _mvcOptions.Filters)
        {
            context.Result.Filters.Add(filter);
        }
        
        foreach (var controllerType in context.ControllerTypes)
        {
            var controllerModel = CreateControllerModel(controllerType);
            if (controllerModel == null)
            {
                continue;
            }
            
            context.Result.Controllers.Add(controllerModel);
            controllerModel.Application = context.Result;
            
            foreach (var propertyHelper in PropertyHelper.GetProperties(controllerType.AsType()))
            {
                var propertyInfo = propertyHelper.Property;
                var propertyModel = CreatePropertyModel(propertyInfo);
                if (propertyModel != null)
                {
                    propertyModel.Controller = controllerModel;
                    controllerModel.ControllerProperties.Add(propertyModel);
                }
            }
            
            foreach (var methodInfo in controllerType.AsType().GetMethods())
            {
                var actionModel = CreateActionModel(controllerType, methodInfo);
                if (actionModel == null)
                {
                    continue;
                }
                
                actionModel.Controller = controllerModel;
                controllerModel.Actions.Add(actionModel);
                
                foreach (var parameterInfo in actionModel.ActionMethod.GetParameters())
                {
                    var parameterModel = CreateParameterModel(parameterInfo);
                    if (parameterModel != null)
                    {
                        parameterModel.Action = actionModel;
                        actionModel.Parameters.Add(parameterModel);
                    }
                }
            }
        }
    }
       
    public void OnProvidersExecuted(ApplicationModelProviderContext context)
    {
        // Intentionally empty.
    }
       
    internal ControllerModel CreateControllerModel(TypeInfo typeInfo)
    {
        if (typeInfo == null)
        {
            throw new ArgumentNullException(nameof(typeInfo));
        }
        
        // For attribute routes on a controller, we want to support 'overriding' routes on a derived class. 
        // So we need to walk up the hierarchy looking for the first class to define routes.        
        // Then we want to 'filter' the set of attributes, so that only the effective routes apply.
        var currentTypeInfo = typeInfo;
        var objectTypeInfo = typeof(object).GetTypeInfo();
        
        IRouteTemplateProvider[] routeAttributes;
        
        do
        {
            routeAttributes = currentTypeInfo.GetCustomAttributes(inherit: false)
                						   .OfType<IRouteTemplateProvider>()
                						   .ToArray();
            
            if (routeAttributes.Length > 0)
            {
                // Found 1 or more route attributes.
                break;
            }
            
            currentTypeInfo = currentTypeInfo.BaseType!.GetTypeInfo();
        }
        while (currentTypeInfo != objectTypeInfo);
        
        // CoreCLR returns IEnumerable<Attribute> from GetCustomAttributes - the OfType<object>
        // is needed to so that the result of ToArray() is object
        var attributes = typeInfo.GetCustomAttributes(inherit: true);
        
        // This is fairly complicated so that we maintain referential equality between items in
        // ControllerModel.Attributes and ControllerModel.Attributes[*].Attribute.
        var filteredAttributes = new List<object>();
        foreach (var attribute in attributes)
        {
            if (attribute is IRouteTemplateProvider)
            {
                // This attribute is a route-attribute, leave it out.
            }
            else
            {
                filteredAttributes.Add(attribute);
            }
        }
        
        filteredAttributes.AddRange(routeAttributes);
        
        attributes = filteredAttributes.ToArray();
        
        var controllerModel = new ControllerModel(typeInfo, attributes);
        
        AddRange(controllerModel.Selectors, CreateSelectors(attributes));
        
        controllerModel.ControllerName = 
            typeInfo.Name.EndsWith("Controller", StringComparison.OrdinalIgnoreCase) 
	            ? typeInfo.Name.Substring(0, typeInfo.Name.Length - "Controller".Length) 
    	        : typeInfo.Name;
        
        AddRange(controllerModel.Filters, attributes.OfType<IFilterMetadata>());
        
        foreach (var routeValueProvider in attributes.OfType<IRouteValueProvider>())
        {
            controllerModel.RouteValues.Add(routeValueProvider.RouteKey, routeValueProvider.RouteValue);
        }
        
        var apiVisibility = attributes.OfType<IApiDescriptionVisibilityProvider>().FirstOrDefault();
        if (apiVisibility != null)
        {
            controllerModel.ApiExplorer.IsVisible = !apiVisibility.IgnoreApi;
        }
        
        var apiGroupName = attributes.OfType<IApiDescriptionGroupNameProvider>().FirstOrDefault();
        if (apiGroupName != null)
        {
            controllerModel.ApiExplorer.GroupName = apiGroupName.GroupName;
        }
        
        // Controllers can implement action filter and result filter interfaces. 
        // We add a special delegating filter implementation to the pipeline to handle it.        
        // This is needed because filters are instantiated before the controller.
        if (typeof(IAsyncActionFilter).GetTypeInfo().IsAssignableFrom(typeInfo) ||
            typeof(IActionFilter).GetTypeInfo().IsAssignableFrom(typeInfo))
        {
            controllerModel.Filters.Add(new ControllerActionFilter());
        }
        if (typeof(IAsyncResultFilter).GetTypeInfo().IsAssignableFrom(typeInfo) ||
            typeof(IResultFilter).GetTypeInfo().IsAssignableFrom(typeInfo))
        {
            controllerModel.Filters.Add(new ControllerResultFilter());
        }
        
        return controllerModel;
    }
        
    internal PropertyModel CreatePropertyModel(PropertyInfo propertyInfo)
    {
        if (propertyInfo == null)
        {
            throw new ArgumentNullException(nameof(propertyInfo));
        }
        
        var attributes = propertyInfo.GetCustomAttributes(inherit: true);
        
        // BindingInfo for properties can be either specified by decorating the property with binding specific attributes.
        // ModelMetadata also adds information from the property's type and any configured IBindingMetadataProvider.
        var declaringType = propertyInfo.DeclaringType!;
        var modelMetadata = _modelMetadataProvider.GetMetadataForProperty(declaringType, propertyInfo.Name);
        var bindingInfo = BindingInfo.GetBindingInfo(attributes, modelMetadata);
        
        if (bindingInfo == null)
        {
            // Look for BindPropertiesAttribute on the handler type if no BindingInfo was inferred for the property.
            // This allows a user to enable model binding on properties by decorating the controller type with BindPropertiesAttribute.
            var bindPropertiesAttribute = declaringType.GetCustomAttribute<BindPropertiesAttribute>(inherit: true);
            if (bindPropertiesAttribute != null)
            {
                var requestPredicate = bindPropertiesAttribute.SupportsGet 
                    ? _supportsAllRequests 
                    : _supportsNonGetRequests;
                
                bindingInfo = new BindingInfo
                {
                    RequestPredicate = requestPredicate,
                };
            }
        }
        
        var propertyModel = new PropertyModel(propertyInfo, attributes)
        {
            PropertyName = propertyInfo.Name,
            BindingInfo = bindingInfo,
        };
        
        return propertyModel;
    }
        
    internal ActionModel? CreateActionModel(
        TypeInfo typeInfo,
        MethodInfo methodInfo)
    {
        if (typeInfo == null)
        {
            throw new ArgumentNullException(nameof(typeInfo));
        }        
        if (methodInfo == null)
        {
            throw new ArgumentNullException(nameof(methodInfo));
        }
        
        if (!IsAction(typeInfo, methodInfo))
        {
            return null;
        }
        
        // CoreCLR returns IEnumerable<Attribute> from GetCustomAttributes - the OfType<object>
        // is needed to so that the result of ToArray() is object
        var attributes = methodInfo.GetCustomAttributes(inherit: true);
        
        var actionModel = new ActionModel(methodInfo, attributes);
        
        AddRange(actionModel.Filters, attributes.OfType<IFilterMetadata>());
        
        var actionName = attributes.OfType<ActionNameAttribute>().FirstOrDefault();
        if (actionName?.Name != null)
        {
            actionModel.ActionName = actionName.Name;
        }
        else
        {
            actionModel.ActionName = CanonicalizeActionName(methodInfo.Name);
        }
        
        var apiVisibility = attributes.OfType<IApiDescriptionVisibilityProvider>().FirstOrDefault();
        if (apiVisibility != null)
        {
            actionModel.ApiExplorer.IsVisible = !apiVisibility.IgnoreApi;
        }
        
        var apiGroupName = attributes.OfType<IApiDescriptionGroupNameProvider>().FirstOrDefault();
        if (apiGroupName != null)
        {
            actionModel.ApiExplorer.GroupName = apiGroupName.GroupName;
        }
        
        foreach (var routeValueProvider in attributes.OfType<IRouteValueProvider>())
        {
            actionModel.RouteValues.Add(routeValueProvider.RouteKey, routeValueProvider.RouteValue);
        }
        
        // Now we need to determine the action selection info (cross-section of routes and constraints)        
        // For attribute routes on a action, we want to support 'overriding' routes on a virtual method, 
        // but allow 'overriding'. So we need to walk up the hierarchy looking for the first definition to define routes.        
        // Then we want to 'filter' the set of attributes, so that only the effective routes apply.
        var currentMethodInfo = methodInfo;
        
        IRouteTemplateProvider[] routeAttributes;
        
        while (true)
        {
            routeAttributes = currentMethodInfo.GetCustomAttributes(inherit: false)
                							.OfType<IRouteTemplateProvider>()
                							.ToArray();
            
            if (routeAttributes.Length > 0)
            {
                // Found 1 or more route attributes.
                break;
            }
            
            // GetBaseDefinition returns 'this' when it gets to the bottom of the chain.
            var nextMethodInfo = currentMethodInfo.GetBaseDefinition();
            if (currentMethodInfo == nextMethodInfo)
            {
                break;
            }
            
            currentMethodInfo = nextMethodInfo;
        }
        
        // This is fairly complicated so that we maintain referential equality between items in
        // ActionModel.Attributes and ActionModel.Attributes[*].Attribute.
        var applicableAttributes = new List<object>(routeAttributes.Length);
        foreach (var attribute in attributes)
        {
            if (attribute is IRouteTemplateProvider)
            {
                // This attribute is a route-attribute, leave it out.
            }
            else
            {
                applicableAttributes.Add(attribute);
            }
        }
        
        applicableAttributes.AddRange(routeAttributes);
        AddRange(actionModel.Selectors, CreateSelectors(applicableAttributes));
        
        return actionModel;
    }
    
    private string CanonicalizeActionName(string actionName)
    {
        const string Suffix = "Async";
        
        if (_mvcOptions.SuppressAsyncSuffixInActionNames &&
            actionName.EndsWith(Suffix, StringComparison.Ordinal))
        {
            actionName = actionName.Substring(0, actionName.Length - Suffix.Length);
        }
        
        return actionName;
    }
    
    
        /// Override this method to provide custom logic to determine which methods are considered actions.
        /// </remarks>
    internal bool IsAction(TypeInfo typeInfo, MethodInfo methodInfo)
    {
        if (typeInfo == null)
        {
            throw new ArgumentNullException(nameof(typeInfo));
        }
        
        if (methodInfo == null)
        {
            throw new ArgumentNullException(nameof(methodInfo));
        }
        
        // The SpecialName bit is set to flag members that are treated in a special way by some compilers
        // (such as property accessors and operator overloading methods).
        if (methodInfo.IsSpecialName)
        {
            return false;
        }
        
        if (methodInfo.IsDefined(typeof(NonActionAttribute)))
        {
            return false;
        }
        
        // Overridden methods from Object class, e.g. Equals(Object), GetHashCode(), etc., are not valid.
        if (methodInfo.GetBaseDefinition().DeclaringType == typeof(object))
        {
            return false;
        }
        
        // Dispose method implemented from IDisposable is not valid
        if (IsIDisposableMethod(methodInfo))
        {
            return false;
        }
        
        if (methodInfo.IsStatic)
        {
            return false;
        }
        
        if (methodInfo.IsAbstract)
        {
            return false;
        }
        
        if (methodInfo.IsConstructor)
        {
            return false;
        }
        
        if (methodInfo.IsGenericMethod)
        {
            return false;
        }
        
        return methodInfo.IsPublic;
    }
    
    /// <summary>
        /// Creates a <see cref="ParameterModel"/> for the given <see cref="ParameterInfo"/>.
        /// </summary>
        /// <param name="parameterInfo">The <see cref="ParameterInfo"/>.</param>
        /// <returns>A <see cref="ParameterModel"/> for the given <see cref="ParameterInfo"/>.</returns>
    internal ParameterModel CreateParameterModel(ParameterInfo parameterInfo)
    {
        if (parameterInfo == null)
        {
            throw new ArgumentNullException(nameof(parameterInfo));
        }
        
        var attributes = parameterInfo.GetCustomAttributes(inherit: true);
        
        BindingInfo? bindingInfo;
        if (_modelMetadataProvider is ModelMetadataProvider modelMetadataProviderBase)
        {
            var modelMetadata = modelMetadataProviderBase.GetMetadataForParameter(parameterInfo);
            bindingInfo = BindingInfo.GetBindingInfo(attributes, modelMetadata);
        }
        else
        {
            // GetMetadataForParameter should only be used if the user has opted in to the 2.1 behavior.
            bindingInfo = BindingInfo.GetBindingInfo(attributes);
        }
        
        var parameterModel = new ParameterModel(parameterInfo, attributes)
        {
            ParameterName = parameterInfo.Name!,
            BindingInfo = bindingInfo,
        };
        
        return parameterModel;
    }
    
    private IList<SelectorModel> CreateSelectors(IList<object> attributes)
    {
        // Route attributes create multiple selector models, we want to split the set of
        // attributes based on these so each selector only has the attributes that affect it.
        //
        // The set of route attributes are split into those that 'define' a route versus those that are
        // 'silent'.
        //
        // We need to define a selector for each attribute that 'defines' a route, and a single selector
        // for all of the ones that don't (if any exist).
        //
        // If the attribute that 'defines' a route is NOT an IActionHttpMethodProvider, then we'll include with
        // it, any IActionHttpMethodProvider that are 'silent' IRouteTemplateProviders. In this case the 'extra'
        // action for silent route providers isn't needed.
        //
        // Ex:
        // [HttpGet]
        // [AcceptVerbs("POST", "PUT")]
        // [HttpPost("Api/Things")]
        // public void DoThing()
        //
        // This will generate 2 selectors:
        // 1. [HttpPost("Api/Things")]
        // 2. [HttpGet], [AcceptVerbs("POST", "PUT")]
        //
        // Another example of this situation is:
        //
        // [Route("api/Products")]
        // [AcceptVerbs("GET", "HEAD")]
        // [HttpPost("api/Products/new")]
        //
        // This will generate 2 selectors:
        // 1. [AcceptVerbs("GET", "HEAD")]
        // 2. [HttpPost]
        //
        // Note that having a route attribute that doesn't define a route template _might_ be an error. We
        // don't have enough context to really know at this point so we just pass it on.
        var routeProviders = new List<IRouteTemplateProvider>();
        
        var createSelectorForSilentRouteProviders = false;
        foreach (var attribute in attributes)
        {
            if (attribute is IRouteTemplateProvider routeTemplateProvider)
            {
                if (IsSilentRouteAttribute(routeTemplateProvider))
                {
                    createSelectorForSilentRouteProviders = true;
                }
                else
                {
                    routeProviders.Add(routeTemplateProvider);
                }
            }
        }
        
        foreach (var routeProvider in routeProviders)
        {
            // If we see an attribute like
            // [Route(...)]
            //
            // Then we want to group any attributes like [HttpGet] with it.
            //
            // Basically...
            //
            // [HttpGet]
            // [HttpPost("Products")]
            // public void Foo() { }
            //
            // Is two selectors. And...
            //
            // [HttpGet]
            // [Route("Products")]
            // public void Foo() { }
            //
            // Is one selector.
            if (!(routeProvider is IActionHttpMethodProvider))
            {
                createSelectorForSilentRouteProviders = false;
                break;
            }
        }
        
        var selectorModels = new List<SelectorModel>();
        if (routeProviders.Count == 0 && !createSelectorForSilentRouteProviders)
        {
            // Simple case, all attributes apply
            selectorModels.Add(CreateSelectorModel(route: null, attributes: attributes));
        }
        else
        {
            // Each of these routeProviders are the ones that actually have routing information on them
            // something like [HttpGet] won't show up here, but [HttpGet("Products")] will.
            foreach (var routeProvider in routeProviders)
            {
                var filteredAttributes = new List<object>();
                foreach (var attribute in attributes)
                {
                    if (ReferenceEquals(attribute, routeProvider))
                    {
                        filteredAttributes.Add(attribute);
                    }
                    else if (InRouteProviders(routeProviders, attribute))
                    {
                        // Exclude other route template providers
                        // Example:
                        // [HttpGet("template")]
                        // [Route("template/{id}")]
                    }
                    else if (routeProvider is IActionHttpMethodProvider &&
                             attribute is IActionHttpMethodProvider)
                    {
                        // Example:
                        // [HttpGet("template")]
                        // [AcceptVerbs("GET", "POST")]
                        //
                        // Exclude other http method providers if this route is an
                        // http method provider.
                    }
                    else
                    {
                        filteredAttributes.Add(attribute);
                    }
                }
                
                selectorModels.Add(CreateSelectorModel(routeProvider, filteredAttributes));
            }
            
            if (createSelectorForSilentRouteProviders)
            {
                var filteredAttributes = new List<object>();
                foreach (var attribute in attributes)
                {
                    if (!InRouteProviders(routeProviders, attribute))
                    {
                        filteredAttributes.Add(attribute);
                    }
                }
                
                selectorModels.Add(CreateSelectorModel(route: null, attributes: filteredAttributes));
            }
        }
        
        return selectorModels;
    }
    
    private static bool InRouteProviders(List<IRouteTemplateProvider> routeProviders, object attribute)
    {
        foreach (var rp in routeProviders)
        {
            if (ReferenceEquals(rp, attribute))
            {
                return true;
            }
        }
        
        return false;
    }
    
    private static SelectorModel CreateSelectorModel(IRouteTemplateProvider? route, IList<object> attributes)
    {
        var selectorModel = new SelectorModel();
        if (route != null)
        {
            selectorModel.AttributeRouteModel = new AttributeRouteModel(route);
        }
        
        AddRange(selectorModel.ActionConstraints, attributes.OfType<IActionConstraintMetadata>());
        AddRange(selectorModel.EndpointMetadata, attributes);
        
        // Simple case, all HTTP method attributes apply
        var httpMethods = attributes.OfType<IActionHttpMethodProvider>()
				                   .SelectMany(a => a.HttpMethods)
				                   .Distinct(StringComparer.OrdinalIgnoreCase)
				                   .ToArray();

        if (httpMethods.Length > 0)
        {
            selectorModel.ActionConstraints.Add(new HttpMethodActionConstraint(httpMethods));
            selectorModel.EndpointMetadata.Add(new HttpMethodMetadata(httpMethods));
        }
        
        return selectorModel;
    }
    
    private bool IsIDisposableMethod(MethodInfo methodInfo)
    {
        // Ideally we do not want Dispose method to be exposed as an action. However there are some scenarios where a user
        // might want to expose a method with name "Dispose" (even though they might not be really disposing resources)
        // Example: A controller deriving from MVC's Controller type might wish to have a method with name Dispose,
        // in which case they can use the "new" keyword to hide the base controller's declaration.
        
        // Find where the method was originally declared
        var baseMethodInfo = methodInfo.GetBaseDefinition();
        var declaringType = baseMethodInfo.DeclaringType;
        
        return (typeof(IDisposable).IsAssignableFrom(declaringType) &&
                declaringType.GetInterfaceMap(typeof(IDisposable)).TargetMethods[0] == baseMethodInfo);
    }
    
    private bool IsSilentRouteAttribute(IRouteTemplateProvider routeTemplateProvider)
    {
        return routeTemplateProvider.Template == null &&
               routeTemplateProvider.Order == null &&
               routeTemplateProvider.Name == null;
    }
    
    private static void AddRange<T>(IList<T> list, IEnumerable<T> items)
    {
        foreach (var item in items)
        {
            list.Add(item);
        }
    }
}

```

##### 2.2.3 api behavior application model provider

```c#
internal class ApiBehaviorApplicationModelProvider : IApplicationModelProvider
{
    public int Order => -1000 + 100;    
    public List<IActionModelConvention> ActionModelConventions { get; }
    
    public ApiBehaviorApplicationModelProvider(
        IOptions<ApiBehaviorOptions> apiBehaviorOptions,
        IModelMetadataProvider modelMetadataProvider,
        IClientErrorFactory clientErrorFactory,
        ILoggerFactory loggerFactory)
    {
        var options = apiBehaviorOptions.Value;
        
        ActionModelConventions = new List<IActionModelConvention>()
        {
            new ApiVisibilityConvention(),
        };
        
        if (!options.SuppressMapClientErrors)
        {
            ActionModelConventions.Add(new ClientErrorResultFilterConvention());
        }
        
        if (!options.SuppressModelStateInvalidFilter)
        {
            ActionModelConventions.Add(new InvalidModelStateFilterConvention());
        }
        
        if (!options.SuppressConsumesConstraintForFormFileParameters)
        {
            ActionModelConventions.Add(new ConsumesConstraintForFormFileParameterConvention());
        }
        
        var defaultErrorType = options.SuppressMapClientErrors ? typeof(void) : typeof(ProblemDetails);
        var defaultErrorTypeAttribute = new ProducesErrorResponseTypeAttribute(defaultErrorType);
        ActionModelConventions.Add(new ApiConventionApplicationModelConvention(defaultErrorTypeAttribute));
        
        if (!options.SuppressInferBindingSourcesForParameters)
        {
            ActionModelConventions.Add(new InferParameterBindingInfoConvention(modelMetadataProvider));
        }
    }
                 
    public void OnProvidersExecuted(ApplicationModelProviderContext context)
    {
    }
    
    public void OnProvidersExecuting(ApplicationModelProviderContext context)
    {
        foreach (var controller in context.Result.Controllers)
        {
            if (!IsApiController(controller))
            {
                continue;
            }
            
            foreach (var action in controller.Actions)
            {
                // Ensure ApiController is set up correctly
                EnsureActionIsAttributeRouted(action);
                
                foreach (var convention in ActionModelConventions)
                {
                    convention.Apply(action);
                }
            }
        }
    }
    
    private static void EnsureActionIsAttributeRouted(ActionModel actionModel)
    {
        if (!IsAttributeRouted(actionModel.Controller.Selectors) &&
            !IsAttributeRouted(actionModel.Selectors))
        {
            // Require attribute routing with controllers annotated with ApiControllerAttribute
            var message = Resources.FormatApiController_AttributeRouteRequired(
                actionModel.DisplayName,
                nameof(ApiControllerAttribute));
            throw new InvalidOperationException(message);
        }
        
        bool IsAttributeRouted(IList<SelectorModel> selectorModel)
        {
            for (var i = 0; i < selectorModel.Count; i++)
            {
                if (selectorModel[i].AttributeRouteModel != null)
                {
                    return true;
                }
            }
            
            return false;
        }
    }
    
    private static bool IsApiController(ControllerModel controller)
    {
        if (controller.Attributes.OfType<IApiBehaviorMetadata>().Any())
        {
            return true;
        }
        
        var controllerAssembly = controller.ControllerType.Assembly;
        var assemblyAttributes = controllerAssembly.GetCustomAttributes();
        return assemblyAttributes.OfType<IApiBehaviorMetadata>().Any();
    }
}

```

##### 2.2.4 authorization provider

```c#
internal class AuthorizationApplicationModelProvider : IApplicationModelProvider
{
    private readonly MvcOptions _mvcOptions;
    private readonly IAuthorizationPolicyProvider _policyProvider;
    
    public AuthorizationApplicationModelProvider(
        IAuthorizationPolicyProvider policyProvider,
        IOptions<MvcOptions> mvcOptions)
    {
        _policyProvider = policyProvider;
        _mvcOptions = mvcOptions.Value;
    }
    
    public int Order => -1000 + 10;
    
    public void OnProvidersExecuted(ApplicationModelProviderContext context)
    {
        // Intentionally empty.
    }
    
    public void OnProvidersExecuting(ApplicationModelProviderContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }
        
        if (_mvcOptions.EnableEndpointRouting)
        {
            // When using endpoint routing, the AuthorizationMiddleware does the work that Auth filters would otherwise perform.
            // Consequently we do not need to convert authorization attributes to filters.
            return;
        }
        
        foreach (var controllerModel in context.Result.Controllers)
        {
            var controllerModelAuthData = controllerModel.Attributes.OfType<IAuthorizeData>().ToArray();
            if (controllerModelAuthData.Length > 0)
            {
                controllerModel.Filters.Add(GetFilter(_policyProvider, controllerModelAuthData));
            }
            foreach (var attribute in controllerModel.Attributes.OfType<IAllowAnonymous>())
            {
                controllerModel.Filters.Add(new AllowAnonymousFilter());
            }
            
            foreach (var actionModel in controllerModel.Actions)
            {
                var actionModelAuthData = actionModel.Attributes.OfType<IAuthorizeData>().ToArray();
                if (actionModelAuthData.Length > 0)
                {
                    actionModel.Filters.Add(GetFilter(_policyProvider, actionModelAuthData));
                }
                
                foreach (var _ in actionModel.Attributes.OfType<IAllowAnonymous>())
                {
                    actionModel.Filters.Add(new AllowAnonymousFilter());
                }
            }
        }
    }
    
    public static AuthorizeFilter GetFilter(IAuthorizationPolicyProvider policyProvider, IEnumerable<IAuthorizeData> authData)
    {
        // The default policy provider will make the same policy for given input, so make it only once.
        // This will always execute synchronously.
        if (policyProvider.GetType() == typeof(DefaultAuthorizationPolicyProvider))
        {
            var policy = AuthorizationPolicy.CombineAsync(policyProvider, authData).GetAwaiter().GetResult()!;
            return new AuthorizeFilter(policy);
        }
        else
        {
            return new AuthorizeFilter(policyProvider, authData);
        }
    }
}

```

#### 2.3 (application) model convention

##### 2.3.1 convention interface

###### 2.3.1.1 application model convention

```c#
public interface IApplicationModelConvention
{    
    void Apply(ApplicationModel application);
}

```

###### 2.3.1.2 controller model convention

```c#
public interface IControllerModelConvention
{    
    void Apply(ControllerModel controller);
}

```

###### 2.3.1.3 parameter model base convention

```c#
public interface IParameterModelBaseConvention
{    
    void Apply(ParameterModelBase parameter);
}

```

###### 2.3.1.4 parameter model convention

```c#
public interface IParameterModelConvention
{    
    void Apply(ParameterModel parameter);
}

```

###### 2.3.1.5 action model convention

```c#
public interface IActionModelConvention
{    
    void Apply(ActionModel action);
}

```

##### 2.3.2 model convention

###### 2.3.2.1 api convention application model convention

```c#
public class ApiConventionApplicationModelConvention : IActionModelConvention
{
    public ProducesErrorResponseTypeAttribute DefaultErrorResponseType { get; }
    
    public ApiConventionApplicationModelConvention(ProducesErrorResponseTypeAttribute defaultErrorResponseType)
    {
        DefaultErrorResponseType = defaultErrorResponseType ?? throw new ArgumentNullException(nameof(defaultErrorResponseType));
    }

    public void Apply(ActionModel action)
    {
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }
        
        if (!ShouldApply(action))
        {
            return;
        }
        
        DiscoverApiConvention(action);
        DiscoverErrorResponseType(action);
    }
    
        /// <summary>
        /// Determines if this instance of <see cref="IActionModelConvention"/> applies to a specified <paramref name="action"/>.
        /// </summary>
        /// <param name="action">The <see cref="ActionModel"/>.</param>
        /// <returns>
        /// <see langword="true"/> if the convention applies, otherwise <see langword="false"/>.
        /// Derived types may override this method to selectively apply this convention.
        /// </returns>
    protected virtual bool ShouldApply(ActionModel action) => true;
    
    private static void DiscoverApiConvention(ActionModel action)
    {
        var controller = action.Controller;
        var apiConventionAttributes = controller.Attributes.OfType<ApiConventionTypeAttribute>().ToArray();
        if (apiConventionAttributes.Length == 0)
        {
            var controllerAssembly = controller.ControllerType.Assembly;
            apiConventionAttributes = controllerAssembly.GetCustomAttributes<ApiConventionTypeAttribute>().ToArray();
        }
        
        if (ApiConventionResult.TryGetApiConvention(action.ActionMethod, apiConventionAttributes, out var result))
        {
            action.Properties[typeof(ApiConventionResult)] = result;
        }
    }
    
    private void DiscoverErrorResponseType(ActionModel action)
    {
        var errorTypeAttribute = action.Attributes
            						 .OfType<ProducesErrorResponseTypeAttribute>()
            						 .FirstOrDefault() 
            					?? action.Controller
            							.Attributes
            							.OfType<ProducesErrorResponseTypeAttribute>()
            							.FirstOrDefault() 
            					?? action.Controller
            							.ControllerType
            							.Assembly
            							.GetCustomAttribute<ProducesErrorResponseTypeAttribute>() 
            					?? DefaultErrorResponseType;

            action.Properties[typeof(ProducesErrorResponseTypeAttribute)] = errorTypeAttribute;
    }
}

```

###### 2.3.2.2 api visibility convention

```c#
public class ApiVisibilityConvention : IActionModelConvention
{
    protected virtual bool ShouldApply(ActionModel action) => true;
       
    public void Apply(ActionModel action)
    {
        if (!ShouldApply(action))
        {
            return;
        }
        
        if (action.Controller.ApiExplorer.IsVisible == null && action.ApiExplorer.IsVisible == null)
        {
            // Enable ApiExplorer for the action if it wasn't already explicitly configured.
            action.ApiExplorer.IsVisible = true;
        }
    }    
}

```

###### 2.3.2.3 client error result filter convention

```c#
 public class ClientErrorResultFilterConvention : IActionModelConvention
 {
     private readonly ClientErrorResultFilterFactory _filterFactory = new ClientErrorResultFilterFactory();
     protected virtual bool ShouldApply(ActionModel action) => true;
     
     public void Apply(ActionModel action)
     {
         if (action == null)
         {
             throw new ArgumentNullException(nameof(action));
         }
         
         if (!ShouldApply(action))
         {
             return;
         }
         
         
         action.Filters.Add(_filterFactory);
     }     
 }

```

###### 2.3.2.4 consumes constraint for form file parameter convention

```c#
public class ConsumesConstraintForFormFileParameterConvention : IActionModelConvention
{
    protected virtual bool ShouldApply(ActionModel action) => true;
    
    public void Apply(ActionModel action)
    {
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }
        
        if (!ShouldApply(action))
        {
            return;
        }
        
        AddMultipartFormDataConsumesAttribute(action);
    }
               
    // Internal for unit testing
    internal void AddMultipartFormDataConsumesAttribute(ActionModel action)
    {
        // Add a ConsumesAttribute if the request does not explicitly specify one.
        if (action.Filters.OfType<IConsumesActionConstraint>().Any())
        {
            return;
        }
        
        foreach (var parameter in action.Parameters)
        {
            var bindingSource = parameter.BindingInfo?.BindingSource;
            if (bindingSource == BindingSource.FormFile)
            {
                // If an controller accepts files, it must accept multipart/form-data.
                action.Filters.Add(new ConsumesAttribute("multipart/form-data"));
                return;
            }
        }
    }
}

```

###### 2.3.2.5 infer parameter binding info convention

```c#
public class InferParameterBindingInfoConvention : IActionModelConvention
{
    private readonly IModelMetadataProvider _modelMetadataProvider;
    protected virtual bool ShouldApply(ActionModel action) => true;
    
    public InferParameterBindingInfoConvention(IModelMetadataProvider modelMetadataProvider)
    {
        _modelMetadataProvider = modelMetadataProvider ?? throw new ArgumentNullException(nameof(modelMetadataProvider));
    }
    
        
    public void Apply(ActionModel action)
    {
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }
        
        if (!ShouldApply(action))
        {
            return;
        }
        
        InferParameterBindingSources(action);
    }
    
    internal void InferParameterBindingSources(ActionModel action)
    {
        for (var i = 0; i < action.Parameters.Count; i++)
        {
            var parameter = action.Parameters[i];
            var bindingSource = parameter.BindingInfo?.BindingSource;
            if (bindingSource == null)
            {
                bindingSource = InferBindingSourceForParameter(parameter);                
                parameter.BindingInfo = parameter.BindingInfo ?? new BindingInfo();
                parameter.BindingInfo.BindingSource = bindingSource;
            }
        }
        
        var fromBodyParameters = action.Parameters.Where(p => p.BindingInfo!.BindingSource == BindingSource.Body).ToList();
        if (fromBodyParameters.Count > 1)
        {
            var parameters = string.Join(Environment.NewLine, fromBodyParameters.Select(p => p.DisplayName));
            var message = Resources.FormatApiController_MultipleBodyParametersFound(
                action.DisplayName,
                nameof(FromQueryAttribute),
                nameof(FromRouteAttribute),
                nameof(FromBodyAttribute));
            
            message += Environment.NewLine + parameters;
            throw new InvalidOperationException(message);
        }
    }
    
    // Internal for unit testing.
    internal BindingSource InferBindingSourceForParameter(ParameterModel parameter)
    {
        if (IsComplexTypeParameter(parameter))
        {
            return BindingSource.Body;
        }
        
        if (ParameterExistsInAnyRoute(parameter.Action, parameter.ParameterName))
        {
            return BindingSource.Path;
        }
        
        return BindingSource.Query;
    }
    
    private bool ParameterExistsInAnyRoute(ActionModel action, string parameterName)
    {
        foreach (var selector in ActionAttributeRouteModel.FlattenSelectors(action))
        {
            if (selector.AttributeRouteModel == null)
            {
                continue;
            }
            
            var parsedTemplate = TemplateParser.Parse(selector.AttributeRouteModel.Template!);
            if (parsedTemplate.GetParameter(parameterName) != null)
            {
                return true;
            }
        }
        
        return false;
    }
    
    private bool IsComplexTypeParameter(ParameterModel parameter)
    {
        // No need for information from attributes on the parameter. Just use its type.
        var metadata = _modelMetadataProvider.GetMetadataForType(parameter.ParameterInfo.ParameterType);
        
        return metadata.IsComplexType;
    }
}

```

###### 2.3.2.6 invalid model state filter convention

```c#
public class InvalidModelStateFilterConvention : IActionModelConvention
{
    private readonly ModelStateInvalidFilterFactory _filterFactory = new ModelStateInvalidFilterFactory();
    protected virtual bool ShouldApply(ActionModel action) => true;
    
    public void Apply(ActionModel action)
    {
        if (action == null)
        {
            throw new ArgumentNullException(nameof(action));
        }
        
        if (!ShouldApply(action))
        {
            return;
        }
        
        action.Filters.Add(_filterFactory);
    }    
}

```

###### 2.3.2.7 route token transformer convention

```c#
public class RouteTokenTransformerConvention : IActionModelConvention
{
    private readonly IOutboundParameterTransformer _parameterTransformer;
    protected virtual bool ShouldApply(ActionModel action) => true;
  
    public RouteTokenTransformerConvention(IOutboundParameterTransformer parameterTransformer)
    {
        if (parameterTransformer == null)
        {
            throw new ArgumentNullException(nameof(parameterTransformer));
        }
        
        _parameterTransformer = parameterTransformer;
    }
    
    /// <inheritdoc />
    public void Apply(ActionModel action)
    {
        if (ShouldApply(action))
        {
            action.RouteParameterTransformer = _parameterTransformer;
        }
    }    
}

```

###### 2.3.2.8 application model convention

```c#
internal static class ApplicationModelConventions
{    
    public static void ApplyConventions(
        ApplicationModel applicationModel,
        IEnumerable<IApplicationModelConvention> conventions)
    {
        if (applicationModel == null)
        {
            throw new ArgumentNullException(nameof(applicationModel));
        }        
        if (conventions == null)
        {
            throw new ArgumentNullException(nameof(conventions));
        }
        
        // Conventions are applied from the outside-in to allow for scenarios where an action overrides a controller, etc.
        foreach (var convention in conventions)
        {
            convention.Apply(applicationModel);
        }
        
        var controllers = applicationModel.Controllers.ToArray();
        // First apply the conventions from attributes in decreasing order of scope.
        foreach (var controller in controllers)
        {
            // ToArray is needed here to prevent issues with modifying the attributes collection while iterating it.
            var controllerConventions = controller.Attributes
                 							    .OfType<IControllerModelConvention>()
                							    .ToArray();
            
            foreach (var controllerConvention in controllerConventions)
            {
                controllerConvention.Apply(controller);
            }
            
            var actions = controller.Actions.ToArray();
            foreach (var action in actions)
            {
                // ToArray is needed here to prevent issues with modifying the attributes collection while iterating it.
                var actionConventions = action.Attributes
                            				 .OfType<IActionModelConvention>()
                            				 .ToArray();

                foreach (var actionConvention in actionConventions)
                {
                    actionConvention.Apply(action);
                }
                
                var parameters = action.Parameters.ToArray();
                foreach (var parameter in parameters)
                {
                    // ToArray is needed here to prevent issues with modifying the attributes collection
                    // while iterating it.
                    var parameterConventions = parameter.Attributes
                        							 .OfType<IParameterModelConvention>()
							                         .ToArray();

                    foreach (var parameterConvention in parameterConventions)
                    {
                        parameterConvention.Apply(parameter);
                    }
                    
                    var parameterBaseConventions = GetConventions<IParameterModelBaseConvention>(conventions, parameter.Attributes);
                    foreach (var parameterConvention in parameterBaseConventions)
                    {
                        parameterConvention.Apply(parameter);
                    }
                }
            }
            
            var properties = controller.ControllerProperties.ToArray();
            foreach (var property in properties)
            {
                var parameterBaseConventions = GetConventions<IParameterModelBaseConvention>(conventions, property.Attributes);
                
                foreach (var parameterConvention in parameterBaseConventions)
                {
                    parameterConvention.Apply(property);
                }
            }
        }
    }
    
    private static IEnumerable<TConvention> GetConventions<TConvention>(
        IEnumerable<IApplicationModelConvention> conventions,
        IReadOnlyList<object> attributes)
    {
        return Enumerable.Concat(
            conventions.OfType<TConvention>(),
            attributes.OfType<TConvention>());
    }
}

```

#### 2.4 application model factory

```c#
internal class ApplicationModelFactory
{
    private readonly IApplicationModelProvider[] _applicationModelProviders;
    private readonly IList<IApplicationModelConvention> _conventions;
    
    public ApplicationModelFactory(
        IEnumerable<IApplicationModelProvider> applicationModelProviders,
        IOptions<MvcOptions> options)
    {
        if (applicationModelProviders == null)
        {
            throw new ArgumentNullException(nameof(applicationModelProviders));
        }        
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }
        
        _applicationModelProviders = applicationModelProviders.OrderBy(p => p.Order).ToArray();
        _conventions = options.Value.Conventions;
    }
    
    public ApplicationModel CreateApplicationModel(IEnumerable<TypeInfo> controllerTypes)
    {
        if (controllerTypes == null)
        {
            throw new ArgumentNullException(nameof(controllerTypes));
        }
        
        var context = new ApplicationModelProviderContext(controllerTypes);
        
        for (var i = 0; i < _applicationModelProviders.Length; i++)
        {
            _applicationModelProviders[i].OnProvidersExecuting(context);
        }
        
        for (var i = _applicationModelProviders.Length - 1; i >= 0; i--)
        {
            _applicationModelProviders[i].OnProvidersExecuted(context);
        }
        
        ApplicationModelConventions.ApplyConventions(context.Result, _conventions);
        
        return context.Result;
    }
    
    public static List<TResult> Flatten<TResult>(
        ApplicationModel application,
        Func<ApplicationModel, ControllerModel, ActionModel, SelectorModel, TResult> flattener)
    {
        var results = new List<TResult>();
        var errors = new Dictionary<MethodInfo, IList<string>>();
        
        var actionsByMethod = new Dictionary<MethodInfo, List<(ActionModel, SelectorModel)>>();
        var actionsByRouteName = new Dictionary<string, List<(ActionModel, SelectorModel)>>(StringComparer.OrdinalIgnoreCase);
        
        var routeTemplateErrors = new List<string>();
        
        foreach (var controller in application.Controllers)
        {
            foreach (var action in controller.Actions)
            {
                foreach (var selector in ActionAttributeRouteModel.FlattenSelectors(action))
                {
                    // PostProcess attribute routes so we can observe any errors.
                    ReplaceAttributeRouteTokens(controller, action, selector, routeTemplateErrors);
                    
                    // Add to the data structures we use to find errors.
                    AddActionToMethodInfoMap(actionsByMethod, action, selector);
                    AddActionToRouteNameMap(actionsByRouteName, action, selector);
                    
                    var result = flattener(application, controller, action, selector);
                    Debug.Assert(result != null);
                    
                    results.Add(result);
                }
            }
        }
        
        var attributeRoutingConfigurationErrors = new Dictionary<MethodInfo, string>();
        foreach (var (method, actions) in actionsByMethod)
        {
            ValidateActionGroupConfiguration(
                method,
                actions,
                attributeRoutingConfigurationErrors);
        }
        
        if (attributeRoutingConfigurationErrors.Count > 0)
        {
            var message = CreateAttributeRoutingAggregateErrorMessage(attributeRoutingConfigurationErrors.Values);
            
            throw new InvalidOperationException(message);
        }
        
        var namedRoutedErrors = ValidateNamedAttributeRoutedActions(actionsByRouteName);
        if (namedRoutedErrors.Count > 0)
        {
            var message = CreateAttributeRoutingAggregateErrorMessage(namedRoutedErrors);
            throw new InvalidOperationException(message);
        }
        
        if (routeTemplateErrors.Count > 0)
        {
            var message = CreateAttributeRoutingAggregateErrorMessage(routeTemplateErrors);
            throw new InvalidOperationException(message);
        }
        
        
        return results;
    }
    
    private static void ReplaceAttributeRouteTokens(
        ControllerModel controller,
        ActionModel action,
        SelectorModel selector,
        List<string> errors)
    {
        if (selector.AttributeRouteModel == null)
        {
            return;
        }
        
        try
        {
            var routeValues = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase)
            {
                { "action", action.ActionName },
                { "controller", controller.ControllerName },
            };
            
            foreach (var kvp in action.RouteValues)
            {
                routeValues.TryAdd(kvp.Key, kvp.Value);
            }
            
            foreach (var kvp in controller.RouteValues)
            {
                routeValues.TryAdd(kvp.Key, kvp.Value);
            }
            
            selector.AttributeRouteModel.Template = AttributeRouteModel.ReplaceTokens(
                selector.AttributeRouteModel.Template!,
                routeValues,
                action.RouteParameterTransformer);
            
            if (selector.AttributeRouteModel.Name != null)
            {
                selector.AttributeRouteModel.Name = AttributeRouteModel.ReplaceTokens(
                    selector.AttributeRouteModel.Name,
                    routeValues,
                    action.RouteParameterTransformer);
            }
        }
        catch (InvalidOperationException ex)
        {
            // Routing will throw an InvalidOperationException here if we can't parse/replace tokens in the template.
            var message = Resources.FormatAttributeRoute_IndividualErrorMessage(
                action.DisplayName,
                Environment.NewLine,
                ex.Message);
            
            errors.Add(message);
        }
    }
    
    private static void AddActionToMethodInfoMap(
        Dictionary<MethodInfo, List<(ActionModel, SelectorModel)>> actionsByMethod,
        ActionModel action,
        SelectorModel selector)
    {
        if (!actionsByMethod.TryGetValue(action.ActionMethod, out var actions))
        {
            actions = new List<(ActionModel, SelectorModel)>();
            actionsByMethod.Add(action.ActionMethod, actions);
        }
        
        actions.Add((action, selector));
    }
    
    private static void AddActionToRouteNameMap(
        Dictionary<string, List<(ActionModel action, SelectorModel selector)>> actionsByRouteName,
        ActionModel action,
        SelectorModel selector)
    {
        var routeName = selector.AttributeRouteModel?.Name;
        if (routeName == null)
        {
            return;
        }
        
        if (!actionsByRouteName.TryGetValue(routeName, out var actions))
        {
            actions = new List<(ActionModel, SelectorModel)>();
            actionsByRouteName.Add(routeName, actions);
        }
        
        actions.Add((action, selector));
    }
    
    private static List<string> AddErrorNumbers(IEnumerable<string> namedRoutedErrors)
    {
        return namedRoutedErrors.Select((error, i) =>
                                        	Resources.FormatAttributeRoute_AggregateErrorMessage_ErrorNumber(
                                                i + 1,
                                                Environment.NewLine,
                                                error))
            				   .ToList();
    }
    
    private static List<string> ValidateNamedAttributeRoutedActions(
        Dictionary<string, List<(ActionModel action, SelectorModel selector)>> actionsByRouteName)
    {
        var namedRouteErrors = new List<string>();
        
        foreach (var (routeName, actions) in actionsByRouteName)
        {
            // We are looking for attribute routed actions that have the same name but
            // different route templates. We pick the first template of the group and
            // we compare it against the rest of the templates that have that same name
            // associated.
            // The moment we find one that is different we report the whole group to the
            // user in the error message so that they can see the different actions and the
            // different templates for a given named attribute route.
            var template = actions[0].selector.AttributeRouteModel!.Template!;
            
            for (var i = 1; i < actions.Count; i++)
            {
                var other = actions[i].selector.AttributeRouteModel!.Template;
                
                if (!template.Equals(other, StringComparison.OrdinalIgnoreCase))
                {
                    var descriptions = actions.Select(a =>
                                                      {                            
                                                          return Resources.FormatAttributeRoute_DuplicateNames_Item(
                                                              a.action.DisplayName, 
                                                              a.selector.AttributeRouteModel!.Template);
                                                      });
                    
                    var message = Resources.FormatAttributeRoute_DuplicateNames(
                        routeName, 
                        Environment.NewLine, 
                        string.Join(Environment.NewLine, descriptions));
                
                    namedRouteErrors.Add(message);
                    break;
                }
            }
        }
        
        return namedRouteErrors;
    }
    
    private static void ValidateActionGroupConfiguration(
        MethodInfo method,
        List<(ActionModel action, SelectorModel selector)> actions,
        IDictionary<MethodInfo, string> routingConfigurationErrors)
    {
        var hasAttributeRoutedActions = false;
        var hasConventionallyRoutedActions = false;
        
        for (var i = 0; i < actions.Count; i++)
        {
            if (actions[i].selector.AttributeRouteModel == null)
            {
                hasConventionallyRoutedActions = true;
            }
            else
            {
                hasAttributeRoutedActions = true;
            }
        }
        
        // Validate that no method result in attribute and non attribute actions at the same time.
        // By design, mixing attribute and conventionally actions in the same method is not allowed.
        //
        // Assuming the controller doesn't specify a route template, this example would not be allowed:
        //
        // [HttpGet]
        // [HttpPost("Foo")]
        // public void Foo() { }
        if (hasAttributeRoutedActions && hasConventionallyRoutedActions)
        {
            var message = CreateMixedRoutedActionDescriptorsErrorMessage(method, actions);
            routingConfigurationErrors.Add(method, message);
        }
    }
    
    private static string CreateMixedRoutedActionDescriptorsErrorMessage(
        MethodInfo method,
        List<(ActionModel action, SelectorModel selector)> actions)
    {
        // Text to show as the attribute route template for conventionally routed actions.
        var nullTemplate = Resources.AttributeRoute_NullTemplateRepresentation;
        
        var actionDescriptions = new List<string>(actions.Count);
        for (var i = 0; i < actions.Count; i++)
        {
            var (action, selector) = actions[i];
            var routeTemplate = selector.AttributeRouteModel?.Template ?? nullTemplate;
            
            var verbs = selector.ActionConstraints?.OfType<HttpMethodActionConstraint>().FirstOrDefault()?.HttpMethods;
            
            var formattedVerbs = string.Empty;
            if (verbs != null)
            {
                formattedVerbs = string.Join(", ", verbs.OrderBy(v => v, StringComparer.OrdinalIgnoreCase));
            }
            
            var description = Resources.FormatAttributeRoute_MixedAttributeAndConventionallyRoutedActions_ForMethod_Item(
                action.DisplayName,
                routeTemplate,
                formattedVerbs);
            
            actionDescriptions.Add(description);
        }
        
        // Sample error message:
        //
        // A method 'MyApplication.CustomerController.Index' must not define attributed actions and
        // non attributed actions at the same time:
        // Action: 'MyApplication.CustomerController.Index' - Route Template: 'Products' - HTTP Verbs: 'PUT'
        // Action: 'MyApplication.CustomerController.Index' - Route Template: '(none)' - HTTP Verbs: 'POST'
        //
        // Use 'AcceptVerbsAttribute' to create a single route that allows multiple HTTP verbs and defines a route,
        // or set a route template in all attributes that constrain HTTP verbs.
        
        var type = method.ReflectedType!;
        var formattedMethodInfo = $"{TypeNameHelper.GetTypeDisplayName(type)}.{method.Name} ({type.Assembly.GetName().Name})";
        return Resources.FormatAttributeRoute_MixedAttributeAndConventionallyRoutedActions_ForMethod(
            formattedMethodInfo,
            Environment.NewLine,
            string.Join(Environment.NewLine, actionDescriptions));
    }
    
    private static string CreateAttributeRoutingAggregateErrorMessage(IEnumerable<string> individualErrors)
    {
        var errorMessages = AddErrorNumbers(individualErrors);
        
        var message = Resources.FormatAttributeRoute_AggregateErrorMessage(
            Environment.NewLine,
            string.Join(Environment.NewLine + Environment.NewLine, errorMessages));
        return message;
    }
}

```

#### 2.5 application part

##### 2.5.1 application part (base)

```c#
public abstract class ApplicationPart
{    
    public abstract string Name { get; }
}

```

##### 2.5.2 assembly part

```c#
public class AssemblyPart : ApplicationPart, IApplicationPartTypeProvider
{
    public Assembly Assembly { get; }        
    public override string Name => Assembly.GetName().Name!;        
    public IEnumerable<TypeInfo> Types => Assembly.DefinedTypes;
       
    public AssemblyPart(Assembly assembly)
    {
        Assembly = assembly ?? throw new ArgumentNullException(nameof(assembly));
    }            
}

```

###### 2.5.2.1 扩展接口

```c#
public interface IApplicationPartTypeProvider
{   
    IEnumerable<TypeInfo> Types { get; }
}

```

#### 2.6 application part factory

##### 2.6.1 application part factory (base)

```c#
public abstract class ApplicationPartFactory
{    
    // get application part 集合，在派生类实现
    public abstract IEnumerable<ApplicationPart> GetApplicationParts(Assembly assembly);
        
    // 从 assembly get（创建）application part factory
    public static ApplicationPartFactory GetApplicationPartFactory(Assembly assembly)
    {
        if (assembly == null)
        {
            throw new ArgumentNullException(nameof(assembly));
        }
        
        // 从 assembly 解析 provider application part factory attribute
        var provideAttribute = assembly.GetCustomAttribute<ProvideApplicationPartFactoryAttribute>();
        
        // 如果 provider attribute 为 null，
        if (provideAttribute == null)
        {
            // 创建 default application part factory
            return DefaultApplicationPartFactory.Instance;
        }
        
        // 由上，provider attribute 不为 null，
        
        // 从 provider attribute 解析 factory type
        var type = provideAttribute.GetFactoryType();
        // 如果 factory type 没有继承 application part factory，-> 抛出异常
        if (!typeof(ApplicationPartFactory).IsAssignableFrom(type))
        {
            throw new InvalidOperationException(
                Resources.FormatApplicationPartFactory_InvalidFactoryType(
                    type,
                    nameof(ProvideApplicationPartFactoryAttribute),
                    typeof(ApplicationPartFactory)));
        }
        
        // 由上，factory type 继承了 application part factory，
        // 实例化 factory type
        return (ApplicationPartFactory)Activator.CreateInstance(type)!;
    }
}

```

###### 2.6.1.1 provide application part factory attribute

```c#
[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)]
public sealed class ProvideApplicationPartFactoryAttribute : Attribute
{
    private readonly Type? _applicationPartFactoryType;
    private readonly string? _applicationPartFactoryTypeName;
        
    public ProvideApplicationPartFactoryAttribute(Type factoryType)
    {
        _applicationPartFactoryType = factoryType ?? throw new ArgumentNullException(nameof(factoryType));
    }
           
    public ProvideApplicationPartFactoryAttribute(string factoryTypeName)
    {
        if (string.IsNullOrEmpty(factoryTypeName))
        {
            throw new ArgumentException(
                Resources.ArgumentCannotBeNullOrEmpty, 
                nameof(factoryTypeName));
        }
        
        _applicationPartFactoryTypeName = factoryTypeName;
    }
            
    public Type GetFactoryType()
    {
        return _applicationPartFactoryType ??
            Type.GetType(_applicationPartFactoryTypeName!, throwOnError: true)!;
    }
}

```

##### 2.6.2 default application part factory

```c#
public class DefaultApplicationPartFactory : ApplicationPartFactory
{    
    public static DefaultApplicationPartFactory Instance { get; } = new DefaultApplicationPartFactory();
                       
    public override IEnumerable<ApplicationPart> GetApplicationParts(Assembly assembly)
    {
        return GetDefaultApplicationParts(assembly);
    }
    
    public static IEnumerable<ApplicationPart> GetDefaultApplicationParts(Assembly assembly)
    {
        if (assembly == null)
        {
            throw new ArgumentNullException(nameof(assembly));
        }
        
        yield return new AssemblyPart(assembly);
    }
}

```

##### 2.6.3 null application part factory

```c#
public class NullApplicationPartFactory : ApplicationPartFactory
{    
    public override IEnumerable<ApplicationPart> GetApplicationParts(Assembly assembly)
    {
        return Enumerable.Empty<ApplicationPart>();
    }
}

```

#### 2.7 application part manager

```c#
public class ApplicationPartManager
{    
    // application feature provider 集合（default）
    public IList<IApplicationFeatureProvider> FeatureProviders { get; } = new List<IApplicationFeatureProvider>();        
    // application part 集合（default，可以注入结果）
    public IList<ApplicationPart> ApplicationParts { get; } = new List<ApplicationPart>();
    
    
    public void PopulateFeature<TFeature>(TFeature feature)
    {
        if (feature == null)
        {
            throw new ArgumentNullException(nameof(feature));
        }
        
        foreach (var provider in FeatureProviders.OfType<IApplicationFeatureProvider<TFeature>>())
        {
            provider.PopulateFeature(ApplicationParts, feature);
        }
    }
    
    internal void PopulateDefaultParts(string entryAssemblyName)
    {
        // 由 assembly name 解析 assembly 集合
        var assemblies = GetApplicationPartAssemblies(entryAssemblyName);
        // 去重的 assembly 集合
        var seenAssemblies = new HashSet<Assembly>();
        
        // 遍历 assembly 集合，
        foreach (var assembly in assemblies)
        {
            // 去重
            if (!seenAssemblies.Add(assembly))
            {
                // "assemblies" may contain duplicate values, but we want unique ApplicationPart instances.
                // Note that we prefer using a HashSet over Distinct since the latter isn't guaranteed to preserve the 
                // original ordering.
                continue;
            }
            
            // 由 assembly 创建 application part factory
            var partFactory = ApplicationPartFactory.GetApplicationPartFactory(assembly);
            // 由 application part factory 创建 application part，注入 application part 集合
            foreach (var applicationPart in partFactory.GetApplicationParts(assembly))
            {
                ApplicationParts.Add(applicationPart);
            }
        }
    }
    
    private static IEnumerable<Assembly> GetApplicationPartAssemblies(string entryAssemblyName)
    {
        var entryAssembly = Assembly.Load(new AssemblyName(entryAssemblyName));
        
        // Use ApplicationPartAttribute to get the closure of direct or transitive dependencies
        // that reference MVC.
        var assembliesFromAttributes = entryAssembly.GetCustomAttributes<ApplicationPartAttribute>()
									            .Select(name => Assembly.Load(name.AssemblyName))
									            .OrderBy(assembly => assembly.FullName, StringComparer.Ordinal)
									            .SelectMany(GetAssemblyClosure);
        
        // The SDK will not include the entry assembly as an application part. We'll explicitly list it
        // and have it appear before all other assemblies \ ApplicationParts.
        return GetAssemblyClosure(entryAssembly).Concat(assembliesFromAttributes);
    }
    
    private static IEnumerable<Assembly> GetAssemblyClosure(Assembly assembly)
    {
        yield return assembly;
        
        var relatedAssemblies = RelatedAssemblyAttribute.GetRelatedAssemblies(assembly, throwOnError: false)
										            .OrderBy(assembly => assembly.FullName, StringComparer.Ordinal);
        
        foreach (var relatedAssembly in relatedAssemblies)
        {
            yield return relatedAssembly;
        }
    }
}

```

##### 2.7.1 application feature provider

```c#
public interface IApplicationFeatureProvider
{
}

public interface IApplicationFeatureProvider<TFeature> : IApplicationFeatureProvider
{    
    // <see cref="ApplicationPart"/> instances in <paramref name="parts"/> appear in the same ordered sequence they
    // are stored in <see cref="ApplicationPartManager.ApplicationParts"/>. This ordering may be used by the feature
    // provider to make precedence decisions.
    void PopulateFeature(IEnumerable<ApplicationPart> parts, TFeature feature);
}

```

#### 2.7.2 application part attribute

```c#
[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
    public sealed class ApplicationPartAttribute : Attribute
    {
        /// <summary>
        /// Initializes a new instance of <see cref="ApplicationPartAttribute" />.
        /// </summary>
        /// <param name="assemblyName">The assembly name.</param>
        public ApplicationPartAttribute(string assemblyName)
        {
            AssemblyName = assemblyName ?? throw new ArgumentNullException(nameof(assemblyName));
        }

        /// <summary>
        /// Gets the assembly name.
        /// </summary>
        public string AssemblyName { get; }
    }
```

##### 2.7.3 related assembly attribute

```c#
[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
public sealed class RelatedAssemblyAttribute : Attribute
{
    public string AssemblyFileName { get; }
    
    public RelatedAssemblyAttribute(string assemblyFileName)
    {
        if (string.IsNullOrEmpty(assemblyFileName))
        {
            throw new ArgumentException(
                Resources.ArgumentCannotBeNullOrEmpty, 
                nameof(assemblyFileName));
        }
        
        AssemblyFileName = assemblyFileName;
    }
                
    public static IReadOnlyList<Assembly> GetRelatedAssemblies(Assembly assembly, bool throwOnError)
    {
        if (assembly == null)
        {
            throw new ArgumentNullException(nameof(assembly));
        }
        
        var loadContext = AssemblyLoadContext.GetLoadContext(assembly) ?? AssemblyLoadContext.Default;
        return GetRelatedAssemblies(
            assembly, 
            throwOnError, 
            File.Exists, 
            new AssemblyLoadContextWrapper(loadContext));
    }
    
    internal static IReadOnlyList<Assembly> GetRelatedAssemblies(
        Assembly assembly,
        bool throwOnError,
        Func<string, bool> fileExists,
        AssemblyLoadContextWrapper assemblyLoadContext)
    {
        if (assembly == null)
        {
            throw new ArgumentNullException(nameof(assembly));
        }
        
        // MVC will specifically look for related parts in the same physical directory as the assembly.
        // No-op if the assembly does not have a location.
        if (assembly.IsDynamic)
        {
            return Array.Empty<Assembly>();
        }
        
        var attributes = assembly.GetCustomAttributes<RelatedAssemblyAttribute>().ToArray();
        if (attributes.Length == 0)
        {
            return Array.Empty<Assembly>();
        }
        
        var assemblyName = assembly.GetName().Name;
        
        // Assembly.Location may be null for a single-file exe. 
        // In this case, attempt to look for related parts in the app's base directory
        var assemblyDirectory = string.IsNullOrEmpty(assembly.Location) 
            ? AppContext.BaseDirectory 
            : Path.GetDirectoryName(assembly.Location);
        
        if (string.IsNullOrEmpty(assemblyDirectory))
        {
            return Array.Empty<Assembly>();
        }
        
        var relatedAssemblies = new List<Assembly>();
        for (var i = 0; i < attributes.Length; i++)
        {
            var attribute = attributes[i];
            if (string.Equals(
                	assemblyName, 
                	attribute.AssemblyFileName, 
                	StringComparison.OrdinalIgnoreCase))
            {
                throw new InvalidOperationException(
                    Resources.FormatRelatedAssemblyAttribute_AssemblyCannotReferenceSelf(
                        nameof(RelatedAssemblyAttribute), 
                        assemblyName));
            }
            
            Assembly relatedAssembly;
            var relatedAssemblyLocation = Path.Combine(assemblyDirectory, attribute.AssemblyFileName + ".dll");
            if (fileExists(relatedAssemblyLocation))
            {
                relatedAssembly = assemblyLoadContext.LoadFromAssemblyPath(relatedAssemblyLocation);
            }
            else
            {
                try
                {
                    var relatedAssemblyName = new AssemblyName(attribute.AssemblyFileName);
                    relatedAssembly = assemblyLoadContext.LoadFromAssemblyName(relatedAssemblyName);
                }
                catch when (!throwOnError)
                {
                    // Ignore assembly load failures when throwOnError = false.
                    continue;
                }
            }
            
            relatedAssemblies.Add(relatedAssembly);
        }
        
        return relatedAssemblies;
    }
    
    internal class AssemblyLoadContextWrapper
    {
        private readonly AssemblyLoadContext _loadContext;
        
        public AssemblyLoadContextWrapper(AssemblyLoadContext loadContext)
        {
            _loadContext = loadContext;
        }
        
        public virtual Assembly LoadFromAssemblyName(AssemblyName assemblyName) => _loadContext.LoadFromAssemblyName(assemblyName);       
        public virtual Assembly LoadFromAssemblyPath(string assemblyPath) => _loadContext.LoadFromAssemblyPath(assemblyPath);
    }
}

```



#### 







